# C

## 基础

### 变量命名

规则

1. 变量名是字母、数字、下划线的组合。
2. 开头必须是字母或下划线，用户变量通常是字母开头，系统变量通常是下划线开头。
3. 字母区分大小写。
4. 变量名不可以是C语言的关键字。

- 通常较短的单词可通过去掉“元音”形成缩写，比如表示“个数”的 count 可以缩写成 cnt；
- 较长的单词可取单词中的几个字母形成缩写；
- 对于一些单词还有大家公认的缩写，比如：
  - temp 可缩写为 tmp;  //temp是“临时”的意思
  - flag 可缩写为 flg;  //flag是“标志位”的意思
  - statistic 可缩写为 stat;  //statistic是“统计”的意思
  - increment 可缩写为 inc;
  - message 可缩写为 msg;

注释规范

![image-20230609160648803](photo/image-20230609160648803.png)

### 声明判断原则

1. 声明从名字开始读取，按照优先级高低依此读取
2. 优先级
   1. 声明中被括号括起来的部分
   2. 后缀表达式
      1. 小括号表示其是个函数
      2. 中括号表示其是个数组
   3. 前缀表达式
      1. 如*表示指针
3. 如果const、volatile后紧跟类型说明符那么它作用于类型说明符，否则作用于它左侧的指针星号char * const *(*next)();

### 隐式类型转换

- 算术运算式中，低类型转换为高类型
- 赋值表达式中，表达式的值转换为左边变量的类型
- 函数调用时，实参转换为形参的类型
- 函数返回值，return表达式转换为返回值类型

### 声明和定义

声明用来告诉编译器变量的名称和类型而不分配内存，`extern 变量类型 变量名`或`typedef`，变量可以有多个声明。声明可以用于程序引用其他文件的变量、引用本文件中非当前作用域的变量。

定义为了给变量分配内存，全局/静态变量初始化为0，局部变量初始化为随机数，在一个程序中变量只能有一个定义。

`int a;`这样的语句同时包含声明和定义。

函数的声明式通知编译器函数名称、参数数量和类型以及返回值类型。

函数的定义式为函数分配内存。

### 关于变量

1. 变量的本质时内存的别名，程序读取的是内存而不是变量本身
2. 在程序执行的时候，变量的本质是代码，存储在代码区
3. 名字、空间、di'zhi
4. 类型、变量名、值

### 防止头文件重复引入

1. 宏定义

```c
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```

其中的_NAME_H是一个独一无二的宏，第一次执行的时候由于该宏还没有定义所以会进行定义，以后执行就不会重复执行包含的内容。但是这种方法每次引入头文件都需要识别是否已经定义了某个宏，效率并不高，但是C/C++都支持宏定义故不会影响项目的可移植性

2. #pragma once

将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。该指令对文件生效所以效率很高，需要注意的是较老版本的编译器可能不支持这种方式（执行会发出警告，但编译还是会继续进行）即该指令的兼容性不是很好。但目前也基本都支持了。

### return原理

return可以在函数释放栈帧的情况下将结果返回，是因为return的底层将结果mov到了eax寄存器中，当返回局部变量的时候会将局部变量的地址放入eax中所以最好不要return局部变量。

### 数组的初始化

1、for 最浪费时间，不建议（其实memset内部也是用循环实现的，只不过memset经过了严格优化，所以性能更高）；

2、{0} 可能有移植性问题，虽然绝大多数编译器看到{0} 都是将数组全部初始化为0， 但是不保证所有编译器都是这样实现的；

3、综合1、2， 推荐使用memset方法，但是使用memset初始化非char类型可能会出错，因为其以字节为单位进行内存填充。

数组不初始化成员将随机，部分初始化未初始化部分为零、全部初始化即全部初始化。

### 数组名

数组名作为类型代表整个数组，因此`sizeof(数组名)`结果是整个数组的大小。

数组名作为地址表示首元素的地址。+1是下一个元素

对数组名取地址表示数组的首地址因此`sizeof(&数组名)`结果是对应类型指针的大小。+1是下一个数组（数组结尾的下一个地址）

动态分配的数组，数组地址&arr不等于数组首地址arr。arr本身是个指针变量，指向堆区分配的空间，那么&arr就是取指针的地址了，而*arr才是数组的首地址

### 局部变量、静态局部变量、全局变量与静态全局变量

- 局部变量：每次重新进入作用域都会重新创建，离开作用域都会销毁。
- 静态局部变量：加`static`，同样在函数内部定义，在函数调用多次时，只有第一次会进行变量定义和初始化，函数退出时也不会销毁而是保留其值为下一次调用使用
- 普通全局变量：定义在函数外面的变量且不加任何修饰词，可以在各个文件中被看到，所以要保证不重名
- 静态全局变量：用来解决重名问题的，将作用域限定在本文件。

1. 定义为初始化，全局变量默认值为0，而局部变量的值时随机的
2. 全局变量的作用域为文件，局部变量的作用域为代码块
3. 全局变量声明周期为整个程序，局部变量为代码块结束
4. 全局变量分配在数据段，局部变量分配在栈段


### 重载

C语言没有函数重载，CPP中会用参数来区分函数名所以可以重载。

### const

C语言可以通过非const指针修改const变量

### 宏

文本替换

[一篇文章](https://blog.csdn.net/Apollon_krj/article/details/82911180)

对于一个简单的函数，我们可以使用宏也可以使用函数。但是函数调用会带来额外的开销，需要开辟栈空间，记录返回地址，将形参压栈，返回，释放堆栈，宏则没有这样的问题。其次函数的参数必须被声明为某一种类型，因此会出现功能相同类型不同的很多重载，**而宏则是类型无关的**。

与函数相比，宏的不利在于每次使用宏的时候，一份宏代码的拷贝都会插入到程序中，除非宏非常短，否则使用宏会大幅度增加程序的长度。

还有一些任务根本无法用函数实现（可以参见上面一篇文章）

### 预处理指令

```c
#define            定义一个预处理宏  
#undef            取消宏的定义  
#if                   编译预处理中的条件命令，相当于C语法中的if语句  
#ifdef              判断某个宏是否被定义，若已定义，执行随后的语句  
#ifndef            与#ifdef相反，判断某个宏是否未被定义
#elif                若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if（扩展条件）  
#else              与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else（扩展条件）  
#endif             #if, #ifdef, #ifndef这些条件命令的结束标志.  
defined         　与#if, #elif配合使用，判断某个宏是否被定义
```

### sizeof和strlen

- sizeof是运算符，其结果在编译期间得到而不是运行中，strlen是字符处理的库函数，
- sizeof的参数可以是任何数据类型或数据（参数不退化），strlen接受字符指针且结尾是'\0'的字符串
- sizeof的值在编译时得到，所以不能用来求动态分配存储空间的大小。

### 如何判断联合体的大小

联合体所有成员都是从第一位开始存储

1. 联合体的大小必须保证能容纳最大成员的大小
2. 联合体大小必须是所有成员变量类型大小的整数倍

### printf的原理

在C/C++中，对函数参数的扫描是从后向前的。

C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。

printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf("%d,%d",a,b);（其中a、b都是int型的）的汇编代码.

### scanf的注意事项

1. scanf也可以有非输入控制符，只是输入的时候需要原样输入。
2. 输出控制符和输出参数在顺序上和数量上一定要对应
3. 输入的数据类型一定要与所需要的数据类型一致，对于%d如果输入为字符，则程序接收到的是乱码，因为%d只识别十进制整数，对 %d 而言，空格、回车、Tab 键都是区分数据与数据的分隔符。当 scanf 进入缓冲区中取数据的时候，如果 %d 遇到空格、回车、Tab 键，那么它并不取用，而是跳过继续往后取后面的数据，直到取到“十进制整数”为止。对于被跳过和取出的数据，系统会将它从缓冲区中释放掉。未被跳过或取出的数据，系统会将它一直放在缓冲区中，直到下一个 scanf 来获取。但是如果 %d 遇到字母，那么它不会跳过也不会取用，而是直接从缓冲区跳出。所以上面这个程序，虽然 scanf 进入缓冲区了，但用户输入的是字母 a，所以它什么都没取到就出来了，而变量 i 没有值，即未初始化，所以输出就是 –858993460。但如果将 %d 换成 %c，那么任何数据都会被当作一个字符，不管是数字还是空格、回车、Tab 键它都会取回。
4. 使用scanf之前最好使用printf进行提示
5. 根据3的最后一句话，如果需要连续输入字符，需要在后面的%c之前加上\n来过滤掉换行符。（或者在每次调用之间加上一个getchar()）

### 生成随机数

使用<stdlib.h>中的`int rand(void)`，会随机生成一个位于0-RAND_MAX之间的整数，这个整数由<stdlib.h>中的一个宏确定，C语言标准并没有规定 RAND_MAX 的具体数值，只是规定它的值至少为 32767。

上述的rand函数每次产生的随机数都是一样的，实际上，rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布。种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。

我们可以通过`srand((unsigned)time(NULL));`函数来重新“播种”，这样种子就会发生改变。他需要一个参数，在实际开发中我们使用可以使用<time.h>中的`time()`来作为参数，只要时间不同生成的种子就不同

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main() {
    int a;
    srand((unsigned)time(NULL));
    a = rand();
    printf("%d\n", a);
    return 0;
}
```

如果想要生成一定范围内的随机数可以使用取模加数的方式。

### 野指针

无法正常使用的指针、指向垃圾内存的指针

1. 未初始化
2. 指针释放后未置空，free释放的只是内存而不是指针
3. 指针超出了变量的作用范围

如果野指针指向不可访问的地址触发段错误，是比较好的情况。当野指针指向没有意义的空间时不会对程序造成损害，但会掩盖错误。指向一个可用空间危害则较大，导致数据受损或程序崩溃。

1. 定义指针时，同时初始化为NULL
2. 在指针解引用之前，先去判断这个指针是不是NULL
3. 指针使用完之后，将其赋值为NULL
4. 在指针使用之前，将其赋值绑定给一个可用地址空间

### 悬空指针

指针所指的对象已经销毁，该指针就是悬空指针

访问悬空指针，结果随机。可能导致程序功能不正常，也可能导致程序崩溃

在释放一块内存后，将指向这块内存的指针设置为`NULL`，访问指针变量之前，先判断是否为`NULL`

### 函数指针

- 如何定义一个函数指针及赋值

  `int (*p)(int. int) = &max`

- 如何调用函数指针

  如果函数指针已经赋值，只需要将指针名当作函数名调用即可

- 回调函数

  把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做`回调`。`回调函数`就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

### memset(this, 0, sizeof(*this))

1. 类中定义了很多int,char,struct等变量，习惯在构造函数中将其初始化为0，但是一句一句写很麻烦，所以直接这样就可以，将整个对象的内存全部置为0
2. 类含有虚函数表：这样做会破坏虚函数表，后续对虚函数表的调用都会出现异常
3. 类中有对象：类中对象在构造函数之前就完成了初始化，这样memset就会破坏了对象的内存

### [文件](https://blog.csdn.net/zimuzi2019/article/details/106108954)

### 内存分区
- 栈（向下扩容）
- 共享存储区（向下扩容）
- 堆（向上扩容）
- 全局/静态存储区（未初始化的在bss，初始化的在data）
- 常量区
- 代码区

<img src="photo/70.png" alt="img"  />

### 堆和栈

- 管理方式
  - 堆由程序员申请和释放（容易产生内存碎片）
  - 栈由编译器自动管理，无需手工控制
- 管理机制
  - 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存首地址记录分配大小，以便正确delete，系统还会将多余的部分重新放入空闲链表中）
  - 只要栈的剩余空间大于所申请空间，系统就会提供栈空间，否则报异常提示栈溢出
- 空间大小
  - 堆的空间不连续（因为申请和释放自由，由链表记录空闲空间），32位机器堆时4G
  - 栈是连续的，windows下是2M
- 碎片问题
  - 对于堆，频繁的new和delete会产生很多内存碎片，降低程序效率
  - 对于栈，类似于数据结构中的栈，不会产生碎片
- 生长方向
  - 堆向上，向高地址方向增长
  - 栈向下，向低地址方向增长
- 分配方式
  - 堆只有动态分配
  - 栈的静态分配由编译器完成，动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，不需要程序员手动释放或实现
- 分配效率
  - 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。
  - 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。

### 堆和栈哪个更快

- 堆中的内存是由程序员自己进行申请的，大小不定，所以实现起来较为困难。一种做法是将内存管理交给内核去做，操作系统提供系统调用，但是这样做的性能较差，malloc和free都需要使用系统调用，系统调用的性能开销是比较大的。另一种做法是malloc提前向操作系统申请了一大块内存作为堆区，并直接对这块内存进行管理。

  随着内存的分配会出现不连续的空闲区域，在申请内存时，首先遍历空闲区域，看是否有大小合适的内存块，如果有就分配，如果没有就向操作系统申请（发生系统调用）。为了保证分配给程序的内存的连续性，malloc() 只会在一个空闲区域中分配，而不能将多个空闲区域联合起来。

  内存块的结构类似于链表，如下图

  ![img](photo/1582785-20210618174150289-2130764485.png)

  在free的时候会将连续的空闲区域合并为一个

  大部分 malloc() 实现都会在内存块中增加一个 pre 指针指向上一个内存块，构成双向链表

  问题：一旦链表中的 pre 或 next 指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到。

  小的空闲区域往往不容易再次分配，形成很多内存碎片。经常分配和释放内存会造成链表过长，增加遍历的时间。

- 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。

### 如何理解库函数

库函数位于用户态，系统调用位于内核态，运行时间同理。

系统调用避免用户直接对底层硬件进行编程、隐藏背后的技术细节、保证系统安全性和稳定性、方便程序的移植性

ISO每年指定C/C++新的标准以及定义API，注意是只定义不实现。有一群专门的人根据发布的API来实现标准库，例如文件读写、内存分配、线程创建之类的API是需要借助系统调用的，所以每一个平台(操作系统)上都有自己特定的标准库实现，因为不同的操作系统提供的功能是不同的，提供的系统调用也是不同的。库函数本质上就是对系统调用的封装，系统调用是比较高效且精简的，而有时程序员可能需要更复杂的功能和处理或更加人性化的需求，就会把这些系统调用封装成为库函数。

库函数是语言或应用程序的一部分，系统调用是操作系统的一部分

部分库函数的性能高于系统调用，因为库函数使用了缓冲区，减少了系统调用的次数，如：`fread、fwrite、fputc、fgetc`

### 被free的内存是直接返还给操作系统吗

被free的内存会被ptmalloc使用双链表保存起来，当用户下一次进行申请内存的时候，会尝试从这些内存中找到适合的内存进行返回。这样避免了频繁的系统调用，同时ptmalloc也会对小块内存进行合并，避免过多的内存碎片。

### main函数需要有返回值吗

根据C99标准，main函数是需要有返回值的。

其中main函数有两种形式。

```c
int main()
{}

int main(int argc,char *argv[])
{}
```

### 结构体对齐

1. 第一个成员的首地址为0
2. 每个成员的首地址是自身大小的整数倍
3. 结构体的总大小，为其成员所含最大类型的整数倍

### #define和const

- define在预处理阶段起作用，const在编译、运行时期起作用
- define只是简单的字符串替换，没有类型检查，const有类型检查
- define只是展开字符串，有多少次替换多少次，
- define不能调试，因为在预处理阶段已经被替换掉了，const可以调试

## 实践

### 用define写一个结构体类型的偏移地址

```c
#define offsetof(StructType, MemberName) (size_t)&(((StructType *)0)->MemberName)
/*StructType是结构体类型名，MemberName是成员名。具体操作方法是：

1、先将0转换为一个结构体类型的指针，相当于某个结构体的首地址是0。此时，
每一个成员的偏移量就成了相对0的偏移量，这样就不需要减去首地址了。

2、对该指针用->访问其成员，并取出地址，由于结构体起始地址为0，
此时成员偏移量直接相当于对0的偏移量，所以得到的值直接就是对首地址的偏移量。

3、取出该成员的地址，强转成size_t并打印，就求出了这个偏移量。*/
```

### 大小端

小端存储：低地址放低位，高地址放高位，大端存储：低地址放高位，高地址放低位

高位→低位，低地址→高地址

大端存储符合人类观察，大端存储就是位数大小的样子

X86系列通常是小端，网络字节序是大端

```c
int checkCPUendian()
{//char的存储位置为int的前四分之一
  union
  {
    unsigned int a;
    unsigned char b; 
  }c;
  c.a = 1;
  return (c.b == 1); //true则为小端
}


int i = 1;   
    char *p = (char *)&i;   
    if(*p == 1)     
          printf("Little Endian"); 
    else
          printf("Big Endian");


int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

### 结构体偏移

使用<stddef.h>头文件中的，offsetof宏。

```cpp
#include <iostream>
#include <stddef.h>
using namespace std;

struct  S
{
	int x;
	char y;
	int z;
	double a;
};
int main()
{
	cout << offsetof(S, x) << endl; // 0
	cout << offsetof(S, y) << endl; // 4
	cout << offsetof(S, z) << endl; // 8
	cout << offsetof(S, a) << endl; // 16
	return 0;
}
```



# C++

## 基础

### C和C++的区别

- C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
- C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
- C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等

- 编译的区别
  1. C++支持面向对象，所以C++编译器要解析类和对象
  2. C++有更严格的类型检查和类型转换，需要通过类型转换运算符来进行强制转换
  3. C++的标准库更为强大和丰富
  4. C++使用命名空间避免变量和函数名冲突的问题
  5. C++支持函数重载和运算符重载

### C和C++的类型安全问题

类型安全基本可以等价为内存安全，即代码是否会访问或修改没有被授权的内存区域。如果用来形容编程语言则可以表示为该语言是否提供了保障内存安全的机制，如果用来形容代码则表示该程序是否隐含类型错误。**需要注意的是类型安全的语言和类型安全的程序之间没有必然联系。目前还没有绝对类型安全的编程语言。**

1. C语言的类型安全

   C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。

   输出一段整型，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误。

   malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，常常有这样的用法char* pStr=(char*)malloc(100*sizeof(char))，这里明显做了显式的类型转换。类型匹配尚且没有问题，但是一旦出现int* pInt=(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。

2. C++的类型安全

   如果C++使用得当，它将远比C更有类型安全性。具体表现如下：

   - 操作符new返回的指针类型严格与对象匹配，而不是void*
   - C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
   - 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换
   - 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全
   - C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

### C++的编译过程

[编译过程](https://www.jinhang.work/tech/cpp-building-process/)

1. 预编译
   1. 展开宏定义
   2. 处理预编译指令
   3. 处理头文件（递归执行）
   4. 删除注释
   5. 添加行号和文件标识（以便产生调试和报错或警告信息）（可选）
2. 预处理产生.i文件，经过编译产生汇编代码文件（编译只需要满足语法正确，函数和变量的声明正确，为了找到定义的声明，需要指明头文件的位置。只要语法正确，编译器就可以生成对应的目标文件，即使没有声明，也会给出目标文件，只是给出警告）
   1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
   2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
   3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
   4. 优化：源代码级别的一个优化过程。
   5. 目标代码产生：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
   6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。
3. 汇编，将汇编代码变成可以执行的指令（机器码），只是根据汇编指令和机器指令的对照表一一翻译过来
4. 链接（链接函数和全局变量，需要在调用函数的文件找到函数定义，否则会报出链接错误），将不同的源文件产生的目标文件进行链接，从而形成一个可执行程序，链接分为静态链接和动态链接，具体见下
5. <img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20230115101258425.png" alt="image-20230115101258425" style="zoom:50%;" />
6. ![image-20230115101519777](C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20230115101519777.png)

### main函数执行前和执行后可能会做哪些事

- 执行前
  - 设置栈指针
  - 初始化静态、全局变量（data段的变量）
  - 为未初始化的全局变量赋默认初始值
  - 全局对象初始化，在main函数调用之前进行构造
  - 将参数传递给main函数，开始执行
- 执行后
  - 全局对象的析构函数
  - 可以用atexit注册一个函数，让他在main之后执行

### 在main函数之前执行函数

1. 全局变量的构造函数
2. 全局变量的赋值函数
3. 指定入口点，入口点中调用原来的入口点

### 指针和引用的区别

1. 指针存放一个其他变量的地址（它本身也是变量，变量就有地址，所以有多级指针），引用是另一个变量的别名
2. 指针是一个实体，需要分配内存，也有地址（所以有多级指针），引用不分配内存
3. 指针可以修改指向的对象，引用不可以（必须初始化）
4. sizeof指针得到指针的大小，而sizeof引用则得到被引用对象的大小
5. 引用作为函数参数时，调用方看不出来是正常参数还是引用参数，可能会引发错误。
6. [TX开发者指针和引用](https://cloud.tencent.com/developer/article/1021622)
7. 引用的目的是在调用函数时不复制对象

### 指针参数传递和引用参数传递有什么区别

1. 指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

2. 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

3. 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

4. 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

### typedef和define和inline和const的区别

- define
  1. 只是简单的字符串替换，没有类型检查
  2. 编译的预处理阶段起作用
  3. 不分配内存，有多少个就替换多少次
  4. 没有类型检查，不能调试
  5. 宏定义是一是编译型概念
- typedef
  1. 常用来定义一个标识符或关键字的别名
  2. 有对应的数据类型，需要进行判断
  3. 在编译、运行时生效
  4. 在静态存储区分配空间，程序运行过程中只有一个拷贝
- inline
  1. 用来替代C中的define，编译期完成
  2. inline函数需要进行类型检查，需要的时候直接将代码写到需要处，减少了压栈、跳转和返回的过程，提高了效率，比define安全，以空间为代价
  3. 定义inline函数只是给编译器的一个建议，对于复杂的函数编译器可能不会将其定义为inline，Google的编程规范中一般10行以下的函数定义为inline
- const
  1. 用来表示常量，不可以修改
  2. 会在编译阶段进行类型检查
  3. const是运行时概念
  4. 需要进行内存分配，存储在数据段中

### new、delete和malloc、free堆区

1. new是运算符，malloc是标准库函数
2. new可以重载，malloc不能重载
3. new的变量是数据类型，malloc是字节大小
4. new可以调用构造函数，malloc不可以
5. new返回指定对象的指针，malloc返回void*
6. malloc申请的空间不够时可以使用realloc扩容，new没有这样的操作
7. new失败默认抛出bad_malloc异常（如果不想捕获异常可以使用std::nothrow），malloc失败返回NULL
8. new通过调用operator new的标准库函数分配空间并调用构造函数，delete对指针所指的对象进行析构，而malloc和free没有相应的机制。
9. new的底层实现是malloc，可以对其创建的对象进行free，不会报错，但是不会调用析构函数。

### 静态类型和动态类型

- 注意区别在于：对变量进行类型检查的时间点。

- 静态类型: 类型检查主要发生在编译阶段。

- 动态类型:类型检查主要发生在运行阶段。

### 静态链接和动态链接

- 所谓静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。
- 所谓动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。

### 什么原因会导致程序崩溃

1. 读取未赋值的变量
2. 函数栈溢出
   1. 定义一个太大的局部变量或参数
   2. 函数递归太深
3. 数组访问越界
4. 指针所指目标不可用
   1. 解引用指针未赋值
   2. 解引用指针已被delete或free
   3. 不恰当的强转
5. 参数错误

### 局部静态变量和全局静态变量

- 相同
  1. 数据在全局数据区分配
  2. 如果没有进行显式初始化则变量会被隐式初始化为0
  3. 始终保存在全局数据区，直到程序结束
- 区别
  1. 全局本文件可见，局部作用域内可见
  2. 全局静态变量不可以被其他文件引用

### static

用来控制变量的存储方式和可见性

1. 作用于函数内部的局部变量（静态局部变量）

   开辟一次空间，只初始化一次，且不会随着函数退出而失效

2. 静态局部变量

   对整个文件是可见的，文件外不可访问

3. 静态函数

   同样是对本文件可见

4. 作用于类的成员变量

   在类中只有一个副本，由该类的所有成员维护和使用，从而实现一个类的不同对象共享数据。

   **访问类的成员变量 类名::变量名（因为静态成员变量不属于任何一个对象）、静态成员需要在类外初始化**

5. 作用于类的成员函数

   静态成员函数主要用来处理该类的静态成员，可以直接访问静态成员函数

- 静态成员变量
  1. 静态成员变量属于整个类所有
  2. 静态成员变量的生命期不依赖于任何对象，为程序的生命周期
  3. 可以通过类名直接访问公有静态成员变量
  4. 所有对象共享类的静态成员变量
  5. 可以通过对象名访问公有静态成员变量
  6. 静态成员变量需要在类外单独分配空间
  7. 静态成员变量在程序内部位于全局数据区 (Type className::VarName = value)
- 静态成员函数
  1. 静态成员函数是类的一个特殊的成员函数
  2. 静态成员函数属于整个类所有，没有this指针
  3. 静态成员函数只能直接访问静态成员变量和静态成员函数
  4. **可以通过类名直接访问类的公有静态成员函数**
  5. 可以通过对象名访问类的公有静态成员函数
  6. 定义静态成员函数，直接使用static关键字修饰即可
- 要点
  1. 生命周期
  2. 共享方式
  3. 定义位置
  4. 初始化位置

### volatile

不稳定的。被它声明的变量可能被某些编译器未知的因素修改，如：操作系统、硬件和线程。遇到这种变量编译器不会对其进行优化。编译器不会去假设volatile变量的值，也就是说，每次用到这个变量都需要从内存中重新读取这个变量的值，而不能使用保存在寄存器中的临时值。多线程中被几个任务共享的变量需要定义为volatile类型。

**一个参数既可以是const也可以是volatile：一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它**。（简单点就是该程序代码不能试图去修改它，但不排除硬件方面修改了它，我们每次都得重新读取它的值。）

几个应用例子： a. 并行设备的硬件寄存器（如：状态寄存器）。 b. 一个中断服务子程序中会访问到的非自动变量。（个人理解：中断服务子程序不能用缓存在寄存器中的值来判断事件，因为那个值可能被修改了，需要重新读取。所以一般需要把这种变量声明为volatile。） c. 多线程应用中被几个任务共享的变量。

### mutable

可变的、易变的。在C++中mutable是为了突破const的限制而设置的，被mutable修饰的变量在常函数中也可以被修改。

### explicit

用来修饰单个参数的构造函数，表明该构造函数是显式的。用来防止隐式转换和复制初始化。

用于用户自己定义的构造函数则表明这个构造函数是默认的。

普通构造函数额可以被隐式调用，而被explicit修饰的构造函数只能被显式调用。

### 强制类型转换

1. C风格的强制转换

   - 基本数据结构分为四类：整型、浮点型、字符型、布尔型。

   1. 浮点型数据赋值给整型数据时，舍弃其小数部分
   2. 整型数据赋值给浮点型变量时，数值不变，但是以指数形式存储
   3. double型数据赋值给float型变量可能会溢出
   4. 字符型数据可以赋值给整型变量，此时存入的字符是ASCII码
   5. 将一个int、short、long型数据赋值给一个char型变量，将低八位送到char型变量中
   6. 将有符号型数据赋值给长度相同的无符号型变量，将原来的符号位一起传送

2. static_cast

   - 在C++语言中static_cast用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。

   ```cpp
   //用法：static_cast<类型说明符>(变量或表达式)
   int a = 10;
   int b = 3;
   double result = static_cast<double>(a) / static_cast<double>(b);
   ```

   1. 于类层次结构中基类和派生类之间指针和引用的转换。进行上行转换（把派生类的指针或引用转换成基类）是安全的，进行下行转换（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，所以是不安全的。
   2. 用于基本数据类型之间的转换，安全性也需要开发人员来保证。
   3. 把空指针转换成目标类型的空指针。
   4. 把任何类型的表达式转换为void类型。

3. const_cast

   在C语言中，const通常被用来限定变量，表示该变量的值不能被修改。

   const_cast用来强制去掉这种不能被修改的常量特性，但const_cast不是去除变量的常量性，而是去除指向变量对象的指针或引用的常量性，其去除常量行的对象必须为指针或引用

   ```cpp
   const int a = 10;
   const int * p = &a;
   *p = 20;//编译错误，*p具有常量性，其值不能被修改
   int b = const_cast<int>(a)//编译错误，const_cast转换对象必须为指针或引用
   ```

4. reinterpret_cast

   作用：***改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型***。

   它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

   **在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！**

   ```cpp
   //将整形指针强制转换为双精度浮点型指针
   int *a = new int;
   double *d = reinterpret_cast<double *>(a);
   ```

5. dynamic_cast

   1. 其他三种都是编译时完成的，而此转换为运行时处理，所以会进行类型检查。
   2. 不能用于内置的基本数据类型的强制转换。
   3. 转换如果成功就返回指向类的指针或引用，失败就会返回NULL
   4. 使用dynamic_cast进行转换，基类中一定要有虚函数，否则编译无法通过（类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义，运行时检查需要运行时的信息，而这个信息存储在虚函数表中）
   5. 在类的转换时，在类层次间进行上行转换时，dynamic_cast和[static_cast](http://baike.baidu.com/view/1745207.htm)的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

### const指针

顶层const和底层const只需要看指针在const的什么位置，用顶层表示指针本身是个常量，用底层表示指针所指向的对象是个常量。更一般地讲，顶层const可以表示任意的对象是常量，底层const用来表示与指针和引用等复合类型有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const或者二者兼备。

如果*离变量更近则*变量无法改变，如果const离指针更近则指针无法改变指向

### final和override

override用来保证子类一定重写父类的方法，如果变量名写错就会报错

final用来限制子类重写父类的方法，在父类的方法定义是加上final关键字子类则一定无法重写这个方法。

### new的类型

1. **plain new**

   言下之意就是普通的new，就是我们常用的new，在C++中定义如下：

   ``` cpp
   void* operator new(std::size_t) throw(std::bad_alloc);
   void operator delete(void *) throw();
   ```

   因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的

2. **nothrow new**

   nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL.

   ``` cpp
   void * operator new(std::size_t,const std::nothrow_t&) throw();
   void operator delete(void*) throw();
   ```

3. **placement new**

   这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：

   ```cpp
   void* operator new(size_t,void*);
   void operator delete(void*,void*);
   ```
   
   - palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
   - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。


### const的作用

1. 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。
6. const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
7. 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
8. 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。
9. const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；
10. const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
11. 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

### 运算符重载

1. 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符的操作数个数
2. 两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符
3. 引入运算符重载，是为了实现类的多态性
4. 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；
5. 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&）
6. 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本
7. 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针

### 重载的匹配原则和顺序

1. 名字查找
2. 确定候选函数
3. 寻找最佳匹配

### extern "c"

使用场景：

1. C++代码中调用C语言代码；

2. 在C++中的头文件中使用；

3. 在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

使用方法如下：

```cpp
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__

extern "C"{
    typedef unsigned int result_t;
    typedef void* my_handle_t;
    
    my_handle_t create_handle(const char* name);
    result_t operate_on_handle(my_handle_t handle);
    void close_handle(my_handle_t handle);
}
```

在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。

## 面向对象

### 类成员的访问权限和继承权限

1. 三种访问权限
   1. public:用该关键字修饰的成员为公有成员，该成员不仅可以在类内被访问，也可以在类外访问，是类对外提供的可访问接口
   2. private:用该关键字修饰的成员为私有成员，该成员仅可以在类内被访问，类外为隐藏状态
   3. protected:用该关键字修饰的成员表示保护成员，保护成员在类外同样是隐藏状态，但对于该类的派生类来说，相当于公有成员
2. 三种继承方式
   1. public:基类成员在派生类中的访问权限保持不变，基类是什么权限，派生类就是什么权限
   2. private:基类所有成员在派生类中的访问权限都变成私有权限
   3. protected:基类的公有成员和保护成员在派生类中的访问权限会变为保护权限，私有成员在派生类中的访问权限仍然是私有权限

​                             <img src="C:\Users\wm\Desktop\C++类访问修饰符.png" alt="C++类访问修饰符" style="zoom: 67%;" />



### 虚函数

C++中的虚函数的作用主要是实现了多态的机制，多态就是通过父类指针指向子类的对象，通过父类指针调用实际子类的成员函数。

#### 虚函数表

虚函数由虚函数表实现，这个表中主要存储一个类的虚函数的地址，这张表解决了继承、覆盖的问题，这个表就分配在了有虚函数的对象的内存中。

C++的编译器为了保证效率应该将虚函数表的指针存放于对象实例最前面的位置。意味着我们可以通过对象实例的地址得到这张虚函数表然后就可以遍历其中函数指针。大致长下面这样：

![image-20230609134231643](photo/image-20230609134231643.png)

**无继承**

虚函数按照声明顺序放在表中，父类的虚函数在子类的虚函数前面。

![image-20230609134257532](photo/image-20230609134257532.png)

**有继承**

覆盖的f函数放到了虚表中原来父类虚函数的位置，没有被覆盖的函数依旧

![image-20230609134426087](photo/image-20230609134426087.png)

**多重继承（无虚函数覆盖）**

每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的虚表中

![image-20230609134526531](photo/image-20230609134526531.png)

**多重继承（有虚函数继承）**

每个父类对应的函数地址都被修改为子类的成员函数

![image-20230609134616606](photo/image-20230609134616606.png)

#### 关于各种函数是否可以声明为虚函数

关于内联函数是否可以是虚函数，如果是类的对象调用函数则可以是虚函数，因为虚函数是编译时候展开的，如果是指针或引用则不行，因为指针或引用调用属于动态绑定，在编译期无法确定调用哪个函数。

静态成员函数不依赖对象实现，不存在成员变量，因此不能是虚函数。

友元函数不是成员函数，所以不能是虚函数。

#### 安全性问题

1. 父类指针无法访问未覆盖父类虚函数函数的子类函数，这样的行为被编译器视为非法，但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为
2. 如果父类的虚函数是private的，但这些虚函数同样会存在于虚函数表中，这样我们就可以通过访问虚函数表的方式来访问这些private函数

### 列表初始化的概念，为什么它会快一些

概念：在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值

效率：用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。

**如果成员是类**，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。**

### 计算类的对象个数

1. 为类设计一个static静态变量count作为计数器
2. 类定义结束后初始化count
3. 在构造函数中对count进行+1
4. 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作
5. 设计赋值构造函数，在进行赋值函数中对count+1操作
6. 在析构函数中对count进行-1；

### 友元函数和友元类

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，其他类可以访问该类中的私有成员和保护成员，通过正确使用友元可以提高程序的运行效率，但也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差

1. 友元函数

   友元函数是定义在类外的普通函数，不属于任何类可以访问其他类的私有成员，但需要在类的定义中声明所有可以访问它的友元函数

   一个函数可以是多个类的友元函数但是每个类中都要声明这个函数

2. 友元类

   友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息。但另一个类中也需要进行响应的声明

3. 注意事项

   1. 友元关系不能继承
   2. 友元关系是单向的，不具有交换性
   3. 友元关系不具有传递性

### 有关this指针

- this指针是类的const指针，指向对象的首地址

- 只有在成员函数中才能使用，this指针只有在成员函数中才有定义，因此不能在static成员函数中使用。

- 只有当对象被创建后this才有意义，且存储位置会因为编译器不同而不同

- this的用处

  对象的this指针并不是对象本身的一部分，不会影响sizeof(对象的结果)，this作用域是在类内部。类的非静态成员函数中访问类的非静态成员的时候，编译器会自动为对象本身的地址作为一个隐含参数传递给指针。

  - 类的非静态成员函数返回对象*this
  - 形参名与成员变量名相同this->n = n

- this的特点

  - 只能在成员函数中使用，成员函数的第一个参数是T* const this
  - 生命周期与其他参数是一样的，但this通常效率比较高，如vc通常通过ecx(计数寄存器)传递this参数

this实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给this（隐式传递）。**成员函数会被编译成和对象无关的普通函数，除了成员变量，会丢失所有的信息，所以在编译时要添加一个额外的参数，把对象的首地址传入，以此来关联成员函数和成员变量。**

### 模板

一个类（普通类或类模板）可以包含本身是模板的成员函数，这种成员被称为成员模板。

### 类型兼容原则

类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。因为公有继承，派生类得到了基类除了构造函数，析构函以外的所有成员。这样，公有派生类实际具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。
类型兼容规则所指的替代包括以下的情况：
1.派生类的对象可以隐含转换为基类的对象。
2.派生类的对象可以初始化基类的引用。
3.派生类的指针可以隐含转化为基类的指针。

### 常函数

在类的成员函数后面加个const，表明这个函数不会对这个类的成员（非静态数据成员）作任何改变。常量对象可以调用const成员函数，但是不能调用非const成员函数。

在设计类的时候，不修改成员的函数都要加上const。

相同函数签名的普通成员函数和常函数之间构成重载。

注：get_name之类的函数，除了要设置成常函数之外，还要使返回值为const，否则会返回私有数据成员的引用（此处假设name为私有成员），那么就可以通过这个引用来修改成员name的值`obj.get_name() = "Li"`。

### 重写、重载和隐藏

1. 重写（覆盖）指派生类实现了基类中定义的虚函数，返回值、函数名和参数列表都完全相同。

2. 重载的函数必须在同一个大括号（作用域内），参数类型或数量不同，不关心返回值，重载和成员函数是否是虚函数无关。

3. 隐藏（重定义）指派生类覆盖基类的同名函数，参数列表不同，有无virtual都是覆盖；参数列表相同无virtual就是覆盖。

### 类与类之间的关系（可能与语言无关）

has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；

use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；

is-A，继承关系，关系具有传递性；

## STl

### 各个容器的特点

[STL各个容器的特点](https://blog.csdn.net/qq_36834959/article/details/104301878?ops_request_misc=%7B%22request%5Fid%22%3A%22164700135916781683957192%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=164700135916781683957192&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-104301878.pc_search_result_control_group&utm_term=STL各容器区别&spm=1018.2226.3001.4187)

### vector

- vector的扩容方式

  当vector容量满了以后将元素复制到一块更大的内存msvc1.5倍，gcc2倍，需要注意的是一旦引起了空间重新配置，之前的所有迭代器就都失效了

- size和capacity

  size返回当前vector中存储的数据个数，capacity返回不扩容的情况下最大能容纳多少数据，capacity永远大于等于size

- resize和reserve

  `resize`改变当前vector中元素的个数，`reserve`改变vector的最大容量（只能大不能小）

- vector的迭代器

  由于vector维护的是线性的内存空间，所以原生指针具备作为vector迭代器的条件，不需要重载`operator+`，`operator*`这些
  
- 迭代器失效

  `erase`操作删除一个元素导致后面所有的元素都向前移动一个位置，从当前位置到最后的迭代器全部失效，但`erase`返回一个迭代器，需要更新迭代器。

- vector内存释放

  vector的内存是只增不减的，只有析构的时候才会释放，常规的操作只会减少元素的个数，内存大小不会减小，`vector<T>().swap();`使用`vector()`创建的临时对象来交换空间，而临时对象立即就会被析构，即可达到缩小vector内存的目的

  `shrink_to_fit()`函数则可以使size和capcity的大小匹配，不过这个操作是否奏效是由编译器决定的。
  
- 排序

  正序用`sort(vec.begin(), vec.end());` 倒序用`sort(vec.begin(), vec.end());`

### vector和list的区别

1. vector底层实现是数组； list是双向链表
2. vector是顺序内存,⽀持随机访问， list不⾏
3. vector在中间节点进⾏插⼊删除会导致内存拷⻉， list不会
4. vector⼀次性分配好内存，不够时才进⾏翻倍扩容； list每次插⼊新节点都会进⾏内存申请
5. vector随机访问性能好，插⼊删除性能差； list随机访问性能差，插⼊删除性能好

### deque

- deque是一个双端开口的线性序列，其内部由分段连续的地址构成，因为内部需要跳转，所以效率没有vector高。注：效率很低，排序可以先拷贝到vector中再拷贝回来
- 优→避免了vector的重新分配空间的时间   坏→迭代器变得很复杂
- deque维护一个map用来检索各段内存空间，实质上是一个二级指针，还维护了start和end

### map和set

- 底层都是红黑树

- set用来判断一个元素是不是在一个集合中，map相当于字典

- 优→查找一个数的时间为O(logN)，采用iterator遍历，效率不错   劣→插入需要调整红黑树

### map和unordered_map

- map底层是红黑树→有序   unordered_map底层是哈希表→无序
- map优→有序性、操作时间为O(logN)    劣→查找效率比较慢，和n相关
- unordered_map优→操作时间为O(1)   劣→基于哈希表，效率不高、操作时间不稳定，取决于哈希函数

### multi系列

multi的含义即元素可重复，那么遍历的时候就会相对麻烦一些

```Cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;
 
int main(){
  multimap<string, int> m_map;
  string name="XiaoMing";
  m_map.insert(make_pair(name, 50));
  m_map.insert(make_pair(name, 55));
  m_map.insert(make_pair(name, 60));
  //方式1
  cout<<"----------方法1-----------"<<endl;
  int k;
  multimap<string, int>::iterator m;
  m = m_map.find(name);
  for (k = 0; k != m_map.count(name); k++, m++)
  	  cout << m->first << "--" << m->second << endl;
  //方式2
  cout<<"----------方法2-----------"<<endl;
  multimap<string, int>::iterator beg, end;
  beg = m_map.lower_bound(name);
  end = m_map.upper_bound(name);
  for (m = beg; m != end; m++)
      cout << m->first << "--" << m->second << endl;
  //方式3
  cout<<"----------方法3-----------"<<endl;
  beg = m_map.equal_range(name).first;
  end = m_map.equal_range(name).second;
  for (m = beg; m != end; m++)
    cout << m->first << "--" << m->second << endl;
  return 0;
}
```

### string相比char*的优势

- string是STL中的一个类，内容可以动态扩展，以及对字符串的方便操作如用+连接
- string的内存管理由系统处理，除非系统内存池用完否则不会出现各种内存问题，char*的内存管理需要由程序员自己进行，很容易出现各种内存问题*
- 我们要定义一个字符串，如果已知需要多少内存可以用char*，但是指针可能会引来各种问题；用string还可以使用函数处理每一个字符，但是char*想要处理字符则需要我们自己编写函数

### 字符串长度相同，C++中的string和char*哪个占用内存大

愚以为，string中存储的是指针以及长度等变量，而char*则是真正存储的字符

### string和char *的转化

```cpp
// string转const char* 
string s = “abc”; 
const char* c_s = s.c_str(); 

// const char* 转string，直接赋值即可 
const char* c_s = “abc”; 
string s(c_s); 

//string 转char*
string s = “abc”; 
char* c; 
const int len = s.length(); 
c = new char[len+1]; 
strcpy(c,s.c_str()); 

// char* 转string 
char* c = “abc”; 
string s(c); 

// const char* 转char* 
const char* cpc = “abc”; 
char* pc = new char[strlen(cpc)+1]; 
strcpy(pc,cpc);

// char* 转const char*，直接赋值即可 
char* pc = “abc”; 
const char* cpc = pc;
```

### 关于string的写时拷贝

首先来一个编程规范，只有当你真正需要一个变量的时候才去声明他，因为程序的局部性原理，这样操作会得到最小的运行时内存消耗。

写时才拷贝（Copy-On-Write）技术，举个例子，我们有个程序要写文件，不断地根据网络传来的数据写，如果每一次fwrite或是fprintf都要进行一个磁盘的I/O操作的话，都简直就是性能上巨大的损失，因此通常的做法是，每次写文件操作都写在特定大小的一块内存中（磁盘缓存），只有当我们关闭文件时，才写到磁盘上（这就是为什么如果文件不关闭，所写的东西会丢失的原因）。更有甚者是文件关闭时都不写磁盘，而一直等到关机或是内存不够时才写磁盘，Unix就是这样一个系统，如果非正常退出，那么数据就会丢失，文件就会损坏。

```cpp
//在如下情况中str1和str2的地址是相同的，如果我们修改了其中一个的值，他们的地址才会不同
string str1 = "addf";
string str2 = str1;
```

- copu-on-write的原理是什么

  使用引用计数，构造函数根据传入的参数从堆上分配内存，当其他对象需要这块内存时，引用计数自动累加，当有类析构时这个计数会减一，知道最后一个类析构时程序才会释放这块内存

- string什么时候会共享内存

  就是一个对象使用另一个对象的内存

- string什么时候触发写时拷贝

  修改数据时会触发

- 具体如何实现

  由于共享内存的各个类指向的时同一个内存区，我们就可以在这块内存上多分配一点空间来存放这个引用计数。

### 迭代器失效问题

对容器进行插入或者删除操作影响了元素的存放位置，称为迭代器失效。

- 序列式容器

  vector、deque使用了连续分配的内存，`erase`操作删除一个元素会导致后面所有的元素向前移动一个位置，这些元素的地址发生了变化，故当前位置到容器末尾元素的所有迭代器全部失效。

  解决方法是`erase`方法可以返回下一个有效的迭代器，接收此迭代器进行后续操作即可。

- 链表式容器

  链表式容器删除当前的迭代器，只会使当前的迭代器失效，在`erase`的时候递增当前迭代器即可，或者也可以利用`erase`返回的下一个有效的迭代器

- 关联式容器

  `erase`只会使当前迭代器失效，递增当前迭代器即可（需要在删除之前递增）。

## C++11

### C++11的新特性

- nullptr替代NULL
- 引入了auto和decltype实现了类型推导
- 范围for循环
- 类和结构体中的初始化列表
- Lambda表达式
- std::forward_list（单向链表）
- 右值引用和move语义

### noexcept

![image-20230628202756605](photo/image-20230628202756605.png)

![image-20230628202808895](photo/image-20230628202808895.png)

### final

- 修饰成员函数，只能通过修饰虚函数来阻止子类重写这个函数
- 修饰类，则此类不能有子类

### auto注意事项及decltype

1. auto声明的变量必须初始化

2. auto不能用来声明数组

3. auto不能作为函数的形参以及返回值，因为并不是每个函数参数都有默认值

4. auto不能修饰模板函数

5. 不能用于声明成员变量（静态和非静态都不行，但是常静态可以因为它可以在类内初始化），因为并不是每个成员变量都有初始值

- 如果表达式是引用，则会去除引用
- 如果表达式时const，则会忽略顶层const
- 当auto带上&时，不会忽略顶层const
- 表达式为数组时，auto会推导出指针
- 表达式为数组时，auto&会推导出数组

如果希望从表达式中推断出变量的类型，却不想用表达式的值去初始化变量，那么就可以选择使用decltype

**他的作用是选择并返回操作数的类型。在此过程中，编译器只是分析表达式并得到它的类型，却不实际计算表达式的值**

decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型

```cpp
int func() {return 0};

//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()
int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留   
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const
int e = 4;
const int* f = &e; // f是底层const
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用
const int i = 3, &j = i;
decltype(j) k = 5; // k的类型是 const int&

//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型

//3. 对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起

//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起

int e = 4;
const int* f = &e; // f是底层const
decltype(auto) j = f;//j的类型是const int* 并且指向的是e
```

### NULL和nullptr

NULL来自C语言，通过宏实现，nullptr是C++11中新增的关键字，C语言中NULL被定义为(void)0，C++中NULL被定义为整数0，C++不能隐式转换为其他类型指针，代码如下：

```cpp
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。那么**在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。**

```cpp
const class nullptr_t{
public:
    template<class T>  inline operator T*() const{ return 0; }
    template<class C, class T> inline operator T C::*() const { return 0; }
private:
    void operator&() const;
} nullptr = {};
```

以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，**另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。

### 断言



### 智能指针

- shared_ptr

  实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

  允许多个对象共享一个指针

  ```cpp
  //初始化方式1
  std::shared_ptr<int> sp1(new int(123));
  
  //初始化方式2
  std::shared_ptr<int> sp2;
  sp2.reset(new int(123));
  
  //初始化方式3
  std::shared_ptr<int> sp3;
  sp3 = std::make_shared<int>(123);
  
  //将sp3的引用计数重置
  sp3.reset();
  
  // 获取原始指针
  sp2.get();
  ```

  默认初始化时智能指针中保存着一个空指针，使用方式也是解引用

  当进行拷贝或者赋值时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象，我们可以认为每个shared_ptr都有一个引用计数器，当我们给shared_ptr赋新值或者指针销毁时（如一个shared_ptr离开其作用域），引用计数就会减少。当引用计数为0时它就会自动释放所管理的对象

  不要使用一个原始指针初始化多个`shared_ptr`，因为一个`shared_ptr`不能增加其他`shared_ptr`中的引用计数，会重复释放

- unique_ptr

  unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。

  转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

  ```cpp
      //初始化方式1
      std::unique_ptr<int> up1(new int(123));
      //初始化方式2
      std::unique_ptr<int> up2;
      up2.reset(new int(123));
      //初始化方式3 (-std=c++14)
      std::unique_ptr<int> up3 = std::make_unique<int>(123);
  ```

- weak_ptr

  weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。
  
- auto_ptr

  主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

  auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

  auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

- shared_ptr实现

  ```cpp
  template<typename T>
  class SharedPtr
  {
  public:
  	SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
  	{}
  
  	SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
  		(*_pcount)++;
  	}
  
  	SharedPtr<T>& operator=(const SharedPtr& s){
  		if (this != &s)
  		{
  			if (--(*(this->_pcount)) == 0)
  			{
  				delete this->_ptr;
  				delete this->_pcount;
  			}
  			_ptr = s._ptr;
  			_pcount = s._pcount;
  			*(_pcount)++;
  		}
  		return *this;
  	}
  	T& operator*()
  	{
  		return *(this->_ptr);
  	}
  	T* operator->()
  	{
  		return this->_ptr;
  	}
  	~SharedPtr()
  	{
  		--(*(this->_pcount));
  		if (*(this->_pcount) == 0)
  		{
  			delete _ptr;
  			_ptr = NULL;
  			delete _pcount;
  			_pcount = NULL;
  		}
  	}
  private:
  	T* _ptr;
  	int* _pcount;//指向引用计数的指针
  };
  ```

### 智能指针的作用

1. C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。
2. 智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。
3. 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的

拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象

4. unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

5. 智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

6. weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少

### auto_ptr

1. auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；
2. auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；
3. auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；
4. 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；
5. Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；
6. auto_ptr支持所拥有的指针类型之间的隐式类型转换。
7. 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；
8. T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。

### lambda表达式

1. 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；
2. 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。
3. lambda表达式的语法定义如下：

```cpp
[捕获列表] （参数列表） mutable ->return-type {代码段};
```

4. lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；
5. 捕获列表
   1. 值捕获不能修改，引用捕获可以修改
   2. 捕获this不能修改this，但是可以通过this修改成员变量

6. 参数
   1. 没有参数的时候可以省略掉参数列表

7. 返回值
   1. 列表初始化必须写返回值类型，其他情况下可以省略掉，lambda表达式会自动识别


### 左值引用和右值引用

C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。

1. 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
2. C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
3. 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
4. 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

**左值和右值**

左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值

```cpp
const int& a = 10;
```

右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

**左值引用和右值引用**

左值引用：传统的C++中引用被称为左值引用

右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置

**这里主要说一下右值引用的特点：**

- 特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
- 特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
- 特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

举个例子：

```text
#include <bits/stdc++.h>
using namespace std;

template<typename T>
void fun(T&& t)
{
	cout << t << endl;
}

int getInt()
{
	return 5;
}

int main() {
	
	int a = 10;
	int& b = a;  //b是左值引用
	int& c = 10;  //错误，c是左值不能使用右值初始化
	int&& d = 10;  //正确，右值引用用右值初始化
	int&& e = a;  //错误，e是右值引用不能使用左值初始化
	const int& f = a; //正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int& g = 10;//正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int&& h = 10; //正确，右值常引用
	const int& aa = h;//正确
	int& i = getInt();  //错误，i是左值引用不能使用临时变量（右值）初始化
	int&& j = getInt();  //正确，函数返回值是右值
	fun(10); //此时fun函数的参数t是右值
	fun(a); //此时fun函数的参数t是左值
	return 0;
}   
```

- 有地址就是左值，没有地址就是右值
- 能指向左值不能指向右值的就是左值引用（因为右值没有地址，无法被修改，所以不能指向；但是常左引用可以指向右值，因为不会被修改）
- 能指向右值不能指向左值的就是右值引用
- **move函数唯一的功能是把左值强制转化为右值**
- 被声明出来的左值引用、右值引用都是左值，因为有地址
- **右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值**。或者说**作为函数返回值的 && 是右值，直接声明出来的 && 是左值**

1. **从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。**
2. **右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。**
3. **作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。**

**可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用**`std::move`**触发移动语义，提升性能。**

### 完美转发

std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。

### 枚举类

单独的枚举是全局域的，也就是说多个枚举中的变量名不能重复，而枚举类则可以

### enable_shared_from_this

`std::enable_shared_from_this`能让其一个对象（假设其名为 t ，且已被一个`std::shared_ptr`对象 pt 管理）安全地生成其他额外的`std::shared_ptr`实例（假设名为 pt1, pt2, … ），它们与 pt 共享对象 t 的所有权。例如：若一个类 T 继承自`std::enable_shared_from_this<T>`，则 T 类中有继承自父类的成员函数：`shared_from_this`。 当 T 类的对象 t 被一个为名为 pt 的`std::shared_ptr`类对象管理时，调用`T::shared_from_this`成员函数，将会返回一个新的`std::shared_ptr`对象，它与 pt 共享 t 的所有权。

为什么要用 enable_shared_from_this？

- 需要在类对象的内部中获得一个指向当前对象的 shared_ptr 对象。
- 如果在一个程序中，对象内存的生命周期全部由智能指针来管理。在这种情况下，要在一个类的成员函数中，对外部返回 this 指针就成了一个很棘手的问题。

什么时候用？

- 当一个类被共享智能指针 `share_ptr` 管理，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的 `share_ptr`。

### functional和bind

#### Callable type

Callable type 指可以像调用函数一样被调用的对象或函数，包括：

- `std::function`
- `std::bind`
- `std::result_of`
- `std::thread::thread`
- `std::call_once`
- `std::async`
- `std::packaged_task`
- `std::reference_wrapper`

根据 C++ 17 Standard，所有 Callable type 都可以通过 `std::invoke` 方法进行[显式调用](http://en.cppreference.com/w/cpp/utility/functional/invoke)。

#### functional

`std::function`类模板是一种通用的函数包装器，它可以容纳所有可以调用的对象（[Callable](http://en.cppreference.com/w/cpp/concept/Callable)），包括 **函数**、**函数指针**、**Lambda表达式**、**bind表达式**、成员函数及成员变量或者其他函数对象。通过 `std::function` 可以储存、拷贝或调用 Callable 对象。它的模板参数如下：

```cpp
template< class R, class... Args >
class function<R(Args...)>
```

```cpp
// functional的例子
#include <iostream>
#include <functional>
double f(int x, char y, double z) {return x + y + z;}
void print_num(int num) {
    std::cout << num << std::endl;
}
struct Dog {
    int id;
    explicit Dog(int id): id(id) {}    
    void print_add(int i) const {        
        std::cout << id + i << std::endl;    
    }
};
class PrintString {
public:    
    void operator()(std::string&& s) const {        
        std::cout << s << std::endl;    
    }
};

int main(int argc, char **argv) {    
    // common function    
    std::function<void(int)> func_display_num = print_num;    
    func_display_num(9);    
    // common function    
    std::function<double(int, char, double)> func_display = f;    
    std::cout << func_display(3, 'a', 1.7) << "\n";    
    // lambda expression    
    std::function<void(const char*)> lbd_dsp_str = [](const char *s) {std::cout << s << std::endl;};     lbd_dsp_str("Scala");    
    // bind expression    
    auto func_num_bind = std::bind(&f, std::placeholders::_1, 'c', 2.4);    
    std::cout << func_num_bind(24) << "\n";    
    // function object    
    std::function<void(std::string&&)> func_obj_print = PrintString();    
    func_obj_print("C++ 17 Nice!");    
    // member function    
    const Dog dog(2424);    
    std::function<void(const Dog&, int)> func_mem_display_num = &Dog::print_add;	
    func_mem_display_num(dog, 24);    
    return 0;
}
```

#### bind

顾名思义，`std::bind`函数用来绑定函数的某些参数并生成一个新的`function`对象。`bind`用于实现偏函数（Partial Function），相当于实现了函数式编程中的 **Currying**（柯里化）。比如有一函数的定义为：

```cpp
void func_muti(int a, std::string&& b, const char* c, double d, char e) {    
    std::cout << a << ", " << b << ", " << c << ", " << d << ", " << e << "\n";
}
```

现在将此函数的一些参数绑定上值，其余部分用占位符对象（std::placeholders）表示。占位符是有序号的，代表调用此函数对象时参数在参数列表中的位置。比如：

```cpp
auto f = std::bind(&func_muti, 24, std::placeholders::_1, "Haha", std::placeholders::_2, 'P');  
f("Hehe", 24.24);
```

调用个函数对象相当于调用以下函数：

```cpp
void f(std::string&& b, double d) {
    std::cout << "24" << ", " << b << ", " << "Haha" << ", " << d << ", " << 'P' << "\n";   
}
```

### 原子类型(std::atomic)

## C++20

### 协程

- Subroutine（函数调用）

  在单线程中进行函数调用，只有等待被调方主动返回才能返回主调方原来的位置

- coroutine（协程）

  而协程可以通过`co_yield`和`co_await`来暂停运行，回到主调方原来的位置，协程的相关资源也不会被释放

  通过调用`resume()`来继续执行协程

```cpp
#include <coroutine>
#include <iostream>
using namespace std;

struct CoRet
{
    struct promise_type
    {
        int _out;
        int _res;
        // suspend_never是进入协程时不暂停，suspend_always是进入协程直接暂停，
        suspend_never initial_suspend() {return {};}
        suspend_always final_suspend() noexcept {return {};} // 协程代码的最后要不要停下来
        // 异常处理
        void unhandled_exception() {}
        // 返回值
        CoRet get_return_object()
        { return 
            {coroutine_handle<promise_type>::from_promise(*this)};
        }
        suspend_always yield_value(int r) {
            _out = r;
            return {};
        }
        void return_value(int r) {
            _res = r;
        }
    };
	// 可以控制协程运行
    coroutine_handle<promise_type> _h; // _h.resume(), _h()
};
struct Note { int guess; };
struct Input
{
    Note& _in;
    // 当遇到co_await的时候是否需要暂停当前协程，true为不需要暂停
    bool await_ready() { return false; }
    // 即将暂停之前的行为，返回值代表要跳转的位置，void为默认位置
    void await_suspend(coroutine_handle<CoRet::promise_type> h) {}
    // 当co_await需要返回一个值的时候执行的代码
    int await_resume() { return _in.guess; }
};

// 一个函数中包含co_await,co_yield,co_return任意一个就会被判定为协程
CoRet Guess(Note& note) {
    // 编译器隐式创建
    // CoRet::promise_type promise;
    // 返回值
    // CoRet ret = promise.get_return_object();
    // co_await promise.initial_suspend();
    int res = (rand()%30)+1;
    Input input{note};
    // 此处代码可以暂停
    int g = co_await input;
    cout << "coroutine: You guess " << g << endl;
    
    co_yield (res>g ? 1: (res == g? 0 : -1));
    // co_await promise.yield_value()

    co_return res;
    // co_await promise.final_suspend();
}

int main()
{
    srand(time(nullptr));
    Note note;
    auto ret = Guess(note);
    cout << "main: make a guess ..." << endl; 
    note.guess = 10;
    ret._h.resume(); // resume from co_await
    cout << "main: result is " << 
      ((ret._h.promise()._out == 1) ? "larger" :
      ((ret._h.promise()._out == 0) ? "the same" : "smaller"))
      << endl;

    ret._h.resume(); // resume from co_yield
    if(ret._h.done())
    {
       cout << "main: the result is " <<  ret._h.promise()._res <<endl;
    }
}
```



## 构造析构函数

### C++中的构造函数

- 默认构造函数
- 初始化构造函数（有参数）
- 拷贝构造函数
- 移动构造函数（move和右值引用）

  通过直接使用将亡值，来避免拷贝构造函数额外的开销；移动构造函数需要的参数是右值引用
- 委托构造函数

  - 不能成环委托
  - 初始化参数列表使用委托构造就不能初始化其他成员了

- 转换构造函数：将其他类型的对象隐式转换为本类的对象

### 构造函数为什么不可以定义为虚函数

1. 创建对象时需要知道对象的类型，而虚函数是运行时确认对象类型的。构造一个对象时，由于对象还未创建，编译器还未确定对象的类型，故不知道该调用基类还是派生类构造函数。

2. 调用虚函数需要使用到虚函数表，虚函数表存放在对象的内存空间中，构造函数为虚函数，对象未构建时没有内存空间也就没有虚函数表，也就没法调用虚函数。

### 析构函数为什么一般定义为虚函数

由于类的多态性，基类指针可以指向派生类的对象，如果释放该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。

如果使用指向对象的引用或者指针来调用虚方法，程序将使用为对象类型定义的方法，而不是该引用或指针类型定义的方法。这称为动态联编（晚期联编）。这种行为非常重要，使得基类引用或指针可以指向派生类对象；

如果析构函数不是虚函数的话，将会采用静态联编，delete语句将直接根据指针类型调用虚构函数，当父类指针指向子类对象的时候就会直接调用父类的析构函数而不会调用子类的析构函数。

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

### 关于虚函数表和虚表指针

1. 虚函数表全局共享，编译期构造完成
2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表

C++中**虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**

### 构造函数或者析构函数调用虚函数

1. 构造函数可以调用虚函数，编译可以通过不会报错，但是起不到动态绑定的作用，只会调用自身所在类的虚函数

2. 析构函数调用虚函数则是实现子类自己的析构函数

### 拷贝构造函数传引用

防止递归拷贝

### 直接初始化和拷贝初始化

直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。

- 当拷贝构造函数为private时：语句3和语句4在编译时会报错
- 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

### 移动构造函数

1. 我们用对象a初始化对象b，之后不再使用对象a，但是对象a还在占用内存，拷贝构造就是把a的内容复制一份给b，那么我们就可以直接使用a的空间，这样就避免了新的空间分配，降低了构造成本，这就是移动构造函数设计的初衷。
2. 对于指针，拷贝构造中一定要使用深拷贝，而移动构造中对于指针我们采用浅拷贝，那么就需要避免第一个指针释放空间，方法就是置空。
3. 移动构造的参数和拷贝构造不同，拷贝构造的参数是一个左值引用，而移动构造的参数是一个右值引用，这意味着移动构造的参数是一个右值或将亡值的引用。

### 空类自动生成的函数

默认构造函数、析构函数、拷贝构造函数、赋值运算符、*取地址运算符及其const版本*

- 这些函数都只有在需要调用的时候，编译器才会生成
- 4个函数都是public的
- 4个函数都是inline的
- 如果显式声明了其中任何一个，编译器就不会生成默认的函数了
- 自定义的拷贝构造函数不仅会覆盖默认拷贝构造函数，还会覆盖默认构造函数

## 内存管理

### 内存泄漏

通常指堆区内存的泄露，程序未能释放掉不再使用的内存，程序申请的一块内存，没有任何指针指向它，实质上是程序主动或被动地失去了对某段内存的控制。程序中动态分配的堆内存由于某种原因未释放或无法释放，造成内存的浪费。也可以指系统资源泄露，如socket、文件描述符，创建了不归还。

有一个宾馆，共有100间房间，顾客每次都是在前台进行登记，然后拿到房间钥匙。如果有些顾客不需要该房间了，既不去前台处登记退房，也不归还钥匙，久而久之，前台处可用房间越来越少，收入也越来越少，濒临倒闭。

1. realloc

   ```c
   /*这里就引出了一个内存泄露的问题，当realloc分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的。如果直接将realloc的返回值赋给ptr。那么当申请内存失败时，就会造成ptr原来指向的内存丢失，造成泄露。*/
   void *ptr = realloc(ptr, new_size);
   if (!ptr) {
       错误处理
   }
   // 以下为正确写法
   void *new_ptr = realloc(ptr, new_size);
   if (!new_ptr) {
       错误处理。
   }
   ptr = new_ptr
   ```
2. 堆内存泄漏→new、malloc和realloc后没有delete或者free
3. 系统资源泄露→bitmap、handle、socket等使用过后没有使用相应函数进行释放
4. 析构函数没有定义为虚函数→基类指针指向派生类对象，如果基类的析构函数不是虚函数，则无法调用子类的析构函数。注：1.正常构造的对象，派生类的析构函数会主动调用基类的析构函数，2.派生类指针指向派生类对象，调用派生类析构函数的同时，也会调用基类的析构函数，3.基类指针指向派生类对象，如果基类指针不是虚函数则只会调用基类的析构函数而不会调用派生类的析构函数，可能造成内存泄漏（std::string是否可以被继承，不可以，因为其虚构函数非虚）（动态关联、静态关联）

指针改变指向，未释放动态分配内存会导致内存泄漏

将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；智能指针可以防止内存泄漏

[内存管理一篇文章](https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368?ops_request_misc=%7B%22request%5Fid%22%3A%22164700289516780264046972%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164700289516780264046972&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79788368.pc_search_result_control_group&utm_term=C%2B%2B内存管理&spm=1018.2226.3001.4187)

#### 避免内存泄漏的几种方法

- 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
- 一定要将基类的析构函数声明为**虚函数**
- 对象数组的释放一定要用**delete []**
- 有new就有delete，有malloc就有free，保证它们一定成对出现

#### 检测内存泄漏

在构造函数和析构函数中计数，程序退出的时候打印看是不是0

### 类的对象存储空间

- 非静态成员的数据类型大小之和

- 编译器加入的额外成员变量(指向虚函数表的指针）

- **为了边缘对齐优化加入的padding**

  空类的对象大小为1（因为不允许一个对象的大小为0，因为不同的对象不能具有相同的地址），作为基类时大小为0
  

### 只能在堆（栈）上创建对象的方法

- 堆

  - 构造函数私有化

    在栈上创建对象也要调用构造函数，故私有化构造函数就不能在栈上创建对象了（拷贝构造也要私有，不然可以用堆上创建好的对象在栈上拷贝构造）。公有化一个静态成员函数，在内部用new创建对象并返回其指针

  - 析构函数私有化

    编译器在编译时会检查，没有析构函数不能创建对象。所以还需要实现一个函数调用私有的析构函数。

- 栈

  - 重载new

    将new重载成一个私有的成员函数

### 禁止一个类被实例化

- 将该类定义为抽象基类
- 私有化构造函数

### delete this是否合法

只要足够小心就是合法的，具体如下

- this指向的对象必须是new出来的，其他都不行
- 当事函数返回之后，该对象的其他函数及成员变量不能被调用或访问（因为已经销毁了）
- 当事函数返回后，不能以任何方式提及this

析构函数中不能使用delete this，因为会递归析构函数。

### 内存分配函数

**malloc**

函数原型： `void* calloc (size_t num, size_t size);`

分配足够的内存给大小为size的对象，并返回指向所分配区域的第一个字节的指针，若内存不够,则返回NULL，并且 不对分配的空间进行初始化。

**calloc**

函数原型: `void* calloc (size_t num, size_t size);`

为一个大小为num的数组分配内存，每个元素的大小是size，并且将每个元素初始化为0，同时返回指向所分配区域的第一个字节的指针。若内存不够，则返回NULL

**realloc**

函数原型： `void* realloc (void* ptr, size_t size);`

作用：将ptr所指向的内存空间的大小改为size个字节。如果新分配的内存比原内存大， 那么原内存的内容保持不变，增加的空间不进行初始化。如果新分配的内存比原内存小，那么新内存保持原内存的内容，增加的空间不进行初始化。返回指向新分配空间的指针。若内存不够,则返回NULL，原ptr指向的内存区不变。

**alloca**

函数原型：`void* alloca(size_t size);`

作用: 在栈上申请内存，不需要free函数释放，程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

### C++的内存分区

堆、栈、自由存储区、全局/静态存储区、常量区、代码区

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221021140634826.png" alt="image-20221021140634826" style="zoom:50%;" />

- 栈：执行函数时，函数内的局部变量在栈上创建，函数结束时这些存储单元自动释放。栈内存分配原则内置于处理器的指令集中，所以效率很高，但是大小有限
- 堆：就是那些new分配的内存块，编译器不负责释放，如果程序结束程序员没有释放掉，那么操作系统会自动回收
- 自由存储区：C++中通过new和delete动态分配和释放对象的抽象概念
- 全局/静态区：没什么好说的，如果没有初始化则自动初始化
- 常量存储区：存放常量，不允许修改
- 代码区：存放函数体的二进制代码

### 关于段错误

段错误通常指程序访问了不可访问的内存，这个内存要么不存在要么受系统给保护。

**如何产生段错误**

- 往受系统保护的内存地址写数据，如scanf
- 往NULL写数据，其实原理同上
- 内存越界（数组越界、变量类型不一致）

# 操作系统

## 基础

### 操作系统的功能

1. 资源分配，资源回收→CPU、硬盘、内存、IO设备

2. 为应用程序提供服务→系统调用接口

3. 管理应用程序→控制进程的生命周期

4. 操作系统内核的功能

   1. 进程调度→决定哪个进程使用CPU

   2. 内存管理→决定内存的分配和回收

   3. 硬件通信→为进程和硬件提供通信

   4. 系统调用→应用程序执行高权限操作，需要系统调用

### Linux如何运行一个可执行文件

[链接](https://blog.csdn.net/mazongshan1/article/details/37936971?ops_request_misc=%7B%22request%5Fid%22%3A%22164700233616781685324624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164700233616781685324624&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-37936971.pc_search_result_control_group&utm_term=执行可执行文件&spm=1018.2226.3001.4187)

### 如何查看一个进程是否被占用

netstat  -anp  | grep   端口号

### 同步、异步、阻塞、非阻塞

IO操作包含两个部分：发起IO请求、实际的IO读写操作。

阻塞与非阻塞的不同在于调用方发起IO请求后：阻塞方式发起IO请求后只能等着，非阻塞发起IO请求后可以直接返回

同步和异步的不同在于被调用方：操作系统帮忙完成并且通知就是异步，自己操作就是同步

![image-20230629200938145](photo/image-20230629200938145.png)

同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。

**同步：发出一个调用，没有得到结果之前，该调用就不返回。一旦调用返回，就得到返回值了。换句话讲，就是调用者主动等待这个调用的结果**

**异步：调用在发出之后，这个调用直接返回了，所以没有返回的结果。一个异步过程调用发出后，调用者不会立即得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或者通过回调函数来处理这个调用。**

阻塞与非阻塞的重点在于进/线程等待消息时候的行为/状态，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。

**阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。**

**非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。**

**同步和异步**、**阻塞和非阻塞**这两对儿概念，同步才区分阻塞和非阻塞，异步则一定是非阻塞的，不存在直接的`异步非阻塞`方式

### 缓冲区溢出

缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是一种异常现象，缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度，总是与所分配的储存空间相匹配，这就为“缓冲区溢出”埋下了隐患。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。

当然，随便往缓冲区中填东西造成它溢出，一般只会出现“分段错误”，而不能达到攻击的目的。最常见的手段是，通过制造缓冲区溢出，使程序运行一个用户shell（计算机壳层，属于“命令解析器”，用于接收用户的命令），再通过shell执行其它命令。如果该程序属于root且有suid权限的话，攻击者就获得了一个有“root权限”（系统权限的一种，也叫“根权限”）的shell，这样就可以对系统进行任意操作了。

C/C++因为没有内置的内存保护措施，更容易受到缓存区溢出攻击，主流操作系统都是C/C++编写·

**防范缓冲区溢出**

1. 编写正确的代码
2. 利用编译器的边界检查，实现对缓冲区的保护
3. 在程序指针失效之前进行完整性检查

### 原子操作时如何实现的

处理器会保证基本的内存操作的原子性。处理器保证从系统内存读取或写入一个字节是原子的，也就是一个处理器读取一个字节，其他处理器不能访问这个字节的内存地址。但是复杂操作无法保证其原子性。于是处理器提供了总线锁定和缓存锁定

- 总线锁定

  **所谓总线锁就是使用处理器提供的一个LOCK信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。**总线锁定把CPU和内存之间的通信锁住了，使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。

- 缓存锁定

  频繁使用的内存会缓存在Ln高速缓存中，那么原子操作就可以直接在处理器内部缓存中进行，而不需要总线锁定。

  所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，**因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。**

  但是当数据不能被缓存在处理器内部或操作的数据跨多个缓存行时、处理器不支持缓存锁定时只能使用总线锁定

### 如何写出让CPU跑的更快的代码

1. 尽量读取连续的数据，提高数据缓存命中率
2. 利用CPU的分支预测，提前将质量放在指令缓存
3. 提升多核CPU的缓存命中率，将线程和某CPU捆绑到一起。`int sched_setaffinity(pid_t pid，size_t cpusetsize，cpu_set_t *mask );`

### 缓存一致性

CPU Cache的数据写入

- 写直达：**把数据同时写入内存和 Cache 中**

  如果数据已经在Cache中了，就先将数据更新到Cache中，再写入到内存里面；如果数据不在Cache中，就直接把数据更新到内存里面

  问题是无论数据在不在Cache中，每次写操作都会写回到内存中。

- 写回，**发生写操作，新的数据值被写入Cache Block中，只有被修改过的Cache Block被替换时才需要写到内存中，减少了数据写回内存的频率**

现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的**缓存一致性（\*Cache Coherence\*）** 的问题。所以就出现了缓存一致性的问题

- 写传播

  当某个核心在Cache更新了数据，就必须同步到其他核心的Cache中。

  具体来讲就是CPU需要监听总线上的一切活动，将其他CPU Cache的更改同步到自己的Cache上。这样增加了总线负载，且不能保证事务串行化

- 事务串行化

  **MESI**协议(*Modified*，已修改,*Exclusive*，独占,*Shared*，共享,*Invalidated*，已失效)

  「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。

  当Cache Line状态时已修改或者独占时，修改更新其数据不需要广播给其他CPU，减轻了总线负载。

  ![img](photo/MESI协议.png)

### 终端退出，终端运行的程序会怎么样

终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出

### 如何让程序后台运行

（1）命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了

（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程

（3）nohup + &，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号

（4）运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响

（5）将 命令+ &放在()括号中，也可以是进程不受HUP信号的影响

## 进程

### 相关接口

```c
//创建一个子进程
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);

//用于回收子进程
//调用立即阻塞自己，找到一个僵尸子进程，wait收集这个子进程的信息放入status，否则一直阻塞
//如果不想得到子进程的信息可以将status设置为NULL
//成功返回回收子进程的pid，如果该进程没有子进程调用失败返回-1，errno设置为ECHILD
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int* status)

//回收子进程
//pid>0等待指定子进程，不管其他结束的子进程；pid=-1此时和wait完全一致
//pid=0等待同一进程组的任何子进程，对于加入别的进程组的子进程不予理睬
//pid<-1等待一个指定进程组的任何子进程，进程组为pid的绝对值
//options，Linux中提供WNOHANG和WUNTRACED，不想使用可以设置为0
//wnohang没有子进程退出立即返回，wuntraced涉及跟踪调试，极少用到
#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t pid,int *status,int options)
```

### 概念

编译过的代码形成的可执行文件只是磁盘上的静态文件，运行时被加载到内存中，CPU执行内存中的指令，这个程序叫做进程。进程时对运行时程序的封装，操作系统进行资源调度和分配的基本单位

用户态内核态→操作系统存在的意义→不允许公民持枪

visudo可以更改用户是否可以sudo的权限

### 进程的状态

<img src="photo/7-进程三个基本状态.jpg" alt="进程的三种基本状态" style="zoom:50%;" />

- 运行状态（*Running*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

<img src="photo/8-进程五个状态.jpg" alt="进程五种状态的变迁" style="zoom:50%;" />

- 创建状态（*new*）：进程正在被创建时的状态；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

<img src="photo/10-进程七中状态.jpg" style="zoom:50%;" />

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

### 进程的控制结构

在操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。**PCB 是进程存在的唯一标识**

- 进程描述信息
  - 进程标识符：标识各个进程，每个进程都有唯一的标识符
  - 用户标识符：进程归属的用户，主要用于共享和保护服务
- 进程控制和管理信息
  - 进程当前状态
  - 进程优先级：进程抢占CPU时的优先级
- 资源分配清单
  - 有关内存地址空间或虚拟地址空间的信息，打开文件的列表和IO设备信息
- CPU相关信息
  - CPU中各个寄存器的值，当进程被切换时，CPU的状态信息就会保存在PCB中

PCB通常是使用链表组织到一起的，分为就绪队列和阻塞队列，因为进程的创建销毁等调度会使进程状态频繁发生变化，所以使用链表来在组织。

### 进程的控制

- 进程创建

  1. 申请空白PCB，向PCB中填写一些控制和管理进程的信息，如进程标识符

  1. 为该进程分配运行时必须的资源，如内存

  1. 将PCB插入到就绪队列中，等待调度

- 进程终止

  1. 查找终止进程的PCB
  2. 如果处于运行状态，终止运行，将CPU分配给其他进程
  3. 如果还有子进程，将子进程交给init进程管理
  4. 将全部资源归还给操作系统
  5. 将其从PCB中删除
- 进程阻塞

  1. 停止进程的运行，保存信息到PCB中

  2. 修改PCB有关内容

  3. 调度其他进程
- 进程唤醒

  1. 从等待队列取出进程

  2. 修改PCB状态

  3. 将PCB插入到就绪队列中，等待调度程序调度

进程的上下文切换需要切换用户态的虚拟内存、站、全局变量等，还有内核态的内核堆栈、寄存器等。

### 进程调度算法

**调度原则**

1. 正在运行的程序发生了IO事件，使得CPU空闲，需要调度
2. 如果程序执行某个任务需要花费很长事件，一直占用CPU导致系统吞吐量降低，需要权衡任务长短进行调度
3. 周转事件=运行时间+等待时间，需要使得等待时间尽可能短
4. 就绪队列中的进程不应等待太久
5. 对于交互性要求比较高的应用，响应时间也是调度程序需要考虑的

- 先来先服务→批处理系统

  按照进程到达任务队列的顺序调度

  非抢占式，易于实现，效率不高

  **利于长作业（CPU繁忙型）不利于短作业（IO繁忙型）**

- 短作业优先→批处理系统

  每次从任务队列中拿出预计执行时间最短的任务

  非抢占式，优先照顾短作业，性能较好，降低平均等待时长，提高吞吐量

  **但是不利于长作业，长作业可能一直处于等待状态**

  未考虑任务的优先程度，不能用于实时系统

- 高响应比优先

  每次调度是计算所有进程的相应比=（等待时间+服务时间）/服务时间，取最高执行

  因为每次都需要计算相应比，效率较低

  但是一个进程的服务时间是不可预知的，所以高相应比有限是理想型调度算法

- 最短剩余时间优先→批处理系统

  该算法按照任务剩余时间挑选最短的任务执行，在作业执行过程中，如果出现剩余时间更短的新作业，则会发生抢占。该算法保证短作业进入系统很快得到处理

- 优先级调度

  为每个进程设置一个优先级，取最高优先级的进程执行，为了防止低优先级进程永远执行不到，可以随着时间增加优先级

- 时间片轮转→交互式系统

  用于分时系统，系统将cpu处理时间分为若干个时间片，进程执行完一个时间片后，计时器发出时钟中断请求，将当前任务移至队尾，以后每次调度都是这样，该算法保证给定时间内可以执行所有用户的请求
  
- 多级反馈队列

  结合时间片轮转和优先级调度

  - 多级表示由多个队列，每个队列优先级从高到低，同时优先级越高时间片越短
  - 反馈表示如果有新的进程加入优先级高的队列，立刻停止当前运行的进程，运行优先级较高的进程

  工作流程：

  - 设置多个队列，每个队列赋予不同的优先级，优先级越高时间片越短
  - 新的进程会被放到一级队列的末尾，按照先来先服务调度，如果在某一级队列规定的时间片内没有运行完，则会下降到下一级队列，以此类推直至完成
  - 当较高优先级队列为空，调度较低优先级队列的进程，如果此时有新进程加入高优先级队列，停止当前进程并移至当前队列尾部，让高优先级进程运行。

### 进程通信方法

- 无名管道

  其实管道就是内核里面的一级缓存

  - 特点

    1. 半双工，数据在同一时刻只能向一个方向流动，所以如果需要双向通信则应创建两个管道

    2. 数据只能从一端写入，另一端读出

    3. 写入管道的数据遵循先入先出的规则

    4. 管道所发送的数据是无格式的，必须由双方事先规定

    5. 无名管道只存在于内存中

    6. 对应内存中的一个缓冲区，不同系统可能大小不一样

    7. 管道中的数据是一次性的，读取完就没了

    8. 无名管道只能在有亲缘关系的进程间使用

    9. 存在阻塞方式

  - 读写管道情况

    1. 写端没有关闭，如果有数据就读出，没有数据就阻塞

    2. 写端关闭，读端返回0

    3. 读端没有关闭，数据满了，写端阻塞

    4. 读端关闭，写端会收到一个信号，然后退出

- 命名管道

  FIFO提供一个路径与之对应，这样不具有亲缘关系的进程也能通过其进行通信

  FIFO在文件系统中是一个特殊的文件，但是其内容却存在磁盘中

  当使用FIFO的进程退出后，FIFO继续保存在文件系统中方便其他进程使用

- 共享内存

  存储映射是使磁盘中的文件于存储空间的一个缓冲区相映射，共享存储映射指给两个或以上进程分配同一块存储区，一个进程写入该存储区的内容，可以被其他进程以读内存的方式读出，效率最高。但是共享内存不保证资源的同步，需要搭配锁来实现同步

- 消息队列

  - 原理

    原理：A进程给B进程发送消息，A进程将数据放入消息队列就可以返回了，B进程需要的时候再去读消息队列即可

  - 特点

    1. 消息队列是存储在内核中的消息链表，每个消息体都是固定大小的存储块，进程将消息体读走就在内核中消失

    2. 没有释放消息队列或关闭操作系统，消息队列会一直存在

  - 缺点

    1. 通信不及时，消息体大小也有限制

    2. 消息队列不适合大量数据的传输，

    3. 消息队列通信时，存在用户态和内核态的拷贝开销

- 信号

  信号是Linux中进程间通信的一种方式，信号可以在任何时候发送给进程而无需知道进程的状态。如果该进程处于未执行状态，信号由内核保存起来，直到进程恢复执行并传递给它为止。信号的开销最小

- socket

  不同主机的通信可以使用socket

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。

但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。

### 僵尸进程

在 Unix/Linux 系统中，正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束。当一个进程调用 exit 命令结束自己的生命时，其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等，但是留下一个称为僵尸进程的数据结构，这个结构保留了一定的信息（包括进程号 the process ID，退出状态，运行时间），这些信息直到父进程通过 wait()/waitpid() 来取时才释放。这样设计的目的主要是保证只要父进程想知道子进程结束时的状态信息，就可以得到。

一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

危害：僵尸进程虽然不占有任何内存空间，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，其进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。

**解决**

1. 父进程通过 wait 和 waitpid 等函数等待子进程结束，但这会导致父进程挂起，所以这并不是一个好办法，父进程如果不能和子进程并发执行的话，那我们创建子进程的意义就没有。同时一个 wait 只能解决一个子进程，如果有多个子进程就要用到多个 wait
2. 子进程退出时，向父进程发送 SIGCHILD 信号，父进程处理 SIGCHILD 信号，在信号处理函数中调用 wait 进行处理僵尸进程。
3. fork两次，原理是将进程成为孤儿进程，从而其的父进程变为 init 进程，通过 init 进程处理僵尸进程。具体操作为：父进程一次 fork() 后产生一个子进程随后立即执行 wait(NULL) 来等待子进程结束，然后子进程 fork() 后产生孙子进程随后立即exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵死进程了。
4. 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被 init 进程接管，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能瞑目而去了。

### 进程终止的方式

1. main函数的自然返回，`return` 
2. 调用`exit`函数，属于c的函数库（会调用终止处理函数、清除IO缓存） 
3. 调用`_exit`函数，属于系统调用（不会做exit函数进行的两步，而是从运行状态直接进入内核，从而退出进程）
4. 调用`abort`函数，异常程序终止，同时发送SIGABRT信号给调用进程。
5. 接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)

## 线程

### 相关接口

```c
// 创建一个新的线程
//编译和连接需要加上-pthread选项
//thread：用来返回线程的tid，*thread值即为tid，类型pthread_t == unsigned long int。
//attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。
//start_routine：线程执行函数的首地址，传入函数指针。
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);

//打印tid
#include <pthread.h>
pthread_t pthread_self(void);

//等待线程结束
//主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。
//tid：创建线程时通过指针得到tid值。
//retval：接受返回值的指针。
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);

//结束线程
//子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。
#include <pthread.h>
pthread_exit(void *retval);

//分离线程
//主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。
#include <pthread.h>
int pthread_detach(pthread_t thread);

// 通过retval传递返回值，可以通过join获取
void pthread_exit(void *retval);

//线程属性
typedef struct{
    int detachstate;    // 线程分离的状态
    int schedpolicy;    // 线程调度策略
    struct sched_param schedparam;    // 线程的调度参数
    int inheritsched;    // 线程的继承性
    int scope;    // 线程的作用域
    // 以下为线程栈的设置
    size_t guardsize;    // 线程栈末尾警戒缓冲大小
    int stackaddr_set;    // 线程的栈设置
    void *    stackaddr;    // 线程栈的位置
    size_t stacksize;    // 线程栈大小
}pthread_attr_t;

pthread_attr_get


```

### 概念及特点

1. 线程是轻量级的进程，也有PCB
2. 在内核中进程和线程是一样的
3. Linux中线程是最小的执行单位，进程是最小的资源调度单位
4. 无论是fork还是pthread_create在内核中都是调用clone函数，如果复制对面地址空间就是进程，共享地址空间就是线程，pthread函数都是库函数而不是系统调用

### 线程共享和非共享资源

- 共享

  1. 文件描述符表

  2. 每种信号的处理方式

  3. 当前工作目录

  4. 用户ID和组ID

  5. 全局变量

  6. 栈空间

- 不共享

  1. 线程ID

  2. 处理器现场和栈指针（内核栈）

  3. 独立的栈空间（用户栈）

  4. errno屏蔽字

  5. 信号屏蔽字

  6. 调度优先级

### 线程优缺点

- 优点

  1. 提高程序并发性

  2. 开销比较小

  3. 数据通信、共享方便

- 缺点

  1. 库函数不如系统调用稳定安全

  2. 调试、编写困难，gdb不支持

  3. 对信号支持不好

### 进程和线程的比较

比较

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

减小开销

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

### 线程的上下文切换

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；



### 进程线程模型

#### 多线程

我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。

我们必须知道，**做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，**而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。

比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。

对于线程，我认为弄清以下两点非常重要：

- 线程之间有无先后访问顺序（线程依赖关系）
- 多个线程共享访问同一变量（同步互斥问题）

另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。

而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。


#### 多进程

每一个进程是资源分配的基本单位。

进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。

实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。

父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。

如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。

我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。

### 多线程

- 多线程的好处

  1. 通常一个应用中会同时进行很多活动，随着程序的运行，这些活动可能会进入阻塞状态，将这些活动分解成多个并发执行的线程，简化设计模型

  2. 多线程共享内存空间，这是多进程所没有的

  3. 线程比进程开销小，更容易创建和释放

  4. 多线程是io密集型时，多线程可以使这些活动重叠运行，提高程序运行效率
- 多线程的注意点

  1. 线程之间有没有先后关系（线程依赖关系）

  2. 多个线程共享同一变量（互斥问题）

  3. 多个线程无法共享彼此独立的栈空间

多线程并发执行一段程序，导致结果不唯一，我们就说多线程之间产生了**竞争**

我们将多线程操作共享变量的代码成为**临界区**，为了避免竞争，我们需要保证同一时间只有一个线程在临界区执行，也就是说线程在临界区执行需要**互斥**

多线程之中的每个线程可能负责不同的工作，也就是线程之间可能是合作的关系，那么就需要让并发的线程在某些关键点上等待/通知，这种等待和通知称为**线程同步**

- 同步：多线程之间执行应该有一定顺序，或者某个线程的执行需要其他线程提供的条件/资源
- 互斥：多线程之间的操作临界区不能再同一时刻进行

#### 线程间同步方法

- 互斥锁

  线程想要访问临界区资源必须先获得锁，没有获得锁的线程只能阻塞等待或返回，待线程访问临界区结束释放锁，其他线程即可开始获得锁

- 条件变量

  两个动作→1.线程等待条件成立而挂起 2.线程使条件成立

- 信号量

  信号量是一个计数器，表示临界资源的数量，有线程释放资源信号量加一，有线程申请到资源时信号量减一

### 一个进程可以创建多少个线程和什么有关

- 如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是10M，那么一个进程最多只能创建 300 个左右的线程。
- 如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。
- 顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁。

### 中断

- 中断的产生：为了实现多道程序并发，提高资源利用率

- 中断的概念和作用：中断意味着操作系统介入，CPU会进入内核态；中断是用户进入内核态的唯一途径

- 内中断（异常）
  - 自愿中断--指令中断--有意为之，如系统调用（trap）
  - 强迫中断--硬件故障--由错误条件引起的，可能被故障处理程序修复，如缺页
  - 软件中断--终止--不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除以0
- 外中断
  - 外设要求：IO操作完成的中断信号
  - 人工干预：用户强行终止一个进程
- 中断处理过程
  1. 关中断（硬件）：CPU响应中断后，应拒绝其他中断源的中断请求
  2. 保存断点（硬件）：为了能够恢复执行这个进程，需要将程序的断点保存下来（程序计数器PC）
  3. 终端服务程序寻址（硬件）：取出中断程序的入口地址送到程序计数器PC
  4. 保存现场和屏蔽字（中断程序）：保护现场，程序状态字寄存器和某些通用寄存器的内容
  5. 开中断（中断程序）：允许更高级中断请求得到响应，想象一下多道程序设计的并发执行，cpu交替执行内存中的各个程序
  6. 执行中断服务程序（中断程序）：这是中断请求的目的，完成某些中断后的操作
  7. 关中断（中断程序）：保证在恢复现场和屏蔽字时不会被中断，完成中断后的操作之后需要恢复现场，不希望被打扰
  8. 恢复现场和屏蔽字（中断程序完成）：将现场和屏蔽字恢复到原来的状态
  9. 开中断->中断返回（中断程序）：中断服务程序的最后一条指令通常是一条中断返回指令，使其回到原程序的断点处，以便继续执行原程序

## 协程

协程分两种，无栈协程(stackless)和有栈协程(stackful)，前者无法解决异步回调模式中上下文保存与恢复的问题

协程是可以暂停和恢复的函数

### 为什么暂停

1. 性能需要
2. 美观需要
3. 逻辑需要

### 暂停之后

1. 回到调度器
2. 回到caller（可以携带计算结果回到上一级调用）
3. 启动另一个协程

```cpp
Result Coroutine() {
  std::cout << 1 << std::endl;
  co_await std::suspend_always{};
  std::cout << 2 << std::endl;
  std::cout << 3 << std::endl;
  co_await std::suspend_always{};
  std::cout << 4 << std::endl;
};
```

在C++中一个函数的返回值类型如果符合协程的规则，那么这个函数就是一个协程。

CPP协程会在开始执行的时候开辟使用operator new开辟一块内存来存放协程的状态信息。 

协程的复杂原因之一是：参数如果是指针或者引用类型，开发者需要自行保证指针或引用的生命周期、如果是值类型，则需要考虑移动或复制的成本。



## 进程和线程

### 进程和线程的区别和联系

- 二者都是程序员实现并发的手段，

1. 进程是对运行程序的封装，进程是系统资源分配的基本单位，线程是CPU（程序计数器、寄存器和栈等）调度的基本单位

2. 相对进程而言，线程更接近于一个执行体，它可以与进程中的其他线程共享进程所有用的全部资源，但拥有自己的栈空间和独立的执行序列

3. 进程的创建需要大量的系统资源如内存、CPU和文件句柄，销毁时也要进行相应的回收，所以创建和销毁进程的代价比较大，而线程则比较小。

4. 进程与进程之间不会互相影响，而一个线程崩溃会导致进程崩溃或终止，从而影响进程中的其他线程

5. 一个进程可以有多个线程，一个线程只能属于一个进程

### 进程和线程的选择

![image-20230318140343938](photo/image-20230318140343938.png)

### 进程线程协程

从定义来看

- 进程是资源分配和拥有的基本单位。进程通过内存映射拥有独立的代码和数据空间，若没有内存映射给进程独立的空间，则没有进程的概念了。
- 线程是程序执行的基本单位。线程都处在一个进程空间中，可以相互访问，没有限制，所以使用线程进行多任务变成十分便利，所以当一个线程崩溃，其他任何一个线程都不能幸免。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。
- 协程是用户态的轻量级线程，线程内部调度的基本单位。协程在线程上执行。

从系统调用来看

- 进程由操作系统进行切换，会在用户态与内核态之间来回切换。在切换进程时需要切换虚拟内存空间，切换页表，切换内核栈以及硬件上下文等，开销非常大。
- 线程由操作系统进行切换，会在用户态与内核态之间来回切换。在切换线程时需要保存和设置少量寄存器内容，开销很小。
- 协程由用户进行切换，并不会陷入内核态。先将寄存器上下文和栈保存，等切换回来的时候再进行恢复，上下文的切换非常快

从并发性来看

- 不同进程之间切换实现并发，各自占有CPU实现并行
- 一个进程内部的多个线程并发执行
- 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理

## 互斥和同步

### 互斥锁

也叫互斥量，一种简单的加锁方式来控制共享资源的访问，只有两种状态加锁和解锁

1. 在访问共享资源之前，对互斥锁进行加锁

2. 访问完成后释放锁

3. 互斥锁被锁后，任何线程访问都会阻塞，直到锁释放
### 读写锁

允许多个读出，只允许一个写入，写优先级高于读

### 自旋锁

如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

### 条件变量

与锁不同，条件变量使用来等待的而不是上锁，用来阻塞进程，直到某个条件满足

优点：相比于互斥锁减少竞争，使用锁的情况，除了生产者和消费者要争夺锁以外，消费者和消费者也要争夺锁，如果没有资源消费者之间争夺锁是没有意义的

### 信号量

信号量本质上是一个计数器，用来控制对公共资源的访问，当信号量大于0时可以访问，否则阻塞等待信号量大于0，P操作使信号量减一，V操作使信号量加一

### 死锁

如果多个进程中的每一个进程都在等待其他进程引发的事件（争夺资源引起的上锁），那么这个进程集合就死锁了。

产生死锁的原因在于，系统中存在一些不可剥夺资源，当两个或以上的进程占由有资源，同时请求对方资源时，就会导致每个进程都无法向前推进。

- 资源

  1. 可抢占式资源→可以从拥有他的进程手中抢夺该资源而不引发副作用，如存储器

  2. 不可抢占式资源→在不引起任何计算失败的情况下，无法把它从其他进程手中抢来

- 必要条件

  1. 互斥→资源具有排他性，即在资源在一段时间内只能被一个进程占有。

  2. 请求和保持→当进程因请求资源而阻塞的时候，不会释放已经占有的资源。

  3. 不可剥夺→已经分配给一个进程的资源无法被其他进程强制抢占，只能由自己释放

  4. 环路等待→死锁发生时，进程中一定有两个或两个以上进程组成的回路

- 处理方法

  鸵鸟算法→假装什么都没发生

- 死锁预防

  1. 破坏请求条件：一次性分配所有资源，这样就不会再有请求了
  2. 破坏保持条件：只要有一个资源得不到分配，就不会给该进程分配其他资源。
  3. 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其他资源，释放已有资源。
  4. 破坏环路等待：系统为资源赋予编号，每个进程按照编号递增进行请求，释放则相反

- 死锁避免

  银行家算法

- 死锁解除

  1. 资源剥夺：挂起某些死锁进程并抢占它的资源
  2. 撤销进程：杀死部分、甚至全部陷入死锁的进程（可以按照进程优先级来杀）
  3. 进程回退：让一个或多个进程回退到足以避免死锁的地步，进程回退时释放资源。要求系统保持进程的历史信息，设置快照

- 死锁检测

  1. 通过检测有向图是否有环，如果有环死锁就可能发生

## 内存管理

### 虚拟内存及相关

最初的操作系统堆内存的操作直接作用在物理内存上，这样处理就会出现问题如：

1.可能出现恶意或错误内存访问。程序都是直接访问内存，恶意程序就可以随意修改其他进程的内存数据，bug程序也可能不小心修改其他程序的内存数据。

2.内存效率低。会产生内存碎片，数据装入装出内存需要的代价比较大，进程之间的切换效率低。

3.程序地址不稳定，操作系统为程序分配的内存是随机的，所以程序运行的地址是不确定的。

#### 虚拟内存

虚拟内存基于一个程序不会同时使用它所需的所有内存，操作系统只需要将需要使用的内存放在内存中，不需要使用的放在磁盘中等待需要时调入内存即可。创建一个进程的时候，操作系统会分配4GB的虚拟进程地址空间（因为32位的指针寻址能力是4GB），在Windows系统下，这个虚拟地址空间被分成了4部分：NULL指针区、用户区、64KB禁入区、内核区。应用程序能使用的只是用户区而已，大约2GB左右(最大可以调整到3GB)。

虚拟内存很适合多道程序设计，多个程序的内存片段被加载到内存中，当一个程序等待它所需数据加载到内存时，可以将CPU交给另一个程序使用。程序所使用的内存均为虚拟内存，程序使用的内存不是接被送到地址总线，而是交给MMU进行地址映射。

#### 内存覆盖

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。

#### 分段

有了虚拟内存之后，想要访问虚拟地址就必须在物理地址和虚拟地址之间进行映射。分段就是其中一种，如将虚拟地址空间上的10M大小空间映射到真实地址空间上。通过这样的方法将不同程序的地址空间映射到不同的真实地址空间就实现了地址隔离，并且程序对此不需要知情，所以程序的运行地址也可以说是确定的了。

分段解决了问题1、3，但是问题2内存使用效率的问题还在。在分段映射方法种，每次换入换出内存的都是整个程序，就会造成大量的IO，这样的操作方法粒度比较大，因为程序的局部性原理，所以分段效率比较低。

#### 分页

将地址空间分成许多页，由CPU和操作系统共同决定，个人pc通常是4KB一页。

分页的主要思想是程序用到哪页就为哪页分配内存，没用到的页暂时保留在磁盘上，用到的时候再分配内存，然后简历虚拟地址空间中的页和分配好的物理内存页之间的映射。

当一个程序启动时，操作系统会为该进程创建一个4GB的虚拟地址空间（只需要创建映射机制所需要的数据结构也就是页表），当程序所需的数据不在内存中时，CPU会陷入操作系统，此状态被称为缺页中断或缺页错误，操作系统会找到一个很少用到的页框将其写回磁盘，将需要访问的页面调入到刚刚被回收的页框，重启引发中断的指令。分页和分段的本质区别在于粒度。

单页表的缺陷在于每个进程都有自己的虚拟地址空间，都有自己的页表，需要占用很大的空间。

#### 分页和分段的区别

1. 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。
2. 页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。
3. 分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
4. 段的信息时逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制

#### 段页式内存管理

分段和分页并不是对立的。我们可以先将程序划分为几个有意义的段，再将每个段划分为多个页，这样地址结构由段号、段内页号、页内偏移三个部分组成。

#### 页表项

![image-20230318140358951](photo/image-20230318140358951.png)

页框号→映射中的输入

在/不在位→用于指出该页表是否在内存中，1表示该表项在内存中可用，为0表示不可用，访问该页会触发缺页中断

保护位→指出一个页面允许什么类型的访问，两位→读、写，三位→读、写、执行

修改位和访问位→为了记录页面的使用情况。如果一个页表的修改位为1则必须将其写回磁盘，否则直接丢弃即可，修改位也被称为脏位。无论是读还是写，访问位都被置一，它的值被用来指导操作系统当发生缺页中断时应该被淘汰哪个页表

高速缓存禁止位→ 操作系统正在循环等待着某个I/O设备对他的指令做出响应，保证硬件是不断的从设备中读取数据而不是访问一个旧的被高速缓存的副本是非常重要的，通过这一位就可以禁止高速缓存。

#### 多级页表/倒排页表

页表一定要覆盖到所有的虚拟地址空间，不分级的页表需要100多万个页表项，而二级分页就只需要1024个页表项（1024个一级页表，二级页表在需要的时候再创建）。多级页表的问题是虚拟地址到物理地址的转换多了几层映射，显然降低了效率。解决方法见上TLB。

#### 转换检测缓冲区（TLB）/相联存储器/快表

通常存储在MMU中。当一个虚拟地址被放入到MMU中进行转换时，硬件先将虚拟页号与TLB中的表项并行匹配，判断此地址是否在TLB中，如果在且保护位匹配则直接取出，如果保护位冲突则产生一个保护错误，即对页表非法访问。如果没有找到，则会在TLB中淘汰一个页表项并用新找到的页表项替代它。

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。

#### 页面置换算法

当发生缺页中断时，操作系统必须选择一个页面将其换回磁盘以加载新的页面，如果该页面被修改过则必须写回磁盘，如果没有被修改过则直接覆盖即可，如果随机置换置换会常用的页面就会比较浪费性能，那么应该按照什么规则来置换呢

- 最优算法

  当需要置换页面时，操作系统置换掉最后被需要的页面，但是操作系统无法知道哪个页面最后被需要，所以此算法无法实现，但是可以作为衡量其他算法优劣的指标

- 最近未使用算法(Not Recently Used→NRU)

<img src="photo/image-20230526133740342.png" alt="image-20230526133740342" style="zoom:50%;" />

通过页表项中的R位和W位将所有页面分为四类，当需要置换页面时，随机选择编号最小的页面进行置换，并且R位会周期性置零。容易实现，性能一般

- 先进先出算法(First-in First-out→FIFO)

  同样是一个开销比较小的算法，将进入内存的页面根据先后顺序维护成一个链表，需要置换页面时，此算法就会将最早进入内存的页面置换掉，但可能会删除最先进入但是持续使用的页面，通过小卖店例子即可发现此算法问题很大

- 第二次机会算法

  此算法位FIFO算法的改进，当需要页面置换的时候，如果发现最早的页面R位为零直接置换，如果为1则会将R位置零并且放到最新使用的位置继续扫描，即第二次机会

- 时钟算法

  第二次机会很好，但是可能需要频繁地在链表中移动元素，降低了效率，时钟算法即将所有进入内存的页面维护为一个类似于时钟的环形链表，使用一个指针指向最老的界面，置换方式和第二机会算法相同，避免了在链表中移动元素的问题

- 最近最少使用算法(Least Recently Used→LRU)

  该算法是对最优算法的一个近似，基于这样的观察：前面频繁使用的页面后面很大可能也会频繁被使用，前面不被使用的页面后面大概率也不会被使用→很久不用的页面未来较长时间内也不会使用，当发生缺页中断需要置换页面时置换未使用时间最长的页面

  LRU算法可以实现但是比较麻烦，需要在内存中维护一个包含所有内存中页面的链表，最近最多使用的在表头，最远最少使用的在表尾，但是这个链表需要在每次访问内存时更新。

  可以使用一个硬件计时器，每条指令执行加1，被访问页面将当前的值保存在页表项中，需要置换时取值最小的页面，但是很少有计算机有这样的硬件

- 软件模拟LRU

  1. 最不常用算法(Not Frequently Used→NFU)

     每个页面使用一个软件计数器，初值为零。每次时钟中断时，操作系统扫描所有页面，将每个页面的R位加到计数器上，置换时取值最小，性能一般

  2. 老化算法

     更加接近LRU算法，同样使计数器加上R位的值，但是每次时钟滴答都会将计数器的值右移一位，这样就避免了某个页面的值过大以后不常用却不能被替换掉的问题

- 工作集算法

  程序在一段时间内，会频繁的访问一部分页面，这一部分页面被称为工作集，如果整个工作集被装载到内存中，那么程序在运行时则不会产生太多的缺页中断

  1. 常规工作集算法

     每次缺页中断时替换掉不在工作集中的页面，需要扫描整个页表才能确认被淘汰的页面

  
  2. 工作集时钟算法
  
     与时钟算法思想类似，以页框为元素的循环表（存有上次使用事件）
  
     发生缺页中断时首先检查R位，为一表明在此时钟滴答中使用过，不适合替换，置零继续遍历。如果R位为零并且生存时间大于X且干净（说明不在工作集中，且不需要写回磁盘），则可以直接替换；如果不干净则继续遍历（避免调度写回磁盘操作引起进程切换，因为后面可能存在一个干净的页面）

#### 虚拟内存的用处

1. 虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
2. 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
3. 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

#### 逻辑地址转换为物理地址的过程

1. 根据逻辑地址计算出页号、页内偏移量
2. 判断页号是否越界
3. 查询页号，找到页号对应的页表项，确定页面
4. 用内存块号和页内偏移量得出物理地址
5. 访问内存单元

### malloc相关

#### Linux内存分布

<img src="photo/32位虚拟内存布局.png" alt="虚拟内存空间划分" style="zoom:33%;" />

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（[跟硬件和内核版本有关 (opens new window)](http://lishiwen4.github.io/linux/linux-process-memory-location)）；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；

#### malloc如何分配内存

实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存，通过以下方式申请堆区内存。

- 方式一：通过 brk() 系统调用从堆分配内存（将堆顶指针向高地址移动，这一步可以扩大进程在运行时的堆大小）
- 方式二：mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；
- 进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。

#### free释放内存

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

#### free怎么知道释放多少空间

malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节，这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。

这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。

### 内存紧张会发生什么

#### 内存分配的过程

应用程序通过malloc函数申请的内存实际上是虚拟内存，应用程序读写了这块内存CPU就会访问此内存，如果发现没有映射到物理内存，CPU就会产生缺页中断。缺页中断函数会查看是否有空闲的内存，如果有直接分配物理内存并和虚拟内存建立映射，如果没有内核就会进行回收内存，以下为回收方式

- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

直接回收后仍不满足需求就会触发**触发 OOM（Out of Memory）机制**。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。

#### 哪些内存可以被回收

- **文件页**（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，**回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存**。
- **匿名页**（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们**回收的方式是通过 Linux 的 Swap 机制**，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。

文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表。

#### 内存回收带来的性能影响

可以看到，回收内存的操作基本都会发生磁盘 I/O 的，如果回收内存的操作很频繁，意味着磁盘 I/O 次数会很多，势必降低系统性能，下面说说解决方法

- 调整文件页和匿名页的回收倾向

  文件页回收的代价相比匿名页会小一些，因为干净的文件页是不会触发IO的，但匿名页Swap一定会触发IO，Linux 提供了一个 `/proc/sys/vm/swappiness` 选项，用来调整文件页和匿名页的回收倾向。swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。

- 尽早触发 kswapd 内核线程异步回收内存

- NUMA，对CPU进行分组，每组拥有自己独立的资源，当某组内存不足，可以去其他组寻找空闲内存。

### 预读失效和缓存污染

通过LRU算法对缓存页面进行存储。

#### 预读失效

操作系统和数据库会对数据进行预读，比如用户想要读3k的数据，操作系统可能读了12k进入内存，这样如果用户想读接下来的数据就不用进行磁盘IO了。

如果这些被提前加载到内存的页没有被访问，就是预读失效，如果使用传统的 LRU 算法，就会把「预读页」放到 LRU 链表头部，而当内存空间不够的时候，还需要把末尾的页淘汰掉。如果这些「预读页」如果一直不会被访问到，**不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率** 

- Linux 操作系统实现两个了 LRU 链表：**活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）**；
- MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：**young 区域 和 old 区域**。

#### 缓存污染

Linux和MySQL通过改进LRU避免了预读失效

但是如果数据只被访问一次就加入到热区，那么就有可能会出现缓存污染的问题。

如果一次需要查询很多数据的话，就会将原来的很多热数据全部淘汰，当这些热数据再次被访问的时候就还要从磁盘中加载，造成系统性能急剧下降。即使查询少量数据也会存在缓存污染的问题，只是没有大量数据那么严重。

数据访问一次就要加入热区这个门槛太低了，Linux和MySQL将门槛提高到两次，并且MySQL还对停留在冷区的时间进行了要求。

### 内部碎片外部碎片

**碎片**是指内存中不足以用来分配给其他进程的小空间。

内部碎片和外部碎片是在内存连续分配中产生的。内部碎片是因为**固定分区**分配方式，而外部碎片是由于**动态分区**分配产生的。

内部碎片：分配给作业的存储空间中**未被利用**的部分。

外部碎片：系统中**无法利用的小存储空间**。

### 动态分区匹配算法

![在这里插入图片描述](photo/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0MjEwNQ==,size_16,color_FFFFFF,t_70.png)

### 系统抖动

在分页存储管理中，从主存中换出某一页，由马上请求换入该页面，这种反复换入换出的现象，成为系统抖动，产生这种现象的主要原因时置换算法选择不当。

系统抖动会导致系统的实际效率非常低，严重的可能会导致系统瘫痪。（FIFO可能经常抖动）

产生原因：进程内存不足，分配页面太少，所以总是缺页。

解决方法：换一个好一点的页面置换算法、减少进程数、增大内存、使内存在自身范围内进行置换。

### 常见内存分配错误

1. 内存分配未成功，却使用了它

   使用内存之前未检查指针是否为NULL

2. 内存分配虽然成功，但是为初始化就引用

   未初始化导致引用初值错误（如数组）

3. 内存分配成功并且已经初始化，但操作越过了内存的边界

4. 忘记释放内存导致内存泄漏

5. 释放了内存却继续使用

## 文件系统

### 文件系统的基本组成

Linux文件系统会为每个文件分配两个数据结构：索引节点、目录项

- 索引节点（inode），用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、**数据在磁盘的位置**等等。索引节点是文件的**唯一**标识，它们之间一一对应，也同样都会被存储在硬盘中，所以**索引节点同样占用磁盘空间**。
- 目录项，也就是 *dentry*，用来记录文件的名字、**索引节点指针**以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，**目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存**。

索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是一对多，就是说文件可以有多个别名（硬链接）

## 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

1. 先来先服务

   按照磁盘请求的顺序进行调度。

   优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

2. 最短寻道时间优先

   优先调度与当前磁头所在磁道距离最近的磁道。

   虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

3. 电梯扫描算法

   电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

   电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

   因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。


## 服务器高并发解决方案

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909150618723.png" alt="image-20220909150618723" style="zoom: 50%;" />

## 五种IO模型

[Linux的五种IO模型](https://blog.csdn.net/qq_36095679/article/details/89641867?ops_request_misc=%7B%22request_id%22%253A%22164516904216780265412270%22%252C%22scm%22%253A%2220140713.130102334..%22%7D&request_id=164516904216780265412270&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89641867.first_rank_v2_pc_rank_v29&utm_term=Linuxio%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187)

## 上下文切换

[上下文切换](https://blog.csdn.net/lee_ham/article/details/102986571?ops_request_misc=%7B%22request%5Fid%22%3A%22164517056716781685382287%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164517056716781685382287&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-102986571.first_rank_v2_pc_rank_v29&utm_term=上下文切换&spm=1018.2226.3001.4187)

## 常用命令

```bash
find / -name 'b'    查询根目录下（包括子目录），名以b的目录和文件；
find / -name 'b*'    查询根目录下（包括子目录），名以b开头的目录和文件；
find . -name '*.pyc' -exec rm -rf {} \;  递归删除.pyc格式的文件
ping 49.32.587.164    查看服务器是否可用
netstat -tunlp|grep 8080   指定端口号的进程情况
ps -aux |grep 28990    查看PID进程信息
wc -l  统计输入多少行数据
```

## 文件系统

bash保留的012文件描述符→标准输入，标准输出，标准错误，这些是进程的行为，不影响其他进程

每一个文件有一个inode元数据存储文件的相关信息用来索引

ls -i 查看文件的inode号，软连接inode号不同，硬链接inode号相同即同一个文件

```c
//打开一个目录
opendir(const char* name);
readdir()
//获取一个文件的属性，传入软链接会击穿，直接找到源文件，lstat取得软链接文件的属性
int stat(const char* pathname, struct stat* buf);
/*
成功返回0，失败返回-1
pathname，文件路径（名）
buf，stat类型的结构体，传出参数，用来获取结果
*/
//同为获取文件描述符，区别是描述文件的方式为文件描述符
int fstat(int fd, struct stat* buf);
//复制一个现存的文件描述符
int dup(int oldfd);
int dup2(int oldfd, int newfd);
/*
成功返回当前可用最小文件描述符，失败返回-1
dup2可以通过newfd指定我们想要的文件描述符
如果newfd已经被占用了，那就将newfd所指的文件关闭
newfd==oldfd，返回newfd，而不关闭newfd所指的文件
dup2所复制的文件描述符与之前的文件描述符共享各种文件状态
*/
int fcntl(int fd, int cmd, .../*arg*/);
```



## LinuxIO模型

两个系统对象：1. **application** 调用这个IO的进程 2. kernel系统内核

IO的过程是：1. **wait for data** 等待数据准备 2. **copy data from kernel to user** 将数据从内核拷贝到用户进程中

进程切换：为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 **进程切换很消耗资源**。

进程阻塞：正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。**当进程进入阻塞状态，是不占用CPU资源的**。

#### 阻塞IO

在linux中，默认情况下所有的socket都是blocking

用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。**整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够**。

所以，blocking IO的特点就是在IO执行的两个阶段都被block了。

#### 非阻塞IO

同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。

由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。**一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性**。

#### 多路IO复用

用户首先将需要进行IO操作的socket添加到select中，然后**阻塞地等待select系统调用返回**。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。

从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在**同一个线程内同时处理多个IO请求的目的**。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

#### 信号驱动IO

使用信号，让内核在文件描述符就绪的时候使用 SIGIO 信号来通知我们。我们将这种模式称为信号驱动 I/O 模式。

允许Socket使用信号驱动 I/O ，还要注册一个 SIGIO 的处理函数，这时的系统调用将会立即返回。然后我们的程序可以继续做其他的事情，当数据就绪时，进程收到系统发送一个 SIGIO 信号，可以在信号处理函数中调用IO操作函数处理数据

由于信号驱动IO在实际中并不常用

#### 异步IO

Linux下的异步IO其实用得很少 ，著名的高性能网络框架netty 5.0版本被废弃的原因便是：使用异步IO提升效率，增加了复杂性，却并且没有显示出明显的性能优势。

第一阶段：当在异步 I/O 模型下时，用户进程如果想进行 I/O 操作，只需进行系统调用，告知内核要进行 I/O 操作，此时内核会马上返回， 用户进程 就可以去处理其他的逻辑了 。

第二阶段：当内核完成所有的 I/O 操作和数据拷贝后，内核将通知我们的程序，此时数据已经在用户空间了,可以对数据进行处理了

#### 总结

前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的。

在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于系统调用。相反，异步I/O模型在这等待数据和接收数据的这两个阶段里面都是非阻塞的，可以处理其他的逻辑，用户进程将整个IO操作交由内核完成，内核完成后会发送通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

### 零拷贝

零拷贝（Zero-Copy）是一种 `I/O` 操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。其在 `FTP` 或者 `HTTP` 等协议中可以显著地提升性能。但是需要注意的是，并不是所有的操作系统都支持这一特性，目前只有在使用 `NIO` 和 `Epoll` 传输时才可使用该特性。

#### 传统IO存在的性能问题

如果服务器要提供文件传输功能：将磁盘上的文件读取出来，然后通过网络协议发送给客户端

传统IO的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，内核空间的数据是通过操作系统层面的IO接口从磁盘读取或写入。如下图

![image-20230609140014819](photo/image-20230609140014819.png)

期间发生了4次用户态和内核态的上下文切换（read和write各两次），期间发生了4次数据拷贝（两次是DMA的拷贝，另外两次是通过CPU拷贝）。

#### 零拷贝

关于零拷贝主要技术有 `mmap+write`、`sendfile`和`splice`等几种方式。

零拷贝的基础是操作系统使用虚拟内存，原因是多个虚拟内存可以指向同一个物理地址，利用这个特性就可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在IO操作时就不需要来回复制了。

#### mmap/write

<img src="photo/image-20230609140507056.png" alt="image-20230609140507056" style="zoom: 80%;" />

整个流程的核心区别就是，把数据读取到内核缓冲区后，应用程序在进行写入操作时，直接把内核的`Read Buffer`复制到`Socket Buffer`中即可，以上流程少了一个CPU拷贝，但是上下文切换还是四次，因为还要应用程序发起`write`操作。

#### sendfile

<img src="photo/image-20230609140737906.png" alt="image-20230609140737906" style="zoom:80%;" />

`sendfile`方式只有三次数据复制（其中只有一次 CPU COPY）以及2次上下文切换。

#### splice 

`splice` 调用和`sendfile` 非常相似，用户应用程序必须拥有两个已经打开的文件描述符，一个表示输入设备，一个表示输出设备。与`sendfile`不同的是，`splice`允许任意两个文件互相连接，而并不只是文件与`socket`进行数据传输。对于从一个文件描述符发送数据到`socket`这种特例来说，一直都是使用`sendfile`系统调用，而`splice`一直以来就只是一种机制，它并不仅限于`sendfile`的功能。也就是说 sendfile 是 splice 的一个子集。

## Linux常用命令

```bash
#任意的TCP和UDp连接与监听工具
nc hostname port #作为客户端连接hostname的port端口
# 查看系统内存占用
free -h # -h含义为以合适的单位显示内存使用情况
# 查看磁盘使用
df -hl # 查看磁盘剩余空间
df -h  # 查看每个根路径的分区大小
du -sh [目录名] # 返回该目录的大小
du -sm [文件夹] # 返回该文件夹总M数
du -h [目录名]  # 查看指定文件夹下的所有文件大小（包含子文件夹）
size #size命令基本上列出了输入目标文件的段大小和总大小
cat /proc/version # 查看linux版本
```

# 网络

## OSI七层网络模型

<img src="photo/v2-2d62ba265be486cb94ab531912aa3b9c_r.jpg" alt="img" style="zoom: 67%;" />

<img src="photo/v2-436927a69a3574532059a78623d3095d_720w.webp" alt="img" style="zoom:67%;" />

<img src="photo/image-20210607144015234.png" alt="image-20210607144015234" style="zoom:67%;" />

- 物理层：底层数据传输，如网线；网卡标准，本层数据称为比特流。
- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址，本层数据称为帧。
- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发，本层数据称为包。
- 传输层：端到端传输数据的基本功能；如 TCP、UDP，本层数据称为TCP报文段或UDP数据报。
- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
- 表示层：数据格式标识，基本压缩加密功能，图像、视频编解码。
- 应用层：建立会话，如Session认证、断点续传，各种应用软件，包括 Web 应用。

## TCP/IP网络模型

<img src="photo/202205072300758.png" alt="img" style="zoom: 80%;" />

<img src="photo/image-20230531143958027.png" alt="image-20230531143958027" style="zoom:50%;" />

TCP/IP网络模型是对OSI七层网络模型的一个具体实现。

因为不同设备之间的通信需要网络，而由于设备的多样性，需要兼容不同设备，所以需要一套大家都遵守的网络协议。

### 应用层

最上层的，也是我们能直接接触到的就是**应用层**（*Application Layer*），我们电脑或手机使用的应用软件都是在应用层实现。

所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。

应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。

而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 传输层

应用层的数据包会传给传输层，**传输层**（*Transport Layer*）是为应用层提供网络支持的。

在传输层会有两个传输协议，分别是 TCP 和 UDP。

TCP 的全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（*TCP Segment*）。

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

### 网络层

实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。

也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是**网络层**（*Internet Layer*）。

网络层最常使用的是 IP 协议（*Internet Protocol*），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。通过IP地址区分网络中的不同主机。通过子网掩码区分出网络号和主机号。

那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。

除了寻址能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

所以，**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。

| 协议 | 名称                 | 作用                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| IP   | 网际协议             | IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |
| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |
| RIP  | 路由信息协议         | 使用“跳数”(即metric)来衡量到达目标地址的路由距离             |
| IGMP | Internet组管理协议   | 用于实现组播、广播等通信                                     |

### 数据链路层

生成了 IP 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。

<img src="photo/封装.png" alt="img" style="zoom:50%;" />

## IP

IP 地址（IPv4 地址）由 `32` 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。因此IP地址的最大值是4294967296，也就是接近43亿。

### IP地址分类

<img src="photo/7.jpg" alt="IP 地址分类" style="zoom:33%;" />

- A类地址(1~126):网络号占前8位，以0开头，主机号占后24位。
- B类地址(128~191):网络号占前16位，以10开头，主机号占后16位。
- C类地址(192~223):网络号占前24位，以110开头，主机号占后8位。（ABC为单播地址）
- D类地址(224~239):以1110开头，保留位多播地址。
- E类地址(240~255):以1111开头，保留位今后使用

### 无分类地址 CIDR

这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是**网络号**，后面是**主机号**。表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**， x 的范围是 `0 ~ 32。

### IP分片和重组

MTU：数据链路层的最大传输单元，每个不同类型的数据链路的使用目的不同，所以MTU不同，以太网是1500字节。

当IP数据包的大小大于MTU，就会被分片，再由对方进行重组。

如果某个分片丢失，则会造成整个IP数据包作废，所以TCP引入了MSS也就是由TCP来分片，那么对于UDP我们尽可能不要发送大于MTU的报文。

### TTL

TTL是IP数据报可以经过的最大路由数，每经过一个路由器此值就会减一，当此值为0则数据包将被丢弃，同时发送ICMP报文通知源路由器。

### ping的工作原理

ping是基于**ICMP**（互联网控制报文协议，主要功能：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等**）的。

其中ICMP的类型0和8分别表示回送响应和回送请求，用于判断发送的数据包是否到达通信对端的一种消息。

## ARP

ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项。

### 为什么要有ARP协议

在局域网中，当主机或其它三层网络设备有数据要发送给另一台主机或三层网络设备时，需要知道对方的网络层地址（即IP地址）。但是仅有IP地址是不够的，因为IP报文必须封装成帧才能通过物理网络发送，因此发送方还需要知道接收方的物理地址（即MAC地址），这就需要一个通过IP地址获取物理地址的协议，以完成从IP地址到MAC地址的映射。地址解析协议ARP即可实现将IP地址解析为MAC地址。

当帧到达目标局域网时，局域网内的所有设备都会收到此帧，并根据帧头部的MAC头部判断接收方是不是自己，如果是则接受此帧并解封非数据包，如果不是则直接丢弃。

### 工作原理

网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。

此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址;源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

一句话总结工作原理：广播ARP请求和单播ARP应答。

### 静态和动态

- 动态ARP表由ARP协议通过报文自动生成和维护，可以被老化、可以被新的ARP报文替代、也可以被静态ARP表项替代，动态ARP适合拓扑结构复杂、通信是适度要求高的网络
- 静态ARP是由网络管理员手工建立的IP地址和MAC地址之间固定的映射关系，不会被动态覆盖、不会老化。可以保证通信的安全性。

### 老化机制

每台主机或设备上都维护着一个高速缓存，这是ARP高效运行的一个关键。在这个高速缓存中，存放主机或设备最近学习到的IP地址到MAC地址的映射关系，即动态ARP表项。

主机或设备每次发送报文时，会先在本地高速缓存中查找目的IP地址所对应的MAC地址。如果高速缓存中有对应的MAC地址，主机或设备不会再发送ARP请求报文，而是直接将报文发至这个MAC地址；如果高速缓存中没有对应的MAC地址，主机或设备才会广播发送ARP请求报文，进行ARP地址解析。一方面由于高速缓存的容量限制，另一方面为了保证高速缓存中ARP表项的准确性，设备会对动态ARP表项进行老化和更新。

动态ARP表项的老化参数有：老化超时时间、老化探测次数和老化探测模式。设备上动态ARP表项到达老化超时时间后，设备会发送老化探测报文（即ARP请求报文），如果能收到ARP应答报文，则更新该动态ARP表项，本次老化探测结束；如果超过设置的老化探测次数后仍没有收到ARP应答报文，则删除该动态ARP表项，本次老化探测结束。

设备发送的老化探测报文可以是单播报文，也可以是广播报文。缺省情况下，设备只在最后一次发送ARP老化探测报文是广播模式，其余均为单播模式发送。当对端设备MAC地址不变时，可以配置接口以单播模式发送ARP老化探测报文。

### RARP

概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 原理： (1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。

(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。

(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。

## TCP

<img src="photo/format,png.png" alt="TCP 头格式" style="zoom:50%;" />

TCP是面向连接的、可靠的、基于字节流的传输层通信协议。

连接：**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket（确认四元组）、序列号（解决乱序问题）和窗口大小（流量控制）称为连接。**

最大连接数：理论值最大为客户端IP数量*客户端端口数。但是实际上服务器的连接数远不能达到理论上限，会受到文件描述符（系统级、用户级、进程级）和内存的限制。

### 面向连接

#### 三次握手（摸手）（确认双方的收发能力）（序列号和SYN）

A：我说话你能听见吗（seq(客户端初始序列号)，SYN（置1表示为握手数据包））

B：你说话我能听见，我说话你能听见吗（seq(服务器初始序列号)，SYN，ACK(确认应答，客户端初始序列号+1)(期望接受的下一个字节编号)

A：你说话我能听见（ACK(确认应答，服务器初始序列号+1)）

不发数据为什么要有序列号→因为超时重传，

<img src="photo/socket三次握手.drawio.png" alt="socket 三次握手" style="zoom:50%;" />

- 客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；
- 服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；
- 客户端协议栈收到 ACK 之后，使得应用程序从 `connect` 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1；
- ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 `accept` 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。

- 为什么要三次握手

  1. 三次握手可以阻止重复历史连接的初始化→客户端的SYN到达服务器，服务器回复SYN+ACK，客户端收到后根据自身的上下文判断这是不是一个历史连接，如果是，客户端向服务器发送RST报文表示取消这次连接。两次握手在服务器发送SYN+ACK后服务器就可以发送数据了，客户端无法判断这是不是历史连接，当客户端准备发送第三次握手时，有足够的上下文来进行判断。

  2. 三次握手可以同步双方的初始序列号→两次握手只确保服务器收到客户端的序列号了

  3. 三次握手可以避免资源浪费

     SYN泛洪攻击

     - 半连接队列：接收到客户端的SYN报文，进入半连接队列，并对其中的报文进行SYN+ACK的回应
     - 全连接队列：接收到了客户端的ACK报文，通过`accpet()`接口从全连接队列中取出连接对象
     
     SYN最直接的办法就是把TCP的半连接队列打满，这样服务器后续在收到SYN报文就会丢弃，导致正常的客户端无法和服务器建立连接。以下为解决方案
     
     - 增大`netdev_max_backlog`
     
       当网卡接收数据包的速度大于内核处理的速度时，有一个队列会保存这些数据包。此参数是控制这个队列大小的
     
     - 增大TCP半连接队列大小
     
     - 开启 net.ipv4.tcp_syncookies
     
       当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 `cookie` 值；将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。最后应用程序通过调用 `accpet()` 接口，从「 Accept 队列」取出的连接。
     
       通过这种方法，即使半连接队列满了也可以保证正常的连接成功。
     
     - 减少 SYN+ACK 重传次数
     
       当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

- seq怎么产生

  seq = C +H(源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每四微秒加一，H是消息摘要算法，输入是一个四元组（源IP地址、目的IP地址、源端口、目的端口)
  
- 各次握手丢失会怎么样

  - 第一次

    客户端收不到服务器的SYN-ACK报文，会重传SYN报文，并且重传的SYN报文序列号是一样的。最大重传次数通常是5次，每次间隔翻倍。

  - 第二次

    客户端没有收到第二次握手，客户端会认为自己的SYN报文丢失了所以会重传，服务器会认为自己的SYN-ACK报文丢失了所以也会重传。

  - 第三次

    客户端发送完第三次握手已经进入ESTABLISH状态，可以进行数据传输了，而服务器此时则是SYN-RCVD状态，服务器认为自己的第二次握手没有传送到，所以由服务器重传SYN-ACK报文。


#### 四次挥手

A：我要断开连接（FIN(结束标志)）(尽对于应用层而言，缓冲区的数据继续发送)

B：同意你断开连接（ACK）

B：我要断开链接（FIN）

A：同意你断开连接（ACK）

<img src="photo/format,png-20230309230538308.png" alt="客户端调用 close 过程" style="zoom:50%;" />

- 客户端调用 `close`，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；
- 服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 `EOF` 到接收缓冲区中，应用程序可以通过 `read` 调用来感知这个 FIN 包。这个 `EOF` 会被**放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；
- 接着，当处理完数据后，自然就会读到 `EOF`，于是也调用 `close` 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；
- 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；
- 客户端经过 `2MSL` 时间之后，也进入 CLOSE 状态；

- 为什么需要四次挥手

  关闭连接时，客户端发送FIN报文，表示其不再发送数据，但还可以接受数据。而服务器可能还有数据需要发送，所以先发送ACK同意客户端的FIN，等所有数据发送完毕再发送FIN，所以比三次握手多了一次。

- TIME_WAIT意义以及为什么是2MSL以及危害

  - 意义

    1. 防止最后一次发送的ack丢失，保证TCP完整结束→四次挥手的最后一个ack是由发起断开方发出，如果对方没有收到这个ack会重发fin（超时重传）有time_wait则可以尽可能保证挥手完整

    2. 使老的连接在网络中彻底消失→防止相同端口复用TCP连接收到旧的报文，导致数据错乱

  - 2MSL

    1. MSL（Maximum Segment Lifetime）报文最大生存时间，任何报文在网络中超过这个时间就会被丢弃

    2. 发送方的数据包发到对面丢失，对面还需要回复，一来一回两个MSL，如果客户端的最后一个ACK没有发送到服务器，那么服务器会再发一个FIN，TIME_WAIT重置

  - 危害

    1. 浪费系统资源，如文件描述符、内存资源、CPU资源、线程资源

    2. 占用端口号，一个TCP连接占用一个端口号，如果发起请求方持有过多的TIME_WAIT状态占满了端口号，就无法发起新的请求
  
- 服务器出现大量TIME_WAIT的原因

  1. HTTP没有使用长连接，只要通信双方有一方没有开启Keep-Alive，就会有服务器主动断开连接。在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select / epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。

  2. HTTP长连接超时：大量客户端建立完TCP连接后，很长一段时间没有发生数据，触发长连接超时，由服务器主动关闭连接

  3. HTTP长连接的请求数量达到上限

     服务器会有如 nginx 的 keepalive_requests 这个参数，限制单次长连接处理的请求数量，如果超过请求数量，就会主动关闭这个长连接。

- 各次挥手报文丢失怎么办

  - 第一次

    客户端（发起挥手方重传FIN报文）

  - 第二次

    如果服务端的第二次挥手丢包了，客户端就会认为是自己地第一次挥手丢包了，所以由客户端重传FIN报文

  - 第三次

    服务器接收到客户端的FIN报文后，内核自动发送ACK报文，同时进入CLOSE_WAIT状态（等待应用进程调用close函数关闭连接）。应用进程调用close函数后，服务器发送FIN报文，如果丢包，则由服务器重传FIN报文。

  - 第四次

    服务器发送完FIN报文后，等待客户端的ACK，此时服务器会处于LAST_ACK状态，客户端的ACK丢失了，则由服务器重传FIN报文。

#### 没有accept能建立连接吗

accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

<img src="photo/3.jpg" alt="半连接队列与全连接队列" style="zoom:50%;" />

### 重传机制


#### 序列号和确认序号

发送方会将发送的数据编号，以便让接收方知道自己接收的数据是不是自己想要的数据

序列号和初始序列号不是无限递增的，超过4G大小就会重新计数，这意味着无法通过序列号来判断新老数据。

#### 确认应答

接收方接收后发送ack

缺点→数据往返时间越长，网络吞吐量越低

#### 超时重传

TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。尽管超时重传的概念十分简单，但是在实现中，TCP处理超时重传的机制与其他可靠性协议相比是相当复杂的。

在数据包或确认应答丢失的情况下会触发超时重传。超市重传时间RTO应该略大于保温往返时间RTT的值。

#### 快速重传

发送方的报文丢失了，接收方收到的并不是自己想要的报文，就会发送之前的ACK，如果连续发送三个之前相同的ACK就会触发服务器的快速重传，但是问题是是重传一个，还是重传所有。

#### SACK

`SACK`（ Selective Acknowledgment）， **选择性确认**。

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

如果要支持 `SACK`，必须双方都要支持。在 Linux 下，可以通过 `net.ipv4.tcp_sack` 参数打开这个功能（Linux 2.4 后默认打开）。

####  Duplicate SACK

Duplicate SACK 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**

在 Linux 下可以通过 `net.ipv4.tcp_dsack` 参数开启/关闭这个功能（Linux 2.4 后默认打开）。

### 流量控制

同步双方的收发速度（根据接收方的接收能力，控制发送方的速度，保护接收方）

滑动窗口→窗口大小内的数据无需确认应答，提高吞吐量→操作系统开辟一个缓冲空间，在接收方确认应答之前，已发送的数据保存在缓冲区，以便超时重传，对方确认应答则清除

窗口大小→win→接收端告诉发送端自己的处理能力

发送方的窗口：发送并收到ACK的数据、已发送但未收到 ACK确认的数据、未发送但总大小在接收方处理范围内、未发送但总大小超过接收方处理范围。由三个指针确定四个区域。`SND.WND`：表示发送窗口的大小（大小是由接收方指定的）；`SND.UNA`（*Send Unacknoleged*）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。`SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。指向 #4 的第一个字节是个相对指针，它需要 `SND.UNA` 指针加上 `SND.WND` 大小的偏移量，就可以指向 #4 的第一个字节了。

接收方的窗口：已成功接收并确认的数据、未收到数据但可以接收的数据、未收到数据并不可以接收的数据。两个指针来确定范围`RCV.WND`：表示接收窗口的大小，它会通告给发送方。`RCV.NXT`：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。指向 #4 的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以指向 #4 的第一个字节了。

- 零窗口问题

  接收方没有缓存时会将窗口设置为0发送给发送方，当接收方有缓存发送窗口大小给发送方但是此包丢失时，就会使双方一直等待

  发送方接收到零窗口时会设置一个持续计时器，周期性地向接收方发送零窗口探测报文段

### 拥塞控制

使用者变多→拥塞→丢包→丢包越多越发→瘫痪→数据全部丢失

判断网络是否发生拥塞→是否有丢包现象→超时重传的报文超时（规定时间内没有收到ACK应答报文）、收到三个重复确认ACK（快重传）。

发送窗口swnd = min(拥塞窗口cwnd, 接收窗口rwnd)，只要网络中没有出现拥塞cwnd就会变大，拥塞了cwnd就会变小，

- 慢启动

  慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。

  1. 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
  2. 每当收到一个ACK，cwnd大小加一，呈线性上升。
  3. 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
  4. 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，启动“拥塞避免算法”

- 拥塞避免

  慢启动⻔限ssthresh的大小通常是65535字节。**发送方每收到一个ACK时，cwnd增加1/cwnd**，如此一来，cwnd每轮增长的数量就变成了1。

  1. 收到一个ACK，则cwnd = cwnd + 1 / cwnd
  2. 每当过了一个往返延迟时间RTT，cwnd大小加一。

  过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。

- 拥塞发生

  网络出现拥塞，发生数据包重传，需要进行重传

  - 超时重传

    ssthresh设置为cwnd/2，cwnd重置为cwnd的初始值。

  - 快重传

    当接收方发现丢了一个中间包时，发送三次丢包的前一个包的ACK，此时发送端触发快重传

    cwnd = cwnd/2，ssthresh=cwnd，进入快恢复算法。

- 快恢复

  快重传和快恢复一般同时使用，快恢复算法认为你还能收到三个重复的ACK说明网络还没那么差

  - 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
  - 重传丢失的数据包；
  - 如果再收到重复的 ACK，那么 cwnd 增加 1；
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

- 为什么快重传是三个ACK

  两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。

### 保活机制

概念→一定时间内TCP连接没有任何活动，启动保活机制，每隔一段时间发送探测报文，等待相应

机制：1. 对端正常相应，重置保活时间 2. 对方程序崩溃，发送RST报文，重置连接 3. 保活报文不可达，探测一定次数后关闭连接

### 为什么IP会分片，TCP还要有MSS

<img src="photo/format,png-1678159443007-3.png" alt="MTU 与 MSS" style="zoom:50%;" />

- MTU：一个网络包的最大长度，以太网中一般为1500字节
- MSS：除去IP和TCP头部后，一个网络包能容纳的TCP数据最大长度

当 IP 层有一个超过 `MTU` 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。

**当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传**。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。

为了最佳效能，TCP协议在建立连接的时候通常会协商双方的MSS值。

### 粘包与解决

粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

- 固定长度的消息

  最简单的方法，如规定一个消息的长度时64字节，接收方接收慢64个字节，就认为这是一个完整且有效的消息，但是灵活性较差，实际中很少用

- 特殊字符作为边界

  再两个用户消息之间插入一个特殊的字符串，接收方读到特定字符串，就认为是一个完整的消息了，HTTP就是如此，需要注意的时如果消息内容中有这个特殊字符，就要对这个字符进行转义

- 自定义消息结构

  定义一个消息结构，包括包头和数据构成，其中包头固定大小，且包头中有一个字段说明其后的数据有多大。
  
- 使用更复杂的协议

  RTMP（实时通信）协议，基于TCP，具有稳定、兼容性强、高穿透的特点，常用于流媒体直播等场景

![image-20230601112014278](photo/image-20230601112014278.png)

### TCP与Socket

<img src="photo/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作" style="zoom: 50%;" />

- 服务端和客户端初始化 `socket`，得到文件描述符；
- 服务端调用 `bind`，将 socket 绑定在指定的 IP 地址和端口;
- 服务端调用 `listen`，进行监听；
- 服务端调用 `accept`，等待客户端连接；
- 客户端调用 `connect`，向服务端的地址和端口发起连接请求；
- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；
- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。

### 已经建立连接的TCP，收到SYN会怎么样

1. **客户端的 SYN 报文里的端口号与历史连接不相同**

   如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。

   如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。

2. **客户端的 SYN 报文里的端口号与历史连接相同**

   处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。

#### 引申问题，如何精细地关闭一条TCP连接

如果采用杀掉进程的方式来关闭TCP连接，客户端会断开与服务器的所有TCP连接，服务器则会断开所有连接，并且无法继续提供服务。

**要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号是对方期望的」这两个条件。**

- tcpkill 工具只能用来关闭活跃的 TCP 连接，无法关闭非活跃的 TCP 连接，因为 tcpkill 工具是等双方进行 TCP 通信后，才去获取正确的序列号，如果这条 TCP 连接一直没有任何数据传输，则就永远获取不到正确的序列号。
- killcx 工具可以用来关闭活跃和非活跃的 TCP 连接，因为 killcx 工具是主动发送 SYN 报文，这时对方就会回复 Challenge ACK ，然后 killcx 工具就能从这个 ACK 获取到正确的序列号。

## TCP和UDP的联系和区别

- 都是传输层协议，都建立在IP（ip通过四元组确定了网络中的两台主机上的两个进程，但是ip没法发送消息，此时将发送数据的任务交给tcp和udp）之上，TCP是流式套接字，UDP是报文套接字

1. TCP是面向连接的协议，提供可靠传输（底层还是会出现错误，但是出现错误的时候tcp会纠正错误，数据丢失会重新发送），发送消息前三次握手建立连接，使用ACK确保消息的准确性。UDP是无连接的协议，不管对方是否收到是否正确
2. TCP只能一对一点对点通信，UDP可以一对一、一对多、多对多通信
3. TCP对系统资源的要求比UDP高同时安全，速度也比UDP慢
4. TCP基于字节流没有边界可能会出现粘包，UDP基于数据包可能会乱序或丢包
5. TCP首部开销比较大，最大为40字节，UDP则为固定的8字节

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909151830455.png" alt="image-20220909151830455" style="zoom:25%;" /> <img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909151847583.png" alt="image-20220909151847583" style="zoom:25%;" />



## 浏览器输入URL后的全过程

<img src="photo/2.jpg" alt="简单的网络模型" style="zoom: 33%;" />

- HTTP解析域名、生成HTTP请求
- DNS查询服务器域名对应的 IP 地址

1. 客户端使用DNS协议将url解析成域名

2. 建立TCP连接

3. 建立HTTP连接，向服务器发送请求

4. 服务器处理请求，将客户端所需数据，发送回客户端

5. 关闭TCP连接

6. 浏览器接收html

7. 渲染

## DNS

DNS服务器存储Web服务器域名和IP的对应关系。DNS中的域名用`.`进行分割，越靠右级别越高。实际上域名最后还有一个点如`www.baidu.com.`，这个点表示根域名。不同层级DNS服务器之间的关系类似于一颗树。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

工作在应用层，使用UDP传输（快）

1. 浏览器查看缓存有没有ip记录。
2. 操作系统查看缓存有没有记录。
3. 查看本机hosts有没有记录。
4. 如果本地没有记录，那么开始DNS请求，分为递归请求和迭代请求

### 递归请求

客户端向局部DNS服务器查询，**局部DNS服务器直接向根服务器查询，由根服务器一层一层向下查询**，最后将查询到的结果返回给局部DNS服务器，由局部DNS服务器将结果返回给哭护短

### 迭代查询

局部DNS服务器不是自己向其他DNS服务器进行查询，**而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序**，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。

## HTTP
### 概述

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

web通信都是建立在HTTP上的→客户端发起HTTP请求，服务器处理后返回HTTP响应报文

特点：1.简单→基本报文格式是header+body，头部信息也是kv 2.灵活以及易于扩展→HTTP协议中的请求方法，状态码，头字段等都可以更改，工作在应用层底层可以更改 3.无状态、明文传输、不安全

默认端口号：80

dns解析出ip地址，TCP三次握手，HTTP请求，关闭TCP连接

### 状态码

1xx→提示信息，表示目前是协议处理的中间状态，还需后续操作

100→收到了请求的起始部分，客户端应该继续请求

101→服务器正在根据客户端的指示切换协议

2xx→成功，报文已被收到并且正确处理

200→客户端请求成功

201→对于需要服务器创建对象的请求，服务器已创建完毕对象

202→请求已接受但服务器未处理

203→服务器成功处理，只不过header包含的信息并非来自原始服务器，而是副本

204→没有响应响应体

205→要求浏览器重置当前页面的HTML

206→部分请求成功

3xx→重定向

301→永久重定向

302→临时重定向

304→客户端的缓存资源时最新的，要求客户端使用缓存

4xx→客户端错误

400→报文语法有错，服务器无法识别

401→请求需要客户端自己认证

402→要求付款（还未启用）

403→请求被服务器拒绝了

404→没有找到资源

5xx→服务器错误

500→服务器内部错误

503→服务器忙，请稍后再试

### 常见字段

- **host**：客户端发送请求时，用来指定服务器的域名
- **Content-Length**：服务器返回数据时，表明本次回应的数据长度
- **Connection**：客户端要求服务器使用长连接
- **Content-Type**：服务器用于告知客户端，本次数据是什么格式
- **Accept**：客户端用来告知服务器自己可以接收哪些数据格式
- **Content-Encoding**：数据的压缩方式，表示服务器返回的数据使用了什么压缩格式

### 请求报文

1. 请求行→（请求方法；URL；协议版本号）

​	URL： <协议>： //<主机>： <端⼝>/<路径>？ <参数>

​	协议版本号： HTTP版本号

​	如： POST /chapter17/user.html HTTP/1.1

2. 请求头→包含请求的附加信息，kv组成

3. 请求体→承载多个请求参数的数据。包含回车、换行和请求数据

- 请求方法

  1. GET：申请获取资源，不对服务器产生影响

  2. POST：向服务器提交数据，会影响服务器，可能会创建新资源或更新原有资源

  3. HEAD：类似于GET，只要求服务器返回头部信息

  4. PUT：上传某个资源

  5. DELETE：删除某个资源

  6. TRACE：用于 测试，要求服务器返回请求内容

  7. CONNECT：用于代理服务器

  8. OPTION：查询服务器对特定URL的请求方法

- get和post

  - get是http的默认请求方式

  - get以请求和检索为主请求主体不带内容（获取），post以创建或者更新为主（处理）

  1. get请求参数放在url中，post请求参数放在请求体中
  2. get请求可以被浏览器缓存，post不可以
  3. get的参数长度受限，常用谷歌浏览器是2Mb（HTTP对此没有限制），post没有
  4. get安全是指不携带数据，不会对服务器产生影响
  5. get不安全是指参数直接显示在请求头中

  - 在 HTTP 协议（RFC规范定义中）里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
  - 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。
  - 在RFC规范下，GET可以有body，POST的url也可以有参数

### 缓存技术

对于重复的HTTP请求，每次请求得到的数据都是一样的，我们就可以把这对*请求-响应*的数据都缓存在本地，以此来加快访问速度。

- 强制缓存

  浏览器判断缓存是否过期，没过期直接使用浏览器本地缓存，主动权在浏览器。

  强制缓存利用以下两个响应头部来实现，用来表示资源在客户端缓存的有效期：Cache-Control（相对时间）（其选项更多，设置更加精细），Expires（绝对时间），如果一个响应头同时有以上两个字段，Cache-Control优先级更高。以下介绍Cache-Control：

  - 浏览器第一次请求访问资源时，服务器返回资源并在头部加上此字段，并在其中设置过期时间。
  - 浏览器再次请求该资源时，会先通过请求资源的时间和字段中设置的过期时间来判断资源是否过期，如果没有，使用该缓存，否则重新请求服务器。
  - 服务器再次收到请求后，更新字段值。

- 协商缓存

  304响应码用来通知浏览器使用缓存，这种通过服务器告知客户端是否使用缓存的方式称为协商缓存。以下为两种实现方法：

  - 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
    - 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
    - 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。
  - 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段
    - 响应头部中 `Etag`：唯一标识响应资源；
    - 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

  第一种基于时间、第二种基于标识，相对来讲后者更准确，避免时间篡改导致的不可靠。同时出现第二种的优先级也更高。以下为原因：

  1. 没有修改文件内容的情况下文件的最后修改时间也可能会改变，这时就需要重新发送资源
  2. 第一种的检查粒度为秒级，如果文件修改是在秒级以内，使用第二种则可以保证更新缓存
  3. 有些服务器不能准确获取文件的最后修改时间。

<img src="photo/http缓存.png" alt="img" style="zoom: 33%;" />

- 如何禁止缓存

  HTTP/1.1 通过 `Cache-Control` 首部字段来控制缓存。

  `no-store`指令规定不能对请求或响应的任何一部分进行缓存。

  `no-cache` 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。

### keep-alive

为什么：早期的HTTP1.0每次请求都要创建连接，需要消耗资源和时间，为了减少资源损耗缩短响应时间，需要重用连接，在请求头中加入Connection: keep-alive，HTTP1.1默认支持长连接，加不加都行

协议是这样规定的，但是实际上还要看服务器和客户端的具体实现。通常服务器都会设置时间，超时断开连接，同时有一个参数叫做最大请求数，请求次数超过此值断开连接

### HTTP各版本

#### HTTP1.1

- 优点

  - 简单：报文格式简单，头部信息也是kv，降低学习和使用的成本
  - 灵活和已于扩展：HTTP1.1中各种请求方法、URI/URL、状态码、头字段等都可以开发者自行修改
  - 应用广泛和跨平台

- 缺点

  - 无状态：好处是服务器不需要存储状态，减轻服务器负担。坏处是在完场有关联的操作时会很麻烦。解决方法就是Cookie，就相当于是一张小纸条，客户端请求的时候带着Cookie，服务器就认得了。
  - 明文传输：抓包完全可见，为调试带来便利。但也等同于信息裸奔，很容易窃取。
  - 性能缺点
    - 请求/响应头部未经压缩就发送，只能压缩Body部分
    - 发送冗长的首部，每次互相发送相同的首部造成较多浪费
    - 服务器处理请求是按顺序的，如果服务其响应慢就会出现队头阻塞
    - 没有请求优先级控制。
    - 请求只能从客户端开始，服务器只能被动响应。

- 性能提升

  HTTP使用TCP/IP，并且使用*请求-应答*通信模式，性能的关键就在这两点

  - 长连接

    早期的HTTP1.0不支持长连接，每发起一个请求，就要重新建立一次TCP连接，增加了通信开销。HTTP1.1增加了长连接，只要任意一端没有提出断开连接，就保持TCP连接状态。如果超过一定时间没有数据交互，服务器还是会主动断开这个连接。

  - 管道运输

    得益于长连接，管道也可以使用起来。只要在同一个TCP连接中，客户端可以发送多个请求而不必等待上一个请求响应从而降低整体响应时间。但是服务器必须按照顺序进行响应。管道传输不是默认开启，也基本没有浏览器支持。

  - 队头阻塞：如果某个请求因某种原因被阻塞，其后的请求也会阻塞。 

- 如何优化

  - 避免发送HTTP请求

    缓存

  - 减少HTTP请求次数

    - 减少重定向次数

      服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 `302` 响应码和 `Location` 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。

      将重定向的工作交给代理服务器即代理服务器不向客户端发送重定向的消息，而是直接将重定向之后的响应返回给客户端，这样就可以减少一次HTTP请求。

    - 合并请求

      将多个小文件的请求合并成一个大请求，传输资源数一样，但是减少了请求次数，减少了头部的开销。

      例如图片、前端三件套等。

      但是如果大资源中的一个小资源发生变化后，客户端就需要重新下载整个完整的大资源

    - 延迟发送请求

      当前不需要的资源，我们没必要也获取过来，于是可以通过「**按需获取**」的方式，来减少第一时间的 HTTP 请求次数。

  - 减少HTTP响应的数据大小

    主要的方法就是压缩

    - 无损压缩

      对信息完整性要求高的文件可以采用这种方法，如gzip

    - 有损压缩

      通过一定算法将图片等对完整性要求不高的文件进行压缩。

#### HTTP2.0

HTTP2.0是基于HTTPS的，所以安全是有保障的。以下是性能改进：

1. 头部压缩

   如果你同时发送多个请求，他们的头部是一样的或者相似的，那么协议会消除重复的部分

   HPACK算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，只发索引号从而达到提高速度的效果

2. 二进制格式

   头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**。

   计算机无需从明文的报文转换为二进制，直接解析二进制报文，提高传输效率

3. 并发传输

   HTTP1.1存在队头阻塞的问题，HTTP2.0提出了Stream的概念，多个Stream复用一个TCP连接。

   1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。客户端可以通过Stream的ID来进行组装HTTP消息，达到并发的效果。

4. 服务器推送

   客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。比如在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。

HTTP2.0的缺陷如下：

**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**

所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

#### HTTP3.0

**HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

1. 无队头阻塞

   QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP请求。

   **QUIC连接的多个流没有依赖，当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。HTTP2则是会阻塞后续流。

2. 更快的连接建立

   之前的HTTP必须TCP握手再TLS握手，HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

3. 连接迁移

   QUIC 协议没有用TCP四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

### Cookie和Session

#### Cookie

Cookie是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送。对于Cookie，可以设置过期时间。

通常，Cookie用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。

Cookie主要用于以下方面：

- 会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)
- 个性化设置(如用户自定义设置、主题等)
- 浏览器行为跟踪(如跟踪分析用户行为等)

#### Session

Cookie存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。为了解决这个问题就出现了Session，利用 Session将用户信息存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

#### Cookie和Session的区别

- 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。
- 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型。考虑数据复杂性首选Session。
- 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。
- 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。
- 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。如果用户所有信息都通过Session存储在服务器开销很大，可以选择将部分非敏感信息存储在客户端。

#### 客户端禁用了Cookie会怎样

方案一：拼接SessionId参数。在GET或POST请求中拼接SessionID，GET请求通常通过URL后面拼接参数来实现，POST请求可以放在Body中。无论哪种形式都需要与服务器获取保持一致。

方案二：基于Token(令牌)。在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器，用于服务器验证请求用户的身份。

### SQL注入

攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 Web端 1）有效性检验。 2）限制字符串输入的长度。 服务端 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。

## HTTPS

### HTTP和HTTPS的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### 概述

为了解决HTTP不安全的缺陷，在HTTP基础上加入SSL（安全套接字）/TSL（安全传输层协议）使得报文能够加密传输

HTTPS在TCP三次握手请求之后还需要进行SSL/TSL握手请求，才能进行传输

TLS 1.0版本的答案，使用RSA密钥交换算法，现在TLS 1.2已经成为主流，使用ECDHE算法，

默认端口号：443

特点：1.信息加密→窃听风险→混合加密 2.校验机制→篡改风险→摘要算法 3.身份证书→冒充风险→数字证书

优点：1.传输使用密钥加密，安全性高 2.可以认证用户和服务器，确保数据传输对象正确

缺点：1.握手延迟较高→会话前还需要进行SSL握手 2.部署成本高→购买CA证书，进行加密解密运算，增加了服务器成本

### 加密方式

1.对称加密→只使用一个密钥，运算速度快，密钥必须保密，无法实现密钥交换

2.非对称加密→使用两个密钥，公钥随意分发私钥保密，解决密钥交换问题，速度慢

3.混合加密→实现机密性，解决窃听风险，HTTPS

通信建立前→采用非对称方式交换会话密钥，后续不再使用非对称加密

通信建立后→全部采用会话密钥对称加密

混合加密验证流程

1. 客户端提交https请求
2. 服务器响应客户，并把证书公钥发给客户端
3. 客户端验证证书公钥的有效性
4. 有效后，会生成一个会话密钥
5. 用证书公钥加密这个会话密钥后，发送给服务器
6. 服务器收到公钥加密的会话密钥后，用私钥解密，回去会话密钥
7. 客户端与服务器双方利用这个会话密钥加密要传输的数据进行通信

### HTTPS传输内容为什么使用对称加密

1. 对称加密的效率比较高

2. 一对公私钥只能实现单向的解密，如果想要非对称加密，要求客户端必须拥有自己的私钥，那么每个客户端都要有自己的私钥这显然是不合理的

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909152954542.png" alt="image-20220909152954542" style="zoom: 33%;" />

[HTTPS真的安全吗](https://blog.csdn.net/itcodexy/article/details/109575171?ops_request_misc=&request_id=&biz_id=102&utm_term=如何拦截一个HTTPS&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-109575171.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)

## Socket编程

<img src="photo/0044549f66c3c4dc70016263a9dd495.png" alt="0044549f66c3c4dc70016263a9dd495" style="zoom:80%;" />

```c
//Linux主机字节序和网络字节序的转换
#include <netinet/in.h>
unsigned long int htonl (unsigned long int hostlong);//htonl表示host to network long
unsigned short int htons (unsigned short int hostshort);
unsigned long int ntohl( unsigned long int netlong);
unsigned short int ntohs (unsigned short int netshort) ;

//通用socket地址
#include <bits/socket.h>
struct sockaddr {
sa_family_t sa_family;char sa_data [ 14];
}

```



## 多路IO复用

收作业例子来解释三者区别：select和poll是学生写完作业会叫老师，但是你不知道是谁叫的，所以需要一个一个地询问，而epoll则是学生写完作业会主动交到讲台上，你一眼就可以看到是谁举手了，就可以直接去收作业。

### select

select函数用来检查套接字描述符是否已经准备好读/写

监听事件收到FD_SETSIZE的约束，一般为1024

select()的机制中提供一种`fd_set`的数据结构，实际上是一个long类型的数组，每一个数组元素都能与一打开的文件句柄（不管是Socket句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

缺点

1. 每次调用select，都需要把`fd_set`集合从用户态拷贝到内核态，如果`fd_set`集合很大时，那这个开销也很大
2. 同时每次调用select都需要在内核遍历传递进来的所有`fd_set`，如果`fd_set`集合很大时，那这个开销也很大
3. 为了减少数据拷贝带来的性能损坏，内核对被监控的`fd_set`集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)

```c
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval* timeout);
nfds:指定被监听的文件描述符的总数，监控的文件描述符最大+1（因为文件描述符从0开始）
三个fd_set分别表示读事件，写事件，异常事件，均为传入传出参数，数组实现的位图
timeval 定时阻塞时间
  1.NULL永远等下去
  2.设置timeval等待固定时间
  3.设置timeval为0，检查到时间立即返回，轮询
返回值
  1.-1异常设置errno
  2.0没有满足事件的文件描述符
  3.>0所有监听集合中满足事件的总数
```

```c
//selectServer
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <poll.h>
#include <sys/epoll.h>
#define SERIP "192.168.164.128"
#define SERPORT 8000
int main(int argc, char*argv[]){

    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror("socket error");
        exit(1);
    }
    struct sockaddr_in seraddr, cliaddr;
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons(SERPORT);
    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);

    int ret = bind(lfd, (struct sockaddr*)&seraddr, sizeof(seraddr));
    if(ret == -1){
        perror("bind error");
        exit(1);
    }
    
    ret = listen(lfd, 8);
    if(ret == -1){
        perror("listen error");
        exit(1);
    }

    //---------------------------
    int maxfd;
    //afds记录的是我们想要监听读事件的所有文件描述符集合
    //rfds为了给select传参用的
    fd_set rfds, afds;
    FD_ZERO(&afds);
    FD_SET(lfd, &afds);
    maxfd = lfd;
    int selReVal;
    socklen_t addrlen = sizeof(cliaddr);
    int i;
    char buf[1024];
    while(1){
        //调用select帮我们监听我们关心的文件描述符对应的事件
        //每次调用select使用afds给rfds重新赋值
        rfds = afds;
        selReVal = select(maxfd+1, &rfds, NULL, NULL, NULL);
        if(selReVal == -1){
            perror("select error");
            exit(1);
        }
        char dst[64];
        for(i = lfd+1; i<maxfd+1; i++){
            if(FD_ISSET(i, &rfds)){
                int readret = read(i, buf, 1024);
                if(readret == -1){
                    perror("read error");
                    exit(1);
                }
                else if(readret == 0){
                    printf("客户端断开连接\n");
                    close(i);
                    FD_CLR(i, &afds);
                }
                else{
                    write(i, buf, readret);
                    write(STDOUT_FILENO, buf, readret);
                }
                if(--selReVal == 0){
                    break;
                }
            }
        }
        //检验lfd是否触发了事件
        if(FD_ISSET(lfd, &rfds)){
            int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &addrlen);
            printf("有新的客户端建立连接 IP%s, port%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, dst, sizeof(dst)), ntohs(cliaddr.sin_port));
            FD_SET(cfd, &afds);
            if(cfd > maxfd){
                maxfd = cfd;
            }
            if(--selReVal == 0){
                continue;
            }
        }
    }
    return 0;
}
```

### poll

poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。也就是说，poll只解决了上面的问题3，并没有解决问题1，2的性能开销问题。poll改变了文件描述符集合的描述方式，使用了pollfd结构而不是select的fd_set结构，使得poll支持的文件描述符集合限制远大于select的1024

```c
int poll(struct pollfd* fds, nfds_t nfds, int timeout);
  struct pollfd{
    int fd;//文件描述符
    short events;//监听的事件
      short revents//监听事件中满足条件返回的事件
  }
nfds->监控数组中有多少需要监控的文件描述符
timeout->等待时间
  -1：阻塞等待
  0：立即返回
  >0：指定等待X毫秒
```

```c
//pollServer
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <poll.h>
#include <sys/epoll.h>
#define SERIP "192.168.164.128"
#define SERPORT 8000
#define MAXFD 1025
int main(int argc, char*argv[]){

    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror("socket error");
        exit(1);
    }
    struct sockaddr_in seraddr, cliaddr;
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons(SERPORT);
    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);

    int ret = bind(lfd, (struct sockaddr*)&seraddr, sizeof(seraddr));
    if(ret == -1){
        perror("bind error");
        exit(1);
    }
    
    ret = listen(lfd, 8);
    if(ret == -1){
        perror("listen error");
        exit(1);
    }

    //---------------------------
    struct pollfd fds[MAXFD];
    int maxi;
    int i;
    for (i = 1; i < MAXFD; i++){
        fds[i].fd = -1;
    }
    fds[0].fd = lfd;
    fds[0].events = POLLIN;
    maxi = 0;
    char buf[1024];
    char dst[64];
    int pollret;
    socklen_t addrlen = sizeof(cliaddr);
    while(1){
        pollret = poll(fds, maxi+1, -1);
        if(pollret < 0){
            perror("poll error");
        }
        if(fds[0].revents & POLLIN){
            int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &addrlen);
            printf("有新的客户端建立连接 IP%s, port%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, dst, sizeof(dst)), ntohs(cliaddr.sin_port));
            for(i = 1; i < MAXFD; i++){
                if(fds[i].fd == -1){
                    break;
                }
            }
            if(i == MAXFD){
                printf("too many client\n");
                return 0;
            }
            fds[i].fd = cfd;
            fds[i].events = POLLIN;
            if(maxi < i){
                maxi = i;
            }
        }
        for (i = 1; i < maxi+1; i++){
            if(fds[i].revents & POLLIN){
                int rr = read(fds[i].fd, buf, 1024);
                if(rr < 0){
                    perror("read error");
                }
                else if(rr == 0){
                    printf("客户端断开连接\n");
                    close(fds[i].fd);
                    fds[i].fd = -1;
                    continue;
                }
                else {
                    write(fds[i].fd, buf, rr);
                    write(STDOUT_FILENO, buf, rr);
                }
            }
        }
    } 
    return 0;
}
```

### epoll

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909153549043.png" alt="image-20220909153549043" style="zoom: 50%;" />

epoll原理：当调用epoll_create函数时，会在内核创建一个eventpoll结构体，在该结构体中有一个rdlist成员和rbr成员，它两分别是一个双向链表和红黑树，而调用epoll_ctl函数添加、修改、删除文件描述符对应的事件集合其实是对红黑树中的节点进行相应的添加、修改、删除操作，而所有添加到epoll的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当文件描述符准备就绪后，内核会回调ep_poll_callback函数，将准备就绪的事件集合添加到rdlist双向链表中，而当调用epoll_wait进行监控的时候，如果双向链表为空，则表明当前没有就绪的事件发生，如果不为空，则将双向链表中的内容复制到用户态，并返回将事件数量返回给用户。

**【注意】：这里的双向链表其实实现的是一个队列，虽然是一个双向链表，但是他只支持先进先出(FIFO)，是队列的特性。每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。**

epoll的优点是事件回调机制、数据拷贝轻量、没有数量限制、接口使用方便。但是当活跃用户比较多时，回调机制效率就会下降

- ET模式

  句柄在发生读写事件时只会通知用户一次，ET模式主要关注fd从不可用到可用或者可用到不可用的情况。ET只支持非阻塞模式。

  代码逻辑：ET模式下读写操作要时用wihle循环，直到读/写够足够多的数据，或者读/写到返回EWOULDBLOCK。尤其时在写大块数据时，一次write操作不足以写完全部数据，或者在读大块数据时，应用层缓冲区数据太小，一次read操作不足以读完全部数据，应用层要么一直调用while循环一直IO到EWOULDBLOCK,或者自己调用epoll_ctl手动触发ET响应。

  优点：效率高，缺点：编码相对困难

- LT模式

  只要句柄一直处于可用状态，就会一直通知用户。 LT模式下，句柄读缓冲区被读空后，句柄会从可用转变未不可以用，这个时候不会通知用户。写缓冲区只要还没写满，就会一直通知用户。 LT模式支持阻塞和非阻塞两种方式。epoll默认的模式是阻塞。 LT下，应用层的业务逻辑比较简单，更不容易遗漏事件，更不容易出错。通常，在将数据写完后，我们会关闭句柄的写事件。

  优点：编码相对容易，缺点：效率低

- ET比LT高效的原因

  ET在通知用户后，就会把fd从就绪队列里删除。而LT通知用户后fd还在就绪链表中，随着fd的增多，就绪链表越大。下次epoll要通知用户时还需要遍历整个就绪链表。遍历的性能是线性，如果fd的数量非常多，就会带来比较显著的效率下降。同样数量的fd下，LT模式维护的就绪链表比ET的大。

- 如何选择

  如果并发量不大的话，LT既易于编写代码，又不会有很大的性能损失

  如果并发量大的话，则要采用ET模式

```c
int epoll_create(int size);
//创建一个内核中的epoll对象，在内存中创建红黑树和双向链表
//size为监听数目初始化红黑树的节点数，如过后续监听数量大于size则重新构建红黑树，返回值为创建的epoll操作句柄
//成功返回文件描述符(操作句柄)
```

```c
int epoll_ctl(int epfd, int op, int fd（要监听的文件描述符的值，给红黑树看的）, struct epoll_event *event);

/*控制某个epoll监控的文件描述符上的事件：注册、修改、删除
epfd epoll操作句柄
op表示动作
  EPOLL_CTL_ADD（注册新的fd到epfd）
  EPOLL_CTR_MOD（修改已经注册的fd监听事件）
  EPOLL_CTR_DEL（从epfd删除一个fd）
event告诉内核需要监听的事件
  struct epoll_event{
    uint32_t events;//关心文件发生的事件（宏）
    epoll_data_t data;
  };
  typedef union epoll_data{(data域)
    void *ptr;
    int fd;//给用户看的，和epoll_ctl参数中的fd一致
    uint32_t u32;//不用
    uint64_t u64;//不用
  }epoll_data_t;*/
```

```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
/*等待所监听的文件描述符上事件的发生
events用来存内核得到事件的集合,数组
maxevents告知内核这个events数组的大小，这个maxevents不能大于创建时的size
timeout超时事件
  -1阻塞
  0立即返回
  >0指定毫秒
返回值：成功返回有多少个文件描述符准备就绪，时间到返回0，出错返回-1*/
```

水平触发LT和边缘触发ET：

LT为epoll的默认行为，但是ET可以减少epoll触发的次数（代价是代码比LT复杂一些），ET模式只会通知一次，带来的后果就是必须一次性将事件产生的数据全部读取，方法如下

1.循环读→引入了阻塞的问题（epoll不支持阻塞）

2.将文件描述符设置为非阻塞状态（fctrl，O_NONBLOCK）具体见代码

```c
//EpollServer
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/epoll.h>
#include <sys/errno.h>
#define SERIP "192.168.164.128"
#define SERPORT 8000
int main(int argc, char*argv[]){
    //创建socket
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror("socket error");
        exit(1);
    }
    struct sockaddr_in seraddr, cliaddr;
    seraddr.sin_family = AF_INET;
    seraddr.sin_port = htons(SERPORT);
    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);

    //为lfd绑定地址结构
    int ret = bind(lfd, (struct sockaddr*)&seraddr, sizeof(seraddr));
    if(ret == -1){
        perror("bind error");
        exit(1);
    }
    //listen设置监听套接字
    ret = listen(lfd, 8);
    if(ret == -1){
        perror("listen error");
        exit(1);
    }
    //---------------------------------
    socklen_t addrlen = sizeof(cliaddr);
    int epfd = epoll_create(64);
    struct epoll_event event, events[1025];  
    event.events = EPOLLIN;
    event.data.fd = lfd; 
    char buf[1024];
    int epollret;
    epollret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &event);
    if(epollret < 0){
        perror("epoll_ctl error");
    }
    while(1){
        epollret = epoll_wait(epfd, events, 1025, -1);
        if(epollret < 0){
            perror("epoll_wait error");
        }
        char dst[64];
        for(int i = 0; i < epollret; i++){
            if(events[i].data.fd == lfd ){
                if(events[i].events &&  EPOLLIN){
                        int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &addrlen);
                        printf("有新的客户端连接ip %s, port%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, dst, sizeof(dst)), ntohs(cliaddr.sin_port));
                        int flag = fcntl(cfd, F_GETFL);
                        flag |= O_NONBLOCK;
                        fcntl(cfd, F_SETFL, flag);
                        event.events = EPOLLIN | EPOLLET;
                        event.data.fd = cfd;
                        int re = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &event);
                        if(re < 0){
                            perror("epoll_ctl error");
                        }
                }
            }
            else {
                if(events[i].events & EPOLLIN){
                    while(1) {//ET模式循环读
                    	int fd = events[i].data.fd;
                    	int rr = read(fd, buf, 5);
                    	if(rr < 0){
                        	if(errno == EWOULDBLOCK){
                                break;
                            }
                        	perror("read error");
                    	}
                    	else if(rr == 0){
                        	printf("客户端断开连接");
                        	int re = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
                        	if(re < 0){
                            	perror("epoll_ctl error");
                        	}
                        	close(fd);
                        	break;
                    	}
                    	else {
                        	write(fd, buf, rr);
                        	write(STDOUT_FILENO, buf, rr);
                    	}
                    }
                }
            }
        }
    }
    return 0;
}
```

### 端口复用

```c
int opt = 1;
// sockfd为需要端口复用的套接字
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&opt, sizeof(opt));
```

# 数据结构与算法

## 数据结构

### 树

#### 二叉树

每个节点最多有两个子节点

#### 二叉搜索树（二叉查找树）

一颗空树或如果左子树不空则左子树上所有节点值小于父节点且如果右子树不空则右子树上左右节点值大于父节点

#### 平衡二叉树（AVL树）

所有节点的左右子树高度差小于1

#### 红黑树

黑色节点绝对平衡，红色节点与其相连的黑色节点同属为二三查找树的一层（红节点不破坏平衡性），红色节点通常实现在左侧，红色节点不连续，

#### B树

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909153923847.png" alt="image-20220909153923847" style="zoom:50%;" />

#### B+树

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909153945895.png" alt="image-20220909153945895" style="zoom:50%;" />

1. B+树非叶子节点只存储键值

2. B+树叶子节点都有一个链指针

3. B+树所有数据记录都存放在叶子节点

### 位运算

x&(x-1)统计x的二进制1的数

### 哈希表

散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的[数据结构](https://www.zhihu.com/search?q=数据结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType":"answer","sourceId":572450659})。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://www.zhihu.com/search?q=散列函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType":"answer","sourceId":572450659})，存放记录的数组称做散列表。

散列函数，顾名思义，它是一个函数。如果把它定义成 **hash(key)** ，其中 key 表示元素的键值，则 **hash(key)** 的值表示经过散列函数计算得到的散列值。

哈希函数的特点：1.确定性（值不同，那么键也不相同）2.散列碰撞（输入和输出不是唯一对应的，两个散列值相同，输入可能相同也可能不相同）3.不可逆性（一个哈希值对应无数个明文，理论上你并不知道哪个是。）4.混淆特性（输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。）

#### 常见哈希函数

- MD5：Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。将输入运算为另一固定长度的值（128bits，4个32bit加起来）
- SHA-1：（Secure Hash Algorithm 1，安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。

#### 散列冲突

理想→如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)，事实上，再好的散列函数都无法避免散列冲突。因为对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的散列冲突。

##### 开放地址法

简单讲就是如果hash算法算出来的值已经被占用了，那就再找一块地方

1. 线性探测法：如果被占用那就从当前位置一直往后找直到空，散列表插入数据越来越多也就越来越可能冲突，极端情况下需要从头遍历到尾。O(n)

2. 二次探测法：也就是二次方探测法，将探测的步长变为原来的二次方（1*2,-1*2,2*2,-2*2）

3. 双重散列法：使用一组散列函数，冲突就换下一个函数进行计算

加载因子→表示当前hash表中元素填满的程度

##### 链表法

相比于开放地址更为常用，在散列表中，每个位置对应一条链表，所有散列值相同的元素都放到相同位置对应的链表中，所以散列表查找的时间复杂度可能不是严格的O(1)

### B树

#### B树的引入

磁盘IO慢-》加快速度-》例：索引（kv）

线性（查找慢、删插慢）-》哈希（哈希冲突、范围查找）

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126130239857.png" alt="image-20221126130239857" style="zoom:33%;" />

二叉树-》二叉搜索树-》二叉平衡树-》红黑树-》B-树-》B+树

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126130659569.png" alt="image-20221126130659569" style="zoom:33%;" />

B树：平衡多路查找树

- 树中每个节点至多有m个孩子节点（至多有m-1个关键字）

- 节点结构<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126132002909.png" alt="image-20221126132002909" style="zoom:50%;" />

  例M叉B树

  <img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126132214710.png" alt="image-20221126132214710" style="zoom: 33%;" />

#### B树的查找

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126132549879.png" alt="image-20221126132549879" style="zoom:33%;" />

16×16×16×16，4096      指针+键值10字节，数据1KB，差100倍，1600×1600×16

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20221126133101790.png" alt="image-20221126133101790"  />

- **B+树和B树的对比**

1、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。

2、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

3、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字和数据，所以在查询这种数据检索的时候会要比**B+树**快。 

## 算法

### 算法适用性

前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。



### 字典序

1. 从原排列中，从右至左，找到第一个左邻小于右邻的字符，记左邻位置为 a。
2. 重新从右至左，找到第一个比 nums[a] 大的字符，记为位置为 b。
3. 交换 a 和 b 两个位置的值。
4. 将 a 后面的数，由小到大排列。

- 第1步中，如果找不到左邻小于右邻的数，则说明给定的排列已经是全排列的最后一个排列了，则直接返回全排列的第一个排列，即所有排列中最小的排列，形成一个循环。
- 在第3步交换前，a 后面的数是按照从大到小进行排列（否则第1步中就可以找到左邻小于右邻的数了）。
- 在交换之后，a 后面的数仍然是按照从大到小排列的
- 既然 a 后面的数是从大到小排列的，那么第4步的排序，直接将 a 后面的数倒序即可。

- 以上描述是已知小的算大的，如果是已知大的算小的只需要将12步骤中的大小于改变即可
- 如果有重复数据则需要在第二步加上与前一个数是否相等的判断
- 如果只能交换一次则不需要排序

### 一致性哈希



# 数据库

## MySQL

### 基础SQL语句

#### 语法

1. SQL语句可以单行或多行书写，以分号结尾
2. SQL语句可以使用空格/缩进来增强语句的可读性
3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
4. 注释：
   - 单行注释：-- 注释内容或# 注释内容（MySQL特有）
   - 多行注释：/* 注释内容 */

#### SQL分类

| 分类 |            全称            |                          说明                          |
| :--: | :------------------------: | :----------------------------------------------------: |
| DDL  |  Data definition language  |  数据定义语言，用来定义数据库对象（数据库、表、字段）  |
| DML  | Data manipulation language |     数据操作语言，用来对数据库表中的数据进行增删改     |
| DQL  |    Data query language     |         数据查询语言，用来查询数据库中表的记录         |
| DCL  |   Data control language    | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

#### 登录数据库

```sql
-- 登录
-- h表示host，即服务器ip（本地服务器默认是localhost/127.0.0.1   登录本地数据库服务器时可省略）
-- P表示port，即服务器端口号 （大写是为了跟后面密码的“p”区分开来； 默认是3306）
-- u表示username, 即用户名，p表示password，即密码
mysql -u root -p-- 登录本地数据库，输入密码即可
mysql -h host -P Port -u username -p-- 登录远程数据库，输入密码即可
exit quit \q-- 退出当前登录
```

#### MySQL中的数据类型

1. 数值类型

![image-20230517114416726](photo/image-20230517114416726.png)

2. 字符串类型

![image-20230517114513572](photo/image-20230517114513572.png)

3. 日期类型

![image-20230517114530654](photo/image-20230517114530654.png)

#### DDL

```sql
-- DDL
show databases;-- 展示数据库
select DATABASE();-- 查询当前数据库
create database [if not exists] 数据库名 [default charset 字符集] [collate 排列顺序];-- 创建数据库
drop database [if exists];-- 删除数据库
use databasename;-- 使用某个数据库
SHOW STATUS;-- 用于显示广泛的服务器状态信息；
SHOW GRANTS;-- 用来显示授予用户（所有用户或特定用户）的安全权限；
SHOW ERRORS和SHOW WARNINGS;-- 用来显示服务器错误或警告消息。
show tables;-- 展示当前数据库中的表
desc tablename;-- 查询表结构
describe table;-- 查询表结构
show colunms from table;-- 查询表结构
show create table tablename;-- 查询指定表的建表语句
show create database databasename;-- 查询指定数据库的创建语句
-- 创建表
create table tablename (
字段1 字段1类型[comment 字段1注释]
字段2 字段2类型[comment 字段2注释]
)[comment 注释];
-- 为表增加字段
alter table tablename add 字段名 类型(长度) [comment 注释] [约束];
-- 修改表的数据类型
alter table tablename modify 字段名 新数据类型(长度);
-- 修改字段名和字段类型
alter table tablename change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];
-- 删除字段
alter table tablename drop 字段名;
-- 修改表名
alter table tablename rename to newtablename;
-- 删除表
drop table [if exists] tablename;
-- 删除指定表，并重新创建该表，相当于清空数据
truncate table tablename;
```

#### DML

```sql
-- DML
-- 包含对数据的增删改
-- 增加数据
-- 注意，插入数据时字段的顺序和值的顺序应该保持一致、字符串和日期型放在引号中、插入的数据大小应该在字段的范围内
-- 1.给指定字段增加数据
insert into tablename(字段1,字段2,...)values(值1,值2,...);
-- 2.给全部字段添加数据
insert into tablename values(值1,值2,...);
-- 3.批量增加数据
insert into tablename(字段1,字段2,...)values(值1,值2,...),(值1,值2,...)...;
insert into tablename values(值1,值2,...),(值1,值2,...)...;
-- 修改数据，条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。
UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ];
-- 删除数据
-- DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。
-- DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。
DELETE FROM 表名 [ WHERE 条件 ] ;
```

#### 比较运算符

|       运算符        |                   功能                   |
| :-----------------: | :--------------------------------------: |
|          >          |                   大于                   |
|         >=          |                 大于等于                 |
|          <          |                   小于                   |
|         <=          |                 小于等于                 |
|          =          |                   等于                   |
|      <> 或 !=       |                  不等于                  |
| BETWEEN ... AND ... |      在某个范围之内(含最小、最大值)      |
|       IN(...)       |       在in之后的列表中的值，多选一       |
|     LIKE 占位符     | 模糊匹配(_匹配单个字符, %匹配任意个字符) |
|       IS NULL       |                  是NULL                  |

#### 逻辑运算符

|  运算符   | 功能                        |
| :-------: | :---------------------------: |
| AND 或 && | 并且 (多个条件同时成立)     |
|   OR 或   | 或者 (多个条件任意一个成立) |
| NOT 或 !  | 非 , 不是                   |

#### 聚合函数

将一列数据作为一个整体，进行纵向计算。

NULL不参与任何聚合函数的运算

| 函数  | 功能     |
| :-----: | :--------: |
| count | 统计数量 |
| max   | 最大值   |
| min   | 最小值   |
| avg   | 平均值   |
| sum   | 求和     |

#### DQL

```sql
-- DQL
SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数
-- 查询多个字段
SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;
SELECT * FROM 表名 ;
-- 字段设置别名
SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名; 
SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;
-- 去重
SELECT DISTINCT 字段列表 FROM 表名;
-- 条件查询
SELECT 字段列表 FROM 表名 WHERE 条件列表 ;
-- 分组查询
-- where和having的区别
-- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。
-- 判断条件不同：where不能对聚合函数进行判断，而having可以。
SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];
-- 排序
-- 排序方式：ASC : 升序(默认值)，DESC: 降序
-- 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;
-- 分页查询
-- 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。
-- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;
```

#### 查询执行顺序

![image-20230519180614871](photo/image-20230519180614871.png)

#### DCL

**用户管理**

```sql
-- 查询所有用户
select * from mysql.user;

-- 创建用户
-- 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。
-- 主机名可以使用 % 通配。
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';

-- 修改用户密码
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;

-- 删除用户
DROP USER '用户名'@'主机名' ;


-- 权限控制

```

**权限管理**

MySQL中常见权限如下：

ALL, ALL PRIVILEGES 所有权限
SELECT                        查询数据
INSERT                         插入数据
UPDATE                       修改数据
DELETE                        删除数据
ALTER                           修改表
DROP                            删除数据库/表/视图
CREATE                        创建数据库/表

```sql
-- 查询权限
SHOW GRANTS FOR '用户名'@'主机名' ;

-- 授予权限
-- 多个权限之间，使用逗号分隔
-- 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';

-- 撤销权限
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
```

### 函数

#### 字符串函数

| 函数                     | 功能                                                      |
| ------------------------ | --------------------------------------------------------- |
| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串              |
| LOWER(str)               | 将字符串str全部转为小写                                   |
| UPPER(str)               | 将字符串str全部转为大写                                   |
| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
| TRIM(str)                | 去掉字符串头部和尾部的空格                                |
| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串           |

```sql
-- 字符串函数案例
-- 字符串拼接
select concat('Hello', 'MySQL');

-- 将字符串转为小写
select lower('Hello');

-- 将字符串转换为大写
select upper('Hello');

-- 左填充
select lpad('01', 5, '-');
-- 将工号变更为5位数，不足五位前面补0
update emp set workno = lpad(workno, 5, '0');

-- 右填充
select rpad('01', 5, '-');

-- 去除空格
select trim(' Hello MySQL ');

-- 截取子字符串，索引从1开始
select substring('Hello MySQL',1,5);
```

#### 数值函数

| 函数       | 功能                               |
| ---------- | ---------------------------------- |
| CEIL(x)    | 向上取整                           |
| FLOOR(x)   | 向下取整                           |
| MOD(x,y)   | 返回x/y的模                        |
| RAND()     | 返回0~1内的随机数                  |
| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |

```sql
-- 通过数据库的函数，生成一个六位数的随机验证码。
-- 思路：获取随机数可以通过rand()函数获得，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0
select lpad(round(rand()*1000000 , 0), 6, '0');
```

#### 日期函数

| 函数                               | 功能                                              |
| ---------------------------------- | ------------------------------------------------- |
| CURDATE()                          | 返回当前日期                                      |
| CURTIME()                          | 返回当前时间                                      |
| NOW()                              | 返回当前日期和时间                                |
| YEAR(date)                         | 获取指定date的年份                                |
| MONTH(date)                        | 获取指定date的月份                                |
| DAY(date)                          | 获取指定date的日期                                |
| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天数      |

```sql
-- 查询所有员工的入职天数，并根据入职天数倒序排序。
-- 思路：入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成
select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;
```

#### 流程函数

| 函数                                                         | 功能                                                      |
| ------------------------------------------------------------ | --------------------------------------------------------- |
| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回f                       |
| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则返回value2              |
| CASE WHEN [ val1 ] THEN [res1] ...ELSE [ default ] END       | 如果val1为true，返回res1，... 否则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN[res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回res1，... 否则返回default默认值 |

### 约束

约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。

| 约束                     | 描述                                                     | 关键字      |
| ------------------------ | -------------------------------------------------------- | ----------- |
| 非空约束                 | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束                 | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE      |
| 主键约束                 | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束                 | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |
| 检查约束(8.0.16版本之后) | 保证字段值满足某一个条件                                 | CHECK       |
| 外键约束                 | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

```sql
-- 创建一个员工表作为演示
CREATE TABLE tb_user(
id int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',
name varchar(10) NOT NULL UNIQUE COMMENT '姓名' ,
age int check (age > 0 && age <= 120) COMMENT '年龄' ,
status char(1) default '1' COMMENT '状态',
gender char(1) COMMENT '性别'
);
```

添加外键的表是从表，键被其他表添加为外键的表是主表。

注意：主表中的某个字段是其他表的外键，那么删除这个字段将会报错（可以变更为其他默认行为）

```sql
-- 外键约束
-- 创建表时添加外键
CREATE TABLE 表名(
字段名 数据类型,
...
[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)
);

-- 修改表时添加外键
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;

-- 删除外键
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```

**删除/更新行为**

| 行为        | 说明                                                         |
| ----------- | ---------------------------------- |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 RESTRICT 一致) 默认行为 |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 NO ACTION 一致) 默认行为 |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。 |
| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)  |

```sql
-- 具体语法
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;
```

### 多表查询

#### 多表关系

项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：一对多（多对一）、多对多、一对一。

- 一对多

  - 案例：部门与员工的关系
  - 关系：一个部门对应多个员工，一个员工对应一个部门
  - 实现：在多的一方建立外键，指向一的一方的主键（在员工表中建立外键，指向部门表的主键）

  ![image-20230526093440049](photo/image-20230526093440049.png)

- 多对多

  - 案例：学生与课程的关系
  - 关系：一个学生可以选修多门课程，一门课程也可以被多个学生选择
  - 实现：建立第三张中间表，中间表至少包含两个外键，分别关联双方主键

  ![image-20230526093452170](photo/image-20230526093452170.png)

- 一对一

  - 案例：用户与用户详情的关系
  - 关系： 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
  - 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)

  ![image-20230526093639945](photo/image-20230526093639945.png)

#### 各种连接

- 笛卡尔积

  `select * from emp , dept;`使用不带条件的夺标查询最终会产生各个表的记录成绩个结果，这就是笛卡尔积（笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况）。笛卡尔积中有大量的无效数据，所以我们在多表查询的时候需要利用条件消除无效数据，如下`select * from emp , dept where emp.dept_id = dept.id;`。

- 内连接

  内连接查询是两张表的交集部分

  - 隐式内连接

    `SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;` 

  - 显示外连接

    `SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;` 

  - 案例

    ```sql
    -- 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)
    select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;
    -- 为每一张表起别名,简化SQL编写
    select e.name,d.name from emp e , dept d where e.dept_id = d.id;
    
    -- 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现)
    select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;
    -- 为每一张表起别名,简化SQL编写
    select e.name, d.name from emp e join dept d on e.dept_id = d.id;
    -- 一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段
    ```

- 外连接

  - 左外连接

    `SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;`

    左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。

  - 右外连接

    `SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;`

    右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。

  - 案例

    ```sql
    -- 查询emp表的所有数据, 和对应的部门信息
    -- 由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的(因为emp中可能有人没有部门号)，需要考虑使用外连接查询。
    -- 左外连接
    select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;
    select e.*, d.name from emp e left join dept d on e.dept_id = d.id;
    
    -- 右外连接
    select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;
    select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;
    -- 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。
    ```

- 自连接

  - 自连接查询

    自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。

    `SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;`

    案例：

    ```sql
    -- 查询员工 及其 所属领导的名字
    select a.name , b.name from emp a , emp b where a.managerid = b.id;
    -- 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来
    select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid =
    b.id;
    -- 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。
    ```

  - 联合查询

    对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集

    ```sql
    SELECT 字段列表 FROM 表A ...
    UNION [ ALL ]
    SELECT 字段列表 FROM 表B ....;
    ```

    **对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。**

    **union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。**

    ```sql
    -- 案例
    -- 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来
    -- 当前对于这个需求我，们可以直接使用多条件查询，使用逻辑运算符or连接即可。我们也可以通过union/union all来联合查询
    select * from emp where salary < 5000
    union all
    select * from emp where age > 50;
    -- 需要注意的是union all知识对查询结果进行合并，没有进行去重，如果需要去重则使用union
    ```


#### 子查询

SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。

`SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );` 

子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。

**按查询结果分类**

1. 标量子查询（子查询结果为单个值）
2. 列子查询(子查询结果为一列)
3. 行子查询(子查询结果为一行)
4. 表子查询(子查询结果为多行多列)

**按子查询位置分类**

1. WHERE之后
2. FROM之后
3. SELECT之后

##### 标量子查询

子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。

常用的操作符：= <> > >= < <= 

```sql
-- 查询 "销售部" 的所有员工信息
select * from emp where dept_id = (select id from dept where name = '销售部');

-- 查询在 "方东白" 入职之后的员工信息
select * from emp where entrydate > (select entrydate from emp where name = '方东
白');
```

##### 列子查询

子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。

常用的操作符：IN-在某个集合内、NOT IN-不在某个集合内、 ANY-任意、SOME-同ANY、 ALL-所有

```sql
 -- 查询 "销售部" 和 "市场部" 的所有员工信息
select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');

-- 查询比 "财务部" 所有人工资都高的员工信息（使用max也可以）
select * from emp where salary > all (select salary from emp where dept_id = (select id from dept where name = '财务部'));

-- 查询比研发部其中任意一人工资高的员工信息
select * from emp where salary > any ( select salary from emp where dept_id =(select id from dept where name = '研发部') );
```

##### 行子查询

子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。

常用的操作符：= 、<> 、IN 、NOT IN

```sql
-- 查询 "张无忌" 的薪资及直属领导
select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');
```

##### 表子查询

子查询返回的结果是多行多列，这种子查询称为表子查询。

常用的操作符：IN

```sql
-- 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息
select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );

-- 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息
select e.*, d.* from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id ;
```

#### 多表查询案例

```sql
--  查询员工的姓名、年龄、职位、部门信息 （隐式内连接）
select e.name , e.age , e.job , d.name from emp e , dept d where e.dept_id = d.id;

-- 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）
select e.name , e.age , e.job , d.name from emp e inner join dept d on e.dept_id = d.id where e.age < 30;

-- 查询拥有员工的部门ID、部门名称
select distinct d.id , d.name from emp e , dept d where e.dept_id = d.id;

--  查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)
select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age > 40 ;

-- 查询所有员工的工资等级
select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary >= s.losal and e.salary <= s.hisal;
select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary between s.losal and s.hisal;

-- 查询 "研发部" 所有员工的信息及 工资等级
select e.* , s.grade from emp e , dept d , salgrade s where e.dept_id = d.id and (e.salary between s.losal and s.hisal ) and d.name = '研发部';

-- 查询 "研发部" 员工的平均工资
select avg(e.salary) from emp e, dept d where e.dept_id = d.id and d.name = '研发部';

-- 查询工资比 "灭绝" 高的员工信息。
select * from emp where salary > ( select salary from emp where name = '灭绝' );

-- 查询比平均薪资高的员工信息
select * from emp where salary > ( select avg(salary) from emp );

-- 查询低于本部门平均工资的员工信息
select * from emp e2 where e2.salary < ( select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id );

-- 查询所有的部门信息, 并统计部门的员工人数
select d.id, d.name , ( select count(*) from emp e where e.dept_id = d.id ) '人数' from dept d;

-- 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称
select s.name , s.no , c.name from student s , student_course sc , course c where s.id = sc.studentid and sc.courseid = c.id ;
```

### 事务

#### 简介                  

​                                                                   

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。

*注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。*

#### 操作

```sql
-- 查看/设置事务提交方式
SELECT @@autocommit;
SET @@autocommit = 0;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。
```

```sql
-- 开启事务
START TRANSACTION 或 BEGIN ;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;
```

#### 事务四大特性

原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。

一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。

隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

简称**ACID**

#### 并发事务问题

赃读：一个事务读到另外一个事务还没有提交的数据。

![image-20230603122202691](photo/image-20230603122202691.png)

比如B读取到了A未提交的数据。



不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

![image-20230603122242706](photo/image-20230603122242706.png)事务A两次读取同一条记录，但是读取到的数据却是不一样的。



幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "幻影"。

![image-20230603122345895](photo/image-20230603122345895.png)

#### 事务隔离级别

![image-20230603122407477](photo/image-20230603122407477.png)

```sql
-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 设置事务隔离级别
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
-- 注意：事务隔离级别越高，数据越安全，但是性能越低。
```

### 存储引擎

#### MySQL体系结构

<img src="photo/image-20230603122733757.png" alt="image-20230603122733757" style="zoom:50%;" />

1. 连接层

   最上层是一些客户端和链接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于

   TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程

   池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务

   器也会为安全接入的每个客户端验证它所具有的操作权限。

2. 服务层

   第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部

   分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解

   析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，

   最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，

   这样在解决大量读操作的环境中能够很好的提升系统的性能。

3. 引擎层

   存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通

   信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库

   中的索引是在存储引擎层实现的。

4. 存储层

   数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询

   日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

#### 存储引擎介绍

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

```sql
-- 建表时指定数据库
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ];

-- 查询当前数据库支持的存储引擎
show engines;

-- 查询建表语句 --- 默认存储引擎: InnoDB
show create table account;
```

#### 各个存储引擎的特点

- InnoDB

  1. InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的

     MySQL 存储引擎。

  2. 特点

     DML操作遵循ACID模型，支持事务；

     行级锁，提高并发访问性能；

     支持外键FOREIGN KEY约束，保证数据的完整性和正确性；

- MyISAM

  1. MyISAM是MySQL早期的默认存储引擎。

  2. 特点

     不支持事务，不支持外键

     支持表锁，不支持行锁

     访问速度快

- Memory

  1. Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为

     临时表或缓存使用。

  2. 特点

     内存存放

     hash索引（默认）

![image-20230603124507596](photo/image-20230603124507596.png)

#### 存储引擎的选择

InnoDB: 是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。

MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。

MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

### 索引

#### 索引概述

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

优势：提高数据检索效率，降低数据库IO成本、通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

劣势：索引列占空间、索引提高查询效率的同时也降低了增删改的效率（其实劣势可以忽略不记，很小）

<img src="photo/image-20230604153944610.png" alt="image-20230604153944610" style="zoom:33%;" />

<img src="photo/image-20230604153957410.png" alt="image-20230604153957410" style="zoom:33%;" />

#### 索引分类

<img src="photo/image-20230604155750246.png" alt="image-20230604155750246" style="zoom: 33%;" />

<img src="photo/image-20230604160036619.png" alt="image-20230604160036619" style="zoom:33%;" />

聚簇索引为必备的索引（存储整行数据），非聚簇索引不是必备的索引（只存储索引的字段，查询时拿到字段再去聚簇索引中查询（这个过程叫回表查询）），聚簇索引的产生规则如下：

- 如果存在主键，主键索引就是聚集索引。
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

#### 索引语法

单列索引、联合索引

```sql
-- 创建索引
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... );

-- 查看索引
SHOW INDEX FROM table_name;

-- 删除索引
DROP INDEX index_name ON table_name;

-- phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。
CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);

-- 为profession、age、status创建联合索引。
CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);
```

#### 性能分析

#####  SQL执行频率

MySQL 客户端连接成功后，通过`show [session|global] status` 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';-- 此处下划线表示操作的长度，如Com_delete: 删除次数（7个下划线）

```

##### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

MySQL的慢查询日志默认没有开启，通过系统变量 `slow_query_log` 查询，`show variables like 'slow_query_log';`

如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2

# 配置完成后，通过 systemctl restart mysqld 重启mysql
#以后就可以在 /var/lib/mysql/localhost-slow.log 中查看慢查询日志了
```

##### profile详情

show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：`SELECT @@have_profiling ;` 

默认关闭，使用 `SET profiling = 1;` 语句打开，接下来所有的SQL语句消耗的时间做了什么都会被记录。

```sql
-- 查看每一条SQL的耗时基本情况
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

##### explain

EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。在extra中会有当前命令的额外信息，如是否使用了索引、是否反向扫描索引

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

<img src="photo/image-20230604173821290.png" alt="image-20230604173821290" style="zoom: 33%;" />

#### 索引使用规则

在建立索引前后执行同样的查询来得知索引是否提高了效率

##### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

*注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。*

##### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。

但当范围查询使用>= 或 <= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。

所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <。

##### 索引失效情况

在索引列上进行运算操作， 索引将失效。

字符串类型字段使用时，不加引号，索引将失效。

尾部模糊匹配，索引不会失效；头部模糊匹配，索引失效。

当or连接的条件，左右两侧字段都有索引时，索引才会生效。

如果MySQL评估使用索引比全表更慢，则不使用索引。

##### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

```sql
-- use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。
explain select * from tb_user use index(idx_user_pro) where profession = '软件工程';

-- ignore index ： 忽略指定的索引。
explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';

-- force index ： 强制使用索引。
explain select * from tb_user force index(idx_user_pro) where profession = '软件工程';
```

##### 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。

##### 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```sql
-- 创建前缀索引
create index idx_xxxx on table_name(column(n)) ;

-- 前缀索引的长度可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
select count(distinct email) / count(*) from tb_user ;
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
```

#### 索引设计原则

1). 针对于数据量较大，且查询比较频繁的表建立索引。

2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索

引。

3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。

5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。

6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。create unique index idx_user_phone_name on tb_user(phone,name); 

7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

### SQL优化

####  insert

1. 将多条记录放在一个insert语句中的效果比一个一个写性能要好

2. 手动控制事务的效果比较好，如下

```sql
start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
```

3. 主键顺序插入，性能要高于乱序插入。

4. 如果一次插入大批量数据（几百万条），可以使用MySQL提供的load指令：

```sql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
-- 执行load指令将准备好的数据，加载到表结构中，数据需要按照表的规则排列好
load data local infile '/root/sql1.log' into table tb_user fields
terminated by ',' lines terminated by '\n' ;
```

#### 主键优化

**数据组织形式**

在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。

在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。

页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果是一行就变成链表了）(如果一行数据过大，会行溢出)，根据主键排列。

**页分裂**

1 从磁盘中申请页，按照主键顺序插入，2 如果一页满了，将会另起一页，页与页之间用指针相连

<img src="photo/image-20230607140853479.png" alt="image-20230607140853479" style="zoom: 50%;" />

上图情况会产生页分裂，是比较耗费性能的操作，如下图

<img src="photo/image-20230607140948932.png" alt="image-20230607140948932" style="zoom: 50%;" />

**页合并**

当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。

当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

<img src="photo/image-20230607141132598.png" alt="image-20230607141132598" style="zoom: 50%;" />

**针对主键的索引优化**

- 满足业务需求的情况下，尽量降低主键的长度。
- 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
- 业务操作时，避免对主键的修改。

#### order by优化

MySQL的排序，有两种方式：

Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。

Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。

A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。

B. 尽量使用覆盖索引。

C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。

D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。

#### group by优化

A. 在分组操作时，可以通过索引来提高效率。

B. 分组操作时，索引的使用也是满足最左前缀法则的。

#### limit优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低

一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化

#### count优化

MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。

InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

<img src="photo/image-20230607141616856.png" alt="image-20230607141616856" style="zoom: 33%;" />

按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(*)，所以尽量使用 count(*)。

#### update优化

update的优化主要从锁的角度考虑，来增加并发性

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。

### 数据库对象

#### 视图

视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

```sql
-- 创建视图
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]

-- 查看创建视图语句
SHOW CREATE VIEW 视图名称;
-- 查看视图数据
SELECT * FROM 视图名称 ...... ;

-- 修改1
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
-- 修改2
ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]

-- 删除
DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...
```

**视图的检查选项**

如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。

当使用`WITH CHECK OPTION`子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： `CASCADED` 和 `LOCAL`，默认值为 `CASCADED` 。

1. CASCADED

   级联

   比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1

2. LOCAL

   本地

   比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1。

**视图的更新**

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）B. DISTINCT C. GROUP BY D. HAVING E. UNION 或者 UNION ALL

**视图作用**

- 简单

  简化用户对数据的理解，并且简化用户的操作

- 安全

  数据库可以授权，但不能授权到数据库特定行和特定列上，通过视图用户只能查询和修改他们所能见到的数据

- 数据独立

  视图可以帮助用户屏蔽真实表结构变化带来的影响

#### 存储过程

存储过程就是预先编译好并存储在数据库中的一段SQL，相当于函数或者库，简化开发操作，提高代码可重用性。

```sql
-- 创建
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])
BEGIN
-- SQL语句
END ;

-- 调用
CALL 名称 ([ 参数 ]);

-- 查看
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'; -- 查询指定数据库的存储过程及状态信息
SHOW CREATE PROCEDURE 存储过程名称; -- 查询某个存储过程的定义

-- 删除
DROP PROCEDURE [ IF EXISTS ] 存储过程名称;
```

##### 变量

1. 系统变量

   系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL，全局变量针对所有会话）、会话变量（SESSION，针对单个会话）。

   ```sql
   SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量
   SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......'; -- 可以通过LIKE模糊匹配方式查找变量
   SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值
   ```

   ```sql
   -- 设置系统变量，如果没有指定global或者session默认是session
   SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;
   SET @@[SESSION | GLOBAL]系统变量名 = 值 ;
   ```

2. 用户定义变量

   用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 "@变量名" 使用就可以。其作用域为当前连接。

   ```sql
   -- 赋值1
   SET @var_name = expr [, @var_name = expr] ... ;
   SET @var_name := expr [, @var_name := expr] ... ;
   
   -- 赋值2
   SELECT @var_name := expr [, @var_name := expr] ... ;
   SELECT 字段名 INTO @var_name FROM 表名;
   
   -- 使用，如果不声明或初始化，则会取到NULL
   SELECT @var_name ;
   ```

3. 局部变量

   局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN ... END块。

   ```sql
   -- 声明，变量类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME
   DECLARE 变量名 变量类型 [DEFAULT ... ] ;
   
   -- 赋值
   SET 变量名 = 值 ;
   SET 变量名 := 值 ;
   SELECT 字段名 INTO 变量名 FROM 表名 ... ;
   ```

##### 控制语句

```sql
-- if
IF 条件1 THEN
.....
ELSEIF 条件2 THEN -- 可选
.....
ELSE -- 可选
.....
END IF;

-- if案例
create procedure p3()
begin
	declare score int default 58;
	declare result varchar(10);
	if score >= 85 then
		set result := '优秀';
	elseif score >= 60 then
		set result := '及格';
	else
		set result := '不及格';
	end if;
	select result;
end;

call p3();
```

```sql
-- 参数
-- 传入、传出、传入传出，默认是传入参数
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])
BEGIN
	-- SQL语句
END ;

-- 案例
create procedure p5(inout score double)
begin
	set score := score * 0.5;
end;

set @score = 198;
call p5(@score);
select @score;
```

```sql
-- case
-- 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
CASE case_value
	WHEN when_value1 THEN statement_list1
	[ WHEN when_value2 THEN statement_list2] ...
	[ ELSE statement_list ]
END CASE;

-- 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list
CASE
	WHEN search_condition1 THEN statement_list1
	[WHEN search_condition2 THEN statement_list2] ...
	[ELSE statement_list]
END CASE;
```

```sql
-- while
WHILE 条件 DO
SQL逻辑...
END WHILE;

-- 案例
create procedure p7(in n int)
begin
	declare total int default 0;
	while n>0 do
		set total := total + n;
		set n := n - 1;
	end while;
	select total;
end;
call p7(100);
```

```sql
-- repeat
REPEAT
	SQL逻辑...
	UNTIL 条件
END REPEAT;

-- 案例
create procedure p8(in n int)
begin
	declare total int default 0;
	repeat
		set total := total + n;
		set n := n - 1;
	until n <= 0
	end repeat;
	select total;
end;
call p8(10);
```

```sql
-- loop,需要配合以下两个语句使用
LEAVE label; -- 退出指定标记的循环体
ITERATE label; -- 直接进入下一次循环

[begin_label:] LOOP
	SQL逻辑...
END LOOP [end_label];
```

```sql
-- 游标
-- 游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE

-- 声明游标
DECLARE 游标名称 CURSOR FOR 查询语句;

-- 打开游标
OPEN 游标名称;

-- 获取游标记录
FETCH 游标名称 INTO 变量 [, 变量 ];

-- 关闭游标
CLOSE 游标名称;

-- 案例：来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表中
create procedure p11(in uage int)
begin
	declare uname varchar(100);
	declare upro varchar(100);
	declare u_cursor cursor for select name,profession from tb_user where age <= uage;
	drop table if exists tb_user_pro;
	create table if not exists tb_user_pro(
		id int primary key auto_increment,
		name varchar(100),
		profession varchar(100)
	);
	open u_cursor;
	while true do
		fetch u_cursor into uname,upro;
		insert into tb_user_pro values (null, uname, upro);
	end while;
	close u_cursor;
end;
call p11(30);
-- 上述程序可以通过游标将数据存入新表中，但是死循环
```

```sql
-- 条件处理程序
-- 条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ;
-- handler_action 的取值：
	CONTINUE: 继续执行当前程序
	EXIT: 终止执行当前程序
-- condition_value 的取值：
	SQLSTATE sqlstate_value: 状态码，如 02000
	SQLWARNING: 所有以01开头的SQLSTATE代码的简写
	NOT FOUND: 所有以02开头的SQLSTATE代码的简写
	SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写
	
-- 想解决上循环中的死循环，只需要声明一个handler如下
-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出
declare exit handler for SQLSTATE '02000' close u_cursor;
```

#### 函数

函数就是有返回值的存储过程，函数的参数只能是传入参数

```sql
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
	-- SQL语句
	RETURN ...;
END ;

-- characteristic说明：
DETERMINISTIC -- 相同的输入参数总是产生相同的结果
NO SQL -- 不包含 SQL 语句。
READS SQL DATA -- 包含读取数据的语句，但不包含写入数据的语句。

```

#### 触发器

触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。

使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。

INSERT 型触发器 NEW 表示将要或者已经新增的数据

UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据

DELETE 型触发器 OLD 表示将要或者已经删除的数据

```sql
-- 创建
CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE
ON tbl_name FOR EACH ROW -- 行级触发器
BEGIN
	trigger_stmt ;
END;

-- 查看
SHOW TRIGGERS ;

-- 删除
DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库
```

### 锁

数据库中的锁分为全局锁、表级锁、行级锁

#### 全局锁

全局锁就是对整个数据库加锁，加锁后整个数据库实例都处于只读状态。

比较常用的场景是做全库备份，对所有的表进行锁定，保证所有表数据的一致性

![image-20230628212907277](photo/image-20230628212907277.png)

```sql
-- 加全局锁
flush tables with read lock ;

-- 数据备份，这个是mysql提供的工具，不是sql指令，在命令行中就可以运行
mysqldump -uroot –p1234 itcast > itcast.sql

-- 释放锁
unlock tables ;
```

问题：

- 如果在主库上备份，那么在备份期间不能执行更新操作，业务基本停摆
- 如果在从库上备份，备份期间不能执行主库同步过来的二进制日志，导致主从延迟

在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

#### 表级锁

分类：表锁、元数据锁、意向锁

- 表锁

  加锁：lock tables 表名... read/write。

  释放锁：unlock tables / 客户端断开连接 。

  - 表共享读锁

    作用：不会影响其他客户读，但会影响其他客户写.

  - 表独占写锁

    阻塞其他客户端的读和写

- 元数据锁

  加锁过程为系统自动控制，无需显式使用，访问一张表的时候就会加上。

  作用是维护表的元数据的数据一致性，当表有事务活动时，无法对表的元数据进行写入

  ![image-20230628214754191](photo/image-20230628214754191.png)

### InnoDB存储引擎

#### 逻辑存储结构

![image-20230701213123697](photo/image-20230701213123697.png)

1. 表空间

   表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。

   1. 独立表空间

      每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。

   2. 共享表空间

      Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。

2. 段

   段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。

3. 区

   区，表空间的单元结构，任何情况下每个区的大小都为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。

4. 页

   页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。

5. 行

   行，InnoDB 存储引擎数据是按行进行存放的。

   在行中有两个隐藏字段：

   Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。

   Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

#### 架构

MySQL5.5 版本开始，默认使用InnoDB存储引擎，擅长事务处理，具有崩溃恢复特性。

<img src="photo/image-20230701215010800.png" alt="image-20230701215010800" style="zoom: 50%;" />

##### 内存架构

1. Buffer Pool

   InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。

   在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。

   缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：

   - free page：空闲page，未被使用。
   - clean page：被使用page，数据没有被修改过。
   - dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。

   在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：`show variables like 'innodb_buffer_pool_size';`

2. Change Buffer

   更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

   与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。

3. Adaptive Hash Index

   自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的InnoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。

   InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。

   **自适应哈希索引，无需人工干预，是系统根据情况自动完成。**

   参数： `adaptive_hash_index`

4. Log Buffer

   Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。

   缓冲区大小：`innodb_log_buffer_size`

   日志刷新到磁盘时机：`innodb_flush_log_at_trx_commit`，取值如下

   1：日志在每次事务提交时写入并刷新到磁盘，默认值。

   0：每秒将日志写入并刷新到磁盘一次。

   2：日志在每次事务提交后写入，并每秒刷新到磁盘一次。

##### 磁盘结构

1. System Tablespace

   系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undo log等)

   参数：`innodb_data_file_path`

2. File-Per-Table Tablespaces

   如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。

   开关参数：`innodb_file_per_table`，该参数默认开启。

   就是说，每创建一个表，都会产生一个表空间文件。

3. General Tablespaces

   通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。

   ```sql
   -- 创建表空间
   CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name;
   
   -- 创建表时指定表空间
   CREATE TABLE xxx ... TABLESPACE ts_name;
   ```

4. Undo Tablespaces

   撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。

5. Temporary Tablespaces

   InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。

6. Doublewrite Buffer Files

   双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。

7. Redo Log

   重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。

##### 后台线程

在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。

1. Master Thread

   核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。

2. IO Thread

   在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。

   ![image-20230701235100325](photo/image-20230701235100325.png)

3. Purge Thread

   主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。

4. Page Cleaner Thread

   协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。

#### 事务原理

##### 再谈事务基础

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

所以想要探究事务的原理本质上就是研究InnoDB是如何保证事务的四个特性的。

原子性、一致性、持久化，是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁，加上MVCC来保证的。

##### redo log

重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用

在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。

有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在的两个redo log文件是循环写的。

**为什么不是每一次提交事务都直接将缓存写入磁盘？**

因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。

##### undo log

回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。

Undo log存储：undo log采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment。

#### MVCC

##### 基本概念

1. 当前读

   读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。

2. 快照读

   简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

   - Read Committed：每次select，都生成一个快照读。
   - Repeatable Read：开启事务后第一个select语句才是快照读的地方。
   - Serializable：快照读会退化为当前读。

3. MVCC

   全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、read View。

##### 隐藏字段

<img src="photo/image-20230702213630180.png" alt="image-20230702213630180" style="zoom:50%;" />

##### undolog

回滚日志，在insert、update、delete的时候产生的便于**数据回滚**的日志。当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。

**版本链**

不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

##### readview

ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。

<img src="photo/image-20230702214126374.png" alt="image-20230702214126374" style="zoom:50%;" />

<img src="photo/image-20230702214141823.png" alt="image-20230702214141823" style="zoom:50%;" />

READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。

REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。

##### 原理

- RC隔离级别

  RC隔离级别下，在事务中每一次执行快照读时生成ReadView。

  在每次获取数据的时候都需要根据最新生成的ReadView到undolog版本链中匹配数据

- RR隔离级别

  RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。

  在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView

所以，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。

### 日志

#### 错误日志

记录MySQL发生严重错误时的相关信息。

该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。

```sql
-- 查看相关参数
show variables like '%log_error%';
```

#### 二进制日志

二进制日志（BIN LOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。

作用：1. 灾难时的数据恢复 2. MySQL的主从复制。

```sql
-- 查看相关参数
show variables like '%log_bin%';
```

- log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要再该basename的基础上加上编号(编号从000001开始)。
- log_bin_index ：bin log的索引文件，里面记录了当前服务器关联的bin log文件有哪些。

<img src="photo/image-20230706132520152.png" alt="image-20230706132520152" style="zoom:50%;" />

```sql
-- 查看格式
show variables like '%binlog_format%';
```

由于日志是以二进制格式存储的，不能直接文本查看，使用mysqlbinlog工具来查看。

二进制日志的清理：

<img src="photo/image-20230706132804248.png" alt="image-20230706132804248" style="zoom:50%;" />

#### 查询日志

查询日志中记录了客户端的所有操作语句，包括查询语句，默认关闭。

```sql
-- 如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：
#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启
general_log=1
#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log
general_log_file=mysql_query.log
```

#### 慢查询日志

慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为10 秒，最小为 0， 精度可以到微秒。

```sql
-- 如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：
#慢查询日志
slow_query_log=1
#执行时间参数
long_query_time=2

-- 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。
#记录执行较慢的管理语句
log_slow_admin_statements =1
#记录执行较慢的未使用索引的语句
log_queries_not_using_indexes = 1
```

### 主从复制

主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。优点如下：

- 主库出现问题，可以快速切换到从库提供服务。
- 实现读写分离，降低主库的访问压力。
- 可以在从库中执行备份，以避免备份期间影响主库服务。

#### 原理

MySQL主从复制的核心就是 二进制日志，具体的过程如下：

<img src="photo/image-20230706133447792.png" alt="image-20230706133447792" style="zoom:50%;" />

1. Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。
2. 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。
3. slave重做中继日志中的事件，将改变反映它自己的数据。

### 分库分表

单机数据库的性能瓶颈

1. IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。

2. CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。

分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

#### 拆分策略

- 分库：将一个数据库中的不同表拆分到多个数据库中

  <img src="photo/image-20230706135538522.png" alt="image-20230706135538522" style="zoom: 33%;" />

- 分表：将一个表中的不同字段拆分到多个表中

  <img src="photo/image-20230706135555511.png" alt="image-20230706135555511" style="zoom:33%;" />

- 垂直分：每个拆分出的库/表的结构是不一样的，也就是拆分列
- 水平分：每个拆分出的库/表的结构是一样的，也就是拆分行

MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表

#### 水平分片规则

- 范围分片：根据指定的字段及其配置的范围与数据节点的对应情况
- 取模分片：根据指定的字段值与节点数量进行求模运算
- 一致性哈希：相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置，有效的解决了分布式数据的拓容问题。
- 枚举分片：通过在配置文件中配置可能的枚举值, 指定数据分布到不同数据节点上, 本规则适用于按照省份、性别、状态拆分数据等业务 。
- 应用指定：运行阶段由应用自主决定路由到那个分片 , 直接根据字符子串（必须是数字）计算分片号。
- 固定hash：该算法类似于十进制的求模运算，但是为二进制的操作，例如，取 id 的二进制低 10 位 与1111111111 进行位 & 运算，位与运算最小值为 0000000000，最大值为1111111111，转换为十进制，也就是位于0-1023之间。
  - 如果是求模，连续的值，分别分配到各个不同的分片；但是此算法会将连续的值可能分配到相同的分片，降低事务处理的难度。
  - 可以均匀分配，也可以非均匀分配。
  - 分片字段必须为数字类型。
- 字符串哈希：截取字符串中的指定位置的子字符串, 进行hash
- 按天分片：按照日期及对应的时间周期来分片。
- 自然月分片：使用场景为按照月份来分片, 每个自然月为一个分片。

### 读写分离

读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。

<img src="photo/image-20230706135950219.png" alt="image-20230706135950219" style="zoom: 33%;" />

#### 一主一从

MySQL的主从复制，是基于二进制日志（bin log）实现的。

<img src="photo/image-20230706140032140.png" alt="image-20230706140032140" style="zoom:33%;" />

#### 双主双从

一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、Master2 互为备机。架构图如下:

<img src="photo/image-20230706140439910.png" alt="image-20230706140439910" style="zoom:33%;" />

































































































### 执行一条select语句期间发生了什么

1. 连接数据库（连接器）

   使用MySQL数据库需要先连接MySQL服务，如果用户名和密码都没问题，连接器就会获取该用户的权限，然后保存下来，后续的操作都会基于此时读取到的权限

   所以如果一个用户已经建立了连接，管理员中途修改了该用户的权限，也不会影响已经存在的连接

   `show processlist`查看当前MySQL服务被多少个客户端连接了

   `wait_timeout`控制空闲连接保持写事件

   `max_connections`控制MySQL服务的最大连接数

2. 查询缓存

   如果客户端执行的是查询语句，那么MySQL就会先查询缓存（缓存的是之前执行过的语句，此过程很鸡肋因为如果表有过更新操作那么表的所有缓存都被清空了）

   此过程在MySQL8中被删除了

   MySQL8之前的版本可以通过将参数 query_cache_type 设置成 DEMAND。

3. 解析SQL（解析器）

   词法分析、语法分析

4. 执行SQL（预处理、优化、执行）

   - 预处理

     检查SQL中的表或字段是否存在

     将*扩展为表中的所有列

   - 优化

     优化器负责将SQL查询的执行方案确定下来（例如使用哪个索引）

   - 执行

     主键索引查询

     全表扫描（如果查询条件没有用到索引）

     索引下推

### MySQL一行记录是怎样被存储的

#### MySQL数据存放的文件（InnoDB）

创建一个数据库就会在var/lib/mysql文件夹下创建一个以数据库名为目录名的目录

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，t_order 的**表结构**会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- t_order.ibd，t_order 的**表数据**会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

表空间由**段（segment）、区（extent）、页（page）、行（row）组成**，大小递减

- 行

  数据库表中的记录，每行记录根据不同的行格式，有不同的存储结构。

- 页

  **InnoDB 的数据是按「页」为单位来读写的**，**默认每个页的大小为 16KB**

- 区

  **在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了，否则查询链表效率太低**

- 段

  表空间是由各个段构成的如下

  索引段：存放 B + 树的非叶子节点的区的集合

  数据段：存放 B + 树的叶子节点的区的集合

  回滚段：存放的是回滚数据的区的集合

#### COMPACT行格式

Redundant现在基本没人用了，Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。

![img](photo/COMPACT.drawio.png)

- 额外信息

  1. 变长字段长度列表

     用来存储变长字段的大小的列表，其中的信息是逆序存放的，也就是将列的顺序翻转后的顺序，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。同样的道理， NULL 值列表的信息也需要逆序存放。

     这个列表不是必须的，表中没有变长字段的时候，行格式中就不会有变长字段长度列表了。

  2. NULL值列表

     1对应该列值为NULL，0对应该列值部位NULL

     NULL值列表必须以一字节为最小存储单元，空位补0

     NULL值列表也不是必须的

  3. 记录头信息

     - delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
     - next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
     - record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

- 真实数据

  - row_id

    如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。

  - trx_id

    事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。

  - roll_pointer

    这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

#### varchar(n)中的n最大取值为多少

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。

n表示的是字符数量，想知道n最大是多少还需要考虑字符集每个字符占用多少字节的情况，ascii字符集每个字符占用1个字节，在 UTF-8 字符集下，一个字符最多需要三个字节

如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」

#### 行溢出后，MySQL 是怎么处理的？

**发生行溢出，多的数据就会存到另外的「溢出页」中**。**COMPACT行格式**中，当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

### 事务

一个最小的工作单元，要么都完成要么都不完成

#### 事务原则（ACID）

- 原子性→事务是一个不可分割的整体，事务中的操作要么都发生，要么都不发生
- 一致性→事务前后的数据满足数据完整性
- 持久性→事务结束后的数据就是永久的，即使系统故障也不会丢失
- 隔离性→排除其他事务对本次事务的影响

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

#### 事务并发带来的问题

- 脏读→一个事务读取了另一个事务还没有提交的数据

- 不可重复读→在一个事务内多次读取同一数据结果不同

- 幻读（虚读）→一个事务内读到了别的事务插入的数据（以前没有的行，由于其他事务插入而出现）

#### 隔离级别

隔离级别越高，性能效率越差，以下为SQL标准，具体数据库实现可能不同

- 读未提交→一个事务可以读到其他事务未提交的数据，全部问题
- 读已提交→一个事务可以读到其他事务提交的数据，解决脏读
- 可重复读→事务可以读取到其他事务已提交的新插入的数据，但不能读到其他事务对数据的修改，多次读取同一记录的结果是相同的，解决不可重复读，MySQL默认隔离级别，解决脏读、不可重复读
- 串行化→事务串行执行，解决所有问题，完全遵守ACID原则，但对性能影响比较大

实现方法如下：

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个**Read View**。

开启事务的方法

- 第一种：begin/start transaction 命令。执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机。
- 第二种：start transaction with consistent snapshot 命令。执行了 start transaction with consistent snapshot 命令，就会马上启动事务。

### 索引

定义：一种帮助MySQL提高查询效率的数据结构，像目录一样

MySQL查询方式 1.全表查询 2.按照索引查询

优点：大大提高查询速度

缺点：1.维护索引需要耗费数据库资源 2.索引需要占用磁盘空间 3.对表的数据更新时，需要维护索引，消耗时间

#### 索引分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

- 主键索引：
  - 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
  - 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
  - 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；


其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

- 单值索引（普通索引）：一个索引只包含一个列，一个表可以有多个单值索引
- 唯一索引：索引的值必须唯一，但可以有空值（unique）
- 复合索引：一个索引包含多个列
  - 1.最左前缀原则 2.动态ti凹征

- full text（全文索引）：innodb不支持 myisam支持

#### 索引的数据结构

B+树→输入无序数据→排序为一个链表→链表太长效率低，通过索引的方式来提高效率→一页默认寸尺16KB数据

默认16KB的B+树约能存储10亿条数据

B+树的高度通常为2-4层，innoDB将根节点常驻内存中，所以实际只需要进行1-3次磁盘操作

![image-20220909154724955](C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909154724955.png)

![image-20220909154734959](C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909154734959.png)

#### 索引原则

1. 索引不是越多越好，小数据量的表不需要加索引

2. 不要对经常变动的数据添加索引

3. 经常用于where查询的字段

4. 有唯一性限制的字段

5. 经常用于order by的字段

#### 优化索引的方法

- 前缀索引优化

  用某个字段中字符串的前几个字符来建立索引

  主要目的是为了减小索引字段大小

  局限：order by无法使用前缀索引、无法把前缀索引用作覆盖索引

- 覆盖索引优化

  覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。

  假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？

  我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

  所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。

- 主键索引最好是自增的

  插入新纪录的时候不需要移动数据

  否则经常插入数据可能会出现大量内存碎片，导致索引结构不紧凑；还会导致页分裂（页满插入数据需要分裂），如果是自增的只需要开辟新数据页即可

- 索引最好设置为NOT NULL

  索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。

  NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么[行格式 (opens new window)](https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些)中**至少会用 1 字节空间存储 NULL 值列表**

- 防止索引失效

  设定了索引不代表查询的时候就会使用索引

  - 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效，因为B+树按照索引值进行排列，只能根据前缀进行比较。
  - 当我们在查询条件中对索引列做了表达式计算、函数、隐式类型转换（mysql在遇到字符串和数字比较的时候，会把字符串转为数字）操作，这些情况下都会造成索引失效；
  - 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
  - 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。（这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。）

#### 聚簇索引和非聚簇索引

聚簇索引→将数据存储和索引放到了一起，叶子节点存放数据

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909154819915.png" alt="image-20220909154819915" style="zoom:50%;" />

非聚簇索引→将数据和索引分开，叶子节点指向数据对应位置、还有索引列的数据

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220909154838141.png" alt="image-20220909154838141" style="zoom:50%;" />

在innodb中，在聚簇索引之上创建的索引成为辅助索引，非聚簇索引都是辅助索引，辅助索引存储的是主键值，通过该主键值到聚簇索引也就是主键索引中查找对应的数据

使用聚簇索引的优势

1. 访问一个数据页时，会将此页加载到内存中，再次访问此页中的数据不需要访问磁盘

2. 辅助索引的叶子节点不存储数据只存储主键值，好处是当数据变动时辅助索引不需要更新，避免对辅助索引的维护，只维护聚簇索引就好了，例如myisam中，数据变动两个非聚簇索引都需要更新

聚簇索引最好使用自增的int值，自增避免了插入数据对前面数据产生影响而需要更新，使用自增的主键值不容易产生磁盘碎片

### 锁

#### 种类

- 全局锁

  `flush tables with read lock`使用全局锁
  
  `  unlock tables  `释放全局锁
  
  对整个数据库实例加锁，MySQL让整个数据库处于只读的状态，其他线程的更新、定义等操作就会被阻塞
  
  应用场景：主要用于全库逻辑备份，但是会影响业务
  
  解决办法：可以在数据库开始备份之前开启事务（可重复读的隔离级别）
  
  备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。
  
- 表级锁
  - 表锁
  
  ```sql
    //表级别的共享锁，也就是读锁；
    lock tables t_student read;
    
    //表级别的独占锁，也就是写锁；
    lock tables t_stuent write;
    
    //解锁
    unlock tables
  ```
  
    不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能
  
  - 元数据锁（MDL）
  
    5.5版本引入，访问（CURD）一个表时默认被加上，保证读写的正确性
  
    对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
  
    对一张表做结构变更操作的时候，加的是 **MDL 写锁**；
  
    MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。当一个写线程请求访问被阻塞，后续的语句都会被阻塞，只要前面的读线程不结束事务，数据库很快就会崩溃。
  
    **为什么写线程被阻塞后续的查询也会阻塞**？因为申请MDL锁的操作会形成一个队列，且写锁比读锁优先级高
    
  - 意向锁
  
    - 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
    - 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
  
    也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
  
    而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。
  
    不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：
  
    ```sql
    //先在表上加上意向共享锁，然后对读取的记录加共享锁
    select ... lock in share mode;
    
    //先表上加上意向独占锁，然后对读取的记录加独占锁
    select ... for update;
    ```
  
  - AUTO-INC 锁
  
    表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。
  
    AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是在执行完插入语句后就会立即释放**。**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。
  
    所以在一个事务持有AUTO-INC锁的时候其他插入语句就会被阻塞，从而保证`AUTO_INCREMENT`自增，但是AUTO-INC锁在对大量数据进行插入的时候比较影响性能。
  
    在MySQL5.1.22以后，InnoDB提供了一种轻量级的锁来实现自增。一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。
  
- 行锁

  如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为**锁定读**。

  ```sql
  //对读取的记录加共享锁
  select ... lock in share mode;
  
  //对读取的记录加独占锁
  select ... for update;
  ```

  上面这两条语句必须在一个事务中，**因为当事务提交了，锁就会被释放**，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。

  - Record Lock

    ecord Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：

    - 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
    - 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

  - Gap Lock

    Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

    设置锁为一个区间，其他语句无法向区间中插入记录

    间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。

  - Next-Key Lock

    Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

# 设计模式

## 简介

- 底层思维：向下，如何把握机器底层从微观理解对象构造

  - 语言构造

  - 编译转换

  - 内存模型

  - 运行时机制

  深入理解三大面向对象机制

  - 封装，隐藏内部实现
  - 继承，复用现有代码
  - 多态，改写对象行为

- 抽象思维：向上，如何将我们的周围世界抽象为程序代码

  - 面向对象

  - 组件封装

  - 设计模式

  - 架构模式

  把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界

如何解决复杂性

- 分解

  分而治之，将复杂问题分解为多个简单问题

- 抽象

  由于不能掌握全部的复杂对象，我们选择忽略它的非本质细节，而去处理泛化和理想化了的对象模型

软件设计的首要原则：**复用**

## 面向对象设计原则

**变化**是复用的天敌，面向对象设计的优势在于**抵御变化**

对象是什么

- 从语言实现层面看，对象封装了代码和数据
- 从规格层面看，对象是一系列可被使用的公共接口
- 从概念层面讲，对象是某种拥有责任的抽象

依赖倒置原则（DIP）

- 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）

开放封闭原则（OCP）

- 对扩展开放，对更改封闭
- 类模块应该是可扩展的，但是不可修改

单一责任原则（SRP）

- 一个类应该仅有一个引起它变化的原因
- 变化的方向隐含着类的责任

Liskov替换原则（LSP）

- 子类必须能够替换它们的基类（IS-A）
- 继承表达类型抽象

接口隔离原则（ISP）

- 不应该强迫客户程序依赖它们不用的方法
- 接口应该小而完备

优先使用对象组合，而不是类继承

- 类继承通常是“白箱复用”，对象组合通常为“黑箱复用”
- 继承在某种程度上破坏了封装性，子类父类耦合度高
- 而对象组合则只要求被组合的对象具有良好定义的接口，

封装的真正含义是**封装变化点**

## 23种设计模式

### 单例模式

有一种特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性以及良好的效率，需要绕过常规构造器，提供一种机制来保证一个类只有一个实例

1. 私有化它的构造函数，以防止外界创建单例类的对象；
2. 使用类的私有静态指针变量指向类的唯一实例；
3. 使用一个公有的静态方法获取该实例。

#### 懒汉模式

单例实例在第一次被使用时才进行初始化，这叫做延迟初始化。

```cpp
class Singleton{
private:
    Singleton();
    Singleton(const Singleton& other) = ;
public:
    static Singleton* getInstance();
    static Singleton* m_instance;
}

Singleton* Singleton::m_instance = nullptr;

// 这种实现多线程可能引发竞态条件：第一个线程if判断m_instance为空，于是开始实例化单例；第二个线程也尝试获取单例，这时m_instance还是空的，于是也开始实例化单例，这样就会实例化出两个对象。解决办法：加锁
// 这种实现只负责new出对象，却没有delete对象，析构函数没有被调用。解决办法：使用智能指针
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

// 双检测锁，解决了线程安全问题以及单检测效率低的问题，但存在内存读写reorder的问题
// 对象的创建分为三个阶段：分配内存、初始化、返回指针
// 但是由于编译器以及指令集的优化，这三个阶段并不一定是顺序执行的，可能会出现分配内存、返回指针、初始化的顺序
// 线程1通过双检查锁，分配了内存、返回了指针，但是没有初始化
// 线程2在第一个判断时，指针不为nullptr，直接返回了m_instance，但是这时的m_instance是不可用的
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {
        Lock lock;
        if (m_instance == nullptr) {
            m_instance = new Singleton();
        }
    }
    return m_instance;
}

//C++ 11版本之后的跨平台实现 (volatile)
std::atomic<Singleton*> Singleton::m instance;
std::mutex Singleton::m mutex;
Singleton* Singleton::getInstance() {
	Singleton* tmp = m instance.load(std::memory_order_relaxed);
	std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence
	if (tmp == nullptr) {
		std::lock guard<std::mutex> lock(m mutex);
		tmp = m_instance.load(std::memory_order_relaxed);
		if (tmp == nullptr) {
			tmp = new Singleton;
			std::atomic_thread_fence(std::memory_order_release);//释放内存fence
			minstance.store(tmp， std::memory_order_relaxed);
        }
    }
	return tmp;
}

// 局部静态变量
// 这个实现用到了C++11标准种的Magic Static特性：如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。
// 这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。
static Singleton& get_instance(){
    static Singleton instance;
    return instance;
}
```

### 观察者模式

我们需要为某些对象简历一种“通知依赖关系”，一个对象（目标对象）的状态发生变化，所以依赖对象（观察者对象）都将得到通知。

观察者模式定义一种交互，即发布-订阅：

- 一个对象当自身状态发生改变时，会发出通知，但是并不知道谁是他的接收者，但每个接收者都会接收到通知，这些接受者称为观察者。
- 作为对通知的响应，每个观察者都将查询目标状态，然后改变自身的状态以和目标状态进行同步。

<img src="photo/image-20230721173222205.png" alt="image-20230721173222205" style="zoom: 33%;" />

Subject：目标，知道它的观察者，提供注册和删除观察者对象的接口

Observer：观察者，为那些在目标发生改变时需获得通知的对象定义一个更新接口

ConcreteSubject：具体目标，存储对象状态，状态改变时，向各个观察者发出通知

ConcreteObserver：具体观察者，维护一个指向ConcreteSubject对象的引用，存储有关状态，实现更新接口update，使自身状态与目标的状态保持一致

```cpp
/*
 * 观察者模式
 * 情景：高数课，ABCD四位同学，A是好学生，去上课，B在寝室睡觉，C在网吧打游戏，D在学校外陪女友逛街
 * 他们约定，如果要点名了，A在QQ群里吼一声，他们立刻赶到教室去。
 * 采用观察者模式实现这个情景的应用。
 */

#include <iostream>
#include <string>
#include <list>

class Observer;

class Subject{
public:
    virtual ~Subject() {};
    virtual void registerObsvr(Observer* obsvr) = 0;
    virtual void removeObsvr(Observer* obsvr) = 0;
    virtual void notifyObsvrs(const std::string &msg) = 0;
};
class Observer {
public:
    virtual ~Observer() {};
    virtual void Update(const std::string &msg)= 0;
    virtual std::string getName() = 0;
protected:
    Observer(){};
};

// -------------------------------------------------
class QQGroup : public Subject {
public:
    QQGroup() { _observers = new std::list<Observer*>(); }
    void registerObsvr(Observer* obsvr);
    void removeObsvr(Observer* obsvr);
    void notifyObsvrs(const std::string &msg);
private:
    std::list<Observer*> *_observers;
};

void QQGroup::registerObsvr(Observer* obsvr) {
    _observers->push_back(obsvr);
}

void QQGroup::removeObsvr(Observer* obsvr) {
    if (_observers->size() > 0)
        _observers->remove(obsvr);
}
void QQGroup::notifyObsvrs( const std::string &msg) {
    std::cout << "群消息：" << msg << std::endl;
    std::list<Observer*>::iterator iter
        = _observers->begin();
    for ( ;iter != _observers->end(); iter++ ) {
        (*iter)->Update(msg);
    }
}

// ------------------------------------------------
class RoomMate : public Observer {
public:
    RoomMate(std::string name, std::string now ,std::string action)
    {
        _name = name;
        _action = action;
        _now = now;
    };
    void Update( const std::string &msg);
    std::string getName();
private:
    std::string _name;
    std::string _action;
    std::string _now;
};

std::string RoomMate::getName() {
    return _name;
}

void RoomMate::Update(const std::string &msg) {
    std::cout<< "This is " << _name << std::endl;
    if ( msg == "点名了" )
        std::cout << "Action: " << _action
        << std::endl << std::endl;
    else
        std::cout << "Go on：" << _now
        << std::endl << std::endl ;
}

//测试代码
int main()
{
    RoomMate* B = new RoomMate("B",
        "sleeping",
        "get dressed and run to classroom");
    RoomMate* C = new RoomMate("C",
        "playing games",
        "pay the fee and run to classroom");
    RoomMate* D = new RoomMate("D",
        "shopping with girl friend",
        "go back to school and be worried about girl friend's angry");

    QQGroup* qqgroup = new QQGroup();
    qqgroup->registerObsvr(B);
    qqgroup->registerObsvr(C);
    qqgroup->registerObsvr(D);

    qqgroup->notifyObsvrs("目前没点名");
    qqgroup->notifyObsvrs("点名了");

    system("Pause");
    return 0;
}
```

### 工厂模式

对象创建模式

动机：在软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型也经常变化。

通过对象创建模式绕开new，来避免对象创建（new）过程中所导致的紧耦合，从而支持对象创建的稳定，在C++中通过虚函数来实现解耦（运行时决定）

缺点：要求创建方法/参数相同

### 抽象工厂

