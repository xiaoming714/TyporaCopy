# 基础

## 用户标识符

1. 标识符只能以数字，字母，下划线组成
2. 标识符开头必须是英文字母或下划线
3. 不能用c关键词为标识符命名

## 多项算数表达式类型

当涉及两种类型时，较小的类型就会被转换为较大的类型，表达式低的类型就会被转换为表达式高的类型

各类表达能力从低到高排列：int→unsigned→long→unsigned long→float→double→long double

运算过程中转化为高类型，即double类型。

在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度

## C++数据类型大小

bool→1，char→1，short→1，int→4，float→4，long→4，long long→8，double→8

指针本质是地址空间，所以占用空间不随数据类型变化，均为8

引用占用空间大小与其引用对象所占空间大小一致

## 浮点数表示形式

C语言中的浮点数有两种形式，一种为十进制小数形式，一种为指数形式，其一般形式为a E n，a为十进制数，n为十进制整数，都不可省略。

## 进制表示

除了天然支持的十进制以外，还支持三种进制分别是：二进制→0b，八进制→0，十六进制→0x

## 全局变量

如果函数定义在全局变量之前则无法访问全局变量

## *.和→

.的优先级比*高所以p→等价于（*p）.

## 大小端

对于一个由2个字节组成的16位整数，在内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端字节序；另一种方法是将高序字节存储在起始地址，这称为大端字节序。

## 指针数组和数组指针

1. int(*p)[4];------[ptr](https://www.baidu.com/s?wd=ptr&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9uHbLuHnYP1b3PvfkuWNh0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6K1TL0qnfK1TL0z5HD0IgF_5y9YIZ0lQzqlpA-bmyt8mh7GuZR8mvqVQL7dugPYpyq8Q1nkPj0krjT4n0)为指向含4个元素的一维整形数组的指针变量（是指针） 
2. int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）
3. 小括号的优先级高，先看是不是指针

## calloc、malloc和new

void* calloc（unsigned int num，unsigned int size）；

在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)的动态存储区中分配num个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。

void *malloc(unsigned int size)；

其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址。

前两个是函数，new是运算符，new返回所分配内存单元的起始地址，分配不成功返回NULL并且抛出异常。

## printf

C++中printf从右向左编译，从左向右输出

在printf中的%作为转义符，两个%才相当于1个%

## 数组初始化

gcc可以用变量来初始化数组大小，msvc则不行

## 代码体积膨胀

宏定义、模板、内联函数（也可能缩小）

## 头文件

\#include <> 编译器直接从系统类库目录里查找头文件，如果类库目录下查找失败，编译器会终止查找。
 \#include "" 编译器默认从当前文件所在目录下查找头文件，如果查找失败，再从项目工程中设置的头文件引用目录查找，在 Linux GCC 编译环境下，则一般通过使用 -L 参数指定引用目录，如果项目配置的头文件引用目录中仍然查找失败，再从系统类库目录里查找头文件。

\#include <> 一般用于包含系统头文件，诸如 stdlib.h、stdio.h、iostream 等；#include "" 一般用于包含自定义头文件，比如我们自定义的 test.h、declare.h 等。

## 数组初始化问题

1、未初始化的全局数组为0；

2、未初始化的局部数组为随机值；

3、初始化部分的全局数组与局部数组，初始化部分为初始化值，未初始化部分都为0；（不管全集还是局部）

## 运算符优先级

赋值运算符<逻辑运算符<关系运算符<算术运算符

```C++
1.   ()   []   .   ->
2.   !   ~   ++   --   +   -   *   &   (type)` `sizeof``--非常爱考
3.   *   /   %
4.   +   -
5.   >>   <<
6.   >   >=   <   <=
7.   ==   !=
8.   &
9.   ^
10.   |
11.   &&
12.   ||
13.   ? :
14.   =   *=   /=   %=   +=   -=   >>=   <<=   &=   ^=   |=
15.   ，
```

## 关于c的主函数

主函数名可以不为main，只是需要在编译是加上注明程序入口的函数名。如指定入口函数为func，则参数为-e _func，注意要在函数名前加下划线

## 关于浮点数的位运算

所有浮点数都不能直接进行位运算，不过可以转为int再运算

## 常对象

一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。

## 逗号表达式

表达式1, 表达式2

先求解表达式 1，再求解表达式 2。整个逗号表达式的值是表达式 2 的值。最右边的那个表达式的值将作为整个逗号表达式的值，其他表达式的值会被丢弃。

sum=num++,++sum,++num；这个表达式等于(（sum=num++）,++sum,++num);

# 类

## 构造函数

构造函数和拷贝构造函数都没有返回值。拷贝构造函数的参数可以使一个或多个，但左起第一个必须是自身类型的引用对象。C++缺省构造函数都是公有

当基类构造函数需要外部传递参数才能进行初始化时，派生类必须显式定义构造函数，为基类传递参数；基类如果不需要传递或者可以不传递参数，派生类可以不用显式定义构造函数。

创建类类型的数组会调用数组大小次构造函数

## 多态

父类指针指向子类对象，如果调用的是实函数则根据指针类型，如果调用的是虚函数则根据对象类型

## 初始化列表

常量成员和引用成员必须在初始化列表中初始化

## 类的大小

大小 = 虚函数指针 +  所有非静态数据成员大小  +  因对齐而多占的字节

## 友元函数

友元关系是单向的，不是对称，不能传递。关于传递性，有人比喻：父亲的朋友不一定是儿子的朋友。那关于对称性，是不是：他把她当朋友，她却不把他当朋友？✧(≖ ◡ ≖✿)

## 拷贝构造和重载

如果初始化对象时直接使用=用已有对象复制则调用拷贝构造函数，因为对象还不存在，否则调用重载=

## 抽象类

1. 抽象类只能用作其他类的基类，不能建立抽象类对象。
2. 抽象类不能用作参数类型、函数返回类型或显式转换的类型。
3. 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。
4. 纯虚函数必须在声明的时候=0

## 关于空指针调用成员函数

对于非虚成员函数，C++这门语言时静态绑定的。Java和Python是在运行时才绑定函数名和对应代码，这种机制也被成为迟绑定、晚绑定。而C++为了保证运行时的效率，设计者认为凡是编译期间能够确定的事情就不要拖到运行时。所以会出现空指针调用非虚成员函数成功的情况（前提是函数中没有解引用操作）

而虚函数则需要在运行时到虚函数表中查找对应需要调用的函数，所以上述调用会失败。

# STL

## vector

### erase

vector 作为序列容器删除一个元素会导致后续所有元素的迭代器失效，而 erase 删除元素后会返回下一个有效迭代器