

# 第一章：引论

## 1.1 什么是操作系统

操作系统运行在内核态（又称管态、核心态）

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831163109500.png" alt="image-20220831163109500" style="zoom: 25%;" />

有些操作系统中的内核态和用户态的区分是模糊的必须：嵌入式系统（无内核态），解释系统（基于Java的操作系统，它采用解释方式，而非硬件方式区分组件）

> Linux内核库总共偶782487次提交记录，作者数位19009位，存储库由61725个文件组成，包含代码约25584633行

操作系统的任务：为应用程序员提供一个资源集的清晰抽象，并管理这些资源。创建好的抽象并实现和管理它所创建的抽象。隐藏硬件，为程序以及程序员提供良好、优雅、一致的抽象。记录哪个程序在使用什么资源，对资源请求进行分配、评估使用代价，并且为不同的程序和用户调节相互冲突的资源请求。

操作系统的实际客户是应用程序，他们与操作系统的抽象打交道，而用户则是和用户接口所提供的抽象打交道

## 1.2 操作系统的历史

为了使编写的程序能够在任何版本的UNIX上运行，IEEE提出了一个UNIX标准，称作POSIX，目前大多数UNIX版本都支持它。POSIX定义了一个凡是UNIX必须支持的小型系统调用接口。事实上，某些其他操作系统也支持POSIX接口

## 1.3 计算机硬件简史

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831163934176.png" alt="image-20220831163934176" style="zoom:25%;" />

### 在x86架构下CPU部分对程序员可见的专用寄存器

1. 程序计数器：它保存了将要去除的下一条指令的内存地址，在取出指令后，程序计数器被更新指向其后继的指令
2. 堆栈指针：它指向当前堆栈的顶端。该栈包含了每一个执行过程的栈帧，一个过程的栈帧保存了有关的输入参数，局部变量，以及那些没有保存在寄存器中的临时变量
3. 程序状态字寄存器PSW：这个寄存器保存了条件码位（由比较指令设置）、CPU优先级、模式（用户态或管态）以及其他控制位

### x86CPU用到的架构

1. 流水线：例如一个CPU可以有单独的取值单元，解码单元和执行单元，当他执行指令n时，还可以对n+1指令解码，对n+2指令读取
2. 超标量：多个CPU读取、解码指令到缓冲区，利用空闲单元对多个指令进行执行
3. 多线程：多线程允许CPU保持多个不同的线程状态，在不同状态之间以纳秒的速度来回切换
4. 多核芯片：含有多个独立完整的处理器，例如GPU含有成千上万个微型核，善于处理大量并行的简单计算，但GPU不能胜任串行任务，并且编程困难，所以操作系统本身不可能运行在GPU上

### IO实现方法

1. 用户发出系统调用，内核将其翻译为对应驱动设备程序的过程调用，设备驱动程序启动IO检查该设备是否完成了工作，IO结束，设备驱动程序将数据送到指定的地方。此方法阻塞CPU
2. 设备驱动程序启动设备，并让设备在完成操作时发出一个中断，设备驱动程序此时立即返回，设备驱动程序检测到工作完成时发出中断通知完成工作
3. DMA

# 第二章 进程与线程

## 进程

### 概念

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说每个进程都有专属于自己的CPU。当然实际上真正的CPU在各个进程之间切换，这种快速切换被称为多道程序设计

### 进程的创建

进程创建主要由以下几个事件触发

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新进程
- 一个批处理作业的初始化

### 进程的终止

进程终止主要由以下几个事件触发

- 正常退出（自愿的）
- 错误退出（自愿的）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）

### 进程的层次结构

- 在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组，其父进程不能剥夺子进程的“继承权”。在UNIX中，所有进程都属于init（在UNIX系统初始化时出现在启动映像中的进程）为根的一颗进程树
- 在Windows中所有进程的地位相同。唯一类似于层次的暗示是在创建进程时，父进程得到的一个特别令牌（句柄），该句柄可以用来控制子进程。他有权把这个句柄交给其他进程，这样就不存在进程层次了

### 进程三态

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831165801153.png" alt="image-20220831165801153" style="zoom:25%;" />

### 进程控制块

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）。每个进程占用一个进程表项（有些作者称这些表项为进程控制块）。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证进程随后能再次启动，就像从未被中断过一样。

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831170130504.png" alt="image-20220831170130504" style="zoom:25%;" />

中断向量：包含中断服务程序的入口地址，中断发生时，中断硬件将正在运行的进程的信息保存到堆栈中，随后跳转到中断向量所指的地址

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831170239929.png" alt="image-20220831170239929" style="zoom:25%;" />

## 线程

### 为什么要有线程

1. 许多应用中同时发生着多种活动，其中某些活动会随着时间推移而阻塞
2. 线程比进程更加轻量级，更容易创建和销毁
3. 若应用同时存在大量的计算和大量的IO时，相乘会大大增加运行速度
4. 在多CPU系统中，多线程使真正的并行成为可能，详见第八章

多线程好处举例：字处理软件，一个线程和用户交互，另一个线程后台处理格式文本等变化，还可以存在第三个线程处理磁盘备份

经典线程模型中线程有独立的程序计数器、寄存器、堆栈

进程负责把资源集中到一起，线程则是CPU调度的实体

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831170710638.png" alt="image-20220831170710638" style="zoom:25%;" />

#### 多线程会遇到的问题

1. 如果父进程有多个线程，那么子进程是否应该具有同样的多个线程
2. 如果父子进程具有同样多的线程，如果父进程read阻塞了是两个线程阻塞吗
3. 一个线程关闭文件，另一个线程还在操作会发生什么

### 在用户空间中实现线程

在用户空间中实现线程包，用户级线程包可以在不支持线程的操作系统上运行。

在用户空间管理线程时，每个进程都有一个专用的线程表，用来跟踪进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器等状态。

进程和线程的一个关键差别就是，线程可以通过函数让出CPU给其他线程，而且该调度都是本地过程，所以它比调用内核速度更快。另一方面，不需要陷入内核、不需要切换上下文，也不需要对高速缓存进行刷新，这就使得线程调度非常快捷。

#### 用户级线程的问题

1. 如何实现阻塞系统调用。
2. 一个线程运行，该进程的其他线程就无法运行，除非第一个线程主动放弃CPU。

多线程不适合处理简单、并发性低的计算。

### 在内核中实现线程

在内核支持和管理线程的情形，此时不再需要运行时系统了。另外每个线程中也没有线程表。相反，在内核中有用来记录所有线程的线程表，一系列操作由系统调用完成。

在内核创建和销毁线程的代价比较大，某些系统采用“环保”的处理方式，回收其线程。当某个线程被撤销是它就被标记为不可运行的，但其数据结构并未受到影响，稍后再必须创建一个新县城是，就重新启动某个旧线程。

### 混合实现

一种方法使使用内核级线程，然后将用户级线程与某些内核线程多路复用起来。

### 调度激活机制（激活阻塞）

当内核了解到一个线程被阻塞后，内核通知该进程的运行时系统，并再堆栈中以参数形式传递有问题的线程编号和发生时间的描述。内核通过已知的一个地址启动运行时系统，从而发出了通知，这个机制称为上行调用。

一旦如此激活，运行时系统就重新调用该线程。

### 弹出式线程（需求创建）

新的数据到达或由新的事务需要处理导致的新线程的创建称之为弹出式线程。

### 使单线程代码多线程化（改写代码）

有许多代码使由单线程编写的，我们把这些代码改编成多线程代码需要更高的技巧。

为避免多个线程同时使用一个全局变量，发生重写的错误，每个线程对于这种全局变量都有一个私有副本，这样可以避免冲突。

## 进程间通信

进程间通信的问题：1.将一个进程的信息传递给另一个。2.确保多个进程在关键活动中不会出现交叉。3.确保进程执行顺序的正确性。后两个问题对于线程也同样适用

### 竞争条件

CPU在进程间切换时容易产生错误，多个进程读写某些共享数据，而最后结果取决于进程运行的精确时序，称为竞争条件。

### 临界区

在某些时候进程可能需要访问共享内存或共享文件或执行另外一些会导致竞争的操作。我们把对共享内存访问的程序片段称作临界区

#### 解决竞争条件需要满足的条件

- 任何两个进程不能同时处于临界区
- 不应对CPU的速度和数量做任何假设
- 临界区外运行的进程不得阻塞其他进程
- 不得使进程无限期等待进入临界区

### 忙等待的互斥

#### 屏蔽中断

在进程刚刚进入临界区时就屏蔽所有中断，也包括时钟中断，这样CPU在执行完当前进程前都不会切换到其他进程。

#### 锁变量

设想有一个共享（锁）变量，其初始值为0。一个进程进入临界区时要先测试这把锁，如果锁的值为0，那么该进程进入临界区，并将其设置为1。若这把锁已经为1，则该进程等待其置为0。

但是在进程刚要将锁置为1时引发了时钟中断，就会造成其他的进程将该锁置为1，并 造成这两个进程同时进入临界区。

#### 严格轮换法

设定一个变量true，初始值为0，当进程0想要进入临界区时先检查true，true为0，进程0进入临界区，又有一个进程1想要进入临界区，检查true为0，则需要等待进程0离开临界区时将true置为1，这时进程1才能进入临界区，后序进程0再想进入临界区也需要等待进程1离开临界区将true置为0。这种方法称为自旋锁。

该方法违反了条件3，不是一个好方法。

#### Peterson解法

在使用共享变量之前，各进程使用参数0或1作为参数来调用enter_region函数。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用leave_region，表示操作已经完成，若其他进程希望进入临进区，则现在就可以进入。

若两个进程都将进程号存入true，但只有后被保存的进程才有效，前一个因重写而丢失。

#### TSL指令

在某些计算机中，特别是那些设计为多处理器的计算机，都有下面一条指令：

TSL RX,LOCK 称为测试并加锁

它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值。读字和写字保证是不可分割的，即该指令结束之前其他处理器均不能访问该内存字。

一个可替代TSL的指令是XCHG，他本质上与TSL的解决方法一样。所有Intel x86CPU在底层同步中使用XCHG指令。

### 睡眠与唤醒

生产者与消费者问题

当缓冲区已满，而生产者还想向其中放入一个新的数据项。其解决办法是让生产者睡眠，待消费者从缓冲区取出一个或多个数据时在唤醒它。同样的，当缓冲区为空，而消费者还想从取出数据而发现缓冲区已经空了时，让消费者睡眠，待生产者向缓冲区放入一个或多个数据时再将其唤醒。

但是这同样会存在竞争条件的问题。这里有可能会出现竞争条件，其原因是对count(表示缓冲区数据量)的访问未加限制。有可能出现以下状况：缓冲区为空，消费者刚刚读取count发现它是0.此时调度程序暂停消费者并启动生产者。生产者向缓冲区中加入一个数据项count+1。现在count变成1了。它推断刚才count为0，所以此时消费者一定处于睡眠状态，于是生产者wakeup消费者。

但是，消费者此时在逻辑上并未睡眠，所以wakeup信号丢失。当消费者下次运行时，它将测试先前读到的count值，发现他为0，于是睡眠。生产者迟早会填满缓冲区，然后睡眠。这样一来两个进程都永远的睡眠下去了。

为了解决此类问题Dijkstra提出了一种方法。

### 信号量

迪杰斯特拉使用一个整形变量来累计唤醒次数，供以后使用。在他的建议中引入的一个新的变量类型，称作信号量。

Dijkstra建议设立两种操作：down和up(一般化的sleep和wakeup)。对一信号量执行down操作，则检查是否其值大于0。若该值大于零，则将其值减1(即用掉一个保存的唤醒信号)并继续；若该值为0，则进程将睡眠，而此时down操作并未结束。检查数值、修改变量值及可能发生的睡眠操作均作为一个单一的，不可分割的原子操作完成。保证一个信号量操作开始，则在该操作完成或阻塞之前，其他进程不允许访问该信号量。

up操作对信号量的值增1。如果一个或多个进程在该信号量上睡眠，无法完成一个先前的操作，则系统会选择其中的一个并允许该进程完成它之前的down操作。于是，对一个有进程在其上睡眠的信号量执行一次up操作后，该信号量的值仍然是0，但在其上睡眠的进程却少了一个。信号量的增值和唤醒一个进程同样是不可分割的。不会有某个进程因执行up而阻塞，正如在前面的模型中不会有进程因执行wakeup而阻塞一样。

顺便提一下，在Dijkstra原来的论文中，他分别使用名称P和V而不是down和up，荷兰语中，Proberen的意思是尝试，Verhogen的含义是增加或升高。由于对于不讲荷兰语的读者来说采用什么记号并无大的干系，所以，这里将使用down和up名称。它们在程序设计语言Algol 68中首次引入。

##### 信号量如何保证原子性

最重要的一点是要采用一种不可分割的方式来实现它，通常使将down和up设置为系统调用，并且当操作系统需要执行测试信号量、更新信号量、使某个进程睡眠时，暂时屏蔽所有中断，这些指令较短所以屏蔽中断也没什么问题。

多CPU情况下，每个信号量都应该由一个锁进行保护，使用TSL和ZXHG来保证同一时刻只有一个CPU对信号量进行操作。

##### 用信号量解决生产者消费者问题

该解决方案使用了三个信号量：full：用来记录充满的缓冲槽数，初始值为0。empty：记录空的缓冲槽数，初始值为缓冲槽数目。mutex：用来确保生产者和消费者不会同时访问缓冲区，初始值为1。

提供给两个或多个进程使用的信号量，其初始值为1，确保同时只有一个进程进入临界区，这种信号量称为二元信号量。

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831184812505.png" alt="image-20220831184812505" style="zoom: 50%;" />

### 互斥量

如果不需要信号量的计数能力，可以使用信号量的一个简化版本→互斥量

Linux中存在快速用户区互斥量futex，它避免陷入内核

### 管程

为了更易于编写正确的程序,Brinch Hansen (1973)和Hoare (1974)提出了一种高级同步原语，称为管程(monitor)。在下面的介绍中会发现，他们两人提出的方案略有不同。一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。

任一时刻管程中只能有一个活跃进程，需要注意的是管程是编程语言的组成部分，编译器知道其特殊性，因此可以采用和其他过程调用不同的方法来处理对管程的调用。

典型处理是，进入管程时先检查管程中是否存在其他活跃进程，如果有则挂起，知道另一个活跃进程离开管程，如果没有则可以直接进入。

### 消息传递

这才是真正的进程间通信

设计要点 1.消息可能会丢失 2.区分新老消息 3.身份认证

#### 消息传递解决PC问题

N条消息，消费者将N条空消息发给生产者，生产者接收后填充一条内容，发给消费者

如何对消息进行编址 1.为每个进程分配唯一的地址 2.生产者和消费者分别建立一个N大小的*信箱*，将信箱的地址随参数传输 3.彻底取消缓存，receive必须在send之前发送，否则发送方将会阻塞。

### 屏障

屏障用来同步进程组而不是双进程，具体做法为只有进程组中所有进程到达屏障，这些进程才能开始下一个阶段。

### 避免锁：读-复制-更新

允许对数据进行更新，但是必须保证读者读到的要么是旧数据，要么是新数据，而不能是新旧数据的组合

## 调度

### 调度简介

计算密集型进程：多数时间花费在了计算上，I/O密集型进程：多数时间花费在等待IO上

何时调度：1.创建新进程后先运行父进程还是先运行子进程 2.一个进程退出时必须调度 3.一个进程阻塞在io或信号量上 4.io中断发生时（说明设备完成工作，阻塞的进程可运行了）

非抢占式调度：让一个进程运行直至被阻塞或者该进程自动释放CPU，抢占式调度：让一个进程运行到某个固定时段的最大值

批处理系统通常使用非抢占式调度，因为用户不需要非常快的相应，交互式系统中抢占式是必须的，实时系统中抢占式有时不是必须的

吞吐量：系统每小时完成的作业数量；周转时间：从一个作业被提交到该作业完成的统计平均时间；CPU利用率；最小响应时间：发出命令到响应之间的时间；

### 批处理系统中的调度

#### 先来先服务

最简单的调度方式，进程按照它们请求CPU的顺序使用CPU。

优点：易于理解和实现

缺点：IO密集型进程会浪费掉很多时间

#### 短作业优先

此调度的条件为运行时间可以预知，每次取最短运行时间的进程调度

#### 最短剩余时间优先

最短作业优先的抢占式版本，调度程序总是选择剩余运行时间最短的进程进行调度。如果新进程剩余时间比当前进程短，则当前进程被挂起。

### 交互式系统中的调度

#### 轮转调度

最古老、最简单、最公平、使用最广的调度算法。

每个进程被分配一个时间片，时间片过了就要挂起换下一个进程。如果当前进程阻塞或结束立即调度。

因为进程调度需要进行上下文切换，如果时间片过短，效率就会很低。但是时间片过长有可能引起短的交互请求相应时间边长。通常设定为20-50ms

#### 优先级调度

轮转调度有一个隐含的假设，那就是所有进程的优先级相同，事实上不同进程之间的优先级很可能不同。调度程序允许优先级最高的可运行进程先运行。

为了防止高优先级进程无限运行有以下两个策略：1.在每个时钟滴答（时钟中断）降低当前进程的优先级。 2.每个进程赋予一个时间片，用完这个时间片换次高优先级进程运行。

nice命令允许用户为了照顾别人而降低自己进程的优先级。

优先级可以静态赋予也可以动态赋予。

需要注意的是不及时调整优先级，低优先级进程可能会产生饥饿现象。

#### 多级队列

为计算密集型进程设置较长时间片比频繁地分给它们很短地时间片更高效（减少交换次数），但是长时间片的进程又会影响响应时间，解决方法就是设立优先级类。

高优先级类的进程时间片较少，每次用完都会降级并且增加时间片，增加时间片通常是指数级别

#### 最短进程优先

根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。

#### 保证调度

向用户做出明确的性能保证，然后去实现它。

在多用户以及多进程环境下保证每个进程获得的CPU时间相同

#### 彩票调度

为进程提供各种系统资源的彩票，需要调度时随机抽出一张彩票，拥有该彩票的进程获得资源。

可以给重要的进程额外的彩票，以便增加它们获胜的机会。

协作进程甚至还可以交换彩票。

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831185407291.png" alt="image-20220831185407291" style="zoom:25%;" />

#### 公平共享调度

为了避免某个用户持有进程过多而占用大部分CPU时间，该调度使得每个用户分配到相同的CPU时间，不管该用户有多少个进程。

## 策略和机制

一个进程可能有很多子进程在其控制下运行，每个子进程的需求可能不同，因此主进程需要对子进程的优先级等方面进行控制。

解决问题的方法是将调度机制和调度策略分离，也就是将调度算法以某种方式参数化，参数可以由用户进程填写。

调度机制属于内核，而调度策略则可以由用户来决定。

## 线程调度

若干进程都有多个线程。

### 用户级线程

内核不知道由线程的存在，所以内核还是和以前一样地操作。选取一个进程予以时间片，由进程的线程调度程序来决定哪个线程运行。但是线程并不知道时钟中断，所以这个线程可以按照它的意愿无限运行直到时间片用完。

从实用性考虑轮转调度和优先级调度更为常用。

用户级线程还可以使用专为应用程序定制的线程调度程序。

### 内核级线程

内核选择一个线程运行，不需要考虑这个线程属于哪个进程（除非有必要）。线程被赋予时间片，直到用完被挂起。

用户级和内核级线程之间的差别在于性能，用户级线程切换只需要少量的机器指令，内核级线程需要完整的上下文切换、修改内存映像、使高速缓存失效。另一方面，内核级线程线程阻塞在IO上不需要像用户级线程那样将整个进程挂起。

从进程A的一个线程切换到进程B的一个线程代价远高于切换为进程A的第2个线程（因为必须修改内存映像，清除高速缓存）。内核对此是了解的，所以在上述情况下内核更倾向于切换为同进程的不同线程。

## 经典的IPC问题

# 第三章 内存管理

## 无存储器抽象

每一个程序都直接访问物理内存。

但是也不是没有可能“同时”运行多个程序，只需要内存交换。

没有交换功能也可以实现并发，将内存分块，psw中存有一个四位保护键，如果访问保护键与psw码不同则不会实现。但是由于进程调度，进程可能会访问到不属于自己的指令。可以使用静态重定位的方法来解决（给每个指令加上某个数）

## 一种存储器抽象：地址空间

物理地址暴露给用户的问题：1.可以轻易破坏操作系统 2.并发困难

为了解决这些问题，创造出了地址空间→为程序分配抽象的内存，每个进程都有自己的地址空间，并且这个地址空间独立于其他进程。（再电话号，身份证号，网站域名等领域也有应用）

### 基址寄存器和界限寄存器

当一个进程运行时，程序的起始物理地址被装载到基址寄存器中，程序的长度被装载到界限寄存器中。每次访问内存，CPU都会检查是否越界。

缺点是每次访问内存都需要进行加法和比较运算。

### 交换技术

交换技术：把一个进程完整调入内存，使进程运行一段时间，再存回磁盘。

内存紧缩：内存交换会产生多个空闲求（又称空洞），把所有进程尽可能向下移动就可以将这些小空闲区合成一大块。不过内存紧缩需要耗费大量的CPU时间，所以通常不进行这个操作。

操作系统为进程精准分配内存，不过如果进程数据段可以增长就会出现问题。较好的解决方案使为堆栈预留空间，用完就被换出。

### 空闲内存管理

#### 位图

内存被分配成一个一个分配单元，每一位对应一个分配单元，0表示空闲，1表示占用。

分配单元越小位图越大

#### 链表

维护一个已分配内存段和空闲内存段的链表，每个节点表示一个进程或者两个进程间的一块空闲区。节点元素包括：空闲区或进程的标志，起始地址，长度，next指针。

分配内存的方法：1.首次适配算法（从头开始找到的第一个足够大的空闲区） 2.下次适配算法（每次找到空闲区都记录当前位置，下次从此位置开始搜索，性能略低于首次） 3.最佳适配算法（搜索整个链表，找到最小满足需求的空间） 4.最差适配算法（每次找到最大的空闲分配，为不要小空闲区）（进程和空闲区维护各自独立的链表，只检查空闲区而不需要检查进程，按照大小对空闲区链表进行排序，这时最佳适配就比较快了） 5.快速适配算法（为常用大小的空闲区维护单独的链表，相当于缓存）

## 虚拟内存

覆盖：程序员手工将程序分割成许多片段。

虚拟内存：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块被称作一页。每一页有连续的地址范围。这些也被映射到物理内存，但并不是所有也都必须在内存中才能运行程序，命中物理内存则直接执行映射，如果没命中则需要从磁盘将程序装入物理内存并重新执行。

虚拟内存适合多道程序使用，许多程序的片段同时保存在内存中，一个程序等待装载另一个程序就可以运行。

### 分页

在虚拟内存中，虚拟地址不是直接送到地址总线上，而是被送到内存管理单元（MMU）上，MMU把虚拟地址映射为物理内存地址。

虚拟地址空间按照固定大小分为称为页面的若干单元，与其对应的物理单元成为页框。

x86架构的处理器支持4kb、2mb、1gb的页面大小，4kb用于用户程序，1gb用于内核程序。

实际的硬件中，用一个在/不在位记录页面在内存中的实际存在情况，如果请求的页面不在内存中，CPU会陷入到操作系统中（缺页中断/缺页错误）。操作系统找到一个很少使用的页框用来交换该页面。

### 页表

虚拟地址被分为虚拟页号（高位）和偏移量（低位），虚拟页号作为页表的索引，以找到该虚拟页面的页表项，页表项可以找到页框号。

页表项：通常大小为32位，包括页框号（用于找到这个值）、在/不在位（1为在内存中）、保护位（允许什么类型的访问，三位读写执行）、修改（被修改过，又称脏位）、访问（访问过，用来帮助操作系统决定缺页中断时交换哪个页面）、禁止高速缓存（保证硬件事从设备中读取数据而不是访问一个旧的高速缓存）。

### 加速分页过程

两个主要问题：1.虚拟到物理的映射必须快 2.虚拟地址空间很大，页表也会很大。

#### 转换检测缓冲区（TLB）

此方法基于大多数程序总是对少量页面多次访问。为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址而不必再访问页表。这种设备被成为转换检测缓冲区（相联存储器/快表），通常在MMU中，包含少量的表项，每个表项记录了一个页面的相关信息。虚拟地址进入MMU，首先将此虚拟页号与所有表项同时进行匹配，判断虚拟页面是否在其中。

#### 软件TLB管理

TLB表项被操作系统显式地装载。当发生TLB访问失效时，不再是由MMU到页表中查找并取出需要的页表项，而是生成一个TLB失效并将问题交给操作系统解决。系统必须先找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。当然，所有这一切都必须在有限的几条指令中完成，因为TLB失效比缺页中断发生得更加频繁。

当使用软件TLB管理时，一个基本要求是要理解两种不同的TLB失效的区别在哪里。当一个页面访问在内存中而不在TLB中时,将产生软失效(soft miss)。那么此时所要做的就是更新一下TLB,不需要产生磁盘I/O。典型的处理需要10~20个机器指令并花费几纳秒完成操作。相反，当页面本身不在内存中(当然也不在TLB中）时，将产生硬失效。此刻需要一次磁盘存取以装入该页面，这个过程大概需要几毫秒。硬失效的处理时间往往是软失效的百万倍。在页表结构中查找相应的映射被称为页表遍历。

实际中遇到的情况可能会更加复杂，未命中的情况可能既不是软失效也不是硬失效。一些未命中相比其他未命中会更“软”(或更“硬”)。举例来说，假设页表遍历没有在进程的页表中找到需要的页，从而引发了一个缺页错误，那么这时有三种可能。第一种，所需的页面可能就在内存中，但却未记录在该进程的页表里。比如该页面可能已由其他进程从硬盘中调入内存，这种情况下只需要把所需的页面正确映射到页表中，而不用再从硬盘调入。这是一种典型的软失效，称为次要缺页错误。第二种，如果需要从硬盘重新调入页面，这就是严重缺页错误。第三种，程序可能访问了一个非法地址，根本不需要向TLB中新增映射。此时，操作系统一般会通过报告段错误来终止该程序。只有第三种缺页属于程序错误，其他缺页情况都会被硬件或操作系统以降低性能为代价而自动修复。

### 针对大内存的页表

#### 多级页表

引入多级页表的原因使避免把全部页表一直保存在内存中。特别是那些不需要的页表就不应该保留。

一个进程根本用不到完整的虚拟地址空间，所以不需要那么大的页表，通过一个顶级页表为真正有用的页表提供索引，不需要的二级页表就可以先不创建，

#### 倒排页表

## 页面置换算法

### 最优算法

此算法不可能实现。在缺页中断发生的时候，选择最久才能被访问到的页面置换掉，计算机也像人一样，希望把不愉快的事情尽可能地往后拖延。

此算法的唯一缺点就是它不可能实现，缺页中断发生的时候操作系统不知道各个页面下一次访问是在什么时候。

首先在仿真程序上运行程序记录下所有页面的访问情况，在第二次运行的时候根据访问情况进行置换是可以实现的。（笑）

用这种方式可以通过最有页面置换算法和其他算法的性能进行比较。

### 最近未使用算法（NRU Not Recently Used）

页面访问位（R）和页面修改位（M）

启动一个进程时所有页面的两位都是0，R为被定期清零（比如每次时钟中断时）以显示出页面最近是否被访问过。（不清除M为是因为M位决定着页面是否需要被写回磁盘）

发生缺页中断时，页面会被分为四类：0.没有被访问，没有被修改 1.没有被访问，已被修改 2.已被访问，没有被修改 3.已被访问，已被修改。发生缺页中断时，从小向大置换页面。

优点是易于理解且能有效地被实现，但性能不是最好的。

### 先进先出算法（FIFO）

算法思想如题

置换掉先进页面的理由是时间过去很久已经不受欢迎了，但这明显是不合理的，所以很少优单纯使用FIFO来进行页面置换的

### 第二次机会算法

FIFO算法可能会将经常使用的页面置换出去，为了避免这个问题，我们检查这个最老页面的R位，如果R位是0，说明这个页面又老又不常用，可以置换掉，如果是1，那么就将R位变为0，并重新放入，即所谓第二次机会。

但是如果在一个时钟间隔内所有页面都被访问过，这个算法被简化为FIFO了，而且效率比较低。

### 时钟算法

第二次机会需要在链表中移动页面，效率比较低。一个更好的办法是把所有页面保存在一个类似与时钟的环形链表中，表针指向最老的页面。发生缺页中断的时候，算法首先检查表针指向如果R位为0就置换，不为零则清零并向前移动，直到找到R位为0。

### 最近最少使用算法（LRU Least Recently Used）

对最优算法的一个很好的近似是基于这样的观察：在前几条指令中频繁使用的页面很可能在后面的及条指令中被使用。（很久没使用的页面很大可能在未来比较长的一段时间内仍然不会被使用）。

LRU可以实现但是代价很高，需要在内存中维护一个所有页面的链表，最近最多使用的在表头，最近最少使用的在表尾，困难的是每次访问内存时都必须更新整个链表，找到一个页面删除它，硬件也是很费时的操作。

有一种特殊硬件实现LRU，要求硬件包含一个64位计数器C，每条指令执行后加一，每个页表项必须有一个足够容纳这个计数器的位置，每次访问内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到一个最小的值，这个页面就是最近最少使用的页面。

### 软件模拟LRU（老化算法）

由于非常少的计算机拥有这种硬件，我们需要用软件来模拟LRU。可行的方案是NFU（Not Frequently Used）每个页面与一个软件寄存器有关，每次时钟中断的时候操作系统将页面的R位加到这个寄存器上。发生缺页中断的时候置换计数器中值最小的页面。

但可能会出现一个曾经常用但是现在不常用的页面，由于其值过于大一直不会被淘汰。

针对以上问题的修改：R位加进来之前对计数器的值右移一位，将R位的值加到计数器最左端的位而不是最右端的位。这种方法被称为老化（aging）算法。发生缺页中断时，置换计数器值最小的页面。

老化算法的问题：1. 如果两个页面计数器的值是相同的，此时无法判断这两个页面在两个时钟滴答之间的访问顺序是怎样的。2. 老化算法由于每次右移一位，所以老化算法对于过往页面的记录是比较差的。

### 工作集页面置换算法

刚刚启动进程时，内存中没有页面，进程不断进行缺页中断将页面调入内存的过程成为请求调页，因为页面是在被需要的时候调入的，而不是预先装入的。多数程序对于页面的访问都呈现出一种局部性访问，在一段时间内进程只是访问较少一部分的页面。

一个进程当前正在使用的页面的集合被称为它的工作集，如果整个工作集都在内存中，则进程运行中不会触发很多缺页中断。而如果内存太小无法容纳整个工作集，那么在进程运行过程中就会触发很多缺页中断，运行速度就会变得缓慢，进程每执行几条指令就要发生一次缺页中断那么就成这个程序发生了颠簸。

所以有很多分页系统都会设法跟踪进程的工作集，确保在让进程运行之前它的工作集就已经在内存中的，这种方法被称为工作集模型，其目的在于大大减少缺页中断率。注意工作集是随着时间变化而变化的。

### 工作集时钟页面置换算法

类似时钟算法

<img src="C:\Users\wm\AppData\Roaming\Typora\typora-user-images\image-20220831190340754.png" alt="image-20220831190340754" style="zoom: 33%;" />

## 分页系统中的设计问题

### 局部分配策略和全局分配策略

怎样在相互竞争的可运行进程之间分配内存

局部页面置换算法可以有效地为每个进程分配固定的内存片段，全局页面置换算法可以在可运行的进程之间动态地分配页框，因此分配给每个进程的页框数是随时间变化的。

全局算法通常情况下比局部算法好，若使用局部算法，即使有大量的空闲页框存在，工作集的增长也会导致颠簸。如果工作集缩小了，局部算法又会浪费内存。

操作系统必须不停地确定应该给每个进程分配多少个页框：1. 检测工作集的大小，工作集大小由老化位指出，但是老化位随着时钟滴答变化，而颠簸可能出现在几微秒之内。2. 定期确定进程运行的数目并为他们分配页面份额，最好是根据进程大小的比例分配，为每个进程规定一个最小的页框数，

### 负载控制

事实上，一旦所有进程的组合工作集超出了内存容量，就可能发生颠簸。有的进程需要更多的内存，但是没有进程需要更少的内存，这种情况下没有办法在不影响其他进程的情况下去满足那些需要更多内存的进程，唯一的解决办法就是暂时从内存中去掉一部分进程。

将部分进程交换到磁盘中，处于颠簸中的进程使用其页框（借用了二级调度的思想）。

另一个需要考虑的问题就是多道程序设计的道数，内存中进程数过少CPU可能在很长一段时间内处于空闲状态。所以在决定交换出哪个进程时不光需要考虑进程的大小和分页率，还要考虑它是什么密集型进程。

### 页面大小

小页面的优点：1.可以减少内存碎片 2. 相比于大页面更节省内存（笑）

但是小页面也意味着程序需要使用更多的页面，也就是需要更大的页表

### 分离的指令空间和数据空间

如果计算机只有一个地址空间，既存程序又存数据，那么就会使程序员对地址空间的使用出现困难，所以会有指令空间和数据空间分离的情况，两种地址空间都可以进行分页，而且相互独立。

### 共享页面

为了避免多个用户在同一时间运行同一个程序时，内存中有同一页面的两个副本，共享只读页面时比较合理的做法，如果支持指令和数据分离那么就直接共享指令空间，每个用户有单独的数据空间。

写时拷贝

### 清除策略

如果系统中有大量的空闲页框，则说明分页系统此时的工作状态比较良好。为了保证内存中有足够多的空闲页框，很多分页系统有一个分页守护进程，多数时间睡眠，定期检查内存的情况，如果空闲页框过少，守护进程就会通过预定的页面置换算法将部分页面置换出内存，如果是脏页则写回磁盘，

